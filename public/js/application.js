'use strict';
/**
 * Global Constants
 * @type {string}
 */
var SAVE = 'SAVE';
var DISCARD = 'DISCARD';
var SKIP = 'SKIP';

// Main App declaration
// It loads library defined modules such as grid, translate, session and custom modules
var app = angular.module(
    'emlogis',
    ['ui.bootstrap', 'ui.router', 'ui.grid', 'ui.select', 'isteven-multi-select', 'pascalprecht.translate',
      'ngStorage', 'ngMessages', 'ngAnimate', 'ngSanitize',
      'emlogis.commonservices',
      'emlogis.commonDirectives',
      'emlogis.commonControllers',
      'ncy-angular-breadcrumb',
      'http-auth-interceptor',
      'emlogis.directives',
      'emlogis.impersonation',
      'emlogis.login',
      'emlogis.home',
      'emlogis.dashboard',
      'emlogis.reports',
      'emlogis.settings',
      'emlogis.admin',
      'emlogis.employeeSchedules',
      'emlogis.schedule_builder',
      'emlogis.employees',
      'emlogis.browser',
      'emlogis.monitoring',
      'emlogis.profile'
    ])
    .config(
    [
      '$stateProvider',
      '$urlRouterProvider',
      '$locationProvider',
      '$httpProvider',
      '$translateProvider',
      '$breadcrumbProvider',
      'dialogsProvider',
      'datepickerConfig',
      function ($stateProvider, $urlRouterProvider, $locationProvider,
                $httpProvider, $translateProvider, $breadcrumbProvider,
                dialogsProvider, datepickerConfig, event) {

        // remove weeks column from all datepickers in application (like in ui style guide)
        datepickerConfig.showWeeks = false;

        $urlRouterProvider.otherwise('/');

        // Specify Default Module Page
        $breadcrumbProvider.setOptions({
          templateUrl: 'modules/_layouts/partials/authenticated_breadcrumb.tpl.html'
        });

        // Default Url
        $stateProvider.
          state('index', {
            url: "/emlogis.html",
            templateUrl: "emlogis.html",
            abstract: true
          })
          // If the use already logs in (have token info) move to home page
          .state('guest', {
            abstract: true,
            templateUrl: "modules/_layouts/partials/guest.html",
            controller: function ($state, $sessionStorage) {
              if ($sessionStorage.info) {

                console.log("Existing Token ID Move to home page ");
                $state.go('authenticated.home');
              }

            }
          })
          .state('guest.login', {
            url: '/',
            views: {
              "content": {
                templateUrl: "modules/_main/partials/login.html",
                controller: 'LoginController'
              }
            }
          })
          .state('authenticated', {
            abstract: true,
            templateUrl: 'modules/_layouts/partials/authenticated.html',
            controller: function ($state, $sessionStorage, $rootScope, $scope,
                                  authService, sseService, wsService, $location, applicationContext) {

              $scope.isLoggedIn = authService.isLoggedIn();
              var tokenId = authService.getToken();
              var baseurl = applicationContext.getBaseUrl();

              if ($rootScope.heartbitWorker == null) {
                // Session Lost pre existing heartbitworker object.
                // Try to recreate them
                $rootScope.startHeartBit(baseurl, tokenId);
              }


//                    if (( Object.keys($rootScope.consumers).length == 1 ) && ( $sessionStorage.consumers != null)){
//                        $rootScope.consumers = $sessionStorage.consumers;
//                    }

              // subscribe to SSE events
              /*
               if ($rootScope.sseServiceStarted != true) {
               sseService.startSSElistener(baseurl, tokenId);
               $rootScope.sseServiceStarted = true;
               }
               */

              // subscribe to WebSockets events
              if ($rootScope.wsServiceStarted != true) {
                wsService.startWSlistener(baseurl, tokenId);
                $rootScope.wsServiceStarted = true;
              }

              // Write Global Properties Username if empty, we have logged in,
              // We hit the refresh
              if (applicationContext.getUsername() == "") {
                applicationContext.setUsername($sessionStorage['username']);
              }

            }
          });

        // Language Translate Provider
        $translateProvider.useStaticFilesLoader({
          prefix: 'l10n/',
          suffix: '.json'
        });

        $translateProvider.preferredLanguage('en_US');

      }])
    .run([
      '$rootScope',
      '$state',
      '$location',
      '$q',
      '$modal',
      '$sessionStorage',
      'appContext',
      'authService',
      'applicationContext',
      'appFunc',
      'datepickerPopupConfig',
      '$templateCache',
      '$interpolate',
      '$translate',
      function ($rootScope, $state, $location, $q, $modal, $sessionStorage, appContext, authService,
                applicationContext, appFunc, datepickerPopupConfig, $templateCache, $interpolate, $translate) {

        $rootScope.$state = $state;

        $rootScope.hasStatePermissions = function (toState) {
          if (angular.isDefined(toState.data) && angular.isDefined(toState.data.permissions)) {
            return toState.data.permissions(authService);
          } else {
            return true;
          }
        };

        $rootScope.hasStatePermissionsByName = function (name) {
          if ($state.get(name)) {
            return $rootScope.hasStatePermissions($state.get(name));
          } else {
            return false;
          }
        };

        $rootScope.authService = authService;

        /**
         * Check Login & Save Work Confirmation Dialog
         */
        $rootScope.$on('$stateChangeStart', function (event, toState, toParams, fromState, fromParams) {

          // / if route requires auth and user is not logged in

          if (( _.string.startsWith(toState.name, 'authenticated') === true) && (authService.isLoggedIn() !== true )) {
            // redirect back to login
            applicationContext.setAfterLoginUrl($location.path());
            event.preventDefault();
            $state.go('guest.login');
          }
          else if ($rootScope.hasStatePermissions(toState)) {

            var working = applicationContext.getWorking();

            var sessionInfo = authService.getSessionInfo();

            if (working.option && working.option.editing === true && sessionInfo.token !== null) {
              event.preventDefault();

              appFunc.getSaveWorkDlg().then(function (reason) {
                  var working = applicationContext.getWorking();

                  if (reason === DISCARD) {
                    if (working.option !== null)
                      working.option.editing = false;

                    $state.go(toState, toParams);

                  }
                  else if (reason === SAVE) {
                    working.saveFunc()
                      .then(function (result) {
                        $state.go(toState, toParams);
                      });
                  }

                },
                function (reject) {
                  console.log('Cancel pressed');
                }
              );
            }

          } else {
            event.preventDefault();
          }

        });


        /**
         *  Hide Page-level notification
         *  if used successfully navigated to another page
         */
        $rootScope.$on('$stateChangeSuccess', function () {
          var working = applicationContext.getWorking();
          var sessionInfo = authService.getSessionInfo();

          if (working.option && !working.option.editing && sessionInfo.token !== null) {
            var notificationMsg = applicationContext.getNotificationMsg();
            notificationMsg.content = '';
            notificationMsg.type = '';
            notificationMsg.visible = false;
            applicationContext.updateNotificationArea();
          }
        });


        // initialize entity2resource map
        // entity2resource is a map between an entity name, and its corresponding
        // REST resource and user friendly label
        // for instance, the entity2resource 'useraccount' attribute would have
        // value {restResource: "useraccounts", label: "User Account"}
        var entity2resource = appContext.get('entity2resource', {});
        _.defaults(entity2resource, {
          getResource: function (entity) {
            return this[entity].restResource;
          },
          getLabel: function (entity) {
            return this[entity].label;
          }
        });


        // Default transition state
        $rootScope.$on('event:auth-loginRequired', function (event) {
          event.preventDefault();
          $state.go('guest.login');

        });

        // if the session storage token id is not valid

        if ($sessionStorage.info) {
          //var sessionInfo = authService.getSessionInfo();
          var sessionInfo = JSON.parse($sessionStorage.info);

          authService.setSessionInfo(sessionInfo);

          //console.log("Refresh Token ID : " + sessionInfo.token);
        }
        else {
          $rootScope.$broadcast('event:auth-loginRequired', null);

        }

        // Tell the module what language to use by default
        if (!$sessionStorage['lang']) {
          $sessionStorage['lang'] = 'en_US';
        }


        $translate.use($sessionStorage['lang']);


        var startSym = $interpolate.startSymbol();
        var endSym = $interpolate.endSymbol();

        $templateCache.put('/dialogs/confirm.html', '<div class="modal-header dialog-header-confirm">' +
        '<button type="button" class="close" ng-click="no()">&times;</button><h4 class="modal-title">' +
        '<span class= "glyphicon glyphicon-check"></span> <span translate>' + startSym + 'header' + endSym +
        '</span></h4></div><div class="modal-body" ><span translate>' + startSym + 'msg' + endSym +
        '</span></div><div class="modal-footer"><button type="button" class="btn btn-default" ng-click="yes()">' +
        startSym + '"DIALOGS_YES" | translate' + endSym + '</button><button type="button" class="btn btn-primary" ' +
        'ng-click="no()">' + startSym + '"DIALOGS_NO" | translate' + endSym + '</button></div>');


        // Modify SelectAll header cell template in UI Grid
        // to add a tooltip

        $templateCache.put('ui-grid/selectionHeaderCell',
          '<div tooltip="Select all visible rows" tooltip-append-to-body="true" tooltip-placement="right">' +
          '<div class="ui-grid-cell-contents" col-index="renderIndex">' +
          '<ui-grid-selection-select-all-buttons ng-if="grid.options.enableSelectAll"></ui-grid-selection-select-all-buttons>' +
          '</div>' +
          '</div>');
      }]
  )

    //--------------------------------------------------------------------
    // Constants
    //--------------------------------------------------------------------

    .constant('emlogisConstants', {
      countries: [
        "USA",
        "Canada",
        "Philippines"
      ]
    })
  ;

app.controller('AppCtrl', [
  '$rootScope',
  '$scope',
  '$location',
  '$state',
  '$http',
  '$translate',
  '$sessionStorage',
  'stateManager',
  'authService',
  'appFunc',
  'sseService',
  'wsService',
  'applicationContext',
  function ($rootScope, $scope, $location, $state, $http, $translate, $sessionStorage, stateManager,
            authService, appFunc, sseService, wsService, applicationContext) {

    $rootScope.heartbitWorker = null;

    // register a listener on login success to activate SSE
    $scope.$on('event:auth-loginConfirmed', function (event) {

      // Store WebSocket service in rootScope 
      $rootScope.wsService = wsService;

      // we just logged in, subscribe to SSE events and send a
      // heartbit periodically
      // get session token and build base url for SSE subscribtion &
      // heartbit
      var tokenId = authService.getToken();
      var baseurl = applicationContext.getBaseUrl();

      /*
       *    $sessionStorage['impersonated'] has 3 statuses
       *   null : user just logs in
       *   true : impersonated to other user
       *   false : unimpersonated back to origin user
       */

      if ($sessionStorage['impersonated'] == null) {

        // TODO REMOVE
        // subscribe to SSE events
        /*
         sseService.startSSElistener(baseurl, tokenId);
         $rootScope.sseServiceStarted = true;
         */

        // subscribe to WebSockets events
        wsService.startWSlistener(baseurl, tokenId);
        $rootScope.wsServiceStarted = true;

        // start a webworker to send a heartbit to server every min
        $rootScope.startHeartBit(baseurl, tokenId);
      }


      // Move to authenticated page.

      if (($sessionStorage['impersonated'] != null) && ($state.current.name == 'authenticated.home')) {

        $state.go($state.current, null, {
          reload: true,
          inherit: false,
          notify: true
        });
      }
      else {
        if (applicationContext.getAfterLoginUrl() === '') {
          event.preventDefault();
          $state.go('authenticated.home');
        }
        else {

          $location.path(applicationContext.getAfterLoginUrl());
          applicationContext.setAfterLoginUrl('');
          console.log("After Login Url empty");
        }

      }

      /**
       * Clear the Notification Area
       */
      applicationContext.setNotificationMsgWithValues('', '', false);


    });

    $rootScope.startHeartBit = function (baseurl, tokenId) {

      if (typeof (Worker) !== "undefined") {
        // Web Workers supported
        if ($rootScope.heartbitWorker != null) {
          // Heartbit work lready active, so let's stop it first
          $rootScope.heartbitWorker.terminate();
          $rootScope.heartbitWorker = null;
        }

        $rootScope.heartbitWorker = new Worker("./heartbit.js");

        // Implement message failure from heartbit.

        $rootScope.heartbitWorker.addEventListener('message', function (e) {

          // In case function called more than in a row, we should show message only one time

          if ($sessionStorage.info != null) {
//                            delete  $sessionStorage.info;
//                            applicationContext.setUsername("");

            //alert(e.data);

            $rootScope.stopWSlistener();
            applicationContext.setNotificationMsgWithValues(e.data, 'danger', true, '');

            //$rootScope.logout();

            return;
          }


        }, false);

        var url = baseurl + 'sseheartbit?tokenId=' + tokenId;

        $rootScope.heartbitWorker.postMessage(url);
      }
    };

    // Change Language Settings
    $scope.setLang = function (langKey) {
      // We can change the language during runtime
      $translate.use(langKey);
      $sessionStorage['lang'] = langKey;

    };

    // Define Logout Function as globally

    $rootScope.logout = function (param) {
      var token = authService.getSessionInfo().token;

      // Stop WebSocketService
      $rootScope.stopWSlistener();

      if (token != null) {

        //stop badge pulling
        appFunc.stopBadgeRefresh();
        applicationContext.setBadgeMsg({});

        // If lost connection, will not call delete api
        if (param != null && param.lostConnection == true) {
          authService.logout(null, "CONNECTION_REFUSED");
        }
        else {
          $http.delete('../emlogis/rest/sessions')
            .success(function (data) {
              console.log('--> logout successful() token:' + data.token);
              authService.logout();
            })
            .error(function () {
              console.log('--> logout FAILED()');
              authService.logout();
            });
        }

      }
    };

    $rootScope.stopWSlistener = function () {
      if ($rootScope.wsService !== undefined && $rootScope.wsService !== null) {
        $rootScope.wsService.stopWSlistener();
        $rootScope.wsService = null;
      }
    };

    stateManager.onStateChangeSuccess();

  }

]);

app.controller('AlertsCtrl', ['$scope', 'alertsManager', '$timeout', function ($scope, alertsManager, $timeout) {
  $scope.alerts = alertsManager.alerts;
  $scope.closeAlert = function (index) {
    alertsManager.closeAlert(index);
  }
}]);
;
var app = angular.module('emlogis');

// This Controller is authenticated global breadcrumb

app.controller('AuthenticatedBreadcrumbCtrl', ['$scope', '$rootScope',
    '$http', 'crudDataService', 'applicationContext',
    function ($scope, $rootScope, $http,
                 crudDataService, applicationContext) {

        //console.log("Authenticated Breadcrumb Controller");

        /**
         * Specify moduleName from applicationContext
         * And applicationContext will be updated later in individual model
         */
       //Specify moduleName from applicationContext

        $scope.module = applicationContext.getModule();

        $scope.hasNavBreadcrumb = function(){
          // Checking module.href for `home` avoids breadcrumbs duplication on Dashboard TODO review Dashboard breadcrumbs
          return !(($scope.module.name == 'Browser') || ($scope.module.href.indexOf('home') > 0));
        };


      // If Site-level Msg is visible
      $rootScope.$watch('sseEventVisible', function(newVal){
        $scope.siteMsgIsVisible = newVal;
      },true);

    }
]);


;
angular.module('emlogis').controller('ChangePasswordDialogCtrl',
  ['$scope', '$modalInstance', 'dataService', 'applicationContext', 'authService',
    function ($scope, $modalInstance, dataService, applicationContext, authService) {

      $scope.passwords = {
        currentPassword: "",
        newPassword: "",
        repeatPassword: ""
      };

      $scope.passwordsMatch = function() {
        return $scope.passwords.newPassword && $scope.passwords.newPassword === $scope.passwords.repeatPassword;
      };

      $scope.changePassword = function() {
        var hashedPassword = CryptoJS.SHA256($scope.passwords.currentPassword + "." + authService.getSessionInfo().tenantId).toString();

        dataService.changePassword(hashedPassword, $scope.passwords.newPassword).
          then(function() {
            applicationContext.setNotificationMsgWithValues("Password changed", 'success', true);
            $modalInstance.dismiss();
          }, function(err) {
            applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
          });
      };

      $scope.cancel = function () {
        $modalInstance.dismiss('cancel');
      };

    }
  ]);


;
angular.module('emlogis').controller('EntitiesTopBreadcrumbCtrl', ['$scope', '$rootScope', '$http', 'crudDataService', 'applicationContext',
    function ($scope, $rootScope, $http, crudDataService, applicationContext) {

        var baseUrl = applicationContext.getBaseRestUrl();
        $scope.search = {txt : ''};

        // Auto Complete KeyField List : mostly it will be name fields
        $scope.getSearchValues = function(val) {

            // Get Filter Info from Global Properties
            var entityFilter = applicationContext.getEntityFilter();

            if ((entityFilter.url === '') || (entityFilter.searchFields === '')) {
                console.log('Filter url or searchFields is(are) empty');
                return null;
            }

            var params = {
                search: val,
                searchfields: entityFilter.searchFields,
                returnedfields: entityFilter.returnedFields,
                orderby: entityFilter.orderBy,
                orderdir: entityFilter.orderDir,
                limit: entityFilter.limit
            };

            return $http.get(baseUrl + entityFilter.url, {params: params})
                .then(function(entities) {
                    return entities.data.map(function(item) {
                        if (!Array.isArray(item)) {
                            item = [item];
                        }
                        var searchItem = {};
                        searchItem.id = item[0];
                        item.splice(0, 1);
                        searchItem.label = item.join(' ');
                        return searchItem;
                    });
                });
        };

        // Search icon click action
        $scope.listKeywords = function() {

            // Save Filter Info as Globalproperties
            var entityFilter = applicationContext.getEntityFilter();
            entityFilter.txt = $scope.search.txt;
            applicationContext.setEntityFilter(entityFilter);

            $rootScope.$broadcast("event:entities-SearchTxtUpdated", null);
        };

        $scope.selectSearchValue = function(item, model, label) {
            $scope.selectEntitySearchValue(item, model, label);
        };
    }
]);


;
// This Controller is header navigation bar controller

angular.module('emlogis').controller('HeaderCtrl',
  [
    '$scope',
    '$rootScope',
    '$location',
    '$stateParams',
    '$state',
    '$http',
    '$sessionStorage',
    '$modal',
    'authService',
    'sseService',
    'wsService',
    'applicationContext',
    'appFunc',
    'scheduleService',
    function ($scope, $rootScope, $location, $stateParams, $state, $http, $sessionStorage,
              $modal, authService, sseService, wsService, applicationContext, appFunc, scheduleService) {


      $scope.location = $location;
      $scope.searchEntity = "Employee";
      $scope.searchEntityLabel = "Search";
      $scope.searchQuery = "";

      $scope.isDevMode = authService.isDevMode();

      $scope.onLoginPage = function () {
        return $location.path() === "/";
      };

      $scope.taskLabel = 'Tasks';
      $scope.accountMgmtTaskLabel = 'Account Mgmt';

      // Navbar should be collapsed by default
      $scope.navbarCollapsed = true;

      /**
       * badge notification settings
       */
      $scope.currentAccountInfo = $sessionStorage.info && JSON.parse($sessionStorage.info);
      $scope.badgeMsg = applicationContext.getBadgeMsg();
      if ($scope.currentAccountInfo && $scope.currentAccountInfo.roles.employeerole) {
        if (authService.hasPermissionIn(['Availability_RequestMgmt', 'Shift_RequestMgmt'])) {
          appFunc.badgeRefresh(true); // Manager = true;
        }
        else if (authService.hasPermissionIn(['Availability_Request', 'Shift_Request'])) {
          appFunc.badgeRefresh(false); // Manager = false;
        }
      }

      $scope.setSearchEntity = function (entity, label) {
        $scope.searchEntity = entity;
        $scope.searchEntityLabel = label;
      };

      $scope.fireSearch = function () {
        var x = 1;
        var currentstate = $state.current;
        var to = 'search.query';
        $state.go(to, {entity: $scope.searchEntity, q: $scope.searchQuery});
      };

      $scope.hasPermission = function (perm) {
        return authService.hasPermission(perm);
      };

      $scope.hasPermissionIn = function (perms) {
        return authService.hasPermissionIn(perms);
      };

      $scope.getUserName = function () {
        var impersonatingUser = authService.getImpersonatingUserName();
        if (impersonatingUser !== null) {
          impersonatingUser = '(' + impersonatingUser + ')';
        }
        else {
          impersonatingUser = '';
        }
        return (authService.getUserName() !== null ? impersonatingUser + authService.getUserName() : '...');
      };


      // Show Users List
      $scope.showImpersonationUsersList = function () {
        //Show Modal with users list

        $modal.open({
          templateUrl: 'modules/impersonation/partials/users_list.html',
          controller: 'ImpersonationManageCtrl',
          size: 'lg',
          windowClass: 'impersonation-users-window'
        });

        //            //keep track of dismissal of the activeDialog
        //            $scope.impersonationModal.result.then(function(reason) {
        //                console.log('Impersonation dialog closed: ' + reason);
        //                //delete $scope.impersonationModal;
        //            }, function(reason) {
        //                console.log('Impersonation dialog dismissed: ' + reason);
        //                //delete $scope.impersonationModal;
        //            });
      };


      $scope.isUserAnEmployee = function () {
        return authService.isUserAnEmployee();
      };

      // returns true/false if the user logged in
      $scope.isLoggedIn = function () {
        return !_.isEmpty(applicationContext.getUsername());
      };

      $scope.isTenantType = function (tenantType) {
        return authService.isTenantType(tenantType);
      };

      // Check Impersonated or not, Defines in HeaderCtrl
      $scope.isImpersonated = function () {
        return $sessionStorage.impersonated === true;
      };

      // Unimpersonate back to origin user
      $scope.unimpersonate = function () {
        $http.post('../emlogis/rest/sessions/ops/unimpersonate')
          .success(function (data) {

            //$http.defaults.headers.common.EmLogisToken = data.token;
            console.log('--> Unimpersonate successfull');

            // reset login info  and just restart as if we were in a new session
            $scope.tenantId = '';
            $scope.login = '';
            $scope.password = '';

            applicationContext.setUsername(data.userName);
            $sessionStorage.impersonated = false;

            authService.loginConfirmed(data);
          })
          .error(function (data) {
            // TODO show login error
            console.log('--> UnImpersonation FAILED()');

            // not much we can do, our initial session  is probably closed,
            // Move to login page

            // TODO should we clear data ?
            $rootScope.logout();
          });
      };

      $scope.showChangePassword = function () {
        if ($scope.isUserAnEmployee()) {
          $state.go("authenticated.profile.password");
        } else {
          showChangePasswordDialogBox();
        }
      };

      function showChangePasswordDialogBox() {
        $modal.open({
          templateUrl: 'modules/_layouts/partials/change_password_dlg.html',
          controller: 'ChangePasswordDialogCtrl'
        });
      }

      $scope.getPrevScheduleId = function() {
        var tmp = scheduleService.getShared();

        if (tmp.schedule && tmp.schedule.id) {
          return tmp.schedule.id;
        }
        else {
          return '';
        }
      };

      $scope.goToEmployeeSchedulesWeekView = function() {
        $state.go('authenticated.employeeSchedules.weekView', null, {reload: true});
      };

      $scope.goToEmployeeSchedulesDayView = function() {
        $state.go('authenticated.employeeSchedules.dayView', null, {reload: true});
      };
    }
  ]
);


;
var app = angular.module('emlogis');

// It will show the several notifications such as invalidated token, etc
app.controller('NotificationCtrl', ['$scope', '$location', '$state',
  '$http', 'applicationContext',
  function ($scope, $location, $state, $http,
            applicationContext) {

    $scope.msg = applicationContext.getNotificationMsg();


    // Close Alert
    $scope.closeAlert = function () {
      var msg = applicationContext.getNotificationMsg();
      msg.visible = false;
      applicationContext.setNotificationMsg(msg);
    };

    /**
     * It will logout from the system and move to login page,
     * after login it will show to saved page
     */
    $scope.moveToLogin = function (param) {
      applicationContext.setAfterLoginUrl($location.path());
      $scope.logout(param);
    };

    // Show Logout and Refresh button
    $scope.showLogoutButton = function () {
      return $scope.msg.visible === true && $scope.msg.type === 'login';
    };

    // Show Save button
    $scope.showSaveButton = function () {
      return $scope.msg.visible === true && $scope.msg.type === 'save';
    };

    $scope.saveAction = function () {
      var working = applicationContext.getWorking();
      return working.saveFunc();
    };


  }
]);




;
var app = angular.module('emlogis');

// This Controller will generate sseevent

app.controller('SseEventCtrl', ['$scope', '$sce', '$rootScope', 'sseService', 'wsService', 
    function ($scope, $sce, $rootScope, sseService, wsService) {

      // TEMP SseEvent TODO: where are Site-level notification being created?
      $rootScope.sseEventVisible = true;
      $scope.closeSseEvent = function () {
        $rootScope.sseEventVisible = false;
      };

        // register a consumer for SSE that will display the event in header
        // (registration can happen safely even before getting events is
        // started.)
        $scope.eventCnt = 0;
        $scope.eventData = 'no event';

        // TODO REMOVE
        /*
        sseService.registerConsumer({
            selector: function () {
                return true;					// for now, subscribe to all
                // events
            },
            callback: function (key, serverEvent) {
                $scope.$apply(function () {     // use $scope.$apply to refresh
                    // the view
                    $scope.eventData = JSON.stringify(serverEvent).substr(0,200);

                    $scope.eventCnt++;
                });
            },
            scope: $scope,
            params: []
        });
        */

        // register a listener for WebSocket connection status
        wsService.registerConnectionStatusListener({
            callback: function (status, connectionOpenAt, connectionClosedAt, message) {
                $scope.$apply(function () {     // use $scope.$apply to refresh the view
                    try { 
                        var display = status; 
                        switch (status) {
                            case 'Active':
                                display = '<font  color="green">WS</font>';
                                break;
                            case 'Inactive':
                                display = '<font  color="red">WS</font>';
                                $scope.eventData = '';
                                break;
                            case 'Reconnecting':
                                var msg = 'WebSocket Connection lost at: ' + new Date(connectionClosedAt).toLocaleString() + ' - ' + message;
                                display = '<font   color="gray">ws... </font> ' + msg;
                                break;
                        }
                        $scope.wsConnectionStatus = $sce.trustAsHtml(display);
                        console.log( "displayed: " + display);
                    }   
                    catch(err) {
                        console.error('Failed to display WebSocket status:' + err);
                    }
                });
            },
            scope: $scope,
            params: []
        });

        // register a consumer for WebSocket Events
        wsService.registerConsumer({
            selector: function () {
                return true;                    // for now, subscribe to all
                // events
            },
            callback: function (key, serverEvent) {
                $scope.$apply(function () {     // use $scope.$apply to refresh
                    // the view
                    /**
                     * Maximum 200 characters
                     */
                    try { 
                        var msg = JSON.stringify(serverEvent);
                        // key is expected as an object (if well formed) or can be just a String, if malformed
                        // key shoudld have format: {topic, tenantId, accountId, entityClass, eventType, entityId}
                        // if correctly decoded, do some beautifying of displayed mesage, otherwise display as is. 
                        if (key.topic !== undefined) {
                            // key has been correctly decoded
                            var prefix;
                            var display;
                            if (key.topic === 'ObjLifecycle') {
                                if (serverEvent.name !== undefined) {
                                    msg = "Object '" + serverEvent.name + "' " + key.eventType + ": " + JSON.stringify(serverEvent);
                                }
                                else if (serverEvent.id !== undefined) {
                                    msg = "Object Id='" + serverEvent.id + "' " + key.eventType + ": " + JSON.stringify(serverEvent);
                                }
                                else {
                                    msg = "Unidentifed Object " + key.eventType + ": " + JSON.stringify(serverEvent);                                    
                                }
                            }
                            else if (key.topic === 'System' && key.eventType == 'Heartbit') {
                                msg = "Heartbit " + JSON.stringify(serverEvent);
                                // as a workaround of inital status display, dispay connection as active when receiving a HB
                                display = '<font  color="green">WS</font>';
                                $scope.wsConnectionStatus = $sce.trustAsHtml(display);
                            }
                            else if (key.topic === 'SysNotifications' && key.entityClass == 'Schedule' && key.eventType == 'Progress') {
                                msg = "Progress " + serverEvent.progress + "%" 
                                + (serverEvent.hardScore !== undefined ? " HardScore: " +  serverEvent.hardScore  : "")
                                + (serverEvent.softScore !== undefined ? " SoftScore: " +  serverEvent.softScore  : "")
                                + ", for: " +  serverEvent.msg ;
                            }
                            else if (key.topic === 'System' && key.entityId == 'EventWebSocket' && key.eventType == 'Notification') {
                                msg = "WebSocket connection for real time events activated.";
                                // as a workaround of inital status display, dispay connection as active when receiving a HB
                                display = '<font  color="green">WS</font>';
                                $scope.wsConnectionStatus = $sce.trustAsHtml(display);
                            }
                        }

                        $scope.eventData = msg.substr(0,200);
                        console.debug('Received Event: ' + msg);

                    }   
                    catch(err) {
                        console.error('Failed to decode event:' + err);
                        $scope.eventData = ("Unknown Event: " + serverEvent).substr(0,200);
                    }
                    $scope.eventCnt++;
                });
            },
            scope: $scope,
            params: []
        });

    }
]);


;
(function () {
  "use strict";


  //
  // Page-level notification
  // This directive controls the DOM behavior
  // for notifications displayed below Top Menu

  var notification = function ($rootScope, $window, applicationContext) {
    return {
      restrict: 'AE',
      replace: true,
      templateUrl: 'modules/_layouts/partials/notification.tpl.html',
      controller: 'NotificationCtrl',
      link: function(scope, element, attrs, controller, transclude){

        //
        // Watch for
        // a new Page-level Notification
        // to be posted to applicationContext

        scope.$watch('msg', function(newValue, oldValue) {
          if (newValue.visible && newValue.type !== oldValue.type || newValue.content !== oldValue.content){
            var newMsg = newValue;

            if (newMsg.type === 'save') {
              showSaveBtn(newMsg);

              angular.element($window).bind("scroll", function() {
                startScrollTimer(newMsg);
              });
            }

          // If msg was hidden and it's not Save,
          // unbind scroll listener

          } else if (!newValue.visible && newValue.type !== 'save') {
            angular.element($window).unbind();
          }
        }, true);


        //
        // On leaving /general and /site_teams,
        // unbind scroll listener

        $rootScope.$on('$stateChangeSuccess', function(event, toState, toParams, fromState, fromParams){
          if (fromState.url.indexOf('general') > -1 || fromState.url.indexOf('site_teams') > -1) {
            angular.element($window).unbind();
          }
        });

        //
        // Show Save Notification
        // based on the visibility of Save btn in Action Bar

        var showSaveBtn = function(msg){
          msg.visible = !isSaveBtnVisible();
          applicationContext.setNotificationMsg(msg);
        };



        //
        // Start listening to
        // $window position on scroll

        var startScrollTimer = function(msg){
          //console.log('scrolling...');
          if (scrollTimer) {
            clearTimeout(scrollTimer);                  // clear any previous pending timer
          }

          var scrollTimer = setTimeout(function() {     // set new timer
            if (msg.type === 'save') {
              showSaveBtn(msg);
            }
          }, 10);
        };



        //
        // Calculate
        // if Save button in Action Bar
        // is visible to user

        var isSaveBtnVisible = function(){
          var siteLevelMsgHeight = $('#siteLevelMsg').outerHeight(),
              breadcrumbsHeight = $('.breadcrumb-section').outerHeight(),
              tabsHeight = $('.eml-top-tabs').outerHeight(),
              actionBarHeight = $('.eml-action-bar').outerHeight() * 0.7;

          var saveBtnHeight = breadcrumbsHeight + tabsHeight + actionBarHeight;
          var windowTopHeight = $(window).scrollTop() + siteLevelMsgHeight;

          return windowTopHeight < saveBtnHeight;
        };
      }
    };
  };

  notification.$inject = ['$rootScope', '$window', 'applicationContext'];
  angular.module('emlogis').directive('notification', notification);


}());
;
(function () {
  "use strict";


  //
  // SVG filters
  // This element is placed right after opening <body> tag
  // to be applied to all SVG images across the app

  var svgFilters = function () {
    return {
      restrict: 'A',
      replace: true,
      template: '<div style="width: 0;height: 0">' +
                  '<svg xmlns="http://www.w3.org/2000/svg" style="width: 0;height: 0">' +
                    '<filter id="dropshadow" height="130%">' +
                      '<feGaussianBlur in="SourceAlpha" stdDeviation="5"/>' +
                      '<feOffset dx="0" dy="5" result="offsetblur"/>' +
                      '<feComponentTransfer>' +
                        '<feFuncA type="linear" slope="0.5"/>' +
                      '</feComponentTransfer>' +
                      '<feMerge>' +
                        '<feMergeNode/>' +
                        '<feMergeNode in="SourceGraphic"/>' +
                      '</feMerge>' +
                    '</filter>' +
                  '</svg>' +
                '</div>'
    };
  };
  svgFilters.$inject = [];
  angular.module('emlogis').directive('svgFilters', svgFilters);



  //
  // Profile icon
  // for top menu section

  var iconProfile = function () {
    return {
      restrict: 'A',
      replace: true,
      template: '<div>' +
                  '<svg xmlns="http://www.w3.org/2000/svg" viewBox="8 0 130 140"> <!-- 0 0 141 128 -->' +
                    '<path class="eml-svg eml-icon-profile" style="filter: url(#dropshadow);" d="M71 5C38.4 5 12 31.4 12 64s26.4 59 59 59 59-26.4 59-59S103.6 5 71 5zm41.6 93.5c-5.4-2.3-18.1-6.7-26-9-.7-.2-.8-.2-.8-3 0-2.3 1-4.6 1.9-6.6 1-2.1 2.2-5.7 2.6-9 1.2-1.4 2.8-4.1 3.9-9.3.9-4.6.5-6.3-.1-7.8-.1-.2-.1-.3-.2-.5-.2-1.1.1-6.7.9-11 .5-3-.1-9.3-4.2-14.6-2.6-3.3-7.6-7.4-16.6-8h-5c-8.9.6-13.9 4.6-16.5 7.9-4.1 5.2-4.8 11.6-4.2 14.6.8 4.3 1.1 9.9.9 11 0 .2-.1.3-.2.5-.6 1.6-1 3.2-.1 7.8 1 5.2 2.7 8 3.9 9.3.4 3.2 1.6 6.8 2.6 9 .7 1.6 1.1 3.7 1.1 6.7 0 2.8-.1 2.8-.7 3-8.1 2.4-21.1 7.1-26 9.2-8-9.4-12.8-21.6-12.8-34.8-.1-29.7 24.2-54 54-54s54.1 24.3 54.1 54.1c0 13.1-4.7 25.2-12.5 34.5z"/>' +
                  '</svg>' +
                '</div>'
    };
  };
  iconProfile.$inject = [];
  angular.module('emlogis').directive('iconProfile', iconProfile);



  //
  // Messages icon
  // for top menu section

  var iconMessages = function () {
    return {
      restrict: 'A',
      replace: true,
      template: '<div>' +
                  '<svg xmlns="http://www.w3.org/2000/svg" viewBox="3 -4 137 140">' +
                    '<path class="eml-svg eml-icon-messages" style="filter: url(#dropshadow);" d="M116.9 5H25.1C14.6 5 6 13.4 6 23.9v52.8c0 10.4 8.6 18.9 19.1 18.9h42.1L97.8 122V95.6h19.1c10.6 0 19.1-8.4 19.1-18.9V23.9C136 13.4 127.4 5 116.9 5z"/>' +
                  '</svg>' +
                '</div>'
    };
  };
  iconMessages.$inject = [];
  angular.module('emlogis').directive('iconMessages', iconMessages);



  //
  // Setting icon
  // for breadcrumb section

  var iconSettings = function () {
    return {
      restrict: 'A',
      replace: true,
      template: '<div>' +
                  '<svg xmlns="http://www.w3.org/2000/svg" viewBox="7 0 127 128">' +
                    '<path class="eml-svg eml-icon-settings" style="filter: url(#dropshadow);" d="M70.5 52.3c-6.2 0-11.2 5-11.2 11.2 0 6.2 5 11.2 11.2 11.2s11.2-5 11.2-11.2c0-6.2-5-11.2-11.2-11.2zm52.1 0H112c-1-3.7-2.4-7.1-4.3-10.3l7.5-7.5c2.9-2.9 2.9-7.6 0-10.5l-5.3-5.3c-2.9-2.9-7.6-2.9-10.5 0L92 26.3c-3.2-1.8-6.7-3.3-10.3-4.3V11.4c0-4.1-3.3-7.4-7.4-7.4h-7.4c-4.1 0-7.4 3.3-7.4 7.4V22c-3.6 1-7.1 2.4-10.3 4.3l-7.5-7.5c-2.9-2.9-7.6-2.9-10.5 0l-5.3 5.3c-2.9 2.9-2.9 7.6 0 10.5l7.5 7.5c-1.8 3.2-3.3 6.7-4.3 10.3H18.4c-4.1 0-7.4 3.3-7.4 7.4v7.4c0 4.1 3.3 7.4 7.4 7.4H29c1 3.7 2.4 7.1 4.3 10.3l-7.5 7.5c-2.9 2.9-2.9 7.6 0 10.5l5.3 5.3c2.9 2.9 7.6 2.9 10.5 0l7.5-7.5c3.2 1.8 6.7 3.3 10.3 4.3v10.5c0 4.1 3.3 7.4 7.4 7.4h7.4c4.1 0 7.4-3.3 7.4-7.4V105c3.6-1 7.1-2.4 10.3-4.3l7.5 7.5c2.9 2.9 7.6 2.9 10.5 0l5.3-5.3c2.9-2.9 2.9-7.6 0-10.5l-7.5-7.5c1.8-3.2 3.3-6.7 4.3-10.3h10.6c4.1 0 7.4-3.3 7.4-7.4v-7.4c0-4.1-3.3-7.5-7.4-7.5zM70.5 89.5c-14.4 0-26-11.7-26-26 0-14.4 11.7-26 26-26 14.4 0 26 11.7 26 26 0 14.4-11.6 26-26 26z"/>' +
                  '</svg>' +
                '</div>'
    };
  };
  iconSettings.$inject = [];
  angular.module('emlogis').directive('iconSettings', iconSettings);



  //
  // Help icon
  // for breadcrumb section

  var iconHelp = function () {
    return {
      restrict: 'A',
      replace: true,
      template: '<div>' +
                  '<svg xmlns="http://www.w3.org/2000/svg" viewBox="7 0 128 128">' +
                    '<path class="eml-svg eml-icon-help" style="filter: url(#dropshadow);" fill-rule="evenodd" clip-rule="evenodd" d="M70.5 4.8c32.7 0 59.3 26.5 59.3 59.3s-26.5 59.3-59.3 59.3S11.2 96.8 11.2 64 37.8 4.8 70.5 4.8zm-7.2 82.4h11.9v11.1H63.3V87.2zm-4-32.2c0-8.1 3.4-13.3 10.8-13.3 3.1 0 8.7 2.7 8.7 9.9 0 6-3.5 8.1-7.2 11.4-4.7 4-6.9 7.7-6.9 18.1h9.6c0-8.5 3.3-11.2 7.8-15 3.8-3.4 7.8-6.3 7.8-14.8 0-11.5-8.5-18-19.4-18-13.2 0-21.3 8.6-21.3 21.7h10.1z"/>' +
                  '</svg>' +
                '</div>'
    };
  };
  iconHelp.$inject = [];
  angular.module('emlogis').directive('iconHelp', iconHelp);



  //
  // Mark as Read icon
  // for Notification's dropdown in top menu

  var markAsRead = function () {
    return {
      restrict: 'A',
      replace: true,
      template: '<div>' +
                  '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 141 128">' +
                    '<path class="eml-svg eml-icon-mark-read" style="filter: url(#dropshadow);" d="M112.7 22.3C101.5 11.1 86.7 5 71 5c-15.8 0-30.6 6.1-41.7 17.3-23 23-23 60.4 0 83.5C40.4 116.9 55.2 123 71 123c15.8 0 30.6-6.1 41.7-17.3 23-23 23-60.4 0-83.4zm-3.4 80c-10.2 10.2-23.9 15.9-38.3 15.9-14.5 0-28.1-5.6-38.3-15.9-21.1-21.1-21.1-55.5 0-76.7C42.9 15.4 56.5 9.8 71 9.8c14.5 0 28.1 5.6 38.3 15.9 21.1 21.1 21.1 55.5 0 76.6zM95.8 46.4l-34.6 37-15.1-16.2c-.9-1-2.4-1-3.4-.1s-1 2.4-.1 3.4l16.9 18h.1v.1c.1.1.3.2.5.3.1.1.2.1.3.2.3.1.6.2.9.2.3 0 .6-.1.9-.2.1 0 .2-.1.3-.2.2-.1.3-.2.5-.3v-.1h.1l36.3-38.8c.9-1 .9-2.5-.1-3.4-1.1-.9-2.6-.9-3.5.1z"/> ' +
                  '</svg>' +
                '</div>'
    };
  };
  markAsRead.$inject = [];
  angular.module('emlogis').directive('markAsRead', markAsRead);



  //
  // Close icon
  // for popup windows and "delete" actions

  var iconClose = function () {
    return {
      restrict: 'A',
      replace: true,
      template: '<div>' +
                  '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 141 128">' +
                    '<path class="eml-svg eml-icon-close" style="filter: url(#dropshadow);" d="M83.4 62.8L129.6 17 116.7 4.2 70.5 50.1 24.2 4 11.4 16.8l46.3 45.9-47.8 47.4 12.8 12.8 47.9-47.4 47.6 47.2 12.7-12.8"/>' +
                  '</svg>' +
                '</div>'
    };
  };
  iconClose.$inject = [];
  angular.module('emlogis').directive('iconClose', iconClose);



  //
  // Calendar icon
  // for inline editing in Employee profile module

  var iconCalendar = function () {
    return {
      restrict: 'A',
      replace: true,
      template: '<div>' +
                  '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 141 128">' +
                    '<path class="eml-svg eml-icon-calendar" style="filter: url(#dropshadow);" d="M95.9 18.8h-6.3v13.1h6.3V18.8zM83 96.8h6.5V58.1H83v6.5h-6.5v6.3H83v25.9zM50.6 19.1h-6.5v12.8h6.5V19.1zm51.8 6.5v12.9H83.1V25.6h-26v12.8H37.4V25.6H18v82.8c0 8.1 6.6 14.7 14.7 14.7h74.7c8.1 0 14.7-6.6 14.7-14.7V25.6h-19.7zm13.1 78.1c0 3.6-2.9 6.5-6.5 6.5H31c-3.6 0-6.5-2.9-6.5-6.5V45.1h91v58.6zm-65-6.5H57V58.1h-6.5v6.5H44v6.5h6.5v26.1z"/>' +
                  '</svg>' +
                '</div>'
    };
  };
  iconCalendar.$inject = [];
  angular.module('emlogis').directive('iconCalendar', iconCalendar);



}());
;
/*global angular:true, browser:true */

/**
 * @license HTTP Auth Interceptor Module for AngularJS
 * (c) 2012 Witold Szczerba
 * License: MIT
 */
(function () {
  'use strict';

  angular.module('http-auth-interceptor', ['http-auth-interceptor-buffer'])

    .factory('authService', ['$rootScope', '$sessionStorage', 'httpBuffer', 'applicationContext',
      function ($rootScope, $sessionStorage, httpBuffer, applicationContext) {
        return {
          // empty session info by default.
          sessionInfo: {
            token: null,
            userName: null,
            permissions: {},
            roles: {}
          },

          ihubSessionInfo: {
            AuthId: null
          },

          /**
           * Call this function to indicate that authentication was successful and trigger a
           * retry of all deferred requests.
           * @param data an optional argument to pass on to $broadcast which may be useful for
           * example if you need to pass through details of the user that was logged in
           */
          loginConfirmed: function (data, configUpdater) {
            console.log('--> loginConfirmed() token:' + data.token + '/' + data.sessionId);


            // It is recommended to save the object as json format.
            /**
             * don't need lang, it causes some trouble
             */
//        delete data.lang;
            $sessionStorage.info = JSON.stringify(data);
            $sessionStorage.appServerMode = data.appServerMode;
            $sessionStorage.username = data.userName;
            var working = applicationContext.getWorking();
            working.option = null;

            // save session information
            this.sessionInfo = data;

            // workaround for Yuriy's chnages
            if (data.token === undefined) {
              this.sessionInfo.token = data.sessionId;
            }

            var updater = configUpdater || function (config) {
                return config;
              };

            // Do the normal steps
            $rootScope.$broadcast('event:auth-loginConfirmed', data);
            httpBuffer.retryAll(updater);
          },
          isLoggedIn: function () {
            return !_.isEmpty($sessionStorage.info);
          },
          isDevMode: function () {
            return $sessionStorage.appServerMode === "DEV";
          },


          /**
           * Call this function to indicate that authentication should not proceed.
           * All deferred requests will be abandoned or rejected (if reason is provided).
           * @param data an optional argument to pass on to $broadcast.
           * @param reason if provided, the requests are rejected; abandoned otherwise.
           */
          loginCancelled: function (data, reason) {

            this.clearSessionInfo();
            httpBuffer.rejectAll(reason);
            $rootScope.$broadcast('event:auth-loginCancelled', data);
          },

          /**
           * Call this function to indicate that logout has happened and login screen should be displayed again
           * All deferred requests will be abandoned or rejected (if reason is provided).
           * @param data an optional argument to pass on to $broadcast.
           * @param reason if provided, the requests are rejected; abandoned otherwise.
           */
          logout: function (data, reason) {

            // Clear WebSocketService
            if ($rootScope.wsService !== undefined && $rootScope.wsService !== null) {
              $rootScope.wsService.stopWSlistener();
              $rootScope.wsService = null;
            }

            this.clearSessionInfo();

            // destruct all $session variables
            delete $sessionStorage.info;
            delete $sessionStorage.appServerMode;

            // TODO REMOVE
            // Clear sseService
            /*
            if ($rootScope.sseService !== null) {
              $rootScope.sseService.close();
              $rootScope.sseService = null;
            }
            */
            

            // Stop Heart bit after logs out

            if ($rootScope.heartbitWorker !== null) {
              // Heartbit work already active, so let's stop it first

              $rootScope.heartbitWorker.terminate();
              $rootScope.heartbitWorker = null;
            }


            // clear applicationContext
            // Clear impersonated status to null so that it will be used for new session
            $sessionStorage.impersonated = null;


            applicationContext.setUsername("");


            httpBuffer.rejectAll(reason);

            $rootScope.$broadcast('event:auth-loginRequired', data);
          },
          clearSessionInfo: function () {
            this.sessionInfo = {
              token: null,
              userName: null,
              permissions: {},
              roles: {}
            };
          },
          getSessionInfo: function () {
//        if (this.sessionInfo.token === null) {
//          this.sessionInfo = JSON.parse($sessionStorage.info);
//        }
            return this.sessionInfo;
          },
          setSessionInfo: function (_sessionInfo) {
            this.sessionInfo = _sessionInfo;
            $sessionStorage.info = JSON.stringify(this.sessionInfo);
          },
          getUserName: function () {
            return this.sessionInfo.userName;
          },
          getImpersonatingUserName: function () {
            return this.sessionInfo.impersonatingUserName;
          },
          getToken: function () {
            return this.sessionInfo.token;
          },
          hasPermission: function (perm) {
            if (Array.isArray(perm)) {
              return this.hasPermissionIn(perm);
            }
            return this.sessionInfo.permissions[perm];
          },
          hasPermissionIn: function (perms) {
            for (var i = 0; i < perms.length; i++) {
              if (this.hasPermission(perms[i])) {
                return true;
              }
            }
            return false;
          },
          /**
           @param {...*} role
           */
          hasRoles: function() {
            for (var i = 0; i < arguments.length; i++) {
              if(!this.sessionInfo.roles[arguments[i]]) return false;
            }
            return true;
          },
          isUserAnEmployee: function () {
            return !_.isEmpty(this.getSessionInfo().employeeId);
          },

          isSchedulableEmployee: function () {
            return this.getSessionInfo().schedulableEmployee;
          },

          isTenantType: function (tenantType) {
            return this.getSessionInfo().tenantType === tenantType;
          },

          setihubSessionInfo: function (ihubSessionInfo) {
            this.ihubSessionInfo = ihubSessionInfo;
          },

          getihubAuthId: function () {
            return this.ihubSessionInfo.AuthId;
          }

        };
      }])

  /**
   * $http interceptor.
   * On 401 response (without 'ignoreAuthModule' option) stores the request
   * and broadcasts 'event:angular-auth-loginRequired'.
   */
    .config(['$httpProvider', function ($httpProvider) {
      $httpProvider.interceptors.push(['$rootScope', '$q', 'httpBuffer', 'authService',
        function ($rootScope, $q, httpBuffer, authService) {
          return {
            // Request Interceptor
            request: function (config) {
              var deferred = $q.defer();

              // if defined, set our application token into header
              try {
                var svc = authService;
                var token = authService.getToken();
                if (token !== undefined) {
                  config.headers.EmLogisToken = token;
                }
              } catch (e) {
                //console.log('--> sending request without token '  + config.url);
              }
              return config;
            }
          };
        }]);

      $httpProvider.interceptors.push(['$rootScope', '$sessionStorage', '$q', 'httpBuffer', 'authService', 'applicationContext',
        function ($rootScope, $sessionStorage, $q, httpBuffer, authService, applicationContext) {
          return {
            // Response Error Interceptor
            responseError: function (rejection) {

              //console.log('--> Got Failure response: ' + rejection.status + ' for url:' + rejection.config.url);
              var deferred = false;
              if (rejection.status === 401 && !rejection.config.ignoreAuthModule) {

                var msg = applicationContext.getNotificationMsg();
                msg.type = 'login';
                msg.content = 'Please login to access this resource.';
                msg.visible = true;
                applicationContext.setNotificationMsg(msg);

                // remove current session information
                //  authService.logout();

//                deferred = $q.defer();
                //httpBuffer.append(rejection.config, deferred);
                // $rootScope.$broadcast('event:auth-loginRequired', rejection);
//                return deferred.promise;

                // default behaviour
                return $q.reject(rejection);
              }
              if (rejection.status === 403) {

                // Show access forbidden
                alert("Your privileges don't provide you access to this feature.");

                //deferred = $q.defer();
                //  $rootScope.$broadcast('event:auth-loginConfirmed', rejection);
                //  return deferred.promise;
                return $q.reject(rejection);
              }

              // otherwise, default behaviour
              return $q.reject(rejection);
            }
          };
        }]);
    }]);

  /**
   * Private module, a utility, required internally by 'http-auth-interceptor'.
   */
  angular.module('http-auth-interceptor-buffer', [])

    .factory('httpBuffer', ['$injector', function ($injector) {
      /** Holds all the requests, so they can be re-requested in future. */
      var buffer = [];

      /** Service initialized later because of circular dependency problem. */
      var $http;

      function retryHttpRequest(config, deferred) {
        function successCallback(response) {
          deferred.resolve(response);
        }

        function errorCallback(response) {
          deferred.reject(response);
        }

        $http = $http || $injector.get('$http');
        $http(config).then(successCallback, errorCallback);
      }

      return {
        /**
         * Appends HTTP request configuration object with deferred response attached to buffer.
         */
        append: function (config, deferred) {
          buffer.push({
            config: config,
            deferred: deferred
          });
        },

        /**
         * Abandon or reject (if reason provided) all the buffered requests.
         */
        rejectAll: function (reason) {
          if (reason) {
            for (var i = 0; i < buffer.length; ++i) {
              buffer[i].deferred.reject(reason);
            }
          }
          buffer = [];
        },

        /**
         * Retries all the buffered requests clears the buffer.
         */
        retryAll: function (updater) {
          for (var i = 0; i < buffer.length; ++i) {
            retryHttpRequest(updater(buffer[i].config), buffer[i].deferred);
          }
          buffer = [];
        }
      };
    }]);
})();


;
(function () {
  'use strict';
  angular.module('emlogis.login', ['http-auth-interceptor'])
    .controller('LoginController', ['$scope', '$http', '$sessionStorage', '$location', 'authService', 'applicationContext', 'appFunc',
      function ($scope, $http, $sessionStorage, $location, authService, applicationContext, appFunc) {

    	var host = $location.host(),
        tenantIdPart = host.substring(0, host.indexOf('-'));

        $scope.tenantId = '';
        $scope.userName = '';
        $scope.password = '';
        $scope.oldPassword = "";
        $scope.newPassword = "";
        $scope.repeatPassword = "";
        $scope.showTenantIdInput = false;

        function validTenantIdPart(tenantIdPart) {
          if (tenantIdPart.indexOf('uidev') !== -1 || tenantIdPart.indexOf('qa.') !== -1) return false;
          if (tenantIdPart === "cloud") return false;
          if (tenantIdPart.length < 3 || tenantIdPart.length > 32) return false;
          if (/^[a-z0-9-]*$/.test(tenantIdPart) === false) return false;
          if (tenantIdPart.indexOf("-") === 0 || tenantIdPart.indexOf("-") === tenantIdPart.length-1) return false;
          if (tenantIdPart.charAt(0) >= '0' && tenantIdPart.charAt(0) <= '9') return false;
          return true;
        }

        // production variant
        if(tenantIdPart.length === 0) {
        	tenantIdPart = host.substring(0, host.indexOf('.emlogis.com'));
        }
        if (host.indexOf('emlogis.com') !== -1 && validTenantIdPart(tenantIdPart)) {
            $scope.tenantId = tenantIdPart;
        }
        // default values for dev cloud environment
        else {
          $scope.showTenantIdInput = true;
          $scope.tenantId = 'tmp';
          $scope.userName = 'alishabe';
          $scope.password = 'chgpwd';
        }

        $scope.forms = {
          0: "Login",
          1: "Forgot Password",
          2: "Change Password"
        };

        $scope.showForm = $scope.forms[0];

        $scope.login = function () {
          $sessionStorage.impersonated = null;

          $http.post('../emlogis/rest/sessions', {
            tenantId: $scope.tenantId,
            login: $scope.userName,
            password: CryptoJS.SHA256($scope.password + "." + $scope.tenantId).toString()
          })
          .success(function(data) {
            applicationContext.setUsername(data.userName);

            data.tenantId = $scope.tenantId;
            authService.loginConfirmed(data);

            // reset login info
            $scope.tenantId = '';
            $scope.userName = '';
            $scope.password = '';

            if (authService.hasPermissionIn(['Availability_RequestMgmt', 'Shift_RequestMgmt'])) {
              appFunc.badgeRefresh(true); // Manager = true;
            }
            else if (authService.hasPermissionIn(['Availability_Request', 'Shift_Request'])) {
              appFunc.badgeRefresh(false); // Manager = false;
            }
          })
          .error(function(err) {
              var msg = err.info || "Failed to login. Please check your credentials.";
              applicationContext.setNotificationMsgWithValues(msg, 'danger', true);
              // TODO: Check how exception will come
              if (err.exception === "ForceChangeOnFirstLogonException" || err.exception === "PendingPasswordChangeException") {
                $scope.showForm = $scope.forms[2];
              }
          });
        };

        $scope.requestPasswordReset = function() {
          $http.post('../emlogis/rest/sessions/ops/resetpassword', {
            tenantId: $scope.tenantId,
            login: $scope.userName
          })
          .success(function(data) {
            var message = data.info || "Instructions have been sent to the emai " + data.emailAddress;
            applicationContext.setNotificationMsgWithValues(message, 'success', true);
            $location.path('/');
          })
          .error(function(err) {
            var msg = err.info || err;
            applicationContext.setNotificationMsgWithValues(msg, 'danger', true);
          });
        };

        $scope.changePassword = function() {
          $http.post('../emlogis/rest/sessions/ops/chgpassword ', {
            tenantId: $scope.tenantId,
            login: $scope.userName,
            oldPassword: CryptoJS.SHA256($scope.oldPassword + "." + $scope.tenantId).toString(),
            newPassword: $scope.newPassword
          })
          .success(function() {
            applicationContext.setNotificationMsgWithValues("Password changed", 'success', true);
            $scope.password = $scope.newPassword;
            $scope.login();
          })
          .error(function(err) {
            var msg = err.info || err.message;
            applicationContext.setNotificationMsgWithValues(msg, 'danger', true);
          });
        };

        $scope.validNewPassword = function() {
          return $scope.newPassword && ($scope.newPassword.length > 4);
        };

        $scope.passwordsMatch = function() {
          return $scope.newPassword && $scope.newPassword === $scope.repeatPassword;
        };

        $scope.$watch("newPassword", function(p) {
          var margin = p ? "-3px" : "15px";
          $(".new-pwd").css("margin-bottom", margin);
        });

        $scope.$watch("repeatPassword", function(p) {
          var margin = $scope.passwordsMatch() ? "-3px" : "15px";
          $(".repeat-pwd").css("margin-bottom", margin);
        });

    }]);
})();

;
var about = angular.module('emlogis.about', ['ui.bootstrap','ui.router', 'http-auth-interceptor']).config(
		
	function ( $stateProvider, $urlRouterProvider, $locationProvider, $httpProvider) {	
		
		// /manage = management module entry point/url	
		$stateProvider.state( 'about', {
			url: '/about',
			templateUrl: 'modules/about/partials/about.html',
	        data : {
	            title : 'about'
	        }
		});
	}
);

about.controller('aboutCtrl', function($scope, $compile) {
	console.log('inside about controller');
});






;

(function () {
	angular
	.module('emlogis.accountmgmt', ['ui.bootstrap','ui.router', 'http-auth-interceptor', 'emlogis.commonservices'])
	.config(
			
		function ($stateProvider, $urlRouterProvider, $locationProvider, $httpProvider) {	

		}
	)
	.run(function(appContext) { 

		var entity2resource = appContext.get('entity2resource', {});
		_.defaults(entity2resource, {
	    	useraccount: {restResource: "useraccounts", label: "User Account"},
	        groupaccount: {restResource: "groupaccounts", label: "User Group"},
	        role: {restResource: "roles", label: "Role"}
	    });
  	});
}());







;
angular.module('emlogis.admin', ['ui.bootstrap', 'ui.router', 'http-auth-interceptor', 'ui.grid', 'ui.grid.moveColumns', 'ui.grid.pagination', 'ui.grid.selection', 'ui.grid.resizeColumns', 'emlogis.commonservices', 'emlogis.commonDirectives', 'frapontillo.bootstrap-switch', 'uiGmapgoogle-maps'])
  .config(['$stateProvider', '$urlRouterProvider',
    function ( $stateProvider, $urlRouterProvider) {

      $urlRouterProvider.when('/admin', '/admin/customers');
      $urlRouterProvider.when('/admin/', '/admin/customers');
      $urlRouterProvider.when('/admin/customers', '/admin/customers/list');
      $urlRouterProvider.when('/admin/customers/', '/admin/customers/list');
      $urlRouterProvider.when('/admin/notification-delivery', '/admin/notification-delivery/email');
      $urlRouterProvider.when('/admin/notification-delivery/', '/admin/notification-delivery/email');
      $urlRouterProvider.when('/admin/notification-delivery/email', '/admin/notification-delivery/email/edit');
      $urlRouterProvider.when('/admin/notification-delivery/email/', '/admin/notification-delivery/email/edit');
      $urlRouterProvider.when('/admin/notification-delivery/sms', '/admin/notification-delivery/sms/edit');
      $urlRouterProvider.when('/admin/notification-delivery/sms/', '/admin/notification-delivery/sms/edit');

      $stateProvider.state('authenticated.admin', {
        url: '/admin',
        abstract: true,
        views: {
          'content@authenticated': {
            templateUrl: 'modules/admin/partials/admin.html',
            controller: 'AdminCtrl'
          },
          'breadcrumb@authenticated': {
            templateUrl: 'modules/admin/partials/admin-breadcrumb.html',
            controller: 'AdminBreadcrumbCtrl'
          }
        },
        data: {
          ncyBreadcrumbLabel: '{{"nav.ADMIN" | translate}}',
          permissions: function (authService) {
            return authService.hasPermissionIn(['Tenant_Mgmt', 'Tenant_View']);
          }
        }
      })
        .state('authenticated.admin.customers', {
          url: '/customers',
          views: {
            'adminContent@authenticated.admin': {
              templateUrl: 'modules/admin/partials/customers/admin-customers.html',
              controller: 'AdminCustomersCtrl'
            },
            'adminBreadcrumb@authenticated.admin': {
              templateUrl: 'modules/admin/partials/customers/admin-customers-breadcrumb.html',
              controller: 'AdminCustomersBreadcrumbCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"admin.CUSTOMERS" | translate}}'
          }
        })
        .state('authenticated.admin.customers.list', {
          url: '/list',
          views: {
            'adminCustomersContent@authenticated.admin.customers': {
              templateUrl: 'modules/admin/partials/customers/admin-customers-list.html',
              controller: 'AdminCustomersListCtrl'
            },
            'adminCustomersBreadcrumb@authenticated.admin.customers': {
              templateUrl: 'modules/admin/partials/customers/admin-customers-list-breadcrumb.html',
              controller: 'AdminCustomersListBreadcrumbCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"app.LIST" | translate}}'
          }
        })
        .state('authenticated.admin.customers.customerEdit', {
          url: '/:tenantId/edit',
          views: {
            'adminCustomersContent@authenticated.admin.customers': {
              templateUrl: 'modules/admin/partials/customers/admin-customers-customer-edit.html',
              controller: 'AdminCustomersCustomerEditCtrl'
            },
            'adminCustomersBreadcrumb@authenticated.admin.customers': {
              templateUrl: 'modules/admin/partials/customers/admin-customers-customer-edit-breadcrumb.html',
              controller: 'AdminCustomersCustomerEditBreadcrumbCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"app.EDIT" | translate}}'
          }
        })
        .state('authenticated.admin.customers.customerEdit.import', {
          url: '/import',
          views: {
            'adminCustomersContentImport@authenticated.admin.customers.customerEdit': {
              templateUrl: 'modules/admin/partials/customers/include/import/admin-customers-customer-edit-import.html',
              controller: 'AdminCustomersCustomerEditImportCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"admin.customers.IMPORT_SERVICES" | translate}}'
          }
        })
        .state('authenticated.admin.customers.create', {
          url: '/create',
          views: {
            'adminCustomersContent@authenticated.admin.customers': {
              templateUrl: 'modules/admin/partials/customers/admin-customers-create.html',
              controller: 'AdminCustomersCreateCtrl'
            },
            'adminCustomersBreadcrumb@authenticated.admin.customers': {
              templateUrl: 'modules/admin/partials/customers/admin-customers-create-breadcrumb.html',
              controller: 'AdminCustomersCreateBreadcrumbCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"app.CREATE" | translate}}'
          }
        })
        .state('authenticated.admin.notificationDelivery', {
          url: '/notification-delivery',
          views: {
            'adminContent@authenticated.admin': {
              templateUrl: 'modules/admin/partials/notification-delivery/admin-notification-delivery.html',
              controller: 'AdminNotificationDeliveryCtrl'
            },
            'adminBreadcrumb@authenticated.admin': {
              templateUrl: 'modules/admin/partials/notification-delivery/admin-notification-delivery-breadcrumb.html',
              controller: 'AdminNotificationDeliveryBreadcrumbCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"admin.NOTIFICATION_DELIVERY" | translate}}'
          }
        })
        .state('authenticated.admin.notificationDelivery.email', {
          url: '/email',
          views: {
            'adminNotificationDeliveryContent@authenticated.admin.notificationDelivery': {
              templateUrl: 'modules/admin/partials/notification-delivery/admin-notification-delivery-email.html',
              controller: 'AdminNotificationDeliveryEmailCtrl'
            },
            'adminNotificationDeliveryBreadcrumb@authenticated.admin.notificationDelivery': {
              templateUrl: 'modules/admin/partials/notification-delivery/admin-notification-delivery-email-breadcrumb.html',
              controller: 'AdminNotificationDeliveryEmailBreadcrumbCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"admin.notification_delivery.EMAIL" | translate}}'
          }
        })
        .state('authenticated.admin.notificationDelivery.email.edit', {
          url: '/edit',
          views: {
            'adminNotificationDeliveryEmailContent@authenticated.admin.notificationDelivery.email': {
              templateUrl: 'modules/admin/partials/notification-delivery/admin-notification-delivery-email-edit.html',
              controller: 'AdminNotificationDeliveryEmailEditCtrl'
            },
            'adminNotificationDeliveryEmailBreadcrumb@authenticated.admin.notificationDelivery.email': {
              templateUrl: 'modules/admin/partials/notification-delivery/admin-notification-delivery-email-edit-breadcrumb.html',
              controller: 'AdminNotificationDeliveryEmailEditBreadcrumbCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"app.EDIT" | translate}}'
          }
        })
        .state('authenticated.admin.notificationDelivery.email.createProvider', {
          url: '/create-provider/:providerType',
          views: {
            'adminNotificationDeliveryEmailContent@authenticated.admin.notificationDelivery.email': {
              templateUrl: 'modules/admin/partials/notification-delivery/admin-notification-delivery-email-create-provider.html',
              controller: 'AdminNotificationDeliveryEmailCreateProviderCtrl'
            },
            'adminNotificationDeliveryEmailBreadcrumb@authenticated.admin.notificationDelivery.email': {
              templateUrl: 'modules/admin/partials/notification-delivery/admin-notification-delivery-email-create-provider-breadcrumb.html',
              controller: 'AdminNotificationDeliveryEmailCreateProviderBreadcrumbCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"admin.notification_delivery.CREATE_PROVIDER" | translate}}'
          }
        })
        .state('authenticated.admin.notificationDelivery.sms', {
          url: '/sms',
          views: {
            'adminNotificationDeliveryContent@authenticated.admin.notificationDelivery': {
              templateUrl: 'modules/admin/partials/notification-delivery/admin-notification-delivery-sms.html',
              controller: 'AdminNotificationDeliverySmsCtrl'
            },
            'adminNotificationDeliveryBreadcrumb@authenticated.admin.notificationDelivery': {
              templateUrl: 'modules/admin/partials/notification-delivery/admin-notification-delivery-sms-breadcrumb.html',
              controller: 'AdminNotificationDeliverySmsBreadcrumbCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"admin.notification_delivery.SMS" | translate}}'
          }
        })
        .state('authenticated.admin.notificationDelivery.sms.edit', {
          url: '/edit',
          views: {
            'adminNotificationDeliverySmsContent@authenticated.admin.notificationDelivery.sms': {
              templateUrl: 'modules/admin/partials/notification-delivery/admin-notification-delivery-sms-edit.html',
              controller: 'AdminNotificationDeliverySmsEditCtrl'
            },
            'adminNotificationDeliverySmsBreadcrumb@authenticated.admin.notificationDelivery.sms': {
              templateUrl: 'modules/admin/partials/notification-delivery/admin-notification-delivery-sms-edit-breadcrumb.html',
              controller: 'AdminNotificationDeliverySmsEditBreadcrumbCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"app.EDIT" | translate}}'
          }
        })
        .state('authenticated.admin.notificationDelivery.sms.createProvider', {
          url: '/create-provider/:providerType',
          views: {
            'adminNotificationDeliverySmsContent@authenticated.admin.notificationDelivery.sms': {
              templateUrl: 'modules/admin/partials/notification-delivery/admin-notification-delivery-sms-create-provider.html',
              controller: 'AdminNotificationDeliverySmsCreateProviderCtrl'
            },
            'adminNotificationDeliverySmsBreadcrumb@authenticated.admin.notificationDelivery.sms': {
              templateUrl: 'modules/admin/partials/notification-delivery/admin-notification-delivery-sms-create-provider-breadcrumb.html',
              controller: 'AdminNotificationDeliverySmsCreateProviderBreadcrumbCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"admin.notification_delivery.CREATE_PROVIDER" | translate}}'
          }
        });
    }
  ])
  .config(['uiGmapGoogleMapApiProvider', function(uiGmapGoogleMapApiProvider) {
    uiGmapGoogleMapApiProvider.configure({
      //    key: 'your api key',
      v: '3.17',
      libraries: 'weather,geometry,visualization'
    });
  }])
  .run(['$rootScope', '$http', function($rootScope, $http) {

  }]);

;
angular.module('emlogis.admin').controller('AdminBreadcrumbCtrl', ['$scope', '$translate', 'applicationContext', 'authService',
  function($scope, $translate, applicationContext, authService) {
    // Update Module Information
    var module = applicationContext.getModule();

    // Call translate directive function. Put translated text;
    $translate('nav.ADMIN')
      .then(function (translation) {
        module.name =  translation;
      });
    module.href = '/admin';
    module.icoClass = 'glyphicon glyphicon-cog';
    module.disableModuleBreadcrumb = false;
    applicationContext.setModule(module);

    $scope.hasPermissionIn = function (perms) {
      return authService.hasPermissionIn(perms);
    };

    $scope.hasPermission = function (perm) {
      return authService.hasPermission(perm);
    };
  }
]);

;
angular.module('emlogis.admin').controller('AdminCtrl', ['$scope', 'authService',
    function($scope, authService) {
      $scope.hasPermissionIn = function (perms) {
        return authService.hasPermissionIn(perms);
      };

      $scope.hasPermission = function (perm) {
        return authService.hasPermission(perm);
      };
    }
]);

;
angular.module('emlogis.admin').controller('AdminCustomersBreadcrumbCtrl', ['$scope', '$state',
  function($scope, $state) {
    $scope.entityName = "admin.customers.NAME";
    $scope.entityResource = "admin.CUSTOMERS";
    $scope.entityQuickSearchUrl = "serviceproviders/emlogisservice/orgs/ops/quicksearch";

    $scope.selectEntitySearchValue = function (item, model, label) {
      $state.go('authenticated.admin.customers.customerEdit', {tenantId: item.id});
    };

    $scope.goToNewEntityState = function () {
      $state.go('authenticated.admin.customers.create');
    };

    $scope.hasMgmtPermission = function () {
      return $scope.hasPermission('Tenant_Mgmt');
    };

    $scope.hasViewPermission = function () {
      return $scope.hasPermission('Tenant_View');
    };
  }
]);

;
angular.module('emlogis.admin').controller('AdminCustomersCreateBreadcrumbCtrl', ['$scope',
    function($scope) {

    }
]);

;
angular.module('emlogis.admin').controller('AdminCustomersCreateCtrl', ['$scope', '$state', '$q', '$translate', 'AdminCustomersService', 'applicationContext',
  function($scope, $state, $q, $translate, AdminCustomersService, applicationContext) {

    $scope.customerDetails = {
      smsDeliveryTenantSettingsDto: {
        providerId: '---Please select---',
        providerName: '---Please select---',
        providerType: '',
        settings: {
          tenantCallNumber: ''
        }
      },
      emailDeliveryTenantSettingsDto: {
        providerId: '---Please select---',
        providerName: '---Please select---',
        providerType: '',
        settings: {
          tenantMailBox: ''
        }
      },
      timeZone: 'UTC'
    };
    $scope.datePickerOpened = {};
    $scope.openDatePicker = function($event, datePickerName) {
      $event.preventDefault();
      $event.stopPropagation();

      $scope.datePickerOpened[datePickerName] = true;
    };

    $scope.datePickerOptions = {
      formatYear: 'yyyy',
      startingDay: 1
    };
    $q.all([$translate('app.TRIAL'), $translate('app.DISABLED')]).then(function(responses) {
      $scope.availableStatusValues = [
        {label: responses[0], value: 'Trial'},
        {label: responses[1], value: 'Disabled'}
      ];
    });

    $scope.goToCustomerListState = function() {
      $state.go('authenticated.admin.customers.list');
    };

    $scope.createCustomer = function() {
      var createdCustomerDetails = {
        name: $scope.customerDetails.name,
        tenantId: $scope.customerDetails.tenantId,
        updateDto: {}
      };
      createdCustomerDetails.updateDto = angular.copy($scope.customerDetails);
      delete createdCustomerDetails.updateDto.name;
      delete createdCustomerDetails.updateDto.tenantId;
      delete createdCustomerDetails.updateDto.smsDeliveryTenantSettingsDto.providerName;
      delete createdCustomerDetails.updateDto.smsDeliveryTenantSettingsDto.providerType;
      delete createdCustomerDetails.updateDto.emailDeliveryTenantSettingsDto.providerName;
      delete createdCustomerDetails.updateDto.emailDeliveryTenantSettingsDto.providerType;

      AdminCustomersService.createCustomer(createdCustomerDetails).then(function(response) {
        applicationContext.setNotificationMsgWithValues('app.CREATED_SUCCESSFULLY', 'success', true);
        $state.go('authenticated.admin.customers.customerEdit', {tenantId: response.data.tenantId});
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
        //$state.go('authenticated.admin.customers.list');
      });
    };
  }
]);

;
angular.module('emlogis.admin').controller('AdminCustomersCustomerEditBreadcrumbCtrl', ['$scope',
    function($scope) {

    }
]);

;
angular.module('emlogis.admin').controller('AdminCustomersCustomerEditImportCtrl', [
  '$scope',
  '$state',
  '$q',
  '$stateParams',
  '$translate',
  'AdminCustomersService',
  'applicationContext',
  'dialogs',
  '$filter',
  function ($scope,
            $state,
            $q,
            $stateParams,
            $translate,
            AdminCustomersService,
            applicationContext,
            dialogs,
            $filter) {

    $scope.tenantId = $stateParams.tenantId;

    var importTypes = {
      EMPLOYEE: "EMPLOYEE__V1"
    };

    $scope.defaults = {
      employee: {
        mappingFields: []
      }
    };

    $scope.configs = {
      employee: {},
      avail:{},
      getObjectFieldNameForImportType: function(importType) {
        switch (importType) {
          case importTypes.EMPLOYEE:
            return "employee";
          default:
            var message = "Unrecognizable import type: " + importType + " in fetched import configuration";
            applicationContext.setNotificationMsgWithValues(message, 'danger', true);
            throw message;
        }
      }
    };

    function initEmployeeImport() {
      AdminCustomersService.getImportConfigurations($scope.tenantId).then(function success(response) {
        _.forEach(response.data.result, function(configuration) {
          console.log(response.data.result);
          $scope.configs[$scope.configs.getObjectFieldNameForImportType(configuration.importType)] = configuration;
        });
      }, function error(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });

      AdminCustomersService.getImportConfigurationMappingFields($scope.tenantId, importTypes.EMPLOYEE)
        .then(function success(response) {
          angular.copy(response.data, $scope.defaults.employee.mappingFields);
      });
    }

    initEmployeeImport();
  //  $scope.importServices = {
  //    employeeImport: {
  //      importDate: new Date()
  //    },
  //    importHistoryList: [],
  //    importHistoryListGridData: [
  //      {
  //        id: '001',
  //        importStartDate: '06/28/2015',
  //        importEndDate: '06/28/2015',
  //        progress: '98%',
  //        status: 'Scheduled',
  //        processed: 286,
  //        updated: 306,
  //        report: '?',
  //        importedFile: 'file_name_06282015.csv'
  //      }, {
  //        id: '002',
  //        importStartDate: '06/29/2015',
  //        importEndDate: '06/29/2015',
  //        progress: '94%',
  //        status: 'In Progress',
  //        processed: 242,
  //        updated: 206,
  //        report: '?',
  //        importedFile: 'file_name_06292015.csv'
  //      }, {
  //        id: '003',
  //        importStartDate: '06/24/2015',
  //        importEndDate: '06/24/2015',
  //        progress: '58%',
  //        status: 'In Progress',
  //        processed: 131,
  //        updated: 206,
  //        report: '?',
  //        importedFile: 'file_name_06242015.csv'
  //      }
  //    ],
  //    importHistoryListGridOptions: {
  //      data: 'importServices.importHistoryListGridData',
  //      columnDefs: [
  //        { field: 'id', visible: false },
  //        { field: 'importStartDate', width: '18%' },
  //        { field: 'importEndDate', width: '18%' },
  //        { field: 'progress', width: '10%' },
  //        { field: 'status', width: '12%' },
  //        { field: 'processed', width: '10%' },
  //        { field: 'updated', width: '10%' },
  //        { field: 'report', width: '10%' },
  //        { field: 'importedFile', width: '15%' }
  //      ]
  //    }
  //  };
  //
  //  $scope.datePickerOpened = {};
  //  $scope.currentDate = new Date();
  //  $scope.openDatePicker = function ($event, datePickerName) {
  //    $event.preventDefault();
  //    $event.stopPropagation();
  //
  //    $scope.datePickerOpened[datePickerName] = true;
  //  };
  //
  //  $scope.datePickerOptions = {
  //    formatYear: 'yyyy',
  //    startingDay: 1
  //  };
  //
  //  $q.all([$translate('app.TRIAL'), $translate('app.DISABLED')]).then(function (responses) {
  //    $scope.availableStatusValues = [
  //      {label: responses[0], value: 'Trial'},
  //      {label: responses[1], value: 'Disabled'}
  //    ];
  //  });
  //
  //  $scope.tabs = [
  //    {
  //      tabHeading: 'admin.customers.GENERAL_SETTINGS',
  //      selected: true
  //    }, {
  //      tabHeading: 'admin.customers.IMPORT_SERVICES',
  //      selected: false
  //    }
  //  ];
  //
  //  $scope.selectTab = function(tab) {
  //    angular.forEach($scope.tabs, function(tab) {
  //      tab.selected = false;
  //    });
  //
  //    tab.selected = true;
  //  };
  //
  //  $scope.subTabs = [
  //    {
  //      tabHeading: 'admin.customers.EMPLOYEE_IMPORT',
  //      selected: true
  //    }, {
  //      tabHeading: 'admin.customers.AVAILABILITY_IMPORT',
  //      selected: false
  //    }, {
  //      tabHeading: 'admin.customers.CONFIGURATION_SERVICE',
  //      selected: false
  //    }, {
  //      tabHeading: 'admin.customers.FILE_SERVICE',
  //      selected: false
  //    }, {
  //      tabHeading: 'admin.customers.IMPORT_PROCESS_SERVICE',
  //      selected: false
  //    }, {
  //      tabHeading: 'admin.customers.S3_SERVICE',
  //      selected: false
  //    }
  //  ];
  //
  //  $scope.selectSubTab = function(subTab) {
  //    angular.forEach($scope.subTabs, function(subTab) {
  //      subTab.selected = false;
  //    });
  //
  //    subTab.selected = true;
  //  };
  //
  //  $scope.goToCustomerListState = function () {
  //    $state.go('authenticated.admin.customers.list');
  //  };
  //
  //  $scope.switchEditMode = function () {
  //    $scope.overviewInEditMode = !$scope.overviewInEditMode;
  //    if ($scope.overviewInEditMode) {
  //      $scope.overviewEditButtonLabel = 'app.END_EDIT';
  //    } else {
  //      $scope.overviewEditButtonLabel = 'app.EDIT_STATUS';
  //    }
  //  };
  //
  //  $scope.setExpirationRelatedValues = function () {
  //    var dayInMilliSeconds = 24 * 3600 * 1000;
  //    var expirationDateInLong = $scope.customerDetails.productLicenseInfo.moduleExpirationDateObj.getTime();
  //    var todayInLong = $scope.currentDate.getTime();
  //    $scope.customerDetails.productLicenseInfo.moduleExpirationDate = $scope.customerDetails.productLicenseInfo.moduleExpirationDateObj.getTime();
  //    $scope.customerDetails.productLicenseInfo.remaining = Math.ceil((expirationDateInLong - todayInLong) / dayInMilliSeconds);
  //    if ($scope.customerDetails.productLicenseInfo.remaining < 0) {
  //      $scope.customerDetails.productLicenseInfo.remaining = 0;
  //    }
  //  };
  //
  //  $scope.fillCustomerDetails = function () {
  //    $scope.customerDetails = angular.copy($scope.customer);
  //    $scope.customerDetails.created = new Date($scope.customer.created);
  //    $scope.customerDetails.productLicenseInfo.moduleExpirationDateObj = new Date($scope.customer.productLicenseInfo.moduleExpirationDate);
  //    var dayInMilliSeconds = 24 * 3600 * 1000;
  //    $scope.customerDetails.productLicenseInfo.remaining = Math.ceil(($scope.customer.productLicenseInfo.moduleExpirationDate - $scope.currentDate.getTime()) / dayInMilliSeconds);
  //    if ($scope.customerDetails.productLicenseInfo.remaining < 0) {
  //      $scope.customerDetails.productLicenseInfo.remaining = 0;
  //    }
  //    $scope.customerDetails.smsDeliveryTenantSettingsDto = {
  //      providerId: $scope.customer.smsDeliveryTenantSettingsDto.providerId,
  //      providerName: $scope.customer.smsDeliveryTenantSettingsDto.providerName,
  //      providerType: $scope.customer.smsDeliveryTenantSettingsDto.providerType,
  //      settings: {
  //        tenantCallNumber: $scope.customer.smsDeliveryTenantSettingsDto.settings.tenantCallNumber
  //      }
  //    };
  //    $scope.customerDetails.emailDeliveryTenantSettingsDto = {
  //      providerId: $scope.customer.emailDeliveryTenantSettingsDto.providerId,
  //      providerName: $scope.customer.emailDeliveryTenantSettingsDto.providerName,
  //      providerType: $scope.customer.emailDeliveryTenantSettingsDto.providerType,
  //      settings: {
  //        tenantMailBox: $scope.customer.emailDeliveryTenantSettingsDto.settings.tenantMailBox
  //      }
  //    };
  //    angular.forEach($scope.customerDetails.modulesLicenseInfo, function (module) {
  //      module.moduleExpirationDateObj = new Date(module.moduleExpirationDate);
  //      module.remaining = Math.ceil((module.moduleExpirationDate - $scope.currentDate.getTime()) / dayInMilliSeconds);
  //      if (module.remaining < 0) {
  //        module.remaining = 0;
  //      }
  //    });
  //  };
  //
  //  $scope.saveCustomer = function () {
  //    var savedCustomerDetails = angular.copy($scope.customerDetails);
  //    delete savedCustomerDetails.tenantId;
  //    delete savedCustomerDetails.clName;
  //    delete savedCustomerDetails.created;
  //    delete savedCustomerDetails.updated;
  //    delete savedCustomerDetails.productLicenseInfo.clName;
  //    delete savedCustomerDetails.productLicenseInfo.moduleName;
  //    delete savedCustomerDetails.productLicenseInfo.moduleExpirationDateObj;
  //    delete savedCustomerDetails.productLicenseInfo.remaining;
  //    angular.forEach(savedCustomerDetails.modulesLicenseInfo, function (module) {
  //      delete module.moduleExpirationDateObj;
  //      delete module.clName;
  //      delete module.remaining;
  //    });
  //    delete savedCustomerDetails.emailDeliveryTenantSettingsDto.providerName;
  //    delete savedCustomerDetails.emailDeliveryTenantSettingsDto.providerType;
  //    delete savedCustomerDetails.smsDeliveryTenantSettingsDto.providerName;
  //    delete savedCustomerDetails.smsDeliveryTenantSettingsDto.providerType;
  //    delete savedCustomerDetails.nbOfSites;
  //    delete savedCustomerDetails.nbOfTeams;
  //    delete savedCustomerDetails.nbOfEmployees;
  //    delete savedCustomerDetails.lastLoggingDate;
  //    delete savedCustomerDetails.lastLoggingUserName;
  //
  //    AdminCustomersService.updateCustomer($scope.tenantId, savedCustomerDetails).then(function (response) {
  //      applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', 'success', true);
  //    }, function (err) {
  //      applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
  //    }).finally(function () {
  //      $scope.initEditDetails();
  //    });
  //  };
  //
  //  $scope.deleteCustomer = function () {
  //    // Confirm deletion
  //    var question = $filter('translate')("admin.customers.DELETE_CUSTOMER") + $scope.customerDetails.name + '?';
  //    var dlg = dialogs.confirm('app.PLEASE_CONFIRM', question);
  //
  //    dlg.result.then(function () {
  //      AdminCustomersService.deleteCustomer($scope.tenantId).then(function (response) {
  //        applicationContext.setNotificationMsgWithValues('app.DELETED_SUCCESSFULLY', 'success', true);
  //        $state.go('authenticated.admin.customers.list');
  //      }, function (err) {
  //        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
  //        $scope.initEditDetails();
  //      });
  //    });
  //  };
  //
  //  $scope.initEditDetails = function () {
  //    AdminCustomersService.getCustomerDetails($scope.tenantId).then(function (response) {
  //      $scope.customer = response.data;
  //      $scope.fillCustomerDetails();
  //    }, function (err) {
  //      applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
  //    });
  //  };
  //
  //  $scope.initEditDetails();
  }
]);

;
angular.module('emlogis.admin').controller('AdminCustomersCustomerEditCtrl', [
  '$scope',
  '$state',
  '$q',
  '$stateParams',
  '$translate',
  'AdminCustomersService',
  'applicationContext',
  'dialogs',
  '$filter',
  function ($scope,
            $state,
            $q,
            $stateParams,
            $translate,
            AdminCustomersService,
            applicationContext,
            dialogs,
            $filter) {

    $scope.tenantId = $stateParams.tenantId;
    $scope.customer = null;
    $scope.customerDetails = {};
    $scope.overviewInEditMode = false;
    $scope.overviewEditButtonLabel = 'app.EDIT_STATUS';
    $scope.importServices = {
      employeeImport: {
        importDate: new Date()
      },
      importHistoryList: [],
      importHistoryListGridData: [
        {
          id: '001',
          importStartDate: '06/28/2015',
          importEndDate: '06/28/2015',
          progress: '98%',
          status: 'Scheduled',
          processed: 286,
          updated: 306,
          report: '?',
          importedFile: 'file_name_06282015.csv'
        }, {
          id: '002',
          importStartDate: '06/29/2015',
          importEndDate: '06/29/2015',
          progress: '94%',
          status: 'In Progress',
          processed: 242,
          updated: 206,
          report: '?',
          importedFile: 'file_name_06292015.csv'
        }, {
          id: '003',
          importStartDate: '06/24/2015',
          importEndDate: '06/24/2015',
          progress: '58%',
          status: 'In Progress',
          processed: 131,
          updated: 206,
          report: '?',
          importedFile: 'file_name_06242015.csv'
        }
      ],
      importHistoryListGridOptions: {
        data: 'importServices.importHistoryListGridData',
        columnDefs: [
          { field: 'id', visible: false },
          { field: 'importStartDate', width: '18%' },
          { field: 'importEndDate', width: '18%' },
          { field: 'progress', width: '10%' },
          { field: 'status', width: '12%' },
          { field: 'processed', width: '10%' },
          { field: 'updated', width: '10%' },
          { field: 'report', width: '10%' },
          { field: 'importedFile', width: '15%' }
        ]
      }
    };

    $scope.datePickerOpened = {};
    $scope.currentDate = new Date();
    $scope.openDatePicker = function ($event, datePickerName) {
      $event.preventDefault();
      $event.stopPropagation();

      $scope.datePickerOpened[datePickerName] = true;
    };

    $scope.datePickerOptions = {
      formatYear: 'yyyy',
      startingDay: 1
    };

    $q.all([$translate('app.TRIAL'), $translate('app.DISABLED')]).then(function (responses) {
      $scope.availableStatusValues = [
        {label: responses[0], value: 'Trial'},
        {label: responses[1], value: 'Disabled'}
      ];
    });

    $scope.tabs = [
      {
        tabHeading: 'admin.customers.GENERAL_SETTINGS',
        selected: true,
        onShow: onGeneralSettingsTabShown
      }, {
        tabHeading: 'admin.customers.IMPORT_SERVICES',
        selected: false,
        onShow: onImportServicesTabShown
      }
    ];

    function onImportServicesTabShown() {
      $state.go('authenticated.admin.customers.customerEdit.import');
    }

    function onGeneralSettingsTabShown() {
      $state.go('authenticated.admin.customers.customerEdit', {tenantId: $scope.tenantId});
    }

    $scope.selectTab = function(tab) {
      angular.forEach($scope.tabs, function(tab) {
        tab.selected = false;
      });

      tab.selected = true;
      if(tab.onShow) {
        tab.onShow();
      }
    };

    $scope.subTabs = [
      {
        tabHeading: 'admin.customers.EMPLOYEE_IMPORT',
        selected: true
      }, {
        tabHeading: 'admin.customers.AVAILABILITY_IMPORT',
        selected: false
      }, {
        tabHeading: 'admin.customers.CONFIGURATION_SERVICE',
        selected: false
      }, {
        tabHeading: 'admin.customers.FILE_SERVICE',
        selected: false
      }, {
        tabHeading: 'admin.customers.IMPORT_PROCESS_SERVICE',
        selected: false
      }, {
        tabHeading: 'admin.customers.S3_SERVICE',
        selected: false
      }
    ];

    $scope.selectSubTab = function(subTab) {
      angular.forEach($scope.subTabs, function(subTab) {
        subTab.selected = false;
      });

      subTab.selected = true;
    };

    $scope.goToCustomerListState = function () {
      $state.go('authenticated.admin.customers.list');
    };

    $scope.switchEditMode = function () {
      $scope.overviewInEditMode = !$scope.overviewInEditMode;
      if ($scope.overviewInEditMode) {
        $scope.overviewEditButtonLabel = 'app.END_EDIT';
      } else {
        $scope.overviewEditButtonLabel = 'app.EDIT_STATUS';
      }
    };

    $scope.setExpirationRelatedValues = function () {
      var dayInMilliSeconds = 24 * 3600 * 1000;
      var expirationDateInLong = $scope.customerDetails.productLicenseInfo.moduleExpirationDateObj.getTime();
      var todayInLong = $scope.currentDate.getTime();
      $scope.customerDetails.productLicenseInfo.moduleExpirationDate = $scope.customerDetails.productLicenseInfo.moduleExpirationDateObj.getTime();
      $scope.customerDetails.productLicenseInfo.remaining = Math.ceil((expirationDateInLong - todayInLong) / dayInMilliSeconds);
      if ($scope.customerDetails.productLicenseInfo.remaining < 0) {
        $scope.customerDetails.productLicenseInfo.remaining = 0;
      }
    };

    $scope.fillCustomerDetails = function () {
      $scope.customerDetails = angular.copy($scope.customer);
      $scope.customerDetails.created = new Date($scope.customer.created);
      $scope.customerDetails.productLicenseInfo.moduleExpirationDateObj = new Date($scope.customer.productLicenseInfo.moduleExpirationDate);
      var dayInMilliSeconds = 24 * 3600 * 1000;
      $scope.customerDetails.productLicenseInfo.remaining = Math.ceil(($scope.customer.productLicenseInfo.moduleExpirationDate - $scope.currentDate.getTime()) / dayInMilliSeconds);
      if ($scope.customerDetails.productLicenseInfo.remaining < 0) {
        $scope.customerDetails.productLicenseInfo.remaining = 0;
      }
      $scope.customerDetails.smsDeliveryTenantSettingsDto = {
        providerId: $scope.customer.smsDeliveryTenantSettingsDto.providerId,
        providerName: $scope.customer.smsDeliveryTenantSettingsDto.providerName,
        providerType: $scope.customer.smsDeliveryTenantSettingsDto.providerType,
        settings: {
          tenantCallNumber: $scope.customer.smsDeliveryTenantSettingsDto.settings.tenantCallNumber
        }
      };
      $scope.customerDetails.emailDeliveryTenantSettingsDto = {
        providerId: $scope.customer.emailDeliveryTenantSettingsDto.providerId,
        providerName: $scope.customer.emailDeliveryTenantSettingsDto.providerName,
        providerType: $scope.customer.emailDeliveryTenantSettingsDto.providerType,
        settings: {
          tenantMailBox: $scope.customer.emailDeliveryTenantSettingsDto.settings.tenantMailBox
        }
      };
      angular.forEach($scope.customerDetails.modulesLicenseInfo, function (module) {
        module.moduleExpirationDateObj = new Date(module.moduleExpirationDate);
        module.remaining = Math.ceil((module.moduleExpirationDate - $scope.currentDate.getTime()) / dayInMilliSeconds);
        if (module.remaining < 0) {
          module.remaining = 0;
        }
      });
    };

    $scope.saveCustomer = function () {
      var savedCustomerDetails = angular.copy($scope.customerDetails);
      delete savedCustomerDetails.tenantId;
      delete savedCustomerDetails.clName;
      delete savedCustomerDetails.created;
      delete savedCustomerDetails.updated;
      delete savedCustomerDetails.productLicenseInfo.clName;
      delete savedCustomerDetails.productLicenseInfo.moduleName;
      delete savedCustomerDetails.productLicenseInfo.moduleExpirationDateObj;
      delete savedCustomerDetails.productLicenseInfo.remaining;
      angular.forEach(savedCustomerDetails.modulesLicenseInfo, function (module) {
        delete module.moduleExpirationDateObj;
        delete module.clName;
        delete module.remaining;
      });
      delete savedCustomerDetails.emailDeliveryTenantSettingsDto.providerName;
      delete savedCustomerDetails.emailDeliveryTenantSettingsDto.providerType;
      delete savedCustomerDetails.smsDeliveryTenantSettingsDto.providerName;
      delete savedCustomerDetails.smsDeliveryTenantSettingsDto.providerType;
      delete savedCustomerDetails.nbOfSites;
      delete savedCustomerDetails.nbOfTeams;
      delete savedCustomerDetails.nbOfEmployees;
      delete savedCustomerDetails.lastLoggingDate;
      delete savedCustomerDetails.lastLoggingUserName;

      AdminCustomersService.updateCustomer($scope.tenantId, savedCustomerDetails).then(function (response) {
        applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', 'success', true);
      }, function (err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      }).finally(function () {
        $scope.initEditDetails();
      });
    };

    $scope.deleteCustomer = function () {
      // Confirm deletion
      var question = $filter('translate')("admin.customers.DELETE_CUSTOMER") + $scope.customerDetails.name + '?';
      var dlg = dialogs.confirm('app.PLEASE_CONFIRM', question);

      dlg.result.then(function () {
        AdminCustomersService.deleteCustomer($scope.tenantId).then(function (response) {
          applicationContext.setNotificationMsgWithValues('app.DELETED_SUCCESSFULLY', 'success', true);
          $state.go('authenticated.admin.customers.list');
        }, function (err) {
          applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
          $scope.initEditDetails();
        });
      });
    };

    $scope.initEditDetails = function () {
      AdminCustomersService.getCustomerDetails($scope.tenantId).then(function (response) {
        $scope.customer = response.data;
        $scope.fillCustomerDetails();
      }, function (err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };

    $scope.initEditDetails();
  }
]);

;
angular.module('emlogis.admin').controller('AdminCustomersListBreadcrumbCtrl', ['$scope',
    function($scope) {

    }
]);

;
angular.module('emlogis.admin').controller('AdminCustomersListCtrl', ['$scope', '$q', 'applicationContext', 'AdminCustomersService',
    function($scope, $q, applicationContext, AdminCustomersService) {

      $scope.tabs = [
        {
          heading: 'admin.customers.LIST_VIEW',
          selected: true,
          templateUrl: 'modules/admin/partials/customers/include/customers-list-view.html'
        }, {
          heading: 'admin.customers.MAP_VIEW',
          selected: false,
          templateUrl: 'modules/admin/partials/customers/include/customers-map-view.html'
        }
      ];

      $scope.selectSubTab = function(tab) {
        angular.forEach($scope.tabs, function(item) {
          item.selected = false;
        });
        tab.selected = true;
      };

      $scope.customerDetails = {
        customerColumnDefs: [
          { field: 'open/Edit',
            enableSorting: false,
            cellTemplate:'<button class="btn btn-default btn-edit-customer" ng-click="grid.appScope.editCustomer(row)" ng-class="{' + "'red-border-cell': grid.appScope.isIncludingRedCell(row)}" + '">{{"app.EDIT" | translate}} ></button>', width: '100' },
          { field: 'tenantId', visible: false },
          { field: 'name', width: '15%' },
          { field: 'geo', width: '5%' },
          { field: 'sites', width: '5%', enableSorting: false },
          { field: 'teams', width: '5%', enableSorting: false },
          { field: 'employees', width: '5%', enableSorting: false },
          { field: 'status', width: '10%', enableSorting: false },
          { field: 'remaining', visible: false },
          { field: 'expirationDate',
            enableSorting: false,
            cellTemplate: '<div class="ui-grid-cell-contents" ng-class="{' + "'red-content-cell': getExternalScopes().isIncludingRedCell(row)}" + '">{{row.entity.expiration}}</div>',
            width: '15%' },
          { field: 'expiration', visible: false },
          { field: 'lastActivity', width: '10%', enableSorting: false },
          { field: 'created', width: '15%' },
          { field: 'updated', width: '15%' }
        ],
        needPagination: true,
        customerEditStateName: 'authenticated.admin.customers.customerEdit'
      };

      $scope.getCustomerList = function(filterTxt) {
        var deferred = $q.defer();
        var offset = 0;
        var limit = 0;
        AdminCustomersService.getCustomerList(filterTxt, offset, limit).then(function(response) {
          if (response.data) {
            deferred.resolve({data: response.data.result});
          } else {
            deferred.reject('Error Occurred while trying to get Customer List');
          }
        }, function(err) {
          applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
          deferred.reject('Error Occurred while trying to get Customer List');
        });
        return deferred.promise;
      };

      $scope.getCustomerListForPagination = function(filterTxt, customerListGridOptions, paginationOptions) {
        var deferred = $q.defer();
        var offset = (paginationOptions.pageNumber - 1) * paginationOptions.pageSize;
        var limit = paginationOptions.pageSize;
        var orderBy = paginationOptions.orderBy;
        var orderDir = paginationOptions.orderDir;
        AdminCustomersService.getCustomerList(filterTxt, offset, limit, orderBy, orderDir).then(function(response) {
          if (response.data) {
            customerListGridOptions.totalItems = response.data.total;
            deferred.resolve({data: response.data.result});
          } else {
            deferred.reject('Error Occurred while trying to get Customer List');
          }
        }, function(err) {
          applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
          deferred.reject('Error Occurred while trying to get Customer List');
        });
        return deferred.promise;
      };
    }
]);

;
angular.module('emlogis.admin').controller('AdminCustomersCtrl', ['$scope', 'applicationContext',
  function($scope, applicationContext) {
    var entityFilter = applicationContext.getEntityFilter();

    entityFilter.url = 'serviceproviders/emlogisservice/orgs/ops/quicksearch';
    entityFilter.searchFields = 'name';
    entityFilter.returnedFields = 'tenantId,name';

    applicationContext.setEntityFilter(entityFilter);

    $scope.hasMgmtPermission = function () {
      return $scope.hasPermission('Tenant_Mgmt');
    };

    $scope.hasViewPermission = function () {
      return $scope.hasPermission('Tenant_View');
    };
  }
]);

;
angular.module('emlogis.admin').controller('CustomerEditContainerCtrl', ['$scope', 'AdminNotificationDeliveryService', 'applicationContext', 'UtilsService',
  function($scope, AdminNotificationDeliveryService, applicationContext, UtilsService) {

    $scope.submitClicked = false;
    $scope.isNotificationCollapsed = false;
    $scope.isSmsProviderSettingsCollapsed = true;
    $scope.isEmailProviderSettingsCollapsed = true;
    $scope.isOptionalModulesCollapsed = false;
    $scope.availableTimeZoneValues = [];
    $scope.smsProviders = [];
    $scope.emailProviders = [];
    $scope.currentDate = new Date();

    $scope.invertNotificationCollapsedFlag = function() {
      $scope.isNotificationCollapsed = !$scope.isNotificationCollapsed;
    };

    $scope.invertSmsProviderSettingsCollapsedFlag = function() {
      $scope.isSmsProviderSettingsCollapsed = !$scope.isSmsProviderSettingsCollapsed;
    };

    $scope.invertEmailProviderSettingsCollapsedFlag = function() {
      $scope.isEmailProviderSettingsCollapsed = !$scope.isEmailProviderSettingsCollapsed;
    };

    $scope.invertOptionalModulesCollapsedFlag = function() {
      $scope.isOptionalModulesCollapsed = !$scope.isOptionalModulesCollapsed;
    };

    $scope.setCurrentSmsProvider = function() {
      var selectedProvider = _.find($scope.smsProviders, function(provider) {return provider.id === $scope.customerDetails.smsDeliveryTenantSettingsDto.providerId;});
      $scope.customerDetails.smsDeliveryTenantSettingsDto.providerName = selectedProvider.name;
      $scope.customerDetails.smsDeliveryTenantSettingsDto.providerType = selectedProvider.providerType;
    };

    $scope.setCurrentEmailProvider = function() {
      var selectedProvider = _.find($scope.emailProviders, function(provider) {return provider.id === $scope.customerDetails.emailDeliveryTenantSettingsDto.providerId;});
      $scope.customerDetails.emailDeliveryTenantSettingsDto.providerName = selectedProvider.name;
      $scope.customerDetails.emailDeliveryTenantSettingsDto.providerType = selectedProvider.providerType;
    };

    $scope.convertModuleStatus = function(module) {
      if (module.moduleStatus === 'Disabled') {
        module.moduleStatus = 'Trial';
      } else {
        module.moduleStatus = 'Disabled';
      }
    };

    $scope.setModuleExpirationDate = function(module) {
      var dayInMilliSeconds = 24 * 3600 * 1000;
      module.moduleExpirationDate = module.moduleExpirationDateObj.getTime();
      module.remaining = Math.ceil((module.moduleExpirationDate - $scope.currentDate.getTime())/dayInMilliSeconds);
      if (module.remaining < 0) {
        module.remaining = 0;
      }
    };

    $scope.getAvailableTimeZones = function() {
      UtilsService.getAvailableTimeZones().then(function(response) {
        $scope.availableTimeZoneValues = response.data;
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };

    $scope.getSmsProviders = function() {
      AdminNotificationDeliveryService.getSmsProviders().then(function(response) {
        $scope.smsProviders = response.data.result;
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };

    $scope.getEmailProviders = function() {
      AdminNotificationDeliveryService.getEmailProviders().then(function(response) {
        $scope.emailProviders = response.data.result;
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };

    $scope.getAvailableTimeZones();
    $scope.getSmsProviders();
    $scope.getEmailProviders();
  }
]);

;
angular.module('emlogis.admin').controller('CustomersListViewCtrl', ['$scope',
  function($scope) {

    $scope.convertCustomerToGridRow = function(customer) {
      var gridRow = {};

      gridRow.tenantId = customer.tenantId;
      gridRow.name = customer.name;
      gridRow.geo = customer.geo;
      gridRow.sites = customer.nbOfSites;
      gridRow.teams = customer.nbOfTeams;
      gridRow.employees = customer.nbOfEmployees;
      gridRow.status = customer.productLicenseInfo.moduleStatus;
      gridRow.expiration = new Date(customer.productLicenseInfo.moduleExpirationDate).toString();
      var dayInMilliSeconds = 24 * 3600 * 1000;
      gridRow.remaining = (customer.productLicenseInfo.moduleExpirationDate - new Date().getTime())/dayInMilliSeconds;
      if (gridRow.remaining < 0) {
        gridRow.remaining = 0;
      }
      gridRow.lastActivity = customer.lastLoggingDate;
      gridRow.created = new Date(customer.created).toString();
      gridRow.updated = new Date(customer.updated).toString();

      return gridRow;
    };

    $scope.filter = {
      filterTxt: '',
      confirmedFilterTxt: ''
    };

    $scope.filterList = function() {
      $scope.filter.confirmedFilterTxt = $scope.filter.filterTxt;
    };

    $scope.getCustomerListViewForPagination = function(gridOptions, paginationOptions) {
      return $scope.getCustomerListForPagination($scope.filter.confirmedFilterTxt, gridOptions, paginationOptions);
    };

    $scope.getCustomerListView = function() {
      return $scope.getCustomerList($scope.filter.confirmedFilterTxt);
    };
  }
]);
;
angular.module('emlogis.admin').controller('CustomersMapViewCtrl', ['$scope', 'applicationContext', 'uiGmapGoogleMapApi',
  function($scope, applicationContext, uiGmapGoogleMapApi) {
    uiGmapGoogleMapApi.then(function(maps) {
      $scope.consts.addresses = [
        {
          address: 'New York City',
          country: 'United States'
        }, {
          address: 'Mexico City',
          country: 'Mexico'
        }, {
          address: 'Beijing',
          country: 'China'
        }, {
          address: 'Tokyo',
          country: 'Japan'
        }, {
          address: 'Sofia',
          country: 'Bulgaria'
        }, {
          address: 'Toronto',
          country: 'Canada'
        }, {
          address: 'New Delhi',
          country: 'India'
        }, {
          address: 'Los Angeles',
          country: 'United States'
        }
      ];
      $scope.map = { center: { latitude: 45, longitude: -73 }, zoom: 8 };
      $scope.customerList = [];
      $scope.getCustomerList('').then(function(response) {
        $scope.customerList = response.data;
        angular.forEach($scope.customerList, function(customer) {

        });
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    });
  }
]);
;
angular.module('emlogis.admin').controller('AdminNotificationDeliveryBreadcrumbCtrl', ['$scope',
  function($scope) {
    $scope.hasMgmtPermission = function () {
      return $scope.hasPermission('Tenant_Mgmt');
    };

    $scope.hasViewPermission = function () {
      return $scope.hasPermission('Tenant_View');
    };
  }
]);

;
angular.module('emlogis.admin').controller('AdminNotificationDeliveryEmailBreadcrumbCtrl', ['$scope', '$state',
  function($scope, $state) {
    $scope.goToNewProviderState = function(providerType) {
      $state.go('authenticated.admin.notificationDelivery.email.createProvider', {providerType: providerType});
    };
  }
]);

;
angular.module('emlogis.admin').controller('AdminNotificationDeliveryEmailCreateProviderBreadcrumbCtrl', ['$scope',
  function($scope) {

  }
]);

;
angular.module('emlogis.admin').controller('AdminNotificationDeliveryEmailCreateProviderCtrl', ['$scope', '$state', '$stateParams', 'applicationContext', 'AdminNotificationDeliveryService',
  function($scope, $state, $stateParams, applicationContext, AdminNotificationDeliveryService) {
    $scope.provider = {
      deliveryType: 'EMAIL',
      providerType: $stateParams.providerType,
      updateDto: {
        settings: {}
      }
    };

    $scope.createProvider = function() {
      AdminNotificationDeliveryService.createProvider($scope.provider).then(function(response) {
        applicationContext.setNotificationMsgWithValues('app.CREATED_SUCCESSFULLY', 'success', true);
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      }).finally(function() {
        $scope.goToProviderListState();
      });
    };

    $scope.goToProviderListState = function() {
      $state.go('authenticated.admin.notificationDelivery.email.edit');
    };
  }
]);

;
angular.module('emlogis.admin').controller('AdminNotificationDeliveryEmailEditBreadcrumbCtrl', ['$scope',
  function($scope) {

  }
]);

;
angular.module('emlogis.admin').controller('AdminNotificationDeliveryEmailEditCtrl', ['$scope', 'applicationContext', 'AdminNotificationDeliveryService',
  function($scope, applicationContext, AdminNotificationDeliveryService) {
    $scope.emailProviders = [];
    $scope.parsedEmailProviders = [];

    $scope.invertProviderCollapsedFlag = function(provider) {
      provider.isCollapsed = !provider.isCollapsed;
    };

    $scope.parseEmailProviders = function() {
      $scope.parsedEmailProviders = [];
      angular.forEach($scope.emailProviders, function(provider) {
        var parsedProvider = angular.copy(provider);
        parsedProvider.lastChecked = new Date(provider.lastChecked).toString();
        parsedProvider.activationChanged = new Date(provider.activationChanged).toString();
        parsedProvider.isCollapsed = false;
        parsedProvider.isTestCompleted = true;

        $scope.parsedEmailProviders.push(parsedProvider);
      });
    };

    $scope.testProvider = function(provider) {
      provider.isTestCompleted = false;
      AdminNotificationDeliveryService.testProvider(provider.id).then(function(response) {
        applicationContext.setNotificationMsgWithValues('admin.notification_delivery.TESTED_SUCCESSFULLY', 'success', true);
        var originalProvider = _.find($scope.emailProviders, function(iterator) {return iterator.id === provider.id;});
        originalProvider.status = response.data.status;
        originalProvider.statusInfo = response.data.statusInfo;
        provider.status = response.data.status;
        provider.statusInfo = response.data.statusInfo;
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      }).finally(function() {
        provider.isTestCompleted = true;
      });
    };

    $scope.saveProvider = function(provider) {
      var savedProviderDetails = {
        name: provider.name,
        active: provider.active,
        settings: provider.settings
      };

      AdminNotificationDeliveryService.updateProvider(provider.id, savedProviderDetails).then(function(response) {
        applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', 'success', true);
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      }).finally(function() {
        $scope.getEmailProviders();
      });
    };

    $scope.deleteProvider = function(provider) {
      AdminNotificationDeliveryService.deleteProvider(provider.id).then(function(response) {
        applicationContext.setNotificationMsgWithValues('app.DELETED_SUCCESSFULLY', 'success', true);
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      }).finally(function() {
        $scope.getEmailProviders();
      });
    };

    $scope.getEmailProviders = function() {
      AdminNotificationDeliveryService.getEmailProviders().then(function(response) {
        $scope.emailProviders = response.data.result;
        $scope.parseEmailProviders();
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };

    $scope.getEmailProviders();
  }
]);

;
angular.module('emlogis.admin').controller('AdminNotificationDeliveryEmailCtrl', ['$scope',
  function($scope) {

  }
]);

;
angular.module('emlogis.admin').controller('AdminNotificationDeliverySmsBreadcrumbCtrl', ['$scope', '$state',
  function($scope, $state) {
    $scope.goToNewProviderState = function(providerType) {
      $state.go('authenticated.admin.notificationDelivery.sms.createProvider', {providerType: providerType});
    };
  }
]);

;
angular.module('emlogis.admin').controller('AdminNotificationDeliverySmsCreateProviderBreadcrumbCtrl', ['$scope',
  function($scope) {

  }
]);

;
angular.module('emlogis.admin').controller('AdminNotificationDeliverySmsCreateProviderCtrl', ['$scope', '$state', '$stateParams', 'applicationContext', 'AdminNotificationDeliveryService',
  function($scope, $state, $stateParams, applicationContext, AdminNotificationDeliveryService) {
    $scope.provider = {
      deliveryType: 'SMS',
      providerType: $stateParams.providerType,
      updateDto: {
        settings: {}
      }
    };

    $scope.createProvider = function() {
      AdminNotificationDeliveryService.createProvider($scope.provider).then(function(response) {
        applicationContext.setNotificationMsgWithValues('app.CREATED_SUCCESSFULLY', 'success', true);
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      }).finally(function() {
        $scope.goToProviderListState();
      });
    };

    $scope.goToProviderListState = function() {
      $state.go('authenticated.admin.notificationDelivery.sms.edit');
    };
  }
]);

;
angular.module('emlogis.admin').controller('AdminNotificationDeliverySmsEditBreadcrumbCtrl', ['$scope',
  function($scope) {

  }
]);

;
angular.module('emlogis.admin').controller('AdminNotificationDeliverySmsEditCtrl', ['$scope', 'applicationContext', 'AdminNotificationDeliveryService',
  function($scope, applicationContext, AdminNotificationDeliveryService) {
    $scope.smsProviders = [];
    $scope.parsedSmsProviders = [];

    $scope.invertProviderCollapsedFlag = function(provider) {
      provider.isCollapsed = !provider.isCollapsed;
    };

    $scope.parseSmsProviders = function() {
      $scope.parsedSmsProviders = [];
      angular.forEach($scope.smsProviders, function(provider) {
        var parsedProvider = angular.copy(provider);
        parsedProvider.lastChecked = new Date(provider.lastChecked).toString();
        parsedProvider.activationChanged = new Date(provider.activationChanged).toString();
        parsedProvider.isCollapsed = false;
        parsedProvider.isTestCompleted = true;

        $scope.parsedSmsProviders.push(parsedProvider);
      });
    };

    $scope.testProvider = function(provider) {
      provider.isTestCompleted = false;
      AdminNotificationDeliveryService.testProvider(provider.id).then(function(response) {
        applicationContext.setNotificationMsgWithValues('admin.notification_delivery.TESTED_SUCCESSFULLY', 'success', true);
        var originalProvider = _.find($scope.emailProviders, function(iterator) {return iterator.id === provider.id;});
        originalProvider.status = response.data.status;
        originalProvider.statusInfo = response.data.statusInfo;
        provider.status = response.data.status;
        provider.statusInfo = response.data.statusInfo;
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      }).finally(function() {
        provider.isTestCompleted = true;
      });
    };

    $scope.saveProvider = function(provider) {
      var savedProviderDetails = {
        name: provider.name,
        active: provider.active,
        settings: provider.settings
      };

      AdminNotificationDeliveryService.updateProvider(provider.id, savedProviderDetails).then(function(response) {
        applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', 'success', true);
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      }).finally(function() {
        $scope.getSmsProviders();
      });
    };

    $scope.deleteProvider = function(provider) {
      AdminNotificationDeliveryService.deleteProvider(provider.id).then(function(response) {
        applicationContext.setNotificationMsgWithValues('app.DELETED_SUCCESSFULLY', 'success', true);
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      }).finally(function() {
        $scope.getSmsProviders();
      });
    };

    $scope.getSmsProviders = function() {
      AdminNotificationDeliveryService.getSmsProviders().then(function(response) {
        $scope.smsProviders = response.data.result;
        $scope.parseSmsProviders();
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };

    $scope.getSmsProviders();
  }
]);

;
angular.module('emlogis.admin').controller('AdminNotificationDeliverySmsCtrl', ['$scope',
  function($scope) {

  }
]);

;
angular.module('emlogis.admin').controller('AdminNotificationDeliveryCtrl', ['$scope',
  function($scope) {
    $scope.hasMgmtPermission = function () {
      return $scope.hasPermission('Tenant_Mgmt');
    };

    $scope.hasViewPermission = function () {
      return $scope.hasPermission('Tenant_View');
    };
  }
]);

;
angular.module('emlogis.admin').directive('customerSelectionList', ['$state', '$timeout', 'uiGridConstants',
  function($state, $timeout, uiGridConstants) {

    return {
      restrict: 'E',
      scope: {
        customerDetails: '=',
        filterTxt: '=',
        getCustomerList: '&',
        convertCustomerToGridRow: '&'
      },
      controller: function($scope) {
        function rowTemplate() {
          return '<div ng-dblclick="grid.appScope.editCustomer(row)" ng-repeat="col in colContainer.renderedColumns track by col.colDef.name" class="ui-grid-cell" ui-grid-cell></div>';
        }

        $scope.customerList = [];
        $scope.customerListGridData = [];

        $scope.customerListGridOptions = {
          data: 'customerListGridData',
          rowTemplate: rowTemplate(),
          columnDefs: $scope.customerDetails.customerColumnDefs
        };

        if ($scope.customerDetails.needPagination) {
          $scope.paginationOptions = {
            pageNumber: 1,
            pageSize: 25,
            orderBy: null,
            orderDir: null
          };
          $scope.customerListGridOptions = _.extend($scope.customerListGridOptions, {
            paginationPageSizes: [25, 50, 75],
            paginationPageSize: 25,
            useExternalPagination: true,
            useExternalSorting: true,
            onRegisterApi: function(gridApi) {
              gridApi.core.on.sortChanged($scope, function(grid, sortColumns) {
                $scope.processOnSortChanged(grid, sortColumns);
              });
              gridApi.pagination.on.paginationChanged($scope, function (newPage, pageSize) {
                $scope.processOnPaginationChanged(newPage, pageSize);
              });
            }
          });

          $scope.processOnSortChanged = function(grid, sortColumns) {
            if (sortColumns.length === 0) {
              $scope.paginationOptions.orderBy = null;
              $scope.paginationOptions.orderDir = null;
            } else {
              $scope.paginationOptions.orderBy = sortColumns[0].field;
              if (sortColumns[0].sort.direction === uiGridConstants.ASC) {
                $scope.paginationOptions.orderDir = 'ASC';
              } else if (sortColumns[0].sort.direction === uiGridConstants.DESC) {
                $scope.paginationOptions.orderDir = 'DESC';
              } else {
                $scope.paginationOptions.orderBy = null;
                $scope.paginationOptions.orderDir = null;
              }
            }
            $scope.getCustomerList({gridOptions: $scope.customerListGridOptions, paginationOptions: $scope.paginationOptions}).then(function (response) {
              $scope.customerList = response.data;
              $scope.parseCustomerListForGrid();
            }, function (err) {
              console.log(err);
              $scope.customerList = [];
              $scope.parseCustomerListForGrid();
            });
          };

          $scope.processOnPaginationChanged = function(newPage, pageSize) {
            $scope.paginationOptions.pageNumber = newPage;
            $scope.paginationOptions.pageSize = pageSize;
            $scope.getCustomerList({gridOptions: $scope.customerListGridOptions, paginationOptions: $scope.paginationOptions}).then(function(response) {
              $scope.customerList = response.data;
              $scope.parseCustomerListForGrid();
            }, function(err) {
              console.log(err);
              $scope.customerList = [];
              $scope.parseCustomerListForGrid();
            });
          };
        }

        $scope.editCustomer = function(row) {
          $state.go($scope.customerDetails.customerEditStateName, {tenantId: row.entity.tenantId});
        };

        $scope.isIncludingRedCell = function(row) {
          if (row.entity.remaining < 30) {
            return true;
          } else {
            return false;
          }
        };

        $scope.initializeCustomerList = function() {
          if ($scope.customerDetails.needPagination) {
            $scope.getCustomerList({gridOptions: $scope.customerListGridOptions, paginationOptions: $scope.paginationOptions}).then(function (response) {
              $scope.customerList = response.data;
              $scope.parseCustomerListForGrid();
            }, function (err) {
              console.log(err);
              $scope.customerList = [];
              $scope.parseCustomerListForGrid();
            });
          } else {
            $scope.getCustomerList().then(function (response) {
              $scope.customerList = response.data;
              $scope.parseCustomerListForGrid();
            }, function (err) {
              console.log(err);
              $scope.customerList = [];
              $scope.parseCustomerListForGrid();
            });
          }
        };

        $scope.parseCustomerListForGrid = function() {
          $scope.customerListGridData = [];
          angular.forEach($scope.customerList, function(customer) {
            var gridRow = $scope.convertCustomerToGridRow({message: customer});

            $scope.customerListGridData.push(gridRow);
          });

          $timeout(function() {
            $('.customer-list').resize();
          }, 0);
        };
      },
      link: function(scope) {
        scope.$watch('filterTxt', function(newValue, oldValue) {
          if (newValue !== oldValue) {
            scope.initializeCustomerList();
          }
        });
        scope.initializeCustomerList();
      },
      templateUrl: 'modules/admin/partials/customers/include/customer-selection-list.html'
    };
  }
]);

;
angular.module('emlogis.admin')
  .service('AdminCustomersService', ['$http', 'applicationContext', 'UtilsService',
    function($http, applicationContext, UtilsService) {
      var baseUrl = applicationContext.getBaseRestUrl();

      function sendRequest(urlPart, method, requestPayload) {
        var apiUrl = baseUrl + urlPart;
        var req = {
          method: method,
          url: apiUrl
        };
        if (method === 'POST' || method === 'PUT') {
          req.data = requestPayload;
        }

        return $http(req);
      }

      this.getCustomerList = function(filterTxt, offset, limit, orderBy, orderDir) {
        var urlPart = '';
        var queryPart = [];

        urlPart = 'serviceproviders/emlogisservice/orgs/ops/query';
        if (!UtilsService.checkEmpty(filterTxt)) {
          queryPart.push('search=' + filterTxt + '&searchfields=name');
        }
        if (!UtilsService.checkEmpty(offset)) {
          queryPart.push('offset=' + offset);
        }
        if (!UtilsService.checkEmpty(limit)) {
          queryPart.push('limit=' + limit);
        }
        if (!UtilsService.checkEmpty(orderBy)) {
          queryPart.push('orderby=' + orderBy);
        }
        if (!UtilsService.checkEmpty(orderDir)) {
          queryPart.push('orderdir=' + orderDir);
        }

        if (queryPart.length > 0) {
          urlPart += '?' + queryPart.join('&');
        }

        return sendRequest(urlPart, 'GET', null);
      };

      this.getCustomerDetails = function(tenantId) {
        var urlPart = 'serviceproviders/emlogisservice/orgs/' + tenantId;

        return sendRequest(urlPart, 'GET', null);
      };

      this.createCustomer = function(customerDetails) {
        var urlPart = 'serviceproviders/emlogisservice/orgs/';

        return sendRequest(urlPart, 'POST', customerDetails);
      };

      this.updateCustomer = function(tenantId, customerDetails) {
        var urlPart = 'serviceproviders/emlogisservice/orgs/' + tenantId;

        return sendRequest(urlPart, 'PUT', customerDetails);
      };

      this.deleteCustomer = function(tenantId) {
        var urlPart = 'serviceproviders/emlogisservice/orgs/' + tenantId;

        return sendRequest(urlPart, 'DELETE', null);
      };

      this.getImportConfigurations = function(tenantId) {
        var urlPart = 'importconfig/serviceproviders/emlogisservice/orgs/' + tenantId + "/imports";

        return sendRequest(urlPart, 'GET', null);
      };

      this.getImportConfigurationMappingFields = function(tenantId, importType) {
        var urlPart = 'importconfig/serviceproviders/emlogisservice/orgs/' + tenantId + "/imports/types/"
          + importType + "/mapping";

        return sendRequest(urlPart, 'GET', null);
      };
    }
  ]);
;
angular.module('emlogis.admin')
  .service('AdminNotificationDeliveryService', ['$http', 'applicationContext',
    function($http, applicationContext) {
      var baseUrl = applicationContext.getBaseRestUrl();

      function sendRequest(urlPart, method, requestPayload) {
        var apiUrl = baseUrl + urlPart;
        var req = {
          method: method,
          url: apiUrl
        };
        if (method === 'POST' || method === 'PUT') {
          req.data = requestPayload;
        }

        return $http(req);
      }

      this.getNotificationDeliveryProviders = function() {
        var urlPart = 'msgdeliveryproviders';

        return sendRequest(urlPart, 'GET', null);
      };

      this.getEmailProviders = function() {
        var urlPart = 'msgdeliveryproviders?filter=deliveryType=1';

        return sendRequest(urlPart, 'GET', null);
      };

      this.getSmsProviders = function() {
        var urlPart = 'msgdeliveryproviders?filter=deliveryType=0';

        return sendRequest(urlPart, 'GET', null);
      };

      this.getProviderDetails = function(providerId) {
        var urlPart = 'msgdeliveryproviders/' + providerId;

        return sendRequest(urlPart, 'GET', null);
      };

      this.createProvider = function(providerDetails) {
        var urlPart = 'msgdeliveryproviders';

        return sendRequest(urlPart, 'POST', providerDetails);
      };

      this.updateProvider = function(providerId, providerDetails) {
        var urlPart = 'msgdeliveryproviders/' + providerId;

        return sendRequest(urlPart, 'PUT', providerDetails);
      };

      this.deleteProvider = function(providerId) {
        var urlPart = 'msgdeliveryproviders/' + providerId;

        return sendRequest(urlPart, 'DELETE', null);
      };

      this.testProvider = function(providerId) {
        var urlPart = 'msgdeliveryproviders/' + providerId + '/ops/check';

        return sendRequest(urlPart, 'POST', {});
      };
    }
  ]);
;
(function() {

    // browser configuration: prior to adding a new entity to the browser,
    // make sure you configure
    // #1 the appContext.entity2resource object (.run() method at the very bottom of the script)
    // #2 the ctlrConfig (controller config)

    // Controllers config data.
    // data which is passed to controllers to configure them
    // organized per 'types' of controllers at first level, then structured as needed by specifi type of controller
    // and the  add a top level in map to have config by controllertype (list/ entitiy/ related entity ...)


    angular
        .module('emlogis.browser', ['ui.bootstrap', 'ui.router', 'http-auth-interceptor', 'emlogis.commonservices',
            'emlogis.accountmgmt', 'dialogs.main', 'ngAnimate'])
        .config(

            function($stateProvider, $urlRouterProvider, $locationProvider, $httpProvider, dialogsProvider) {

                $stateProvider
                // generic state for top level entity lists (all groups, all users, all roles)
                // should likely be defined at App level as applying to any entity
                .state('authenticated.browser', {
                    url: '/browser/{entity}',
                    data: {
                        ncyBreadcrumbLabel: '{{entityTypeLabel}}s'
                    },
                    views:{
                        "content@authenticated":{
                            templateUrl: function($stateParams) {
                                var config = ctlrConfig.entityListCtlr[$stateParams.entity];
                                if (config && config.partial) {
                                    return 'modules/browser/partials/' + config.partial;
                                } else {
                                    return 'modules/browser/partials/' + $stateParams.entity + 'list.html';
                                }
                            },
                            controllerProvider: function($stateParams) {
                                var config = ctlrConfig.entityListCtlr[$stateParams.entity];
                                var ctlr;
                                if (config) {
                                    if (config.genericCtlr) {
                                        // this entity is configured for using the generic ctlr
                                        ctlr = 'EntityListCtlr';
                                    } else {
                                        // specific controler, thus by convention, ctlr name should be: entity with first letter in capital + MgmtCtlr
                                        // ex for groupaccounts: 'GroupaccountListCtlr'
                                        ctlr = entity.substring(0, 1).toUpperCase() + entity.substring(1, entity.length) + 'ListCtlr';
                                    }
                                    // copy config into $stateParams to pass them to ctlr
                                    $stateParams.ctlrConfig = config;
                                } else {
                                    // assume we use the specific controler, see naming convention above
                                    ctlr = entity.substring(0, 1).toUpperCase() + entity.substring(1, entity.length) + 'ListCtlr';
                                }
                                return ctlr;
                            }
                        },
                        "breadcrumb@authenticated": {
                            templateUrl: "modules/browser/partials/breadcrumb.html",
                            controller: 'BrowserBreadcrumbCtrl'
                        }

                        // returning a controller name is mandatory for breadcrumb label to use scope.
                    }

                })

                // generic state for top entity details (specific group, user, role)
                // should actually be defined at App level as applying to any entity
                .state('authenticated.entity', {
                    url: '/entity/{entity}/{id}', //?parentEntityId={parentEntityId},
                    data: {
                        ncyBreadcrumbLabel: '{{entityTypeLabel}}: {{elt.name}}'
                    },
                    views: {
                        "content@authenticated":{
                            templateUrl: function($stateParams) {
                                // by convention, tpl name should be: <entity>.html
                                var url = 'modules/browser/partials/' + $stateParams.entity + '.html';
                                return url;
                            },
                            controllerProvider: function($stateParams) {
                                console.log("entity.getCtlr(): " + _.values($stateParams));
                                var entity = $stateParams.entity;
                                var config = ctlrConfig.entityCtlr[entity];
                                $stateParams.ctlrConfig = config;
                                // check if we use the generic entity controller
                                if (config.genericCtlr) {
                                    // yes, this entity is configured for using the generic ctlr
                                    return 'EntityCtlr';
                                }
                                // by convention, ctlr name should be: entity with first letter in capital + Ctlr
                                // ex for groupaccounts: 'GroupaccountCtlr'
                                //entity = $stateParams.entity;
                                var ctrl = entity.substring(0, 1).toUpperCase() + entity.substring(1, entity.length) + 'Ctlr';
                                return ctrl;
                            }
                        },
                        "breadcrumb@authenticated": {
                            templateUrl: "modules/browser/partials/breadcrumb.html",
                            controller: 'BrowserBreadcrumbCtrl'
                        }
                    }
                })

                // top level state for creating an entity associated to a parent one
                // controllers are  same as for top level entities 
                .state('authenticated.createchildentity', {
                    url: '/parententity/{parentEntity}/{parentEntityId}/createchild/{entity}/{id}/',
                    data: {
                        ncyBreadcrumbLabel: 'Create new {{entityTypeLabel}}'
                    },
                    views: {
                        "content@authenticated": {
                            templateUrl: function ($stateParams) {

                                // by convention, tpl name should be: <parententity>_create<entity>.html
                                // but can be overriden by config.secundaryEntityCreatePartial
                                var url = 'modules/browser/partials/',
                                    config = ctlrConfig.relatedEntityCtlr[$stateParams.parentEntity][$stateParams.entity];
                                if (config && config.secundaryEntityCreatePartial) {
                                    url = config.secundaryEntityCreatePartial;
                                } else {
                                    url += ($stateParams.parentEntity + '_create' + $stateParams.entity + '.html');
                                }
                                return url;
                            },
                            controllerProvider: function ($stateParams) {
                                var entity = $stateParams.entity;

                                // get the navigation configuration
                                // and copy config into $stateParams to pass it to ctlr
                                var config = ctlrConfig.relatedEntityCtlr[$stateParams.parentEntity][$stateParams.entity];
                                $stateParams.ctlrConfig = config;

                                // get the entity configuration
                                config = ctlrConfig.entityCtlr[entity];
                                // check if we use the generic entity controller
                                if (config.genericCtlr) {
                                    // yes, this entity is configured for using the generic ctlr
                                    $stateParams.ctlrConfig = config;
                                    return 'EntityCtlr';
                                }
                                // Otherwise, use the cistom ctlr which by convention, has a name that must be: entity with first letter in capital + Ctlr
                                // ex for groupaccounts: 'GroupaccountCtlr'
                                //var entity = $stateParams.entity;
                                var ctrl = entity.substring(0, 1).toUpperCase() + entity.substring(1, entity.length) + 'Ctlr';
                                return ctrl;
                            }
                        }
                    }
                })
                    /*
                                  // by convention, ctlr name should be: entity with first letter in capital + Ctlr
                                            // ex for groupaccounts: 'GroupaccountCtlr'
                                            var entity = $stateParams.entity;
                                            var ctrl = entity.substring(0, 1).toUpperCase() + entity.substring(1, entity.length) + 'Ctlr';
                                            return ctrl;
                                        }
                                    })
                         */

                // sub states for related entities
                .state('authenticated.entity.relatedentity', {
                    url: '/relatedentity/{relatedentity}',
                    data: {
                        ncyBreadcrumbLabel: '{{relatedentityTypeLabel}}s'
                    },

                    templateUrl: function ($stateParams) {
                        // by convention, tpl name should be: <entity>_<relatedentity> + list.html
                        // ex for useraccounts of groupaccounts: 'entity_relatedentitylist.tpl.html'
                        var url,
                            entity = $stateParams.entity,
                            relatedentity = $stateParams.relatedentity;
                        var config = ctlrConfig.relatedEntityCtlr[entity][relatedentity];
                        if (config && config.partial) {
                            return 'modules/browser/partials/' + config.partial;
                        } else {
                            url = 'modules/browser/partials/' + $stateParams.entity + '_' + $stateParams.relatedentity + 'list.html';
                        }
                        return url;
                    },

                    controllerProvider: function ($stateParams) {
                        // by convention, ctlr name should be: entity with first letter in capital + ListCtlr
                        // ex for useraccounst of groupaccounts: 'Groupaccount_useraccountListCtlr'
                        var ctlr,
                            entity = $stateParams.entity,
                            relatedentity = $stateParams.relatedentity;

                        ctlr = 'SecundaryEntityListCtlr'; // force
                        var config = ctlrConfig.relatedEntityCtlr[entity];
                        if (config) {
                            config = config[relatedentity];
                            if (config) {
                                config.entity = entity;
                                config.relatedentity = relatedentity;
                                $stateParams.ctlrConfig = config;
                                if (config.controller) {
                                    ctlr = config.controller;
                                }
                            }
                        }
                        return ctlr;
                    }

                });

                dialogsProvider.useBackdrop('static');
                dialogsProvider.useEscClose(false);
                dialogsProvider.useCopy(false);
                dialogsProvider.setSize('sm');
                

            }
        )
        .run( function( appContext) {

            var entity2resource = appContext.get('entity2resource', {});
            _.defaults(entity2resource, {
                useraccount: {
                    restResource: "useraccounts",
                    label: "User Account"
                },
                groupaccount: {
                    restResource: "groupaccounts",
                    label: "User Group"
                },
                role: {
                    restResource: "roles",
                    label: "Role"
                },
                permission: {
                    restResource: "permissions",
                    label: "Permission"
                },
                ace: {
                    restResource: "aces",
                    label: "Access Control Element"
                },

                site: {
                    restResource: "sites",
                    label: "Site"
                },
                team: {
                    restResource: "teams",
                    label: "Team"
                },
                skill: {
                    restResource: "skills",
                    label: "Skill"
                },
                employee: {
                    restResource: "employees",
                    label: "Employee"
                },
                absencetype: {
                    restResource: "absencetypes",
                    label: "Absence Type"
                },
                ciavailability: {
                    restResource: "ciavailability",
                    label: "CI Availability"
                },
                cdavailability: {
                    restResource: "cdavailability",
                    label: "CD Availability"
                },
                schedule: {
                    restResource: "schedules",
                    label: "Schedule"
                },
                shiftstructure: {
                    restResource: "shiftstructures",
                    label: "Shift Structure"
                },
                shiftreq: {
                    restResource: "shiftreqs",
                    label: "Shift Requirement"
                },
                shift: {
                    restResource: "shifts",
                    label: "Shift"
                },
                shifttype: {
                    restResource: "shifttypes",
                    label: "Shift Type"
                },
                change: {
                    restResource: "changes",
                    label: "Change"
                },
                contract: {
                    restResource: "contracts",
                    label: "Contract"
                },
                sitecontract: {
                    restResource: "contracts",
                    label: "Site Contract"
                },
                teamcontract: {
                    restResource: "contracts",
                    label: "Team Contract"
                },
                employeecontract: {
                    restResource: "contracts",
                    label: "Employee Contract"
                },
                contractline: {
                    restResource: "contractlines",
                    label: "Contract Line"
                },
                appserver: {
                    restResource: "appservers",
                    label: "App Server"
                },
                engine: {
                    restResource: "engines",
                    label: "Engine"
                },
                session: {
                    restResource: "sessions",
                    label: "Session"
                }
            });
        });

    var imagePath = "modules/browser/assets/images/";

    var ctlrConfig = {
        entityListCtlr: { // config for Management type controllers, which display a list of toplevel homogeneous  entities
            // an entry  with genericCtlr = true indicates the Generic 'EntityListCtlr' controller will be used for that listing instances of that entity
            groupaccount: {
                genericCtlr: true,
                viewPermissions: ['Account_View'],
                createPermissions: ['Account_Mgmt'],
                editPermissions: ['Account_Mgmt'],
                deletePermissions: ['Account_Mgmt'],
                partial: 'entitylist.tpl.html',
                // TODO: add support for renderers on columns basd on type
                // by default type is assumed to be string and value rendered as is
                columns: [ // grid columns
                    {
                        name: 'name',
                        label: 'Name',
                        sortable: true
                    }, {
                        name: 'description',
                        label: 'Description',
                        sortable: true
                    }, {
                        name: 'id',
                        label: 'Id',
                        sortable: true
                    }
                ],
                views: {
                    list: true,
                    card: true
                },
                card: ['name', 'description'], // card attributes
                entityDrillDown: true, // enable link to show entity details
                entityDelete: true, // enable element delete btn
                entityAdd: true, // enable element add btn
                entityIcon: imagePath + 'glyphicons/png/usergroup.png'
            },
            useraccount: {
                genericCtlr: true,
                viewPermissions: ['Account_View'],
                createPermissions: ['Account_Mgmt'],
                editPermissions: ['Account_Mgmt'],
                deletePermissions: ['Account_Mgmt'],
                partial: 'useraccountlist.html',
                // TODO: add support for renderers on columns basd on type
                // by default type is assumed to be string and value rendered as is
                columns: [ // grid columns
                    {
                        name: 'name',
                        label: 'Name',
                        sortable: true
                    }, {
                        name: 'description',
                        label: 'Description',
                        sortable: true
                    }, {
                        name: 'login',
                        label: 'Login',
                        sortable: true
                    }, {
                        name: 'email',
                        label: 'Email',
                        sortable: true
                    }, {
                        name: 'id',
                        label: 'Id',
                        sortable: true
                    }
                ],
                views: {
                    list: true,
                    card: true
                },
                card: ['name', 'description', 'login', 'email'], // card attributes
                entityDrillDown: true, // enable link to show entity details
                entityDelete: true, // enable element delete btn
                entityAdd: true, // enable element add btn
                entityIcon: imagePath + 'glyphicons/png/user.png'
            },
            role: {
                genericCtlr: true,
                viewPermissions: ['Account_View', 'Role_View'],
                createPermissions: ['Role_Mgmt'],
                editPermissions: ['Role_Mgmt'],
                deletePermissions: ['Role_Mgmt'],
                partial: 'entitylist.tpl.html',
                // TODO: add support for renderers on columns basd on type
                // by default type is assumed to be string and value rendered as is
                columns: [ // grid columns
                    {
                        name: 'name',
                        label: 'Name',
                        sortable: true
                    }, {
                        name: 'description',
                        label: 'Description',
                        sortable: true
                    }, {
                        name: 'id',
                        label: 'Id',
                        sortable: true
                    }
                ],
                views: {
                    list: true,
                    card: true
                },
                card: ['name', 'description'], // card attributes
                entityDrillDown: true, // enable link to show entity details
                entityDelete: true, // enable element delete btn
                entityAdd: true, // enable element add btn
                entityIcon: imagePath + 'glyphicons/png/role.png'
            },
            permission: {
                genericCtlr: true,
                viewPermissions: ['Account_View', 'Role_View'],
                createPermissions: [],
                editPermissions: [],
                deletePermissions: [],
                partial: 'entitylist.tpl.html',
                // TODO: add support for renderers on columns basd on type
                // by default type is assumed to be string and value rendered as is
                columns: [ // grid columns
                    {
                        name: 'name',
                        label: 'Name',
                        sortable: true
                    }, {
                        name: 'description',
                        label: 'Description',
                        sortable: true
                    }, {
                        name: 'type',
                        label: 'Type',
                        sortable: true
                    }, {
                        name: 'scope',
                        label: 'Scope',
                        sortable: true
                    }, {
                        name: 'id',
                        label: 'Id',
                        sortable: true
                    }
                ],
                views: {
                    list: true,
                    card: true
                },
                card: ['name', 'type', 'scope'], // card attributes
                entityDrillDown: false, // enable link to show entity details
                entityDelete: false, // enable element delete btn
                entityAdd: false, // enable element add btn
                entityIcon: imagePath + 'glyphicons/png/permission.png'
            },
            skill: {
                genericCtlr: true,
                viewPermissions: ['OrganizationProfile_View'],
                createPermissions: ['OrganizationProfile_Mgmt'],
                editPermissions: ['OrganizationProfile_Mgmt'],
                deletePermissions: ['OrganizationProfile_Mgmt'],
                partial: 'entitylist.tpl.html',
                // by default type is assumed to be string and value rendered as is
                columns: [ // grid columns
                    {
                        name: 'name',
                        label: 'Name',
                        sortable: true
                    }, {
                        name: 'abbreviation',
                        label: 'Abbreviation',
                        sortable: true
                    }, {
                        name: 'description',
                        label: 'Description',
                        sortable: true
                    }, {
                        name: 'id',
                        label: 'Id',
                        sortable: true
                    }
                ],
                views: {
                    list: true,
                    card: true
                },
                card: ['name', 'abbreviation', 'description'], // card attributes
                entityDrillDown: true, // enable link to show entity details
                entityDelete: true, // enable element delete btn
                entityAdd: true, // enable element add btn          
                entityIcon: imagePath + 'glyphicons/png/skill.png'
            },
            site: {
                genericCtlr: true,
                viewPermissions: ['OrganizationProfile_View'],
                createPermissions: ['OrganizationProfile_Mgmt'],
                editPermissions: ['OrganizationProfile_Mgmt'],
                deletePermissions: ['OrganizationProfile_Mgmt'],
                partial: 'entitylist.tpl.html',
                // by default type is assumed to be string and value rendered as is
                columns: [ // grid columns
                    {
                        name: 'name',
                        label: 'Name',
                        sortable: true
                    }, {
                        name: 'description',
                        label: 'Description',
                        sortable: true
                    }, {
                        name: 'firstDayOfWeek',
                        label: 'First Day Of Week',
                        sortable: true
                    }, {
                        name: 'timeZone',
                        label: 'Time Zone',
                        sortable: true
                    }, {
                        name: 'weekendDefinition',
                        label: 'Weekend Definition',
                        sortable: true
                    }, {
                        name: 'id',
                        label: 'Id',
                        sortable: true
                    }
                ],
                views: {
                    list: true,
                    card: true
                },
                card: ['name', 'description'], // card attributes
                entityDrillDown: true, // enable link to show entity details
                entityDelete: true, // enable element delete btn
                entityAdd: true, // enable element add btn        
                entityIcon: imagePath + 'glyphicons/png/site.png'
            },
            team: {
                genericCtlr: true,
                viewPermissions: ['OrganizationProfile_View'],
                createPermissions: ['OrganizationProfile_Mgmt'],
                editPermissions: ['OrganizationProfile_Mgmt'],
                deletePermissions: ['OrganizationProfile_Mgmt'],
                partial: 'entitylist.tpl.html',
                // by default type is assumed to be string and value rendered as is
                columns: [ // grid columns
                    {
                        name: 'name',
                        label: 'Name',
                        sortable: true
                    }, {
                        name: 'abbreviation',
                        label: 'Abbreviation',
                        sortable: true
                    }, {
                        name: 'description',
                        label: 'Description',
                        sortable: true
                    }, {
                        name: 'id',
                        label: 'Id',
                        sortable: true
                    }
                ],
                views: {
                    list: true,
                    card: true
                },
                card: ['name', 'description'], // card attributes
                entityDrillDown: true, // enable link to show entity details
                entityDelete: true, // enable element delete btn
                entityAdd: true, // enable element add btn 
                entityIcon: imagePath + 'glyphicons/png/team.png'
            },
            employee: {
                genericCtlr: true,
                viewPermissions: ['OrganizationProfile_View', 'Employee_View'],
                createPermissions: ['OrganizationProfile_Mgmt', 'Employee_Mgmt'],
                editPermissions: ['OrganizationProfile_Mgmt', 'Employee_Mgmt'],
                deletePermissions: ['OrganizationProfile_Mgmt', 'Employee_Mgmt'],
                partial: 'entitylist.tpl.html',
                columns: [ // grid columns
                    {
                        name: 'firstName',
                        label: 'First Name',
                        sortable: true
                    }, {
                        name: 'lastName',
                        label: 'Last Name',
                        sortable: true
                    }, {
                        name: 'notificationEmail',
                        label: 'Notification Email',
                        sortable: true
                    }, {
                        name: 'notificationSmsNumber',
                        label: 'Notification SmsNumber',
                        sortable: true
                    }, {
                        name: 'id',
                        label: 'Id',
                        sortable: true
                    }
                ],
                views: {
                    list: true,
                    card: true
                },
                card: ['firstName', 'lastName', 'employeeIdentifier'], // card attributes
                entityDrillDown: true, // enable link to show entity details
                entityDelete: true, // enable element delete btn
                entityAdd: true, // enable element add btn
                entityIcon: imagePath + 'glyphicons/png/user.png'
            },
            schedule: {
                genericCtlr: true,
                viewPermissions: ['Demand_View'],
                createPermissions: ['Demand_Mgmt'],
                editPermissions: ['Demand_Mgmt'],
                deletePermissions: ['Demand_Mgmt'],
                partial: 'entitylist.tpl.html',
                // TODO: add support for renderers on columns basd on type
                // by default type is assumed to be string and value rendered as is
                columns: [ // grid columns
                    {
                        name: 'name',
                        label: 'Name',
                        sortable: true
                    },  {
                        name: 'scheduleType',
                        label: 'Type',
                        sortable: true
                    }, {
                        name: 'description',
                        label: 'Description',
                        sortable: true
                    }, {
                        name: 'startDate',
                        label: 'Start Date',
                        dateFilter: 'yyyy-MM-dd',
                        sortable: true
                    }, {
                        name: 'endDate',
                        label: 'End Date',
                        dateFilter: 'yyyy-MM-dd',
                        sortable: true
                    }, {
                        name: 'scheduleLengthInDays',
                        label: 'Length',
                        sortable: true
                    }, {
                        name: 'status',
                        label: 'Status',
                        sortable: true
                    }, {
                        name: 'state',
                        label: 'Exe State',
                        sortable: true
                    }, {
                        name: 'executionStartDate',
                        label: 'Last Run',
                        dateFilter: 'yyyy-MM-dd HH:mm',
                        sortable: true
                    }, {
                        name: 'completion',
                        label: 'Completion',
                        sortable: true
                    }, {
                        name: 'returnedOpenShifts',
                        label: 'Open Shifts',
                        sortable: true
                    }, {
                        name: 'returnedAssignedShifts',
                        label: 'Assigned Shifts',
                        sortable: true
                    },   {
                        name: 'scheduledTeamCount',
                        label: 'Teams',
                        sortable: true
                    }, {
                        name: 'scheduledEmployeeCount',
                        label: 'Employees',
                        sortable: true
                    }, {
                        name: 'engineLabel',
                        label: 'Engine',
                        sortable: true
                    }, {
                        name: 'scheduleGroupId',
                        label: 'GroupId',
                        sortable: false
                    }, {
                        name: 'id',
                        label: 'Id',
                        sortable: false
                    }
                ],
                views: {
                    list: true,
                    card: true
                },
                card: ['name', 'type', 'startDate'], // card attributes
                entityDrillDown: true, // enable link to show entity details
                entityDelete: true, // enable element delete btn
                entityAdd: true, // enable element add btn
                entityIcon: imagePath + 'glyphicons/png/schedule.png'
            },
            shiftstructure: {
                genericCtlr: true,
                viewPermissions: ['Demand_View'],
                createPermissions: ['Demand_Mgmt'],
                editPermissions: ['Demand_Mgmt'],
                deletePermissions: ['Demand_Mgmt'],
                partial: 'entitylist.tpl.html',
                // TODO: add support for renderers on columns basd on type
                // by default type is assumed to be string and value rendered as is
                columns: [ // grid columns
                    {
                        name: 'startDate',
                        dateFilter: 'yyyy-MM-dd',
                        label: 'Start Date',
                        sortable: true
                    }, {
                        name: 'id',
                        label: 'Id',
                        sortable: true
                    }
                ],
                views: {
                    list: true,
                    card: false
                },
                //card:['startDate'],       // card attributes
                entityDrillDown: true, // enable link to show entity details
                entityDelete: true, // enable element delete btn
                entityAdd: true, // enable element add btn
                entityIcon: imagePath + 'glyphicons/png/shiftstructure.png'
            },
            shiftreq: {
                genericCtlr: true,
                viewPermissions: ['Demand_View'],
                createPermissions: ['Demand_Mgmt'],
                editPermissions: ['Demand_Mgmt'],
                deletePermissions: ['Demand_Mgmt'],
                partial: 'entitylist.tpl.html',
                columns: [ // grid columns
                    {
                        name: 'startTime',
                        label: 'Start Time',
                        sortable: true
                    }, {
                        name: 'endTime',
                        label: 'End Time',
                        sortable: true
                    }, {
                        name: 'dayIndex',
                        label: 'Day Index',
                        sortable: true
                    }, {
                        name: 'night',
                        label: 'is Night',
                        sortable: true
                    }, {
                        name: 'excess',
                        label: 'is Excess',
                        sortable: true
                    }, {
                        name: 'shiftTypeId',
                        label: 'ShiftType Id',
                        sortable: true
                    }, {
                        name: 'employeeCount',
                        label: 'Employees',
                        sortable: true
                    }, {
                        name: 'skillId',
                        label: 'Skill Id',
                        sortable: true
                    }, {
                        name: 'skillProficiencyLevel',
                        label: 'Skill level',
                        sortable: true
                    }, {
                        name: 'id',
                        label: 'Id',
                        sortable: true
                    }
                ],
                views: {
                    list: true,
                    card: false
                },
                //card:['startDate'],       // card attributes
                entityDrillDown: true, // enable link to show entity details
                entityDelete: true, // enable element delete btn
                entityAdd: true, // enable element add btn
                entityIcon: imagePath + 'glyphicons/png/shiftreq.png'
            },
            shifttype: {
                genericCtlr: true,
                viewPermissions: ['OrganizationProfile_View', 'Employee_View'],
                createPermissions: ['OrganizationProfile_Mgmt'],
                editPermissions: ['OrganizationProfile_Mgmt'],
                deletePermissions: ['OrganizationProfile_Mgmt'],
                partial: 'entitylist.tpl.html',
                columns: [ // grid columns
                    {
                        name: 'name',
                        label: 'Name',
                        sortable: true
                    }, {
                        name: 'description',
                        label: 'Description',
                        sortable: true
                    }, {
                        name: 'shiftLength',
                        label: 'Length',
                        sortable: true
                    }, {
                        name: 'paidHours',
                        label: 'Paid Hours',
                        sortable: true
                    }, {
                        name: 'id',
                        label: 'Id',
                        sortable: true
                    }
                ],
                views: {
                    list: true,
                    card: true
                },
                card: ['name', 'shiftLength', 'paidHours'], // card attributes
                entityDrillDown: true, // enable link to show entity details
                entityDelete: true, // enable element delete btn
                entityAdd: true, // enable element add btn
                entityIcon: imagePath + 'glyphicons/png/unknown.png'
            },
            absencetype: {
                genericCtlr: true,
                viewPermissions: ['OrganizationProfile_View', 'Employee_View'],
                createPermissions: ['OrganizationProfile_Mgmt'],
                editPermissions: ['OrganizationProfile_Mgmt'],
                deletePermissions: ['OrganizationProfile_Mgmt'],
                partial: 'entitylist.tpl.html',
                // by default type is assumed to be string and value rendered as is
                columns: [ // grid columns
                    {
                        name: 'name',
                        label: 'Name',
                        sortable: true
                    }, {
                        name: 'hoursToDeduct',
                        label: 'Hours  to deduct',
                        sortable: true
                    }, {
                        name: 'description',
                        label: 'Description',
                        sortable: true
                    }, {
                        name: 'id',
                        label: 'Id',
                        sortable: true
                    }
                ],
                views: {
                    list: true,
                    card: true
                },
                card: ['name', 'hoursToDeduct', 'description'], // card attributes
                entityDrillDown: true, // enable link to show entity details
                entityDelete: true, // enable element delete btn
                entityAdd: true, // enable element add btn 
                entityIcon: imagePath + 'glyphicons/png/unknown.png'
            },
            contract: {
                genericCtlr: true,
                viewPermissions: ['OrganizationProfile_View', 'Employee_View'],
                partial: 'entitylist.tpl.html',
                columns: [ // grid columns
                    {
                        name: 'name',
                        label: 'Name',
                        sortable: true
                    }, {
                        name: 'clName',
                        label: 'Type',
                        sortable: false
                    }, {
                        name: 'defaultContract',
                        label: 'Default Contract',
                        sortable: true
                    }, {
                        name: 'id',
                        label: 'Id',
                        sortable: true
                    }
                ],
                views: {
                    list: true,
                    card: false
                },
                entityDrillDown: true,   // enable link to show entity details
                entityDelete: false,     // enable element delete btn
                entityAdd: false,        // enable element add btn
                entityIcon: imagePath + 'glyphicons/png/contract.png'
            },
            appserver: {
                genericCtlr: true,
                viewPermissions: [],
                partial: 'entitylist.tpl.html',
                columns: [ // grid columns
                    {
                        name: 'name',
                        label: 'Name',
                        sortable: true
                    }, {
                        name: 'ip',
                        label: 'IP@',
                        sortable: false
                    }, {
                        name: 'updated',
                        label: 'Last heartbit',
                        dateFilter: 'yyyy-MM-dd HH:mm',
                        sortable: true
                    }, {
                        name: 'id',
                        label: 'Id',
                        sortable: true
                    }
                ],
                views: {
                    list: true,
                    card: false
                },
                entityDrillDown: false,   // enable link to show entity details
                entityDelete: false,     // enable element delete btn
                entityAdd: false,        // enable element add btn
                entityIcon: imagePath + 'glyphicons/png/appserver.png'
            },
            engine: {
                genericCtlr: true,
                viewPermissions: [],
                partial: 'entitylist.tpl.html',
                columns: [ // grid columns
                    {
                        name: 'name',
                        label: 'Name',
                        sortable: true
                    }, {
                        name: 'ip',
                        label: 'IP@',
                        sortable: false
                    }, {
                        name: 'updated',
                        label: 'Last heartbit',
                        dateFilter: 'yyyy-MM-dd HH:mm',
                        sortable: true
                    }, {
                        name: 'id',
                        label: 'Id',
                        sortable: true
                    }
                ],
                views: {
                    list: true,
                    card: false
                },
                entityDrillDown: false,   // enable link to show entity details
                entityDelete: false,     // enable element delete btn
                entityAdd: false,        // enable element add btn
                entityIcon: imagePath + 'glyphicons/png/engine.png'
            },

            session: {
                genericCtlr: true,
                viewPermissions: [],
                partial: 'entitylist.tpl.html',
                columns: [ // grid columns
                    {
                        name: 'tenantId',
                        label: 'Tenant Id',
                        sortable: false
                    }, {
                        name: 'userName',
                        label: 'User',
                        sortable: false
                    }, {
                        name: 'impersonatingUserName',
                        label: 'Impersonating User',
                        sortable: false
                    }, {
                        name: 'started',
                        label: 'Started',
                        dateFilter: 'yyyy-MM-dd HH:mm',
                        sortable: false
                    }, {
                        name: 'clientIPAddress',
                        label: 'IP@',
                        sortable: false
                    }, {
                        name: 'clientHostname',
                        label: 'HostName',
                        sortable: false
                    }, {
                        name: 'clientUserAgent',
                        label: 'User Agent',
                        sortable: false
                    }, {
                        name: 'token',
                        label: 'Token',
                        sortable: false
                    }, {
                        name: 'lang',
                        label: 'Language',
                        sortable: false
                    }
                ],
                views: {
                    list: true,
                    card: false
                },
                entityDrillDown: false,     // enable link to show entity details
                entityDelete: false,        // enable element delete btn
                entityAdd: false,           // enable element add btn
                entityIcon: imagePath + 'glyphicons/png/unknown.png'
            }
        },

        entityCtlr: { // config for Entity type controllers, which allow to Create and/or Edit an entity
            groupaccount: {
                genericCtlr: true,
                tabs: [{
                    name: 'useraccount',
                    label: 'Users',
                    icon: imagePath + 'glyphicons/png/user.png'
                }, {
                    name: 'role',
                    label: 'Roles',
                    icon: imagePath + 'glyphicons/png/role.png'
                }, {
                    name: 'acl',
                    label: 'Access Control Lists (NA)',
                    icon: imagePath + 'glyphicons/png/unknown.png'
                }],
                defaultRelatedEntity: 'useraccount'
            },
            useraccount: {
                genericCtlr: true,
                tabs: [{
                    name: 'groupaccount',
                    label: 'Groups',
                    icon: imagePath + 'glyphicons/png/usergroup.png'
                }, {
                    name: 'role',
                    label: 'Roles',
                    icon: imagePath + 'glyphicons/png/role.png'
                }, {
                    name: 'acl',
                    label: 'Access Control Lists (NA)',
                    icon: imagePath + 'glyphicons/png/unknown.png'
                }],
                defaultRelatedEntity: 'groupaccount'
            },
            role: {
                genericCtlr: true,
                tabs: [{
                    name: 'permission',
                    label: 'Permissions',
                    icon: imagePath + 'glyphicons/png/permission.png'
                }, {
                    name: 'acl',
                    label: 'Access Control Lists (NA)',
                    icon: imagePath + 'glyphicons/png/unknown.png'
                }],
                defaultRelatedEntity: 'permission'
            },
            permission: {
                genericCtlr: false, // false as the default ctlr allows actions (such as delete entities) which are not permitted for permissions
                defaultRelatedEntity: ''
            },
            skill: {
                genericCtlr: true,
                tabs: [{
                    name: 'site',
                    label: 'Sites (NA)',
                    icon: imagePath + 'glyphicons/png/site.png'
                }, {
                    name: 'team',
                    label: 'Teams (NA)',
                    icon: imagePath + 'glyphicons/png/team.png'
                }, {
                    name: 'employee',
                    label: 'Employees (NA)',
                    icon: imagePath + 'glyphicons/png/user.png'
                }],
                defaultRelatedEntity: 'site'
            },
            site: {
                genericCtlr: false,
                tabs: [{
                    name: 'team',
                    label: 'Teams',
                    icon: imagePath + 'glyphicons/png/user.png'
                }, {
                    name: 'skill',
                    label: 'Skills',
                    icon: imagePath + 'glyphicons/png/skill.png'
                }, {
                    name: 'employee',
                    label: 'Employees (NA)',
                    icon: imagePath + 'glyphicons/png/user.png'
                }],
                defaultRelatedEntity: 'team'
            },
            team: {
                genericCtlr: false,
                tabs: [{
                    name: 'employee',
                    label: 'Employees',
                    icon: imagePath + 'glyphicons/png/user.png'
                }, {
                    name: 'skill',
                    label: 'Skills',
                    icon: imagePath + 'glyphicons/png/skill.png'
                }, {
                    name: 'schedule',
                    label: '^ Schedules (NA)',
                    icon: imagePath + 'glyphicons/png/schedule.png'
                }, {
                    name: 'shiftstructure',
                    label: 'Shift Structures',
                    icon:  imagePath + 'glyphicons/png/shiftstructure.png'
                }],
                defaultRelatedEntity: 'employee'
            },
            employee: {
                genericCtlr: false,
                tabs: [{
                    name: 'team',
                    label: 'Teams',
                    icon: imagePath + 'glyphicons/png/team.png'
                }, {
                    name: 'skill',
                    label: 'Skills',
                    icon: imagePath + 'glyphicons/png/skill.png'
                }, {
                    name: 'ciavailability',
                    label: 'CI Availability (NA)',
                    icon: imagePath + 'glyphicons/png/unknown.png'
                }, {
                    name: 'cdavailability',
                    label: 'CD Availability (NA)',
                    icon: imagePath + 'glyphicons/png/unknown.png'
                }],
                defaultRelatedEntity: 'team'
            },
            schedule: {
                genericCtlr: false,
                tabs: [{
                    name: 'team',
                    label: 'Teams',
                    icon: imagePath + 'glyphicons/png/team.png'
                }, {
                    name: 'shiftstructure',
                    label: 'Shift Structures',
                    icon: imagePath + 'glyphicons/png/shiftstructure.png'
                }, {
                    name: 'shift',
                    label: 'Shifts & Assignments',
                    icon: imagePath + 'glyphicons/png/shift.png'
                }, {
                    name: 'shiftsgrid',
                    label: 'Shifts',
                    icon: imagePath + 'glyphicons/png/shift.png'
                    
                }, {
                    name: 'change',
                    label: 'Changes',
                    icon: imagePath + 'glyphicons/png/change.png'
                    
                }, {
                    name: 'scheduleoptions',
                    label: 'Schedule options',
                    icon: imagePath + 'glyphicons/png/unknown.png'
                }, {
                    name: 'report',
                    label: 'Execution report',
                    icon: imagePath + 'glyphicons/png/unknown.png'
                }],
                defaultRelatedEntity: 'shift'
            },
            shiftstructure: {
                genericCtlr: false,
                tabs: [{
                    name: 'schedules',
                    label: '^ Schedules (NA)',
                    icon: imagePath + 'glyphicons/png/schedule.png'
                }, {
                    name: 'shiftreq',
                    label: 'Shift Requirements',
                    icon: imagePath + 'glyphicons/png/shiftreq.png'
                }],
                defaultRelatedEntity: 'schedules'
            },
            shiftreq: {
                genericCtlr: false,
                defaultRelatedEntity: ''
            },
            shifttype: {
                genericCtlr: true,
                defaultRelatedEntity: ''
            },
            absencetype: {
                genericCtlr: true,
                defaultRelatedEntity: ''
            },
            ciavailability: {
                genericCtlr: false,
                defaultRelatedEntity: ''
            },
            cdavailability: {
                genericCtlr: false,
                defaultRelatedEntity: ''
            },
            // see after this variable declaration for the extension to employee, team, site, contract
            contract: {
                genericCtlr: true,                
                tabs: [{
                    name: 'contractlines',
                    label: 'Contract Lines',
                    icon: imagePath + 'glyphicons/png/contract.png'
                }],
                defaultRelatedEntity: 'contractline'
            },
            contractline: {
                genericCtlr: false,                
                defaultRelatedEntity: ''
            }
        },

        relatedEntityCtlr: { // config for RelatedEntity type controllers (invoked from EntityCtlr s)

            groupaccount: { // groupaccount navigation
                useraccount: {
                    viewPermissions: ['Account_View'],
                    addPermissions: ['Account_Mgmt'],
                    removePermissions: ['Account_Mgmt'],
                    partial: 'entity_relatedentitylist.tpl.html',
                    columns: [ // grid columns
                        {
                            name: 'name',
                            label: 'Name',
                            sortable: true
                        }, {
                            name: 'description',
                            label: 'Description',
                            sortable: true
                        }, {
                            name: 'login',
                            label: 'Login',
                            sortable: true
                        }, {
                            name: 'email',
                            label: 'Email',
                            sortable: true
                        }, {
                            name: 'id',
                            label: 'Id',
                            sortable: true
                        }
                    ],
                    relatedEntityicon: imagePath + 'glyphicons/png/user.png',
                    dataServiceGetAssociatedEntitiesAPI: 'getGroupMembers',
                    dataServiceGetUnassociatedEntitiesAPI: 'getUnassociatedGroupMembers',
                    dataServiceAssociateEntityAPI: 'addMemberToGroup',
                    dataServiceUnassociateEntityAPI: 'removeMemberFromGroup',
                    secundaryEntityAddPartial: 'modules/browser/partials/entity_addrelatedentity.tpl.html'
                },
                role: {
                    viewPermissions: ['Account_View', 'Role_View'],
                    addPermissions: ['Account_Mgmt'],
                    removePermissions: ['Account_Mgmt'],
                    partial: 'entity_relatedentitylist.tpl.html',
                    columns: [ // grid columns
                        {
                            name: 'name',
                            label: 'Name',
                            sortable: true
                        }, {
                            name: 'description',
                            label: 'Description',
                            sortable: true
                        }, {
                            name: 'id',
                            label: 'Id',
                            sortable: true
                        }
                    ],
                    relatedEntityIcon: imagePath + 'glyphicons/png/role.png',
                    dataServiceResource: 'groupaccounts',
                    dataServiceGetAssociatedEntitiesAPI: 'getAccountRoles',
                    dataServiceGetUnassociatedEntitiesAPI: 'getUnassociatedAccountRoles',
                    dataServiceAssociateEntityAPI: 'addRoleToAccount',
                    dataServiceUnassociateEntityAPI: 'removeRoleFromAccount',
                    secundaryEntityAddPartial: 'modules/browser/partials/entity_addrelatedentity.tpl.html'
                }
            },

            useraccount: { // useraccount navigation
                groupaccount: {
                    partial: 'entity_relatedentitylist.tpl.html',
                    viewPermissions: ['Account_View'],
                    addPermissions: [],
                    removePermissions: [],
                    type: 'addremove',
                    dataServiceGetAssociatedEntitiesAPI: 'getUserGroups',
                    columns: [ // grid columns
                        {
                            name: 'name',
                            label: 'Name',
                            sortable: true
                        }, {
                            name: 'description',
                            label: 'Description',
                            sortable: true
                        }, {
                            name: 'id',
                            label: 'Id',
                            sortable: true
                        }
                    ],
                    relatedEntityIcon: imagePath + 'glyphicons/png/usergroup.png'
                },
                role: {
                    partial: 'entity_relatedentitylist.tpl.html',
                    viewPermissions: ['Account_View', 'Role_View'],
                    addPermissions: ['Account_Mgmt'],
                    removePermissions: ['Account_Mgmt'],
                    columns: [ // grid columns
                        {
                            name: 'name',
                            label: 'Name',
                            sortable: true
                        }, {
                            name: 'description',
                            label: 'Description',
                            sortable: true
                        }, {
                            name: 'id',
                            label: 'Id',
                            sortable: true
                        }
                    ],
                    relatedEntityIcon: imagePath + 'glyphicons/png/role.png',
                    dataServiceResource: 'useraccounts',
                    dataServiceGetAssociatedEntitiesAPI: 'getAccountRoles',
                    dataServiceGetUnassociatedEntitiesAPI: 'getUnassociatedAccountRoles',
                    dataServiceAssociateEntityAPI: 'addRoleToAccount',
                    dataServiceUnassociateEntityAPI: 'removeRoleFromAccount',
                    secundaryEntityAddPartial: 'modules/browser/partials/entity_addrelatedentity.tpl.html'
                }
            },

            role: { // role navigation
                permission: {
                    partial: 'entity_relatedentitylist.tpl.html',
                    //          viewPermissions: ['Role_View'],
                    addPermissions: ['Role_Mgmt'],
                    removePermissions: ['Role_Mgmt'],
                    columns: [ // grid columns
                        {
                            name: 'name',
                            label: 'Name',
                            sortable: true
                        }, {
                            name: 'description',
                            label: 'Description',
                            sortable: true
                        }, {
                            name: 'type',
                            label: 'Type',
                            sortable: true,
                            showInAddModal: false
                        }, {
                            name: 'scope',
                            label: 'Scope',
                            sortable: true,
                            showInAddModal: false
                        }, {
                            name: 'id',
                            label: 'Id',
                            sortable: true
                        }
                    ],
                    relatedEntityIcon: imagePath + 'glyphicons/png/permission.png',
                    dataServiceGetAssociatedEntitiesAPI: 'getRolePermissions',
                    dataServiceGetUnassociatedEntitiesAPI: 'getUnassociatedRolePermissions',
                    dataServiceAssociateEntityAPI: 'addPermissionToRole',
                    dataServiceUnassociateEntityAPI: 'removePermissionFromRole',
                    secundaryEntityAddPartial: 'modules/browser/partials/entity_addrelatedentity.tpl.html'
                }
            },

            site: { // site navigation
                team: {
                    partial: 'entity_relatedentitylist.tpl.html',
                    columns: [ // grid columns
                        {
                            name: 'name',
                            label: 'Name',
                            sortable: true
                        }, {
                            name: 'description',
                            label: 'Description',
                            sortable: true
                        }, {
                            name: 'id',
                            label: 'Id',
                            sortable: true
                        }
                    ],
                    relatedEntityIcon: imagePath + 'glyphicons/png/team.png',
                    viewPermissions: ['Demand_View'],
                    createPermissions: ['Demand_Mgmt'],
                    deletePermissions: ['Demand_Mgmt'],
                    dataServiceGetAssociatedEntitiesAPI: 'getSiteTeams',
                    dataServiceCreateAssociatedEntityAPI: 'createSiteTeam',
                    dataServiceGetUnassociatedEntitiesAPI: 'getUnassociatedSiteTeams',
                    dataServiceDeleteAssociatedEntityAPI: 'deleteSiteTeam',
                    secundaryEntityCreatePartial: 'modules/browser/partials/site_createteam.html'
                },
                skill: {
                    viewPermissions: ['OrganizationProfile_View'],
                    addPermissions: ['OrganizationProfile_Mgmt'],
                    removePermissions: ['OrganizationProfile_Mgmt'],
                    partial: 'entity_relatedentitylist.tpl.html',
                    columns: [ // grid columns
                        {
                            name: 'name',
                            label: 'Name',
                            sortable: true
                        }, {
                            name: 'abbreviation',
                            label: 'Abbreviation',
                            sortable: true
                        }, {
                            name: 'description',
                            label: 'Description',
                            sortable: true
                        }, {
                            name: 'id',
                            label: 'Id',
                            sortable: true
                        }
                    ],
                    relatedEntityIcon: imagePath + 'glyphicons/png/skill.png',
                    dataServiceGetAssociatedEntitiesAPI: 'getSiteSkills',
                    dataServiceGetUnassociatedEntitiesAPI: 'getUnassociatedSiteSkills',
                    dataServiceAssociateEntityAPI: 'addSiteSkill',
                    dataServiceUnassociateEntityAPI: 'removeSkillFromSite',
                    secundaryEntityAddPartial: 'modules/browser/partials/entity_addrelatedentity.tpl.html'
                }
            },

            team: { // team navigation
                employee: {
                    viewPermissions: ['OrganizationProfile_View', 'Employee_View'],
                    addPermissions: ['OrganizationProfile_Mgmt'],
                    removePermissions: ['OrganizationProfile_Mgmt'],
                    partial: 'entity_relatedentitylist.tpl.html',
                    columns: [ // grid columns
                        {
                            dto: 'employeeSummaryDto',
                            name: 'firstName',
                            label: 'First Name',
                            sortable: true
                        }, {
                            dto: 'employeeSummaryDto',
                            name: 'lastName',
                            label: 'Last Name',
                            sortable: true
                        }, {
                            name: 'isFloating',
                            label: 'Floating',
                            sortable: true,
                            showInAddModal: false
                        }, {
                            name: 'isHomeTeam',
                            label: 'Home Team',
                            sortable: true,
                            showInAddModal: false
                        }, {
                            name: 'isSchedulable',
                            label: 'Schedulable',
                            sortable: true,
                            showInAddModal: false
                        }, {
                            //                    dto: 'employeeNamesDto',
                            name: 'id',
                            label: 'Id',
                            sortable: true
                        }
                    ],
                    relatedEntityIcon: imagePath + 'glyphicons/png/user.png',
                    dataServiceGetAssociatedEntitiesAPI: 'getTeamEmployees',
                    dataServiceGetUnassociatedEntitiesAPI: 'getUnassociatedTeamEmployees',
                    dataServiceAssociateEntityAPI: 'addEmployeeToTeam',
                    dataServiceUnassociateEntityAPI: 'removeEmployeeFromTeam',
                    secundaryEntityAddPartial: 'modules/browser/partials/entity_addrelatedentity.tpl.html'
                },
                skill: {
                    viewPermissions: ['OrganizationProfile_View'],
                    addPermissions: ['OrganizationProfile_Mgmt'],
                    removePermissions: ['OrganizationProfile_Mgmt'],
                    partial: 'entity_relatedentitylist.tpl.html',
                    columns: [ // grid columns
                        {
                            name: 'name',
                            label: 'Name',
                            sortable: true
                        }, {
                            name: 'abbreviation',
                            label: 'Abbreviation',
                            sortable: true
                        }, {
                            name: 'description',
                            label: 'Description',
                            sortable: true
                        }, {
                            name: 'id',
                            label: 'Id',
                            sortable: true
                        }
                    ],
                    relatedEntityIcon: imagePath + 'glyphicons/png/team.png',
                    dataServiceGetAssociatedEntitiesAPI: 'getTeamSkills',
                    dataServiceGetUnassociatedEntitiesAPI: 'getUnassociatedTeamSkills',
                    dataServiceAssociateEntityAPI: 'addTeamSkill',
                    dataServiceUnassociateEntityAPI: 'removeSkillFromTeam',
                    secundaryEntityAddPartial: 'modules/browser/partials/entity_addrelatedentity.tpl.html'
                },
                schedule: {
                    viewPermissions: ['Demand_View'],
                    partial: 'entity_relatedentitylist.tpl.html',
                    columns: [ // grid columns
                        {
                            name: 'name',
                            label: 'Name',
                            sortable: true
                        }, {
                            name: 'startDate',
                            label: 'Start Date',
                            dateFilter: 'yyyy-MM-dd HH:mm',
                            sortable: true
                        }, {
                            name: 'type',
                            label: 'Type',
                            sortable: true
                        }, {
                            name: 'state',
                            label: 'State',
                            sortable: true
                        }, {
                            name: 'id',
                            label: 'Id',
                            sortable: true
                        }
                    ],
                    relatedEntityIcon: imagePath + 'glyphicons/png/schedule.png',
                    dataServiceGetAssociatedEntitiesAPI: 'getTeamSchedules'
                },
                shiftstructure: {
                    partial: 'entity_relatedentitylist.tpl.html',
                    columns: [ // grid columns
                        {
                            name: 'startDate',
                            label: 'Start date',
                            dateFilter: 'yyyy-MM-dd HH:mm',
                            sortable: false
                        }, {
                            name: 'id',
                            label: 'Id',
                            sortable: false
                        }
                    ],
                    relatedEntityIcon: imagePath + 'glyphicons/png/shiftstructure.png',
                    viewPermissions: ['Demand_View'],
                    createPermissions: ['Demand_Mgmt'],
                    deletePermissions: ['Demand_Mgmt'],
                    secundaryEntity: true,
                    dataServiceGetAssociatedEntitiesAPI: 'getShiftStructures',
                    dataServiceGetAssociatedEntityAPI: 'getShiftStructure',
                    dataServiceCreateAssociatedEntityAPI: 'createShiftStructure',
                    dataServiceDeleteAssociatedEntityAPI: 'deleteShiftStructure',
                    secundaryEntityCreatePartial: 'modules/browser/partials/team_createshiftstructure.html'
                }
            },

            employee: { // employee navigation
                team: {
                    //          viewPermissions: ['OrganizationProfile_View'],
                    addPermissions: ['OrganizationProfile_Mgmt'],
                    removePermissions: ['OrganizationProfile_Mgmt'],
                    partial: 'entity_relatedentitylist.tpl.html',
                    columns: [ // grid columns
                        {
                            dto: 'teamDto',
                            name: 'name',
                            label: 'Name',
                            sortable: true
                        }, {
                            name: 'isHomeTeam',
                            label: 'Home Team',
                            sortable: true,
                            showInAddModal: false
                        }, {
                            name: 'isFloating',
                            label: 'Floating',
                            sortable: true,
                            showInAddModal: false
                        }, {
                            name: 'isSchedulable',
                            label: 'Schedulable',
                            sortable: true,
                            showInAddModal: false
                        }, {
                            name: 'id',
                            label: 'Id',
                            sortable: true
                        }
                    ],
                    relatedEntityIcon: imagePath + 'glyphicons/png/user.png',
                    dataServiceGetAssociatedEntitiesAPI: 'getEmployeeTeams',
                    dataServiceGetUnassociatedEntitiesAPI: 'getUnassociatedEmployeeTeams',
                    dataServiceAssociateEntityAPI: 'addTeamToEmployee',
                    dataServiceUnassociateEntityAPI: 'removeTeamFromEmployee',
                    unassociateIdAttribute: {
                        o: 'teamDto',
                        id: 'id'
                    },
                    secundaryEntityAddPartial: 'modules/browser/partials/entity_addrelatedentity.tpl.html'
                },
                skill: {
                    //          viewPermissions: ['OrganizationProfile_View'],
                    addPermissions: ['OrganizationProfile_Mgmt'],
                    removePermissions: ['OrganizationProfile_Mgmt'],
                    partial: 'entity_relatedentitylist.tpl.html',
                    columns: [ // grid columns
                        {
                            dto: 'skillDto',
                            name: 'name',
                            label: 'Name',
                            sortable: true
                        }, {
                            dto: 'skillDto',
                            name: 'abbreviation',
                            label: 'Abbreviation',
                            sortable: true
                        }, {
                            name: 'isPrimarySkill',
                            label: 'Primary',
                            sortable: true
                        }, {
                            name: 'skillScore',
                            label: 'Level',
                            sortable: true
                        }, {
                            name: 'id',
                            label: 'Id',
                            sortable: true
                        }
                    ],
                    relatedEntityIcon: imagePath + 'glyphicons/png/skill.png',
                    dataServiceGetAssociatedEntitiesAPI: 'getEmployeeSkills',
                    dataServiceGetUnassociatedEntitiesAPI: 'getUnassociatedEmployeeSkills',
                    dataServiceAssociateEntityAPI: 'addSkillToEmployee',
                    dataServiceUnassociateEntityAPI: 'removeSkillFromEmployee',
                    unassociateIdAttribute: {
                        o: 'skillDto',
                        id: 'id'
                    },
                    secundaryEntityAddPartial: 'modules/browser/partials/entity_addrelatedentity.tpl.html' /* a bit ugly but same template as for team */
                },
                ciavailability: {
                    //          viewPermissions: ['OrganizationProfile_View'],
                    partial: 'entity_relatedentitylist.tpl.html',
                    columns: [ // grid columns
                        
                        {
                            name: 'availabilityType',
                            label: 'Type',
                            sortable: true
                        },
                        {
                            name: 'dayOfTheWeek',
                            label: 'Day of week',
                            sortable: true
                        }, 
                        {
                            name: 'startTime',
                            label: 'At',
                            dateFilter: 'HH:mm',
                            sortable: true
                        },{
                            name: 'durationInMinutes',
                            label: 'For (mins)',
                            sortable: true
                        }, {
                            name: 'absenceTypeId',
                            label: 'Absence Type',
                            sortable: true
                        }, {
                            name: 'reason',
                            label: 'Absence reason',
                            sortable: true
                        }, {
                            name: 'startDate',
                            label: 'From (date)',
                            dateFilter: 'yyyy-MM-dd',
                            sortable: true
                        }, {
                            name: 'endDate',
                            label: 'To (date)',
                            dateFilter: 'yyyy-MM-dd',
                            sortable: true
                        }, {
                            name: 'id',
                            label: 'Id',
                            sortable: true
                        }
                    ],
                    relatedEntityIcon: imagePath + 'glyphicons/png/unknown.png',
                    viewPermissions: ['Demand_View'],
                    createPermissions: ['Demand_Mgmt'],
                    deletePermissions: ['Demand_Mgmt'],
                    secundaryEntity: true,
                    dataServiceGetAssociatedEntitiesAPI: 'getEmployeeCIAvailabilities',
                    dataServiceGetAssociatedEntityAPI: 'getEmployeeCIAvailability',
                    dataServiceCreateAssociatedEntityAPI: 'createEmployeeCIAvailability',
                    dataServiceUpdateAssociatedEntityAPI: 'updateEmployeeCIAvailability',
                    dataServiceDeleteAssociatedEntityAPI: 'deleteEmployeeCIAvailability',
                    secundaryEntityCreatePartial: 'modules/browser/partials/employee_createciavailability.html'
                },
                cdavailability: {
                    //          viewPermissions: ['OrganizationProfile_View'],
                    partial: 'entity_relatedentitylist.tpl.html',
                    columns: [ // grid columns
                        
                        {
                            name: 'availabilityType',
                            label: 'Type',
                            sortable: true
                        },{
                            name: 'startDate',
                            label: 'On (date)',
                            dateFilter: 'yyyy-MM-dd',
                            sortable: true
                        },{
                            name: 'startTime',
                            label: 'At',
                            dateFilter: 'HH:mm',
                            sortable: true
                        },{
                            name: 'durationInMinutes',
                            label: 'For (mins)',
                            sortable: true
                        }, {
                            name: 'absenceTypeId',
                            label: 'Absence Type',
                            sortable: true
                        }, {
                            name: 'reason',
                            label: 'Absence reason',
                            sortable: true
                        },  {
                            name: 'id',
                            label: 'Id',
                            sortable: true
                        }
                    ],
                    relatedEntityIcon: imagePath + 'glyphicons/png/unknown.png',
                    viewPermissions: ['Demand_View'],
                    createPermissions: ['Demand_Mgmt'],
                    deletePermissions: ['Demand_Mgmt'],
                    secundaryEntity: true,
                    dataServiceGetAssociatedEntitiesAPI: 'getEmployeeCDAvailabilities',
                    dataServiceGetAssociatedEntityAPI: 'getEmployeeCDAvailability',
                    dataServiceCreateAssociatedEntityAPI: 'createEmployeeCDAvailability',
                    dataServiceUpdateAssociatedEntityAPI: 'updateEmployeeCDAvailability',
                    dataServiceDeleteAssociatedEntityAPI: 'deleteEmployeeCDAvailability',
                    secundaryEntityCreatePartial: 'modules/browser/partials/employee_createcdavailability.html'
                }
            },

            shiftstructure: {              
                team: {
                    partial: 'entity_relatedentitylist.tpl.html',
                    columns: [ // grid columns
                        {
                            name: 'name',
                            label: 'Name',
                            sortable: false
                        }, {
                            name: 'id',
                            label: 'Id',
                            sortable: false
                        }
                    ],
                    relatedEntityIcon: imagePath + 'glyphicons/png/team.png',
                    viewPermissions: ['Demand_View'],
                    secundaryEntity: true,
                    dataServiceGetAssociatedEntitiesAPI: 'getShiftStructureTeams'
                },
                shiftreq: {
//                    partial: 'entity_relatedentitylist.tpl.html',
//                    columns: [ // grid columns
//                        {
//                            name: 'dayIndex',
//                            label: 'Day Index',
//                            sortable: true
//                        }, {
//                            name: 'startTime',
//                            label: 'Start Time',
//                            dateFilter: 'HH:mm',
//                            sortable: true
//                        }, {
//                            name: 'durationInMins',
//                            label: 'Duration (mins)',
//                            sortable: true
//                        }, {
//                            name: 'employeeCount',
//                            label: 'Employees',
//                            sortable: true
//                        }, {
//                            name: 'id',
//                            label: 'Id',
//                            sortable: true
//                        }
//                    ],
//                    relatedEntityIcon: imagePath + 'glyphicons/png/shiftreq.png',
                    viewPermissions: ['Demand_View'],
                    createPermissions: ['Demand_Mgmt'],
                    deletePermissions: ['Demand_Mgmt'],
                    secundaryEntity: true,
                    dataServiceGetAssociatedEntityAPI: 'getShiftReq',
                    dataServiceGetAssociatedEntitiesAPI: 'getShiftReqs',
                    dataServiceCreateAssociatedEntityAPI: 'createShiftReq',
                    dataServiceUpdateAssociatedEntityAPI: 'updateShiftReq',
                    dataServiceDeleteAssociatedEntityAPI: 'deleteShiftReq',
                    secundaryEntityCreatePartial: 'modules/browser/partials/shiftreq.html'
                }
            },

            schedule: { // schedule navigation
                team: {
                    viewPermissions: ['Demand_View'],
                    dataServiceGetAssociatedEntitiesAPI: 'getScheduleTeams',
                    partial: 'entity_relatedentitylist.tpl.html',
                    columns: [ // grid columns
                        {
                            name: 'name',
                            label: 'Name',
                            sortable: true
                        }, {
                            name: 'id',
                            label: 'Id',
                            sortable: true
                        }
                    ],
                    relatedEntityIcon: imagePath + 'glyphicons/png/team.png'
                },
                shiftstructure: {
                    viewPermissions: ['Demand_View'],
                    dataServiceGetAssociatedEntitiesAPI: 'getScheduleShiftStructures',
                    partial: 'entity_relatedentitylist.tpl.html',
                    columns: [ // grid columns
                        {
                            name: 'startDate',
                            label: 'Start Date',
                            dateFilter: 'yyyy-MM-dd HH:mm',
                            sortable: true
                        }, {
                            name: 'id',
                            label: 'Id',
                            sortable: true
                        }
                    ],
                    relatedEntityIcon: imagePath + 'glyphicons/png/shiftstructure.png'
                },
                shift: {
                    partial: 'entity_relatedentitylist.tpl.html',
                    viewPermissions: ['Demand_View'],
                    columns: [ // grid columns
                        {
                            name: 'startDateTime',
                            label: 'Start DateTime',
                            dateFilter: 'yyyy-MM-dd HH:mm',
                            sortable: true
                        }, {
                            name: 'endDateTime',
                            label: 'End DateTime',
                            dateFilter: 'HH:mm',
                            sortable: true
                        }, {
                            name: 'employeeName',
                            label: 'Employee',
                            sortable: true
                        }, {
                            name: 'skillName',
                            label: 'Skill',
                            sortable: true
                        }, {
                            name: 'shiftTypeName',
                            label: 'Shift Type',
                            sortable: true
                        }, {
                            name: 'teamName',
                            label: 'Team',
                            sortable: true
                        }, {
                            name: 'employeeId',
                            label: 'Employee Id',
                            sortable: true
                        }, {
                            name: 'scheduleStatus',
                            label: 'Schedule Status',
                            sortable: true
                        }, {
                            name: 'assignmentType',
                            label: 'AssignmentType',
                            sortable: true
                        }, {
                            name: 'id',
                            label: 'Id',
                            sortable: true
                        }
                    ],
                    relatedEntityIcon: imagePath + 'glyphicons/png/unknown.png',
                    dataServiceGetAssociatedEntitiesAPI: 'getScheduleShifts'
                },
                shiftsgrid:{
                    partial: 'schedule_shiftsgrid.html',
                    dataServiceGetAssociatedEntitiesAPI: 'getScheduleShifts',
                    controller: 'ShiftsCtlr'
                },
                change: {
                    viewPermissions: ['Demand_View'],
                    dataServiceGetAssociatedEntitiesAPI: 'getScheduleChanges',
                    partial: 'entity_relatedentitylist.tpl.html',
                    columns: [ // grid columns
                        {
                            name: 'changeDate',
                            label: 'Change Date',
                            dateFilter: 'yyyy-MM-dd HH:mm',
                            sortable: true
                        }, {
                            name: 'reason',
                            label: 'Reason',
                            sortable: true
                        }, {
                            name: 'category',
                            label: 'Category',
                            sortable: true
                        }, {
                            name: 'type',
                            label: 'Type',
                            sortable: true
                        }, {
                            name: 'changeEmployeeName',
                            label: 'Changed By',
                            sortable: true
                        }, {
                            name: 'employeeAName',
                            label: 'Employee A',
                            sortable: true
                        }, {
                            name: 'employeeBName',
                            label: 'Employee B',
                            sortable: true
                        }, {
                            name: 'id',
                            label: 'Id',
                            sortable: true
                        }
                    ],
                    relatedEntityIcon: imagePath + 'glyphicons/png/unknown.png'
                },
                scheduleoptions:{
                    partial: 'schedule_options.html',
                    controller: 'ScheduleOptionsCtrl'
                },
                report:{
                    partial: 'schedule_report.html',
                    controller: 'ScheduleReportCtrl'
                }
            },

            employeecontract: {
                contractline: {
                    partial: 'entity_relatedentitylist.tpl.html',
                    columns: [ // grid columns
                        {
                            name: 'contractLineType',
                            label: 'Type',
                            sortable: false
                        }, {
                            name: 'description',
                            label: 'Description',
                            sortable: false
                        }, {
                            name: 'id',
                            label: 'Id',
                            sortable: false
                        }
                    ],
                    relatedEntityIcon: imagePath + 'glyphicons/png/contractline.png',
                    viewPermissions: ['OrganizationProfile_View', 'Employee_View'],
                    createPermissions: ['OrganizationProfile_Mgmt', 'Employee_Mgmt'],
                    deletePermissions: ['OrganizationProfile_Mgmt', 'Employee_Mgmt'],
                    secundaryEntity: true,
                    dataServiceGetAssociatedEntitiesAPI: 'getContractLines',
                    dataServiceGetAssociatedEntityAPI: 'getContractLine',
                    dataServiceCreateAssociatedEntityAPI: 'createContractLine',
                    dataServiceDeleteAssociatedEntityAPI: 'deleteContractLine',
                    secundaryEntityCreatePartial: 'modules/browser/partials/contract_createcontractline.html'
                }
            }
        }
    };

    // duplicate the contract config to site, team, employee contracts
    var entityCtlr = ctlrConfig.entityCtlr;
    entityCtlr.sitecontract = entityCtlr.employeecontract = entityCtlr.employeecontract = entityCtlr.contract;


}());

;
var employees = angular.module('emlogis.browser');

employees.controller('BrowserBreadcrumbCtrl', ['$scope', '$state', '$translate', 'applicationContext',
    function($scope, $state, $translate, applicationContext ) {

        $scope.entity =  $state.params.entity;
        console.log("Browser Breadcrumb Ctrl (Entity) : " +  $state.params.entity);

        var module = applicationContext.getModule();

        // Call translate directive function. Put translated text;
        $translate('nav.BROWSER')
            .then(function (translation) {
                module.name =  translation;
            });


        /**
         * state attribute will not update href attribute actually.
         * because this is called behind after ui-sref attribute rendered
         */

        module.icoClass = '';
        module.href = '/browser/site';
        module.disableModuleBreadcrumb = false;
        applicationContext.setModule(module);
    }
]);

;
var employees = angular.module('emlogis.browser');

employees.controller('BrowserEntityBreadcrumbCtrl', ['$scope', '$state', 'appContext',
    function($scope,$state, appContext ) {

        $scope.entity =  $state.params.entity;
        console.log("Browser Entity Breadcrumb Ctrl (Entity) : " +  $state.params.entity);

        $scope.relatedentity =  $state.params.relatedentity;
    }
]);

;
(function () {

// test
//var fn = function(name) { deleteElement(name); return "deleted: " + name;  function deleteElement(elt){console.log('delete ' +elt); }};

/*
    // utility and convenience methods and controlers for the browser module
*/

    var module =  angular.module('emlogis.browser');


    /*
     *  Controller for displaying the top level List of an Entity
     *
     * It drives the display of the selected Entity Detailed Information / Browser
     * (on selection of a row (element), it displays the corresponding information
     * and allows also to delete one entity from the list. 
     *
     * As of now, the only required parameters is the entity name provided via the $stateParams parameter
     *
     */

    module.controller(
        'EntityListCtlr', 
        ['$scope', '$stateParams', '$state', '$filter', 'authService', 'appContext', 'dataService', 'dialogs',
        function($scope, $stateParams, $state, $filter, authService, appContext, dataService, dialogs) {

            console.log('inside EntityListCtlr controller for: ' + $stateParams.entity + '/' + $stateParams.id);

            var listandcardpagingctlr = new ListAndCardPagingCtlr();
            listandcardpagingctlr.init.call(listandcardpagingctlr, $scope, $stateParams, $state, $filter, authService, appContext, dataService, dialogs);
            listandcardpagingctlr.getElements();

            // Delete Element details according to selected row
            // TODO (curently we don't have the ability to select one or several rows)
            /*
            $scope.deleteOrRemoveElt = function(element){
                $scope.selectedElement = element;
                console.log('--> TODO: deleteOrRemoveElt(' + element + ')' + ' => ' + element.name + ',' + element.id);
                
                //var to = "groupaccount";
                //$state.go(to, {entity: $stateParams.entity, id: element.id});
                var x =1;
            }; 
            */

            // delete the current row Element  
            $scope.deleteElement = function(element) {
                var dlg = dialogs.confirm('Please Confirm','Do you realy want to delete entity ' + element.name +'?');
                dlg.result.then(function(btn){
                    deleteElement(element);
                },function(btn){
                    console.log("entity not deleted");
                });
            };

            // ===========================================================================
            // Controller private methods

            // delete Element  
            function deleteElement(elt){

                dataService
                .deleteElement($scope.resource, elt.id)
                .then(function (result) {
                    console.log('--> deleted[' + elt.name + ': ' + elt.id + ']'); 
                    $scope.elements = _.without($scope.elements, elt); 
                    listandcardpagingctlr.getElements(); // force refresh
                }, function (error) {
                    dialogs.error("Error", error.data.message, 'lg');
                });               
            }
        }   

    ]);



    /*
     *  Controller for displaying/updating information about a single Entity / cretaing an entity
     *
     * Allows to 
     * - create a new entity
     * - update an existing entity 
     * - display related entities and navigate to these related entities
     *
     * As of now, the only required parameters is the entity name provided via the $stateParams parameter
     *
     */
    module.controller(
        'EntityCtlr',
        ['$scope', '$stateParams', '$state', 'stateManager', '$filter', 'authService', 'appContext', 'dataService', 'dialogs', 'alertsManager',
        function($scope, $stateParams, $state, stateManager, $filter, authService, appContext, dataService, dialogs, alertsManager) {

            console.log("EntityCtlr: " + _.values($stateParams));

            EditOrCreateEntityCtlr($scope, $stateParams, $state, stateManager, $filter, authService, appContext, dataService, dialogs, alertsManager);

//            var ctlrConfig = $stateParams.ctlrConfig;
//            $state.go('entity.relatedentity', {relatedentity: ctlrConfig.defaultRelatedEntity});
        }          
    ]);

     /* 
     *  Controller for Listing the 'secundary' entities of 'primary' entity
     * Allows to  add / removee a 'secundary' to/from the 'primary' 
     *  AND / OR 
     * to create and associate / delete secundary entities to/from the primary one
     * Add / Create / Remove / Delete are driven by permissions (see below) specified in config
     * for short,
     * viewPermissions      allow to view an entity
     * addPermissions       allow to associate a selected secundary entity to the primary one
     * removePermissions    allow to un-associate a selected secundary entity from the primary one
     * createPermissions    allow to create and associate a secundary entity to the primary one
     * deletePermissions:   allow to un-associate selected secundary entity from the primary one and delete the secundary entity
     *
     * When invoked, this controler expects in the $stateParams the following attributes:
     * - entity: the name of the 'primary' entity (ex 'groupaccount' in add user to group scenario)
     * - relatedentity: the name of the 'secundary' entity (ex 'useraccount' in add user to group scenario)

     * AND in the  $stateParams.ctlrConfig object, the following attributes:
     *
     * //entityTypeLabel: user friendly label for the 'primary' entity
     * //relatedentityTypeLabel: user friendly label for the 'secundary' entity
     * 
     *
     * - dataServiceResource: the data service resource parameter for some APIs that need it like account role mngt  apis
     * that are generic and apply to UserAccounst as well GroupAccounts 
     * !! Leave unspecified for general cases !!
     *
     * - dataServiceGetAssociatedEntitiesAPI: name of dataservice API to invoke to get the list of 'secundary' entities 
     * currently unassociated  to the primary one. (ex: 'getGroupMembers' in add user to group scenario)
     *
     *
     *
     * Parameters for adding / removing related entities 
     * -------------------------------------------------
     *
     * - dataServiceGetUnassociatedEntitiesAPI: name of dataservice API to invoke to get the list of unassociated 'secundary' entities 
     * (ex: 'getGroupMembers' in add user to group scenario)
     *
     * - dataServiceAssociateEntityAPI: name of dataservice API to invoke to associate the 'secundary' entity to the primary one
     * (ex: 'addMemberToGroup' n add user to group scenario)
     *
     * - dataServiceUnassociateEntityAPI: name of dataservice API to invoke to associate the 'secundary' entity to the primary one
     * (ex: 'removeMemberFromGroup' in remove user from group scenario)
     *
     * - secundaryEntityAddPartial: name of partial to diplay the secundary 'pickup' list on Add operation
     *
     *
     * Parameters for creating / deleting related entities
     * ---------------------------------------------------
     *
     * - dataServiceDeleteAssociatedEntityAPI: name of dataservice API to invoke to create & assoc the 'secundary' entity to the primary one
     * (ex: 'addMemberToGroup' n add user to group scenario)
     *
     * - dataServiceDeleteAssociatedEntityAPI: name of dataservice API to invoke to un-associate & delete 'secundary' entity from the primary one
     * (ex: 'removeMemberFromGroup' in remove user from group scenario)
     *
     * - secundaryEntityAddPartial: name of partial to diplay the secundary 'pickup' list on Add operation
     *
     * - secundaryEntityCreatePartial: name of partial to diplay the secundary  entity creation
     */

    module.controller(
        'SecundaryEntityListCtlr', 
        ['$scope', '$stateParams', '$state', '$filter', 'authService', 'appContext', 'dataService', '$modal', 'dialogs',
        function($scope, $stateParams, $state, $filter, authService, appContext, dataService, $modal, dialogs) {

            console.log('inside SecundaryEntityListCtlr controller for: ' + $stateParams.entity + '/' + $stateParams.id + ' to: ' + $stateParams.relatedentity);
            $scope.relatedentity = $stateParams.relatedentity;
            var entity2resource = appContext.get('entity2resource');             
            $scope.relatedentityTypeLabel = entity2resource.getLabel($scope.relatedentity);
            $scope.entityId = $stateParams.id;
            var ctlrConfig = $stateParams.ctlrConfig;

            // get a list controller
            var listctlr = new ListAndCardPagingCtlr();
            listctlr.init.call(listctlr, $scope, $stateParams, $state, $filter, authService, appContext, dataService, dialogs);

            // override the getElemnts() ftn to get only Group members
            listctlr.getElements = function(){
                console.log('inside  redefined SecundaryEntityListCtlr.getElements()');
                console.log("inside  redifined getElements, $scope: " + $scope);
                console.log("inside  redifined getElements, resource: " + $scope.resource);

                var queryParams = {filter: $scope.q};

                if ($scope.orderby) {
                    queryParams.orderby = $scope.orderby;
                    if($scope.orderColumn.dto){
                        queryParams.orderby = $stateParams.relatedentity + '.' + $scope.orderby;
                    }
                    queryParams.orderdir = (!$scope.reverse ? 'ASC' : 'DESC');
                }

                var params = [$stateParams.id, queryParams, $scope.currentPage, $scope.pageSize];
                if (ctlrConfig.dataServiceResource) {
                    params.unshift(ctlrConfig.dataServiceResource);
                }
                dataService[ctlrConfig.dataServiceGetAssociatedEntitiesAPI]              
                .apply(this, params)
                .then(function (result) {
                    $scope.elements = result.data;
                    $scope.totalRecords = result.total;

                    // debug code
                    var i = 0;
                    for( i=0; i<$scope.elements.length; i++){
                        var elt = $scope.elements[i];
                        console.log('--> loaded[' + i + ']' + elt.clName + ': ' + elt.id);                  
                    }
                    // end debug
                    $scope.filterElements($scope.filterText); 
                }, function (error) {
                        dialogs.error("Error", error.data.message, 'lg');
                }); 
            };
            
            //$scope.orderColumn;
            if(ctlrConfig.columns){
                $scope.orderColumn = ctlrConfig.columns[0];
            }

            $scope.setOrder = function (orderby) {
                if (orderby.name === $scope.orderby) {
                    $scope.reverse = !$scope.reverse;
                }
                $scope.orderby = orderby.name;
                $scope.orderColumn = orderby;
                $scope.this.getElements();
                var x  = 1;
            };

            listctlr.getElements();

            // un-associate the current related entity
            $scope.removeElement = function(elt) {
                var dlg = dialogs.confirm('Please Confirm','Do you realy want to delete relationship ' + elt.name +'?');
                dlg.result.then(function(btn){
                    removeElement(elt);
                    var x = 1;
                },function(btn){
                    console.log("entity not deleted");
                });
            };

            function removeElement(elt){

                var params = [$stateParams.id, elt.id];     // standard case
                if (ctlrConfig.unassociateIdAttribute) {
                    // related object id is in a subobject
                    var attrSpec = ctlrConfig.unassociateIdAttribute;
                    var relatedId = elt[attrSpec.o][attrSpec.id]; 
                    params = [$stateParams.id, relatedId];
                }
                if (ctlrConfig.dataServiceResource) {
                    params.unshift(ctlrConfig.dataServiceResource);
                }
                dataService[ctlrConfig.dataServiceUnassociateEntityAPI]
                    .apply(this, params)
                    .then(function (result) {
                        console.log('--> removed[' + elt.name + ': ' + elt.id + ']');
                        $scope.elements = _.without($scope.elements, elt);
                        listctlr.getElements(); // force refresh
                    }, function (error) {
                        dialogs.error("Error", error.data.message, 'lg');
                    });
            }

            // delete the current related entity
            $scope.deleteElement = function(elt) {

                $scope.toBeDeletedEltLabel = (elt.name ? elt.name : elt.id);
                if ($scope.secundaryEntity) {
                    // api call has form: api($parentId, id)
                    var params = [$stateParams.id, elt.id];     
                    dataService[ctlrConfig.dataServiceDeleteAssociatedEntityAPI]
                        .apply(this, params)
                        .then(function (result) {
                            var label = $scope.toBeDeletedEltLabel;
                            console.log('--> deleted[' + label + ']'); 

                            // update state
                            $scope.elements = _.without($scope.elements, elt);
                            listctlr.getElements(); // force refresh
                            //$stateParams.id = elt.id; // doesn't work
                            dialogs.notify("Success", "'" + label + "' successfully deleted.");
                        },function (error) {
                            var label = $scope.toBeDeletedEltLabel;
                            dialogs.error("Error", "Error while deleting: '" + label + "': " + error.data.message, 'lg');
                        });
                }
                else {
                    // pseudo top level entity, api call has standard form: deleteElement(id)
                    var entity2resource = appContext.get('entity2resource');             
                    var resource = entity2resource.getResource($scope.relatedentity);
                    dataService
                        .deleteElement(resource, elt.id)
                        .then(function (result) { 
                            var elt = result;
                            var label = $scope.toBeDeletedEltLabel;
                            console.log('--> deleted[' + label + ']'); 

                            // update state
                            $scope.elements = _.without($scope.elements, elt);
                            listctlr.getElements(); // force refresh
                            //$stateParams.id = elt.id; // doesn't work
                            dialogs.notify("Success", "'" + label + "' successfully deleted.");
                        },function (error) {
                            var label = $scope.toBeDeletedEltLabel;
                            dialogs.error("Error", "Error while deleting: '" + label + "': " + error.data.message, 'lg');
                        });
                }  
                var x = 1;
            };

            /*
            * showAddModal() invoked when user click on Add related entity button
            */
            $scope.showAddModal = function() {

                $scope.opts = {
                    backdrop: true,
                    backdropClick: true,
                    dialogFade: false,
                    keyboard: true,
                    templateUrl : ctlrConfig.secundaryEntityAddPartial,
                    controller : ModalInstanceCtrl,
                    size : 'lg',
                    resolve: {} // empty storage
                };

                var subctlrConfig = {
                    title: 'Add ' + $scope.relatedentityTypeLabel  + '(s) to ' +  $scope.entityTypeLabel,
                    entity: $scope.entity,
                    relatedentity: $scope.relatedentity,
                    entityTypeLabel: $scope.entityTypeLabel,
                    relatedentityTypeLabel: $scope.relatedentityTypeLabel,
                    columns: ctlrConfig.columns,
                    relatedEntityIcon: ctlrConfig.relatedEntityIcon,
                    dataServiceResource: ctlrConfig.dataServiceResource,
                    dataServiceGetUnassociatedEntitiesAPI: ctlrConfig.dataServiceGetUnassociatedEntitiesAPI,
                    dataServiceAssociateEntityAPI: ctlrConfig.dataServiceAssociateEntityAPI
                };
                $scope.opts.resolve.item = function() {
                    return angular.copy(subctlrConfig); // pass params to Dialog
                };

                var modalInstance = $modal.open($scope.opts);

                modalInstance.result.then(function(){
                    //on ok button press, refresh list
                    listctlr.getElements();
                },function(){
                    //on cancel button press
                    console.log("Add Modal Closed");
                });
            };


            /*
            * showElementDetails() displays Element details according to selected row
            * overloads base showElementDetails() to deal with non top level entities 
            */
            $scope.showElementDetails = function(elt){

                var parentEntity = $scope.entity,
                    parentEntityId  = $stateParams.id; // = $scope.entityId

                $scope.selectedElement = elt;

                // get entity from element class name.
                var actualentity = elt.clName.toLowerCase();
                if ($scope.secundaryEntity) {
                    $state.go( 'authenticated.createchildentity', {
                        entity: $scope.relatedentity,  // sometimes we need to use the actualentity => make it configurable
                        id: elt.id, 
                        parentEntity: $scope.entity, 
                        parentEntityId: $stateParams.id
                    });
                }
                else {
                    actualentity = elt.clName.toLowerCase();
                    console.log('--> showElementDetails(' + actualentity + ':' + elt + ')' + ' => ' + elt.name + ',' + elt.id);
                    var to = 'authenticated.entity';
                    $state.go(to, {entity: actualentity, id: elt.id});
                }
                var x =1;
            }; 

            /*
            * showCreateModal() invoked when user click on Add 'New' related entity button
            */
            $scope.showCreateModal = function() {

                // new approach. redirect to entity page with extra params
//                $state.go( 'entity', {entity: $scope.relatedentity, id: 'new', parentEntity: $scope.entity, parentEntityId: $stateParams.id});

                $state.go( 'authenticated.createchildentity', {entity: $scope.relatedentity, id: 'new', parentEntity: $scope.entity, parentEntityId: $stateParams.id});
                return;

                /*
                $scope.opts = {
                    backdrop: true,
                    backdropClick: true,
                    dialogFade: false,
                    keyboard: true,
                    templateUrl : ctlrConfig.secundaryEntityCreatePartial,
                    controller : ModalInstanceCtrl,
                    size : 'lg',
                    resolve: {} // empty storage
                };

                var subctlrConfig = {
                    title: 'Add ' + $scope.relatedentityTypeLabel  + '(s) to ' +  $scope.entityTypeLabel,
                    entity: $scope.entity,
                    relatedentity: $scope.relatedentity,
                    entityTypeLabel: $scope.entityTypeLabel,
                    relatedentityTypeLabel: $scope.relatedentityTypeLabel,
                    dataServiceResource: ctlrConfig.dataServiceResource,
                    dataServiceCreateAssociatedEntityAPI: ctlrConfig.dataServiceCreateAssociatedEntityAPI
                };
                $scope.opts.resolve.item = function() {
                    return angular.copy(subctlrConfig); // pass params to Dialog
                };

                var modalInstance = $modal.open($scope.opts);

                modalInstance.result.then(function(){
                    //on ok button press, refresh list
                    listctlr.getElements();  
                },function(){
                    //on cancel button press
                    console.log("Create Modal Closed");
                });*/
            };
        }
    ]);

    /* 
     * Controller allowing to display a list of entities that can be associated to a an other 'primary' entity
     *
     * When invoked, this controler expects in the $scope.item object, the following attributes
     *
     * entity: the name of the 'primary' entity (ex 'groupaccount' in add user to group scenario)
     * relatedentity: the name of the 'secundary' entity (ex 'useraccount' in add user to group scenario)
     * entityTypeLabel: user friendly label for the 'primary' entity
     * relatedentityTypeLabel: user friendly label for the 'secundary' entity
     *
     * - dataServiceResource: the data service resource parameter for some APIs that need it like account role mngt  apis
     * that are generic and apply to UserAccounst as well GroupAccounts 
     * !! Leave unspecified for general cases !!
     *
     * - dataServiceGetUnassociatedEntitiesAPI: name of dataservice API to invoke to get the list of unassociated 'secundary' entities 
     * (ex: 'getUnassociatedGroupMembers' n add user to group scenario)
     *
     * - dataServiceAssociateEntityAPI: name of dataservice API to invoke to associate the 'secundary' entity to the primary one
     * (ex: 'addMemberToGroup' n add user to group scenario)
     */

    module.controller(
        'AddRelatedEntityCtrl', ['$scope', '$stateParams', '$state', '$filter', 'authService', 'appContext', 'dataService', 'dialogs', 'alertsManager',
            function($scope, $stateParams, $state, $filter, authService, appContext, dataService, dialogs, alertsManager) {

                $scope.alerts = [];

                //overide entity and relatedentity state params

                // init controler from params provided in $scope.item
                var ctlrConfig = $scope.item;
                /*
                $state.entity = ctlrConfig.entity;
                $state.relatedentity = ctlrConfig.relatedentity;
                $scope.entityTypeLabel = ctlrConfig.entityTypeLabel;
                $scope.relatedentityTypeLabel = ctlrConfig.relatedentityTypeLabel;
                */
                $state.entity = ctlrConfig.relatedentity;
                $state.relatedentity = ctlrConfig.entity;
                $scope.entityTypeLabel = ctlrConfig.relatedentityTypeLabel;
                $scope.relatedentityTypeLabel = ctlrConfig.entityTypeLabel;


                var listandcardpagingctlr = new ListAndCardPagingCtlr();
                listandcardpagingctlr.init.call(listandcardpagingctlr, $scope, $stateParams, $state, $filter, authService, appContext, dataService, dialogs);
                listandcardpagingctlr.getElements = function(){

                    var queryParams = {filter: $scope.q};
                    if ($scope.orderby) {
                        queryParams.orderby = $scope.orderby;
                        queryParams.orderdir = (!$scope.reverse ? 'ASC' : 'DESC');
                    }

                    var params = [$stateParams.id, queryParams, $scope.currentPage, $scope.pageSize];
                    if (ctlrConfig.dataServiceResource) {
                        params.unshift(ctlrConfig.dataServiceResource);
                    }
                    dataService[ctlrConfig.dataServiceGetUnassociatedEntitiesAPI]              
                    .apply(this, params)
                    .then(function (result) {
                        $scope.elements = result.data;
                        $scope.totalRecords = result.total;

                        // debug code
                        var i = 0;
                        for( i=0; i<$scope.elements.length; i++){
                            var elt = $scope.elements[i];
                            console.log('--> loaded[' + i + ']' + elt.clName + ': ' + elt.id);
                        }
                        // end debug
                        $scope.filterElements($scope.filterText);
                    }, function (error) {
                        dialogs.error("Error", error.data.message, 'lg');
                    });
                };

                listandcardpagingctlr.getElements();

                $scope.associateEntity = function(element) {
                    associateEntity(element);
                };

                $scope.closeAlert = function(index) {
                    $scope.alerts.splice(index, 1);
                };

                function associateEntity(elt){
                    $scope.elt = elt;

                    var params = [$stateParams.id, elt.id];
                    if (ctlrConfig.dataServiceResource) {
                        params.unshift(ctlrConfig.dataServiceResource);
                    }
                    dataService[ctlrConfig.dataServiceAssociateEntityAPI]              
                    .apply(this, params)
                    .then(function (result) {

                        console.log('--> added[' + elt.name + ': ' + elt.id + ']');                           
//                          $scope.elements = _.without($scope.elements, elt);
                        var label = (elt.name !== undefined ? elt.name : 'elt with id: ' + elt.id);
                            alertsManager.addAlert("'" + label + "' successfully added to " +
                                $scope.relatedentityTypeLabel, "success");
                        listandcardpagingctlr.getElements();
                    }, function (error) {

                        $scope.error = error;
                        var label = (elt.name !== undefined ? elt.name : 'elt with id: ' + elt.id);
                        dialogs.error("Error", "Error while adding: '" + label + "' to " +
                             $scope.relatedentityTypeLabel + ": " + error.data.message, 'lg');
                    });
                }

            }
        ]
    );


    /* 
     * Controller allowing to create a new 'sub' entity that will be asscoiated to a parent entity
     *
     * When invoked, this controler expects in the $scope.item object, the following attributes
     *
     * entity: the name of the 'primary' entity (ex 'groupaccount' in add user to group scenario)
     * relatedentity: the name of the 'secundary' entity (ex 'useraccount' in add user to group scenario)
     * entityTypeLabel: user friendly label for the 'primary' entity
     * relatedentityTypeLabel: user friendly label for the 'secundary' entity
     *
     * - dataServiceResource: the data service resource parameter for some APIs that need it like account role mngt  apis
     * that are generic and apply to UserAccounst as well GroupAccounts 
     * !! Leave unspecified for general cases !!
     *
     * - dataServiceGetUnassociatedEntitiesAPI: name of dataservice API to invoke to get the list of unassociated 'secundary' entities 
     * (ex: 'getUnassociatedGroupMembers' n add user to group scenario)
     *
     * - dataServiceAssociateEntityAPI: name of dataservice API to invoke to associate the 'secundary' entity to the primary one
     * (ex: 'addMemberToGroup' n add user to group scenario)
     */
/*
    module.controller(
        'CreateRelatedEntityCtrl',
         ['$scope', '$stateParams', '$state', '$filter', 'authService', 'appContext', 'dataService',
            function($scope, $stateParams, $state, $filter, authService, appContext, dataService) {

                $("#alert").hide();
                $scope.alerts = [];

                console.log( "in CreateRelatedEntityCtrl");

                // $scope. entity=team, id=teamid


                //overide entity and relatedentity state params

                // init controler from params provided in $scope.item
                var ctlrConfig = $scope.item;


            }
        ]
    );
*/
// see controlerhelpers.   must be declared in this file if we want it to have access to some variables
// but create a lot of code duplication
// TODO improve this ...
    var ModalInstanceCtrl = function($scope, $modalInstance, $modal, item) {
        $scope.item = item;
        $scope.ok = function () {
            $modalInstance.close();
        };
        $scope.cancel = function () {
            $modalInstance.dismiss('cancel');
        };
    };
//

    /* 
     * Controller allowing to display a list of entities for selection of one or several items
     * (NOTE: ONLY ONE item SELECTED SUPPORTED TODAY, but could be easily extended to optionally
     * support single or multiple selections)
     *
     * When invoked, this controler expects in the $scope.item object, the following attributes
     *
     * entity: the name of the 'primary' entity (ex 'team' in Team creation scenario)
     * relatedentity: the name of the 'secundary' entity (ex 'site' in Team creation scenario)
     * entityTypeLabel: user friendly label for the 'primary' entity
     * relatedentityTypeLabel: user friendly label for the 'secundary' entity
     *
     * - dataServiceResource: the data service resource parameter for some APIs that need it like account role mngt  apis
     * that are generic and apply to UserAccounst as well GroupAccounts 
     * !! Leave unspecified for general cases !!
     *
     * - dataServiceGetEntitiesAPI: name of dataservice API to invoke to get the list of  'secundary' entities 
     * (ex: 'getElements' in a Team creation that needs to select a parent Site )
     *
     */

    module.controller(
        'SelectRelatedEntityCtrl', ['$scope', '$stateParams', '$state', '$filter', 'authService', 'appContext', 'dataService', 'dialogs',
            function($scope, $stateParams, $state, $filter, authService, appContext, dataService, dialogs) {

                console.log("SelectRelatedEntityCtrl: " + getScopeHierachy($scope));
                console.log("SelectRelatedEntityCtrl state params " + $stateParams.parentEntity + "." + $stateParams.entity);
                console.log("SelectRelatedEntityCtrl scope params " + $scope.entity + "->" + $scope.relatedentity);
                console.log("SelectRelatedEntityCtrl scope order " + $scope.orderby);

                // init controler from params provided in $scope.item
                var ctlrConfig = $scope.item;
                if (ctlrConfig) {
                    // copy controllr config parmas into scope
                    _.extend($scope, ctlrConfig); 
                    // switch entity and related entity params
                    $stateParams.entity = ctlrConfig.relatedentity;
                    $stateParams.relatedentity = ctlrConfig.entity;
                    $stateParams.ctlrConfig = ctlrConfig;
                    $scope.entityTypeLabel = ctlrConfig.relatedentityTypeLabel;
                    $scope.relatedentityTypeLabel = ctlrConfig.entityTypeLabel;
                }


                var listandcardpagingctlr = new ListAndCardPagingCtlr();
                listandcardpagingctlr.init.call(listandcardpagingctlr, $scope, $stateParams, $state, $filter, authService, appContext, dataService, dialogs);
                listandcardpagingctlr.getElements = function(){

                    console.log("SelectRelatedEntityCtrl.getElements()");
                    console.log("SelectRelatedEntityCtrl state params " + "." + $stateParams.entity);
                    console.log("SelectRelatedEntityCtrl scope params " + $scope.entity + "->" + $scope.relatedentity);
                    console.log("SelectRelatedEntityCtrl scope order " + $scope.orderby);

                    var queryParams = {filter: $scope.q};
                    if ($scope.orderby) {
                        queryParams.orderby = $scope.orderby;
                        queryParams.orderdir = (!$scope.reverse ? 'ASC' : 'DESC');
                    }

                    var params = [queryParams, $scope.currentPage, $scope.pageSize];
                    if (ctlrConfig.dataServiceResource) {
                        params.unshift(ctlrConfig.dataServiceResource);
                    }
                    dataService[ctlrConfig.dataServiceGetEntitiesAPI]              
                    .apply(this, params)
                    .then(function (result) {
                        $scope.elements = result.data;
                        $scope.totalRecords = result.total;
                        $scope.filterElements($scope.filterText);
                    }, function (error) {
                            dialogs.error("Error", error.data.message, 'lg');
                    });
                };

                listandcardpagingctlr.getElements();

                /* 
                 * default element select action: just set selected entity in parent ctlr 
                 * (actually, 2 levels up, which should be the modal dialog box ctlr)
                */
                $scope.selectEntity = function(elt) {
                    console.log('--> selected[' + elt.name + ': ' + elt.id + ']'); 
                    // put selected item in modal controler
                    $scope.$parent.$parent.selectedEntity = elt;

                    if ($scope.lastSelected) {
                        $scope.lastSelected.selected = '';
                    }
                    this.selected = 'selected';
                    $scope.lastSelected = this;
                };

            }
        ]
    );


}());


;

(function () {

    var module =  angular.module('emlogis.browser');

    /* 
     * Controller for a single ShiftStructure entity
     * Extends / Overrides the Generic 'EntityCtlr' to buid the create and update Dtos as per ShiftStructure API definition
     */
    module.controller(
        'CdavailabilityCtlr',
        ['$scope', '$stateParams', '$state', 'stateManager', '$filter', 'authService', 'appContext', 'dataService', '$modal', 'dialogs', 'alertsManager',
            function($scope, $stateParams, $state, stateManager, $filter, authService, appContext, dataService, $modal, dialogs, alertsManager) {

            console.log("CdavailabilityCtlr: " + _.values($stateParams));
            console.log("CdavailabilityCtlr: " + getScopeHierachy($scope));


            if ($stateParams.parentEntityId) {
                // we have a parentEntittyId specified in state. 
                $scope.parentEntityId = $stateParams.parentEntityId;
            }

            $scope.availabilityTypes = [
                {label:'Availability',   id:0, val: 'Avail'},
                {label:'Unavailability', id:1, val: 'UnAvail'}
            ];

            /*
            * override postGetElement() to set some $scope attributes used by partial 
            */
            $scope.postGetElement = function() {
                var elt = $scope.elt;
                if (elt) {
                    var idx; 
                    idx = ($scope.elt.availabilityType  == 'Avail' ? 0 : 1);
                    $scope.availabilityType = $scope.availabilityTypes[idx];
                }
            };

            EditOrCreateEntityCtlr($scope, $stateParams, $state, stateManager, $filter, authService, appContext, dataService, dialogs, alertsManager);


            // create a default Availability record if create mode (and overrides defaults created by EditOrCreateEntityCtlr)
            if (!$scope.elt || !$scope.elt.id) {
                $scope.readonly = 'readonly';
                $scope.elt = {
                    clName: 'CDAvailabilityTimeFrame'//,
                };
                $scope.availabilityType = $scope.availabilityTypes[0];
            }


            // Override the method to build the create and update Dtos

            /*
            * getCreateDto() method to be overriden in some controllers that need
            * to process the data to be sent to the backend on object create  
            */
            $scope.getCreateDto = function() {
                console.log('in CdavailabilityCtlr.getCreateDto()');
                // build the create Dto
                var elt = $scope.elt;                
                var dto = _.pick(elt, 'clName', 'absenceTypeId', 'reason',  'startTime', 'durationInMinutes', 'startDate');
                dto.employeeId = $scope.parentEntityId;
                // set availabilityType by its value (control sets a $scope.availabilityTypes entry)
                dto.availabilityType = $scope.availabilityType.val;
                return dto;
            };

            /*
            * getUpdateDto() method to be overriden in some controllers that need
            * to process the data to be sent to the backend on object update  
            */
            $scope.getUpdateDto = function() {
                console.log('in CdavailabilityCtlr.getUpdateDto()');
                return $scope.getCreateDto(); // dto is same as for create
            };

            $scope.vetoCreate = function() {
                if ($scope.availabilityType.val == 'Avail' || $scope.elt.absenceTypeId) {
                    return false;
                }
                // Absence requested but absence type unspecified. need to select one
                $scope.opts = {
                    scope: $scope,  // use current scope for modal so as to get results more conveniently
                    backdrop: true,
                    backdropClick: true,
                    dialogFade: false,
                    keyboard: true,
                    templateUrl : 'modules/browser/partials/entity_selectentity.tpl.html',
                    controller : ModalInstanceCtrl,
                    size : 'lg',
                    resolve: {} // empty storage
                };

                var subctlrConfig = {
                    title: 'Please select an Absence Type',
                    entity: $scope.entity,
                    relatedentity: 'absencetype',
                    entityTypeLabel: '$scope.entityTypeLabel',
                    relatedentityTypeLabel: 'Absence Type',
                    dataServiceResource: 'absencetypes',
                    dataServiceGetEntitiesAPI: 'getElements',
                    columns: [ // grid columns
                        {
                            name: 'name',
                            label: 'Name',
                            sortable: true
                        }, {
                            name: 'description',
                            label: 'Description',
                            sortable: true
                        }, {
                            name: 'id',
                            label: 'Id',
                            sortable: true
                        }
                    ],
                    relatedEntityIcon: './img/glyphicons/png/unknown.png'
                };
                $scope.opts.resolve.item = function() {
                    return angular.copy(subctlrConfig); // pass params to Dialog
                };

                var modalInstance = $modal.open($scope.opts);

                modalInstance.result.then(function(selectedEntity){
                    //on ok button press
                    $scope.elt.absenceTypeId = selectedEntity.id;
                    // how to trigger saveOrCreate() on base editCtlr ?
                    console.log("Fire create...");
                    $scope.saveOrCreate();
                },function(){
                    //on cancel button press
                    delete $scope.elt.absenceTypeId;  // clear selection on cancel
                    console.log("Modal Closed");
                });
                return true;
            };
    }]);
            
}());





;

(function () {

    var module =  angular.module('emlogis.browser');

    /* 
     * Controller for a single ShiftStructure entity
     * Extends / Overrides the Generic 'EntityCtlr' to buid the create and update Dtos as per ShiftStructure API definition
     */
    module.controller(
        'CiavailabilityCtlr',
        ['$scope', '$stateParams', '$state', 'stateManager', '$filter', 'authService', 'appContext', 'dataService', '$modal', 'dialogs', 'alertsManager',
            function($scope, $stateParams, $state, stateManager, $filter, authService, appContext, dataService, $modal, dialogs, alertsManager) {

            console.log("CiavailabilityCtlr: " + _.values($stateParams));
            console.log("CiavailabilityCtlr: " + getScopeHierachy($scope));


            if ($stateParams.parentEntityId) {
                // we have a parentEntittyId specified in state. 
                $scope.parentEntityId = $stateParams.parentEntityId;
            }

            $scope.daysOfTheWeek = [
                {label:'Sunday',     id:0, val:'Sunday'},
                {label:'Monday',     id:1, val:'Monday'},
                {label:'Tuesday',    id:2, val:'Tuesday'},
                {label:'Wednesday',  id:3, val:'Wednesday'},
                {label:'Thursday',   id:4, val:'Thursday'},
                {label:'Friday',     id:5, val:'Sunday'},
                {label:'Saturday',   id:6, val:'Saturday'}    
            ];

            /*
            * override postGetElement() to set some $scope attributes used by partial 
            */
            $scope.postGetElement = function() {
                var elt = $scope.elt;
                if (elt) {
                    var idx; 
                    idx = $scope.elt.dayOfTheWeek;
                    $scope.dayOfTheWeek = $scope.daysOfTheWeek[idx];
                }
            };

            EditOrCreateEntityCtlr($scope, $stateParams, $state, stateManager, $filter, authService, appContext, dataService, dialogs, alertsManager);


            // create a default Availability record if create mode (and overrides defaults created by EditOrCreateEntityCtlr)
            if (!$scope.elt || !$scope.elt.id) {
                $scope.readonly = 'readonly';
                $scope.elt = {
                    clName: 'CIAvailabilityTimeFrame'//,
                    //availabilityType: $scope.availabilityTypes[0].val,
                    //dayOfTheWeek: $scope.daysOfTheWeek[1].val
                };
                $scope.availabilityType = $scope.availabilityTypes[0];
                $scope.dayOfTheWeek = $scope.daysOfTheWeek[1];
            }

            /*
            * Go to parent entity page 
            * workaround for                 
            * ui-sref="entity({entity: 'employee', id: parentEntityId })
            * which for some reason gets was getting null for parentEntityId 
            * However tgis seems to be working now.
            */
            /*
            $scope.backToParent = function() {
                $state.go('entity', {entity: $stateParams.parentEntity, id: $stateParams.parentEntityId},  {reload: false});
            }; 
            */

            // Override the method to build the create and update Dtos

            /*
            * getCreateDto() method to be overriden in some controllers that need
            * to process the data to be sent to the backend on object create  
            */
            $scope.getCreateDto = function() {
                console.log('in CiavailabilityCtlr.getCreateDto()');
                // build the create Dto
                var elt = $scope.elt;                
                var dto = _.pick(elt, 'clName', 'absenceTypeId', 'reason',  'startTime', 'durationInMinutes', 'startDate', 'endDate');
                dto.employeeId = $scope.parentEntityId;
                dto.availabilityType = 'UnAvail';
                dto.dayOfTheWeek = $scope.dayOfTheWeek.id;
                return dto;
            };

            /*
            * getUpdateDto() method to be overriden in some controllers that need
            * to process the data to be sent to the backend on object update  
            */
            $scope.getUpdateDto = function() {
                console.log('in CiavailabilityCtlr.getUpdateDto()');
                return $scope.getCreateDto(); // dto is same as for create
            };

            $scope.vetoCreate = function() {
                if ($scope.availabilityType.val == 'Avail' || $scope.elt.absenceTypeId) {
                    return false;
                }
                // Absence requested but absence type unspecified. need to select one
                $scope.opts = {
                    scope: $scope,  // use current scope for modal so as to get results more conveniently
                    backdrop: true,
                    backdropClick: true,
                    dialogFade: false,
                    keyboard: true,
                    templateUrl : 'modules/browser/partials/entity_selectentity.tpl.html',
                    controller : ModalInstanceCtrl,
                    size : 'lg',
                    resolve: {} // empty storage
                };

                var subctlrConfig = {
                    title: 'Please select an Absence Type',
                    entity: $scope.entity,
                    relatedentity: 'absencetype',
                    entityTypeLabel: '$scope.entityTypeLabel',
                    relatedentityTypeLabel: 'Absence Type',
                    dataServiceResource: 'absencetypes',
                    dataServiceGetEntitiesAPI: 'getElements',
                    columns: [ // grid columns
                        {
                            name: 'name',
                            label: 'Name',
                            sortable: true
                        }, {
                            name: 'description',
                            label: 'Description',
                            sortable: true
                        }, {
                            name: 'id',
                            label: 'Id',
                            sortable: true
                        }
                    ],
                    relatedEntityIcon: './img/glyphicons/png/unknown.png'
                };
                $scope.opts.resolve.item = function() {
                    return angular.copy(subctlrConfig); // pass params to Dialog
                };

                var modalInstance = $modal.open($scope.opts);

                modalInstance.result.then(function(selectedEntity){
                    //on ok button press
                    $scope.elt.absenceTypeId = selectedEntity.id;
                    // how to trigger saveOrCreate() on base editCtlr ?
                    console.log("Fire create...");
                    $scope.saveOrCreate();
                },function(){
                    //on cancel button press
                    delete $scope.elt.absenceTypeId;  // clear selection on cancel
                    console.log("Modal Closed");
                });
                return true;
            };
    }]);
            
}());





;
// TODO: allow the selection of more than one ContractLine on creation


(function () {

    var module =  angular.module('emlogis.browser');

    /* 
     * Controller for a single ContractLine entity
     * Extends / Overrides the Generic 'EntityCtlr' to buid the create and update Dtos as per ContractLine API definition
     */
    module.controller(
        'ContractlineCtlr',
        ['$scope', '$stateParams', '$state', 'stateManager', '$filter', 'authService', 'appContext', 'dataService', '$modal',
        function($scope, $stateParams, $state, stateManager, $filter, authService, appContext, dataService, $modal) {

            console.log("ContractLineCtlr: " + getScopeHierachy($scope));

            var editCtlr = EditOrCreateEntityCtlr($scope, $stateParams, $state, stateManager, $filter, authService, appContext, dataService);

            if ($stateParams.parentEntityId) {
                // we have a parentEntittyId specified in state. 
                $scope.parentEntityId = $stateParams.parentEntityId;
            }

            $scope.ctlr = 'ContractLineCtrl';

            if (!$scope.elt || !$scope.elt.id) {
                // create a default contract line
                $scope.readonly = 'readonly';
                $scope.elt = {
                    contractLineType: 'HOURS_PER_WEEK',
                    minimumEnabled: true,
                    minimumValue: 40,
                    minimumWeight: 100,
                    maximumEnabled: true,
                    maximumValue: 40,
                    maximumWeight: 100
                };
            }

            $scope.type2class = {
                HOURS_PER_DAY: 'IntMinMaxCL',
                HOURS_PER_WEEK: 'IntMinMaxCL',
                HOURS_BETWEEN_SHIFTS: 'IntMinMaxCL',
                HOURS_PER_WEEK_PRIME_SKILL: 'IntMinMaxCL',
                DAYS_PER_WEEK: 'IntMinMaxCL',
                CONSECUTIVE_WORKING_DAYS: 'IntMinMaxCL',
                COMPLETE_WEEKENDS: 'BooleanCL'
            };

            // Override the method to build the create and update Dtos

            /*
            * getCreateDto() method to be overriden in some controllers that need
            * to process the data to be sent to the backend on object create  
            */
            $scope.getCreateDto = function() {
                console.log('in ContractLineCtlr.getCreateDto()');
                // build the create Dto
                var elt = $scope.elt;
                elt.contractId = $scope.parentEntityId;

                var dto;
                switch ($scope.type2class[elt.contractLineType]) {
                case 'IntMinMaxCL':
                    dto = _.pick(elt, 'clName',  'minimumEnabled', 'minimumValue', 'minimumWeight', 'maximumEnabled', 'maximumValue', 'maximumWeight');
                    break;
                case 'BooleanContractLine':
                    dto = _.pick(elt,  'enabled', 'weight');
                    break;
                default:
                    // invalid type
                    return null;
                }

                if (elt.clName) {
                    dto.clName = elt.clName;
                }
                dto.contractLineType = elt.contractLineType;
                dto.contractId = elt.contractId;
                dto.name = dto.contractLineType;

/*
                public final static String CATEGORY = "category";
    public final static String NAME = "name";
    public final static String CONTRACTLINETYPESTRING = "contractLineType";
    public final static String CONTRACTID = "contractId";
    public final static String MINIMUMENABLED = "minimumEnabled";
    public final static String MINIMUMVALUE = "minimumValue";
    public final static String MINIMUMWEIGHT = "minimumWeight";
    public final static String MAXIMUMENABLED = "maximumEnabled";
    public final static String MAXIMUMVALUE = "maximumValue";
    public final static String MAXIMUMWEIGHT = "maximumWeight";
    
    private String category;
    private String name;
    private String contractLineType;
    private String contractId;
    private boolean minimumEnabled;
    private int minimumValue;
    private int minimumWeight;
    private boolean maximumEnabled;
    private int maximumValue;
    private int maximumWeight;
*/
                return dto;
            };


            /*
            * getUpdateDto() method to be overriden in some controllers that need
            * to process the data to be sent to the backend on object update  
            */
            $scope.getUpdateDto = function() {
                console.log('in ContractLineCtlr.getUpdateDto()');
                var elt = $scope.elt;
                // TODO !! PENDING IMPLEMENTATION
                //var dto =  _.pick( elt, 'clName', 'name', 'description', 'type');
                //return dto;
            };

            $scope.vetoCreate = function() {
                return false;
            };


    }]);
            
}());




;
(function () {

    var module =  angular.module('emlogis.browser');

    /* 
     * Controller for a single Team entity
     * Extends / Overrides the Generic 'EntityCtlr' to buid the create and update Dtos as per Team API definition
     */
    module.controller(
        'EmployeeCtlr',
        ['$scope', '$stateParams', '$state', 'stateManager', '$filter', 'authService', 'appContext', 'dataService', 'dialogs', 'alertsManager',
        function($scope, $stateParams, $state, stateManager, $filter, authService, appContext, dataService, dialogs, alertsManager) {

            EditOrCreateEntityCtlr($scope, $stateParams, $state, stateManager, $filter, authService, appContext, dataService, dialogs, alertsManager);

            // Override the method to build the create and update Dtos

            /*
            * getCreateDto() method to be overriden in some controllers that need
            * to process the data to be sent to the backend on object create  
            */
            $scope.getCreateDto = function() {
                console.log('in EmployeeCtlr.getCreateDto()');
                // build the create Dto
                var elt = $scope.elt;

                 // base create dto
                var dto = _.pick( elt, 'clName', 'firstName', 'lastName', 'employeeIdentifier');
                // add update dto if relevant
                if (elt.middleName || elt.notificationEmail || elt.notificationSmsNumber) {
                    dto.updateDto =  _.pick( elt, 'middleName', 'notificationEmail', 'notificationSmsNumber');
                } 
                // add userAccount dto if relevant
                if (elt.login || elt.email) {
                    dto.userAccountDto =  _.pick( elt, 'login', 'email');
                    dto.userAccountDto.name = dto.userAccountDto.login;     // use login as name 
                } 
                return dto;
            };

            /*
            * getUpdateDto() method to be overriden in some controllers that need
            * to process the data to be sent to the backend on object update  
            */
            $scope.getUpdateDto = function() {
                console.log('in EmployeeCtlr.getUpdateDto()');
                // TODO build the update Dto
                var elt = $scope.elt;

                 // base create dto
                var dto = _.pick( elt, 'clName',
                    'firstName', 'lastName', 'employeeIdentifier', 
                    'middleName', 'notificationEmail', 'notificationSmsNumber',
                    'isEngineSchedulable', 'isManuallySchedulable'
                );
                return dto;
            };

            /*
            * showEmployeeAccount() goes to Account page for account associated to Employee  
            */
            $scope.showEmployeeAccount = function() {

                dataService.getEmployeeAccount($scope.elt.id)
                .then(function (result) {
                    var accountId = result.id;
                    $state.go('entity', {entity: 'useraccount', id: accountId});
                },function (error) {
                    dialogs.error("Error", error.data.message, 'lg');
                }); 
            };

            /*
            * showEmployeeContract() goes to default account page 
            */
            $scope.showEmployeeContract = function() {

                dataService.getEmployeeContracts($scope.elt.id, {}, 1, 10)
                .then(function (result) {
                    // we assume only one contract comes back in this version
                    var contractId = result.data[0].id;
                    $state.go('entity', {entity: 'employeecontract', id: contractId});
                },function (error) {
                    dialogs.error("Error", error.data.message, 'lg');
                }); 
            };

        }
    ]);

            
}());


;
// TODO: allow the selection of more than one Schedule on creation


(function () {

    var module =  angular.module('emlogis.browser');

    /* 
     * Controller for a single Schedule entity
     * Extends / Overrides the Generic 'EntityCtlr' to buid the create and update Dtos as per Schedule API definition
     */
    // Image Base folder path

    // Image Base folder path
    var imagePath = "modules/browser/assets/images/";
    
    module.controller(
        'ScheduleCtlr',
        ['$scope', '$stateParams', '$state', 'stateManager', '$filter', 'authService', 'sseService', 'wsService', 'appContext',
        'dataService', '$modal', 'dialogs', 'alertsManager',
        function($scope, $stateParams, $state, stateManager, $filter, authService, sseService, wsService, appContext,
                 dataService, $modal, dialogs, alertsManager) {

            console.log("ScheduleCtlr: " + getScopeHierachy($scope));

            $scope.maxComputationTimes = [
                {label:'Infinite',   id:0, val: -1},
                {label:'1  min',     id:1, val: 60},
                {label:'5  min',     id:2, val: 300},
                {label:'10 min',     id:3, val: 600},
                {label:'15 min',     id:4, val: 900},
                {label:'30 min',     id:5, val: 1800}
            ];

            $scope.maximumUnimprovedSecondsSpents = [
                {label:'Default (100)',   id:0, val: 0},
                {label:'10',     id:0, val: 10},
                {label:'20',     id:1, val: 20},
                {label:'50',     id:2, val: 50},
                {label:'100',    id:3, val: 100},
                {label:'200',    id:4, val: 200}
            ];


            $scope.scheduleTypes = [
                {label:'Pattern based',   id:0, val: 'ShiftPatternBased'},
                {label:'Shift Structure based',     id:1, val: 'ShiftStructureBased'}
            ];

            /*
            * override postGetElement() to compute durations 
            */
            $scope.postGetElement = function() {
                var elt = $scope.elt;
                if (elt) {
                    _.extend($scope, {
                        totalExeTime: duration(elt.executionStartDate, elt.executionEndDate),
                        requestBuildTime: duration(elt.executionStartDate, elt.requestSentDate),
                        requestAckTime: duration(elt.requestSentDate, elt.executionAckDate),
                        engineProcessingTime: duration(elt.executionAckDate, elt.responseReceivedDate),
                        responseProcessingTime: duration(elt.responseReceivedDate, elt.executionEndDate)
                    });

                    var maxComputationTime = elt.maxComputationTime;
                    var options = $scope.maxComputationTimes;
                    var i;
                    for (i=0 ; i < options.length; i++) {
                        if (options[i].val == maxComputationTime) {
                            $scope.maxComputationTime = options[i];
                            break;
                        }
                    }

                    var maximumUnimprovedSecondsSpent = elt.maximumUnimprovedSecondsSpent;
                    options = $scope.maximumUnimprovedSecondsSpents;
                    for (i=0 ; i < options.length; i++) {
                        if (options[i].val == maximumUnimprovedSecondsSpent) {
                            $scope.maximumUnimprovedSecondsSpent = options[i];
                            break;
                        }
                    }

                    var scheduleType = elt.scheduleType;
                    options = $scope.scheduleTypes;
                    for (i=0 ; i < options.length; i++) {
                        if (options[i].val == scheduleType) {
                            $scope.scheduleType = options[i];
                            break;
                        }
                    }
                }
            };

            EditOrCreateEntityCtlr($scope, $stateParams, $state, stateManager, $filter, authService, appContext, dataService, dialogs, alertsManager);

            $scope.ctlr = 'ScheduleCtrl';
            // set some default values if create mode
            if (!$scope.elt || !$scope.elt.id) {
                $scope.maxComputationTime = $scope.maxComputationTimes[0];
                $scope.maximumUnimprovedSecondsSpent = $scope.maximumUnimprovedSecondsSpents[3];
                $scope.scheduleType = $scope.scheduleTypes[0];
                $scope.preservePreAssignedShifts = false;
                $scope.preservePostAssignedShifts = false;
           }


            // register an event consumer to diplay the progression of the schedule execution
            // ideally we should unregister this listener when leaving this page.
            // possibly need to register a stateLeve event to do that

            //"<SysNotifications><jcso><><Schedule><Progress><bf2f0a13-b1c1-4db6-bd39-2dd351e39dd6>"
            // Key format: <topic><tenantId><accountId><entityClass><eventType><entityId>

            // TODO REMOVE
            /*
            sseService.registerConsumer({
                id: 'scheduleCtlrProgressHandler',
                selector: function (key) {
                    if ($scope.elt && $scope.elt.id) {
                        var keyselector = '<SysNotifications><.*><><Schedule><Progress><' + $scope.elt.id + '>';
                        var match = key.match(keyselector);
                        console.log( "Schedule Progress event: " + key + " with: " + keyselector + " -> " + match); 
                        return key.match(keyselector);
                    }
                    return false;                    // for now, subscribe to all events
                },
                callback: function (key, serverEvent) {
                    $scope.$apply(function () {     // use $scope.$apply to refresh the view
                        $scope.progress = serverEvent.progress;
                        $scope.hardScore = (serverEvent.hardScore == -999999 ? '' : serverEvent.hardScore);
                        $scope.mediumScore = (serverEvent.mediumScore == -999999 ? '' : serverEvent.mediumScore);
                        $scope.softScore = (serverEvent.softScore == -999999 ? '' : serverEvent.softScore);
                        $scope.progressInfo  = serverEvent.msg;
                    });
                },
                scope: $scope,
                params: []
            });
            sseService.registerConsumer({
                id: 'scheduleCtlrUpdateHandler',
                selector: function (key) {
                    if ($scope.elt && $scope.elt.id) {
                        var keyselector = '<ObjLifecycle><.*><><Schedule><Update><' + $scope.elt.id + '>';
                        var match = key.match(keyselector);
                        console.log( "Schedule Update event: " + key + " with: " + keyselector + " -> " + match); 
                        return key.match(keyselector);
                    }
                    return false;                    // for now, subscribe to all events
                },
                callback: function (key, serverEvent) {
                    $scope.$apply(function () {     // use $scope.$apply to refresh the view
                        var updatedElt = serverEvent;
                        // convert date attributes from longs to Js dates (done by dataservice layer normally)
                        var dateAttributes = ['created', 'updated', 'startDate', 'endDate',
                            'executionStartDate', 'requestSentDate', 'executionAckDate', 'responseReceivedDate', 'executionEndDate'
                        ];                      
                        for (var i=0 ; i < dateAttributes.length; i++) {
                            var dateAttr = dateAttributes[i];
                            if (updatedElt[dateAttr] > 0) {
                                updatedElt[dateAttr] = new Date(updatedElt[dateAttr]);
                            }
                            else {
                                updatedElt[dateAttr] =  '-';   
                            }
                        }
                        // then update current elt in scope
                        $scope.elt = updatedElt;
                    });
                },
                scope: $scope,
                params: []
            });
            */
            // register consumers on WebSocket events
            wsService.registerConsumer({
                id: 'scheduleCtlrProgressHandler',
                selector: function (key) {
                    if ($scope.elt && $scope.elt.id) {
                        var keyselector = '<SysNotifications><.*><><Schedule><Progress><' + $scope.elt.id + '>';
                        var match = key.match(keyselector);
                        console.log( "Schedule Progress event: " + key + " with: " + keyselector + " -> " + match); 
                        return key.match(keyselector);
                    }
                    return false;                    // for now, subscribe to all events
                },
                callback: function (key, serverEvent) {
                    $scope.$apply(function () {     // use $scope.$apply to refresh the view
                        $scope.progress = serverEvent.progress;
                        $scope.hardScore = (serverEvent.hardScore == -999999 ? '' : serverEvent.hardScore);
                        $scope.mediumScore = (serverEvent.mediumScore == -999999 ? '' : serverEvent.mediumScore);
                        $scope.softScore = (serverEvent.softScore == -999999 ? '' : serverEvent.softScore);
                        $scope.progressInfo  = serverEvent.msg;
                    });
                },
                scope: $scope,
                params: []
            });
            wsService.registerConsumer({
                id: 'scheduleCtlrUpdateHandler',
                selector: function (key) {
                    if ($scope.elt && $scope.elt.id) {
                        var keyselector = '<ObjLifecycle><.*><><Schedule><Update><' + $scope.elt.id + '>';
                        var match = key.match(keyselector);
                        console.log( "Schedule Update event: " + key + " with: " + keyselector + " -> " + match); 
                        return key.match(keyselector);
                    }
                    return false;                    // for now, subscribe to all events
                },
                callback: function (key, serverEvent) {
                    $scope.$apply(function () {     // use $scope.$apply to refresh the view
                        var updatedElt = serverEvent;
                        // convert date attributes from longs to Js dates (done by dataservice layer normally)
                        var dateAttributes = ['created', 'updated', 'startDate', 'endDate',
                            'executionStartDate', 'requestSentDate', 'executionAckDate', 'responseReceivedDate', 'executionEndDate'
                        ];                      
                        for (var i=0 ; i < dateAttributes.length; i++) {
                            var dateAttr = dateAttributes[i];
                            if (updatedElt[dateAttr] > 0) {
                                updatedElt[dateAttr] = new Date(updatedElt[dateAttr]);
                            }
                            else {
                                updatedElt[dateAttr] =  '-';   
                            }
                        }
                        // then update current elt in scope
                        $scope.elt = updatedElt;
                    });
                },
                scope: $scope,
                params: []
            });

            // Override the method to build the create and update Dtos

            /*
            * getCreateDto() method to be overriden in some controllers that need
            * to process the data to be sent to the backend on object create  
            */
            $scope.getCreateDto = function() {
                console.log('in ScheduleCtlr.getCreateDto()');
                // build the create Dto
                var elt = $scope.elt;

                // base create dto
                //var dto = _.pick( elt, 'startDate', 'teamIds');
                var startDate = Date.parse(elt.startDate); 
                var dto = {
                    clName: elt.clName,
                    startDate: startDate, 
                    scheduleLengthInDays: 7,
                    scheduleType: 'ShiftStructureBased',
                    teamIds:[elt.teamIds]
                };

                // add update dto 
                dto.updateDto =  _.pick(elt, 'name', 'description');
                dto.updateDto.status = 'Simulation';
                dto.updateDto.maxComputationTime = $scope.maxComputationTime.val; 
                dto.updateDto.maximumUnimprovedSecondsSpent = $scope.maximumUnimprovedSecondsSpent.val;
                dto.updateDto.scheduleType = $scope.scheduleType.val; 
                dto.updateDto.preservePreAssignedShifts = $scope.preservePreAssignedShifts;
                dto.updateDto.preservePostAssignedShifts = $scope.preservePostAssignedShifts;
                return dto;
            };


            /*
            * getUpdateDto() method to be overriden in some controllers that need
            * to process the data to be sent to the backend on object update  
            */
            $scope.getUpdateDto = function() {
                console.log('in ScheduleCtlr.getUpdateDto()');
                var elt = $scope.elt;
                var dto =  _.pick( elt, 'clName', 'name', 'description', 'ruleWeightMultipliers', 'preservePreAssignedShifts', 'preservePostAssignedShifts');
//                var startDate = Date.parse(elt.startDate);
//                dto.startDate = startDate;
                dto.maxComputationTime = $scope.maxComputationTime.val;
                dto.maximumUnimprovedSecondsSpent = $scope.maximumUnimprovedSecondsSpent.val;
                // remove scheduleType as no longer supported by schedule.update API
                delete dto.scheduleType;
                return dto;
            };

            $scope.vetoCreate = function() {
                if ($scope.elt.teamIds) {
                    // sideId is present, one can create the Schedule
                    return false;
                }
                // needs to select a Site

                $scope.opts = {
                    scope: $scope,  // use current scope for modal so as to get results more conveniently
                    backdrop: true,
                    backdropClick: true,
                    dialogFade: false,
                    keyboard: true,
                    templateUrl : 'modules/browser/partials/entity_selectentity.tpl.html',
                    controller : ModalInstanceCtrl,
                    size : 'lg',
                    resolve: {} // empty storage
                };

                var subctlrConfig = {
                    title: 'Please select a Team',
                    entity: $scope.entity,
                    relatedentity: 'team',
                    entityTypeLabel: '$scope.entityTypeLabel',
                    relatedentityTypeLabel: 'Team',
                    dataServiceResource: 'teams',
                    dataServiceGetEntitiesAPI: 'getElements',
                    columns:  [ // grid columns
                        {name: 'name', label: 'Name', sortable: true},
                        {name: 'description', label: 'Description', sortable: true},
                        {name: 'id', label: 'Id',sortable: true}
                    ],
                    relatedEntityIcon: imagePath + 'glyphicons/png/team.png'
                };

                $scope.opts.resolve.item = function() {
                    return angular.copy(subctlrConfig); // pass params to Dialog
                };

                var modalInstance = $modal.open($scope.opts);

                modalInstance.result.then(function(selectedEntity){
                    //on ok button press
                    $scope.elt.teamIds = selectedEntity.id;
                    // how to trigger saveOrCreate() on base editCtlr ?
                    console.log("Fire create...");
                    $scope.saveOrCreate();
                },function(){
                    //on cancel button press
                    $scope.elt.teamIds = false;  // clear selection on cancel
                    console.log("Modal Closed");
                });
                return true;
            };


            /*
            * Execute a Schedule 
            */
            $scope.execute = function() {
                console.log('in ScheduleCtlr.execute()');
                var elt = $scope.elt;
                $scope.progress = 0;
                $scope.hardScore = '';
                $scope.mediumScore = '';
                $scope.softScore = '';
                $scope.progressInfo = '';

                var dto = {
                    maxComputationTime: elt.maxComputationTime,
                    maximumUnimprovedSecondsSpent: elt.maximumUnimprovedSecondsSpent
                };
                dataService
                .executeSchedule(elt.id, dto)
                .then(function (elt) {
                    console.log('--> executed[' + elt.name + ': ' + elt.id + ']'); 
                    $scope.elt = elt;  // update view with updated schedule
                }, function (error) {
                    dialogs.error("Error", error.data.message, 'lg');
                });               
            };

            /*
            * Carry Schedule over to next period
            */
            $scope.carryOverNextOrPrev = function(next) {
                console.log('in ScheduleCtlr.carryOverNext()');
                var elt = $scope.elt;
                var newDate = elt.startDate.getTime();
                var delta = elt.scheduleLengthInDays * 24 * 3600 * 1000;
                if (next) {
                    newDate += delta;
                }
                else {
                    newDate -= delta;
                }
                console.log("Duplicating schedule for: " + new Date(newDate));
                dataService
                .duplicateSchedule(elt.id, {startDate: newDate, mode:0})
                .then(function (elt) {
                    $scope.elt = elt;   // updated view with 
                                        // TODO update Shifts tab
                }, function (error) {
                    dialogs.error("Error", error.data.message, 'lg');
                });               
            };

            /*
            * Promote Schedule 
            */
            $scope.promote = function() {
                console.log('in ScheduleCtlr.promote()');
                var elt = $scope.elt;

                dataService
                .promoteSchedule(elt.id)
                .then(function (elt) {
                    $scope.elt = elt;   // updated view with 
                                        // TODO update Shifts tab
                }, function (error) {
                    dialogs.error("Error", error.data.message, 'lg');
                });               
            };

            /*
            * Generate Shifts 
            */
            $scope.generateShifts = function() {
                console.log('in ScheduleCtlr.generateShifts()');
                var elt = $scope.elt;

                dataService
                .generateShifts(elt.id)
                .then(function (elt) {
                    $scope.elt = elt;   // updated view with 
                                        // TODO update Shifts tab
                }, function (error) {
                    dialogs.error("Error", error.data.message, 'lg');
                });               
            };

            /*
            * Reset Schedule State 
            */
            $scope.resetState = function() {
                console.log('in ScheduleCtlr.resetState()');
                var elt = $scope.elt;

                dataService
                .resetScheduleState(elt.id)
                .then(function (elt) {
                    $scope.elt = elt;   // updated view with 
                                        // TODO update Shifts tab
                }, function (error) {
                    dialogs.error("Error", error.data.message, 'lg');
                });               
            };

            /*
            * Refresh a Schedule 
            */
            $scope.refresh = function() {
                $scope.getElement();
                $state.go('authenticated.entity.relatedentity', {relatedentity: 'shift'},  {reload: true});
            }; 

            /*
            * Abort a Schedule 
            */
            $scope.abort = function() {
                console.log('in ScheduleCtlr.abort()');
                var elt = $scope.elt;

                dataService
                .abortSchedule(elt.id)
                .then(function (elt) {
                    console.log('--> abort sent[' + elt.name + ': ' + elt.id + ']'); 
                    $scope.elt = elt;  // update view with update schedule
                }, function (error) {
                    dialogs.error("Error", error.data.message, 'lg');
                });               
            };

            /*
             * Edit Constraints modal dialog
             */
            $scope.editConstraints = function () {
                initRules();

                $scope.opts = {
                    scope: $scope,  // use current scope for modal so as to get results more conveniently
                    backdrop: true,
                    backdropClick: true,
                    dialogFade: false,
                    keyboard: true,
                    templateUrl : 'modules/browser/partials/schedule_constraints.html',
                    controller : SimpleModalInstanceCtrl,
                    resolve: {
                        newSchedule: function () {
                            return $scope.rules;
                        }
                    }
                };

                var modalInstance = $modal.open($scope.opts);
                modalInstance.result.then(function(){
                    //on ok button press
                    $scope.elt.ruleWeightMultipliers = $scope.rules;

                },function(){
                    //on cancel button press
                    console.log("Modal Closed");
                });
                return true;
            };

            function initRules() {
                $scope.rules = angular.copy($scope.elt.ruleWeightMultipliers);
                $scope.rulesIsEnable = angular.copy($scope.elt.ruleWeightMultipliers);
                for(var i in $scope.rulesIsEnable){
                    if($scope.rulesIsEnable[i]>0){
                        $scope.rulesIsEnable[i] = true;
                    } else {
                        $scope.rulesIsEnable[i] = false;
                    }
                }
                $scope.rulesBackup = {};
            }

            $scope.disableEnableRule = function (rule) {
                if($scope.rulesIsEnable[rule]){
                    $scope.rules[rule] = $scope.rulesBackup[rule] || 1;
                } else {
                    $scope.rulesBackup[rule] = $scope.rules[rule];
                    $scope.rules[rule] = 0;
                }
            };

            $scope.resetAllRules = function () {
                initRules();
            };

            $scope.resetRule = function (rule) {
                $scope.rules[rule] = $scope.elt.ruleWeightMultipliers[rule];
                $scope.rulesIsEnable[rule] = $scope.elt.ruleWeightMultipliers[rule];
                if($scope.rulesIsEnable[rule]>0){
                    $scope.rulesIsEnable[rule] = true;
                } else {
                    $scope.rulesIsEnable[rule] = false;
                }
            };

            /*
             * Duplicate schedule modal dialog
             */
            $scope.duplicate = function () {

                var newDate = angular.copy($scope.elt.startDate);
                newDate.setDate($scope.elt.startDate.getDate() + $scope.elt.scheduleLengthInDays);
                $scope.newSchedule = {
                    startDate: newDate,
                    mode: $scope.assignModes[0]
                };
                $scope.opts = {
                    scope: $scope,  // use current scope for modal so as to get results more conveniently
                    backdrop: true,
                    backdropClick: true,
                    dialogFade: false,
                    keyboard: true,
                    templateUrl : 'modules/browser/partials/schedule_duplicate.html',
                    controller : SimpleModalInstanceCtrl,
                    resolve: {
                        newSchedule: function () {
                            return $scope.newSchedule;
                        }
                    }
                };

                var modalInstance = $modal.open($scope.opts);

                modalInstance.result.then(function(){
                    //on ok button press
                    var dto = $scope.newSchedule;
                    console.log("Duplicating schedule for: " + dto.startDate);
                    dto.mode = dto.mode.val;
                    dto.startDate.setHours(0,0,0);
                    dto.startDate = dto.startDate.getTime();
                    dataService.duplicateSchedule($stateParams.id, dto)
                        .then(function (data) {
                            $state.go('authenticated.entity', {entity: "schedule", id: data.id});
                        }, function (error) {
                            dialogs.error("Error", error.data.message, 'lg');
                        });
                },function(){
                    //on cancel button press
                    console.log("Modal Closed");
                });
                return true;
            };

            $scope.assignModes = [
                {label: 'NOASSIGNMENT', val: 'NOASSIGNMENT'},
                {label:'PREASSIGNMENT', val: 'PREASSIGNMENT'},
                {label:'ALLASSIGNMENT', val: 'ALLASSIGNMENT'}
            ];

            $scope.newSchedule = {};

            $scope.executeWithMaxDuration = function () {
                $scope.opts = {
                    scope: $scope,  // use current scope for modal so as to get results more conveniently
                    backdrop: true,
                    backdropClick: true,
                    dialogFade: false,
                    keyboard: true,
                    templateUrl : 'modules/browser/partials/schedule_execute.html',
                    controller : SimpleModalInstanceCtrl,
                    resolve: {
                        executeConfig: function () {
                            return $scope.executeConfig;
                        }
                    }
                };

                var modalInstance = $modal.open($scope.opts);

                modalInstance.result.then(function(){
                    //on ok button press
                    var config = $scope.executeConfig;
                    config.maxComputationTime = config.maxComputationTime.val;
                    dataService.executeSchedule($stateParams.id, config)
                        .then(function (elt) {
                            console.log('--> executed[' + elt.name + ': ' + elt.id + ']');
                            $scope.elt = elt;  // update view with updated schedule
                        }, function (error) {
                            dialogs.error("Error", error.data.message, 'lg');
                        });
                },function(){
                    //on cancel button press
                    console.log("Modal Closed");
                });
                return true;
            };

            $scope.executeConfig = {
                maxComputationTime: $scope.maxComputationTimes[0]
            };

    }]);

    var SimpleModalInstanceCtrl = function ($scope, $modalInstance, $modal) {
        $scope.ok = function () {
            $modalInstance.close();
        };
        $scope.cancel = function () {
            $modalInstance.dismiss('cancel');
        };
    };
            
}());




;
(function () {
    var module = angular.module('emlogis.browser');

    /**
     * Controller for schedule options
     */
    module.controller('ScheduleOptionsCtrl', ['$scope', '$stateParams', 'dataService', 'dialogs', 'alertsManager', '$rootScope',
        function ($scope, $stateParams, dataService, dialogs, alertsManager, $rootScope) {

            console.log("inside ScheduleOptionsCtrl");

            $scope.options = [

//                {name: 'Override MAX CONSECUTIVE DAYS', value:'MAX_CONSECUTIVE_DAYS_OVERRIDE'},
                {name: 'Override PTO', value: 'PTO_OVERRIDE'},
//                {name: 'Override ALL DAY UNAVAILABLE', value:'ALL_DAY_UNAVAILABLE_OVERRIDE'},
//                {name: 'Override TIME WINDOW UNAVAILABLE', value:'TIME_WINDOW_UNAVAILABLE_OVERRIDE'},
                {name: 'Override WEEKDAY ROTATION', value: 'WEEKDAY_ROTATION_OVERRIDE'},
                {name: 'Override COUPLED WEEKEND', value: 'COUPLED_WEEKEND_OVERRIDE'},
                {name: 'Override DAYS OFF AFTER', value: 'DAYS_OFF_AFTER_OVERRIDE'},
                {name: 'Override DAYS OFF BEFORE', value: 'DAYS_OFF_BEFORE_OVERRIDE'},
                {name: 'Override MIN HOURS BETWEEN DAYS', value: 'MIN_HOURS_BETWEEN_DAYS_OVERRIDE'},
                {name: 'Override MIN HOURS DAY', value: 'MIN_HOURS_DAY_OVERRIDE'},
                {name: 'Override MAX HOURS DAY', value: 'MAX_HOURS_DAY_OVERRIDE'},
                {name: 'Override MAX HOURS WEEK', value: 'MAX_HOURS_WEEK_OVERRIDE'},
                {name: 'Override MAX DAYS WEEK', value: 'MAX_DAYS_WEEK_OVERRIDE'},
                {name: 'Override MIN HOURS WEEK', value: 'MIN_HOURS_WEEK_OVERRIDE'},
//                {name: 'EMPLOYEE UNAVAILABLE', value:'EMPLOYEE_UNAVAILABLE'},
//                {name: 'Override AVOID', value:'AVOID_OVERTIME'},
//                {name: 'TEAM FLOAT ON', value:'TEAM_FLOAT_ON'}
            ];

            $scope.employees = [];
            $scope.scheduleoptions = {};

            dataService.getScheduleEmployees($stateParams.id, {}, 1, -1)
                .then(function (employees) {
                    createEmptyModel(employees);
                    dataService.getScheduleOptions($stateParams.id)
                        .then(function (options) {
                            setModel(options);
                        });
                });

            function createEmptyModel(employees) {
                $scope.employees = employees.data;

                angular.forEach($scope.employees, function (emp) {
                    emp.options = {};
                    angular.forEach($scope.options, function (opt) {
                        emp.options[opt.value] = false;
                    });
                });
            }

            function setModel(options) {
                $scope.scheduleoptions = options;
                var opts = options.overrideOptions;
                for (var i in opts) {
                    var j;
                    switch (opts[i].scope) {
                        case "None":
                            break;
                        case "All":
                            for (j = 0; j < $scope.employees.length; j++) {
                                $scope.employees[j].options[i] = true;
                            }
                            break;
                        case "Select":
                            for (j = 0; j < $scope.employees.length; j++) {
                                if (_.contains(opts[i].employeeIds, $scope.employees[j].id)) {
                                    $scope.employees[j].options[i] = true;
                                }

                            }
                            break;
                    }
                }
            }

            $scope.change = function (emp, opt) {

                var option = $scope.scheduleoptions.overrideOptions[opt.value];
                var ids = option.employeeIds;
                if (emp.options[opt.value]) {
                    ids.push(
                        emp.id
                    );
                } else {
                    if (option.scope == "All") {
                        for (var j = 0; j < $scope.employees.length; j++) {
                            ids.push(
                                $scope.employees[j].id
                            );
                        }
                    }
                    var index = ids.indexOf(emp.id);
                    ids.splice(index, 1);

                }

                switch (ids.length) {
                    case 0:
                        option.scope = "None";
                        break;
                    case $scope.employees.length:
                        option.scope = "All";
                        ids.length = 0;
                        break;
                    default :
                        option.scope = "Select";
                        break;
                }

            };

            $scope.clear = function (opt) {
                var option = $scope.scheduleoptions.overrideOptions[opt.value];
                var ids = option.employeeIds;
                option.scope = "None";
                ids.length = 0;
                for (var j = 0; j < $scope.employees.length; j++) {
                    $scope.employees[j].options[opt.value] = false;
                }


            };

            $scope.all = function (opt) {
                var option = $scope.scheduleoptions.overrideOptions[opt.value];
                var ids = option.employeeIds;
                option.scope = "All";
                ids.length = 0;
                for (var j = 0; j < $scope.employees.length; j++) {
                    $scope.employees[j].options[opt.value] = true;
                }
            };

            $scope.saveOptions = function () {
                dataService.updateScheduleOptions($stateParams.id, $scope.scheduleoptions)
                    .then(function (result) {
                        alertsManager.addAlert("'" + $stateParams.id + "' successfully updated.", 'success');
                    }, function (error) {
                        dialogs.error("Error", error.data.message, 'lg');
                    });
            };

        }
    ]);


}());


;
(function () {
    var module = angular.module('emlogis.browser');

    /**
     * Controller for schedule options
     */
    module.controller('ScheduleReportCtrl', ['$scope', '$stateParams', 'dataService', 'dialogs', 'alertsManager', '$rootScope',
        function ($scope, $stateParams, dataService, dialogs, alertsManager, $rootScope) {

            console.log("inside ScheduleReportCtrl");

            $scope.elt = angular.element('form[name="form1"]').scope().elt;

            dataService.getScheduleReport($stateParams.id)
                .then(function (responce) {
                    $scope.report = responce;
                    $scope.report.completionReport = angular.fromJson(responce.completionReport);
                });


        }
    ]);


}());


;
(function () {
    var module = angular.module('emlogis.browser');

    module.directive('shiftTimeline', function () {
        return {
            restrict: 'A',
            link: function postLink(scope, elem, attrs) {

                scope.timelineWidth = attrs.width;
                scope.maxHours = 48;

                scope.$on('event:showLightbox', function (event, args) {

                    scope.initShiftEditForm();
                    init();
                });
                scope.$on('event:updateShift', function (event, args) {
                    init();
                });

                function init() {
                    elem.resizable({handles: 'w,e', containment: "parent", grid: [scope.step, 1], minWidth : 1});
                }

                elem.on('resizestop', function (evt, ui) {
                    scope.$apply(function () {
                        scope.$eval(attrs.firstpos + '=' + ui.position.left);
                        scope.$eval(attrs.endpos + '=' + (ui.size.width + 2));
                    });
                });
            }
        };
    });

    /**
     * Controller for Shift edit
     */
    module.controller('ShiftEditCtlr', ['$scope', '$stateParams', 'dataService', 'dialogs', '$rootScope', 'alertsManager',
        function ($scope, $stateParams, dataService, dialogs, $rootScope, alertsManager) {

            console.log("inside ShiftEditCtlr");

            $scope.close = function () {
                $rootScope.currentShift = $scope.currentShift;
                $scope.close_form();
            };

            $scope.initShiftEditForm = function () {

                $scope.hoursBeforeAfter = 4;
                $scope.currentShift = $rootScope.currentShift;

                $scope.openShift = '';
                if ($scope.currentShift.employeeId === null) {
                    $scope.openShift = 'openShift';
                }

                $scope.startDate = new Date($scope.currentShift.startDateTime);
                $scope.endDate = new Date($scope.currentShift.endDateTime);

                $scope.startPtoDate = new Date($scope.currentShift.startDateTime);
                $scope.endPtoDate = new Date($scope.currentShift.startDateTime);

                $scope.newShiftModel = {
                    start: 0,
                    width: 0,
                    position: ''
                };

                $scope.initTimeline();

                $scope.dropfill = 'drop';
                $scope.changeToPto = false;

                $scope.hasNewShift = function () {
                    if ($scope.endPtoDate.getTime() > $scope.startPtoDate.getTime()) {
                        return true;
                    } else
                        return false;
                };

                $scope.getAbsenceTypes = function () {
                    dataService.getElement('teams', $scope.currentShift.teamId + '/site', {}) //getting site by teamId
                        .then(function (site) {
                            getAbsenceTypes(site);
                        }, function (error) {
                            console.log("Error while getting site for '" + $scope.currentShift.employeeName + "': " + error.data.message);
                        });
                };

                function getAbsenceTypes(site) {
                    dataService.getAbsenceTypes(site.id)
                        .then(function (result) {
                            var absenceTypes = [];
                            var ticked = true;
                            for (var i in result.data) {
                                if (i > 0) {
                                    ticked = false;
                                }
                                absenceTypes.push(
                                    {id: result.data[i].id, name: result.data[i].name, ticked: ticked}
                                );
                            }
                            $scope.absenceTypes = absenceTypes;
                        });
                }

                $scope.getAbsenceTypes();
                $scope.selectAbsenceTypes = [];
            };

            $scope.initTimeline = function () {

                var timelineWidth = $scope.timelineWidth;

                var startDateLine = new Date($scope.currentShift.startDateTime);
                startDateLine.setHours(startDateLine.getHours() - $scope.hoursBeforeAfter, 0, 0, 0);
                startDateLine.setHours(startDateLine.getHours() + startDateLine.getHours()%2, 0, 0, 0);
                var endDateLine = new Date($scope.currentShift.endDateTime);
                endDateLine.setHours(endDateLine.getHours() + $scope.hoursBeforeAfter, 0, 0, 0);

                $scope.hoursN = (endDateLine.getTime() - startDateLine.getTime()) / 1000 / 60 / 60;

                var koef1 = 1;
                if ($scope.hoursN > 12) {
                    koef1 = Math.ceil($scope.hoursN / 12);
                    switch (koef1){
                        case 5:
                            koef1 = 6;
                            break;
                        case 7:
                            koef1 = 8;
                            break;
                        default :
                            if(koef1 > 8 && koef1 <= 12){
                                koef1 = 12;
                            } if(koef1 > 12){
                            koef1 = 24;
                        }
                    }
                    //koef1 = Math.pow(2, Math.floor($scope.hoursN / 12));
                }
                $scope.hours = [];
                for (var i = 0; i < $scope.hoursN / koef1; i++) {
                    var temp = new Date(startDateLine);
                    temp.setHours(temp.getHours() + i * koef1);
                    $scope.hours[i] = temp;
                }

                var minStep = 15;
                //var minStep = 15 * Math.pow(2, Math.floor(Math.sqrt(koef1)) - 1);
                //if (minStep > 60) {
                //    minStep = 60;
                //}
                $scope.step = timelineWidth / ($scope.hoursN * (60 / minStep));

                var controldate = new Date($scope.hours[$scope.hours.length - 1]);
                controldate.setHours(controldate.getHours() + koef1);
                if (controldate.getTime() > endDateLine.getTime()) {
                    endDateLine = controldate;
                }

                var lineDiff = endDateLine.getTime() - startDateLine.getTime();
                var startPoint = $scope.startDate.getTime() - startDateLine.getTime();
                var duration = $scope.endDate.getTime() - $scope.startDate.getTime();

                $scope.shiftModel = {
                    start: startPoint * timelineWidth / lineDiff,
                    width: duration * timelineWidth / lineDiff
                };

                $scope.newShiftModel.start = ($scope.startPtoDate.getTime() - startDateLine.getTime()) * timelineWidth / lineDiff;
                $scope.newShiftModel.width = ($scope.endPtoDate.getTime() - $scope.startPtoDate.getTime()) * timelineWidth / lineDiff;


                $scope.limits = {
                    start: ($scope.currentShift.startDateTime - startDateLine.getTime()) * timelineWidth / lineDiff,
                    end: ($scope.currentShift.endDateTime - startDateLine.getTime()) * timelineWidth / lineDiff
                };

                $scope.watchers.shiftModel = $scope.$watch('[shiftModel.start, shiftModel.width]', function (newValue, oldValue) {

                    $scope.startDate = new Date(roundTime((newValue[0] * lineDiff) / timelineWidth + startDateLine.getTime(), minStep));
                    $scope.endDate = new Date(roundTime((newValue[1] * lineDiff) / timelineWidth + $scope.startDate.getTime(), minStep));

                    var newVal = {
                        start: newValue[0],
                        width: newValue[1]
                    };

                    var oldVal = {
                        start: oldValue[0],
                        width: oldValue[1]
                    };

                    var shiftModel = {
                        start: newVal.start,
                        width: newVal.width
                    };
                    var newShiftModel = angular.copy($scope.newShiftModel);

                    angular.forEach(newValue, function(value, key) {
                        if (newValue[key] < 0){
                            newValue[key] = 0;
                        }
                    });

                    if (!$scope.hasNewShift()) {
                        if ((newVal.start > oldVal.start)) {
                            newShiftModel.start = $scope.limits.start;
                            if ((newVal.start - $scope.limits.start) > 0) {
                                newShiftModel.width = newVal.start - $scope.limits.start;
                            } else {
                                newShiftModel.width = 0;
                            }
                            newShiftModel.position = 'before';

                        } else if ((newVal.width < oldVal.width)) {
                            newShiftModel.start = newVal.start + newVal.width;
                            if (($scope.limits.end - newVal.width) > 0) {
                                newShiftModel.width = $scope.limits.end - (newVal.width + newVal.start);
                            } else {
                                newShiftModel.width = 0;
                            }
                            newShiftModel.position = 'after';
                        }

                    } else if (newShiftModel.position == 'before') {
                        if ((newVal.start > oldVal.start)) {
                            newShiftModel.width += (newVal.start - oldVal.start);

                        } else if (newVal.start >= newShiftModel.start) {
                            newShiftModel.width = newShiftModel.width - (oldVal.start - newVal.start);
                        } else {
                            newShiftModel.start = newVal.start;
                            newShiftModel.width = 0;
                        }

                        //} else if (newShiftModel.position == 'after' && $scope.backUpEndDate.getTime() != $scope.endDate.getTime()) {
                    } else if (newShiftModel.position == 'after' && (
                            ( Math.abs((newVal.start + newVal.width) - (oldVal.start + oldVal.width)) > 3 ))) {
                        var widthDiff = newVal.width - oldVal.width;
                        if ((newVal.width < oldVal.width)) {
                            newShiftModel.start += widthDiff;
                            newShiftModel.width -= widthDiff;

                        } else if ((newVal.start + newVal.width) < (newShiftModel.start + newShiftModel.width) &&
                            (newVal.start + newVal.width) > newShiftModel.start) {
                            newShiftModel.start += widthDiff;
                            newShiftModel.width -= widthDiff;
                        } else {
                            newShiftModel.start = newVal.start;
                            newShiftModel.width = 0;
                        }
                    }

                    if($scope.hasNewShift()){
                        if (newShiftModel.position == 'before' && (newVal.width < oldVal.width) &&
                            ((newVal.width + newVal.start) < $scope.limits.end)) {
                            shiftModel.width = Math.abs($scope.limits.end - newVal.start);
                        }

                        if (newShiftModel.position == 'after' && (newVal.width < oldVal.width) &&
                            (shiftModel.start > $scope.limits.start)) {
                            shiftModel.start = $scope.limits.start;
                            shiftModel.width = Math.abs(newShiftModel.start - $scope.limits.start);
                        }

                        if (shiftModel.start + shiftModel.width > newShiftModel.start  && newShiftModel.position == 'after'){
                            var diff = shiftModel.start + shiftModel.width - newShiftModel.start;
                            newShiftModel.width -= diff;
                            newShiftModel.start += diff;
                        }
                    }


                    $scope.shiftModel = angular.copy(shiftModel);
                    $scope.newShiftModel = angular.copy(newShiftModel);

                    $scope.startPtoDate = new Date(roundTime(($scope.newShiftModel.start * lineDiff) / timelineWidth + startDateLine.getTime(), minStep));
                    $scope.endPtoDate = new Date(roundTime(($scope.newShiftModel.width * lineDiff) / timelineWidth + $scope.startPtoDate.getTime(), minStep));

                }, true);

                function roundTime(time, min) {
                    return (Math.round(time / 1000 / 60 / min)) * min * 60 * 1000;
                }
            };

            $scope.zoomIn = function () {
                if ($scope.hoursBeforeAfter > 1) {
                    $scope.hoursBeforeAfter /= 2;

                    var tempStartDateLine = new Date($scope.currentShift.startDateTime);
                    tempStartDateLine.setHours(tempStartDateLine.getHours() - $scope.hoursBeforeAfter, 0, 0, 0);
                    var tempEndDateLine = new Date($scope.currentShift.endDateTime);
                    tempEndDateLine.setHours(tempEndDateLine.getHours() + $scope.hoursBeforeAfter, 0, 0, 0);
                    if (tempStartDateLine.getTime() <= $scope.startDate.getTime() &&
                        tempEndDateLine.getTime() >= $scope.endDate.getTime()) {
                        $scope.updateTimeLine();
                        return true;
                    } else {
                        $scope.hoursBeforeAfter *= 2;
                        return false;
                    }
                }
            };

            $scope.zoomOut = function () {
                $scope.hoursBeforeAfter *= 2;

                var tempStartDateLine = new Date($scope.currentShift.startDateTime);
                tempStartDateLine.setHours(tempStartDateLine.getHours() - $scope.hoursBeforeAfter, 0, 0, 0);
                var tempEndDateLine = new Date($scope.currentShift.endDateTime);
                tempEndDateLine.setHours(tempEndDateLine.getHours() + $scope.hoursBeforeAfter, 0, 0, 0);

                if ( (tempEndDateLine.getTime() - tempStartDateLine.getTime()) < ($scope.maxHours * 60 * 60 * 1000)) {
                    $scope.updateTimeLine();
                    return true;
                } else {
                    $scope.hoursBeforeAfter /= 2;
                    return false;
                }
            };

            $scope.zoomBest = function () {
                var i = true;
                while(i){
                    i = $scope.zoomIn();
                }
            };

            $scope.loadEmployees = function () {
                dataService.getScheduleEmployees($stateParams.id)
                    .then(function (result) {
                        var filteredEmployees = _.uniq(result.data, function (item) {
                            return item.id;
                        });
                        var employees = [];
                        // Filter only name attributes
                        for (var i in filteredEmployees) {
                            employees.push(
                                {
                                    id: filteredEmployees[i].id,
                                    name: filteredEmployees[i].firstName + ' '
                                    + filteredEmployees[i].lastName,
                                    ticked: false
                                }
                            );
                        }
                        // Save the filtered properties into scope variable
                        $scope.employees = employees;
                    });
            };

            $scope.selectEmployee = [];
            $scope.selectEmployeeToAssign = [];
            $scope.loadEmployees();

            $scope.updateCurrentShift = function (newShift) {
                if (newShift) {
                    $scope.currentShift = _.extend($scope.currentShift, newShift);
                }
                $scope.removeWatchers();
                $scope.initShiftEditForm();
                $scope.$broadcast('event:updateShift');
            };

            $scope.updateTimeLine = function () {
                $scope.removeWatchers();
                $scope.$broadcast('event:updateShift');

                $scope.initTimeline();
            };

            $scope.assignShift = function () {
                if ($scope.selectEmployeeToAssign.length > 0) {
                    dataService.assignShift($stateParams.id, $scope.currentShift.mainId, $scope.selectEmployeeToAssign[0].id)
                        .then(function (res) {
                            $scope.updateCurrentShift(res);
                            alertsManager.addAlert('Shift successfully assigned to ' + $scope.selectEmployee[0].name, 'success');
                        }, function (err) {
                            dialogs.error('Error', 'Error while assigning shift: ' + err.data.message, 'lg');
                        });
                }
            };

            $scope.dropShift = function () {
                var dlg = dialogs.confirm('Please Confirm', 'Do you realy want to drop shift from ' + $scope.currentShift.employeeName + '?');
                dlg.result.then(function (btn) {
                    dataService.dropShift($stateParams.id, $scope.currentShift.mainId)
                        .then(function (result) {
                            alertsManager.addAlert('Shift from ' + $scope.currentShift.employeeName + ' successfully dropped.', 'success');
                            $scope.updateCurrentShift(result);
                        }, function (error) {
                            dialogs.error("Error", "Error while dropping shift from '" + $scope.currentShift.employeeName + "': " + error.data.message, 'lg');
                        });
                }, function (btn) {
                    console.log("shift not dropped");
                });
            };

            $scope.deleteShift = function () {
                var dlg = dialogs.confirm('Please Confirm', 'Do you realy want to delete shift from ' + $scope.currentShift.employeeName + '?');
                dlg.result.then(function (btn) {
                    dataService.deleteShift($stateParams.id, $scope.currentShift.mainId)
                        .then(function (result) {
                            $scope.close_form();
                            alertsManager.addAlert('Shift from ' + $scope.currentShift.employeeName + ' successfully deleted.', 'success');
                        }, function (error) {
                            dialogs.error("Error", "Error while deleted shift from '" + $scope.currentShift.employeeName + "': " + error.data.message, 'lg');
                        });
                }, function (btn) {
                    console.log("shift not deleted");
                });
            };

            $scope.saveAndApply = function () {
                console.log($scope.currentShift);

                var dto = _.pick($scope.currentShift, 'endDateTime', 'startDateTime');
                dto.startDateTime = $scope.startDate.getTime();
                dto.endDateTime = $scope.endDate.getTime();

                dataService.updateShift($stateParams.id, $scope.currentShift.mainId, dto)
                    .then(function (result) {

                        alertsManager.addAlert('Shift from ' + $scope.currentShift.employeeName + ' successfully updated.', 'success');

                        if ($scope.dropfill === 'fill' && $scope.hasNewShift()) {
                            createNewShift();
                        }
                        if ($scope.changeToPto && $scope.currentShift.employeeId !== null && $scope.hasNewShift()) {
                            createAvailability();
                        }
                        $scope.updateCurrentShift(result);
                    }, function (error) {
                        dialogs.error("Error", "Error while updating shift from '" + $scope.currentShift.employeeName + "': " + error.data.message, 'lg');
                    });
            };

            function createNewShift() {
                var newDto = _.pick($scope.currentShift, 'teamId', 'skillId', 'skillProficiencyLevel', 'endDateTime', 'startDateTime');
                newDto.startDateTime = $scope.startPtoDate.getTime();
                newDto.endDateTime = $scope.endPtoDate.getTime();
                // create open shift
                dataService.createShift($stateParams.id, newDto)
                    .then(function (result) {
                        if ($scope.selectEmployee.length > 0) {
                            //assign to selected employee
                            dataService.assignShift($stateParams.id, result.id, $scope.selectEmployee[0].id)
                                .then(function (res) {
                                    alertsManager.addAlert('Shift successfully created and assigned to ' + $scope.selectEmployee[0].id, 'success');
                                }, function (err) {
                                    dialogs.error('Error', 'Error while assigning shift: ' + err.data.message, 'lg');
                                });
                        } else { //
                            alertsManager.addAlert('Shift successfully created.', 'success');
                            console.log(result);
                        }

                    }, function (error) {
                        dialogs.error('Error', 'Error while creating shift: ' + error.data.message, 'lg');
                    });
            }

            function createAvailability() {
                var availabilityDto = {};
                availabilityDto.startDate = $scope.startPtoDate.getTime();
                availabilityDto.startTime = (($scope.startPtoDate.getHours() * 60) + $scope.startPtoDate.getMinutes()) * 60 * 1000;
                availabilityDto.durationInMinutes = ($scope.endPtoDate.getTime() - $scope.startPtoDate.getTime()) / 1000 / 60;
                availabilityDto.absenceTypeId = $scope.selectAbsenceTypes[0].id;
                availabilityDto.availabilityType = 'UnAvail';

                dataService.createEmployeeCDAvailability($scope.currentShift.employeeId, availabilityDto)
                    .then(function (result) {
                        alertsManager.addAlert('AvailabilityTimeFrame for ' + $scope.currentShift.employeeName + ' successfully created.', 'success');
                    }, function (error) {
                        dialogs.error("Error", "Error while creating AvailabilityTimeFrame for '" + $scope.currentShift.employeeName + "': " + error.data.message, 'lg');
                    });
            }


        }
    ]);
}());

;
// TODO: allow the selection of more than one ShiftStructure on creation


(function () {

    var module =  angular.module('emlogis.browser');
    var imagePath = "modules/browser/assets/images/";
    /* 
     * Controller for a single ShiftStructure entity
     * Extends / Overrides the Generic 'EntityCtlr' to buid the create and update Dtos as per ShiftStructure API definition
     */
    module.controller(
        'ShiftreqCtlr',
        ['$scope', '$stateParams', '$state', 'stateManager', '$filter', 'authService', 'appContext', 'dataService', '$modal', 'dialogs', 'alertsManager',
            function($scope, $stateParams, $state, stateManager, $filter, authService, appContext, dataService, $modal, dialogs, alertsManager) {

            console.log("ShiftreqCtlr: " + _.values($stateParams));
            console.log("ShiftreqCtlr: " + getScopeHierachy($scope));

            var edirCtrl = EditOrCreateEntityCtlr($scope, $stateParams, $state, stateManager, $filter, authService, appContext, dataService, dialogs, alertsManager);

            $scope.ctlr = 'ShiftreqCtlr';
            if ($stateParams.parentEntityId) {
                // we have a parentEntittyId specified in state. 
                $scope.parentEntityId = $stateParams.parentEntityId;
            }

            // Override the method to build the create and update Dtos

            /*
            * getCreateDto() method to be overriden in some controllers that need
            * to process the data to be sent to the backend on object create  
            */
            $scope.getCreateDto = function() {

                // build the create Dto
                var elt = $scope.elt;
                var dto = _.pick( elt,  'clName', 'startTime', 'durationInMins', 'dayIndex', 'night', 'excess', 'shiftTypeId', 'skillId', 'employeeCount', 'skillProficiencyLevel');
                dto.startTime = Date.parse(elt.startTime);
//                // line below should not be required ...
//                // TODO to be removed when backend API is fixed

                dto.shiftStructureId = $scope.parentEntityId;
                return dto;
            };


            /*
            * getUpdateDto() method to be overriden in some controllers that need
            * to process the data to be sent to the backend on object update  
            */
            $scope.getUpdateDto = function() {

                // TODO !! for now, just return the element as is
                var elt = $scope.elt;
                var dto = _.pick( elt, 'clName','startTime', 'durationInMins', 'dayIndex', 'night', 'excess', 'shiftTypeId', 'skillId', 'employeeCount', 'skillProficiencyLevel');
                 // line below should not be required ...
                // TODO to be removed when backend API is fixed
               dto.shiftStructureId = $scope.parentEntityId;
                return elt;
            };

            $scope.vetoCreate = function() {
                if ($scope.checkConfigComplete()) {
                    return false;
                }
                var subctlrConfig;
                var modalInstance;
                if( !$scope.elt.shiftTypeId) {
                    // needs to select a ShiftType.
                    $scope.opts = {
                        scope: $scope,  // use current scope for modal so as to get results more conveniently
                        backdrop: true,
                        backdropClick: true,
                        dialogFade: false,
                        keyboard: true,
                        templateUrl : 'modules/browser/partials/entity_selectentity.tpl.html',
                        controller : ModalInstanceCtrl,
                        size : 'lg',
                        resolve: {} // empty storage
                    };

                    subctlrConfig = {
                        title: 'Please select a Shift Type',
                        entity: $scope.entity,
                        relatedentity: 'shifttype',
                        entityTypeLabel: '$scope.entityTypeLabel',
                        relatedentityTypeLabel: 'Shift Type',
                        dataServiceResource: 'shifttypes',
                        dataServiceGetEntitiesAPI: 'getElements',
                        columns: [ // grid columns
                            {
                                name: 'name',
                                label: 'Name',
                                sortable: true
                            }, {
                                name: 'description',
                                label: 'Description',
                                sortable: true
                            }, {
                                name: 'id',
                                label: 'Id',
                                sortable: true
                            }
                        ],
                        relatedEntityIcon: imagePath + 'glyphicons/png/unknown.png'

                    };

                    $scope.opts.resolve.item = function() {
                        return angular.copy(subctlrConfig); // pass params to Dialog
                    };

                    modalInstance = $modal.open($scope.opts);

                    modalInstance.result.then(function(selectedEntity){
                        //on ok button press
                        $scope.elt.shiftTypeId = selectedEntity.id;
                        if ($scope.checkConfigComplete()) {
                            console.log("Fire create...");
                            $scope.saveOrCreate();
                        }
                    },function(){
                        //on cancel button press
                        $scope.elt.shiftTypeId = false;  // clear selection on cancel
                        console.log("Modal Closed");
                    });
                }


                if( !$scope.elt.skillId) {
                    // needs to select a Skill.
                    // we display the full list here, but should display only team skills
                    $scope.opts = {
                        scope: $scope,  // use current scope for modal so as to get results more conveniently
                        backdrop: true,
                        backdropClick: true,
                        dialogFade: false,
                        keyboard: true,
                        templateUrl : 'modules/browser/partials/entity_selectentity.tpl.html',
                        controller : ModalInstanceCtrl,
                        size : 'lg',
                        resolve: {} // empty storage
                    };

                    subctlrConfig = {
                        title: 'Please select a Skill (please pick a Skill that belongs to that Team)',
                        entity: $scope.entity,
                        relatedentity: 'skill',
                        entityTypeLabel: '$scope.entityTypeLabel',
                        relatedentityTypeLabel: 'Skill',
                        dataServiceResource: 'skills',
                        dataServiceGetEntitiesAPI: 'getElements',
                        columns: [ // grid columns
                            {
                                name: 'name',
                                label: 'Name',
                                sortable: true
                            }, {
                                name: 'abbreviation',
                                label: 'Abbreviation',
                                sortable: true
                            }, {
                                name: 'id',
                                label: 'Id',
                                sortable: true
                            }
                        ],
                        relatedEntityIcon: imagePath + 'glyphicons/png/skill.png'
                    };

                    $scope.opts.resolve.item = function() {
                        return angular.copy(subctlrConfig); // pass params to Dialog
                    };

                    modalInstance = $modal.open($scope.opts);

                    modalInstance.result.then(function(selectedEntity){
                        //on ok button press
                        $scope.elt.skillId = selectedEntity.id;
                        if ($scope.checkConfigComplete()) {
                            console.log("Fire create...");
                            $scope.saveOrCreate();
                        }
                    },function(){
                        //on cancel button press
                        $scope.elt.skillId = false;  // clear selection on cancel
                        console.log("Modal Closed");
                    });
                }
                return true;
            };

            $scope.checkConfigComplete = function() {
                if ($scope.elt.shiftTypeId && $scope.elt.skillId) {
                    return true;
                }
            };

            $scope.skillProficiencyLevels = [
                {name:'0', id:0},
                {name:'1', id:1},
                {name:'2', id:2},
                {name:'3', id:3},
                {name:'4', id:4},
                {name:'5', id:5}
            ];

    }]);

            
}());

angular.module("template/timepicker/timepicker.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/timepicker/timepicker.html",
            "<table>\n" +
            "	<tbody>\n" +
            "		<tr class=\"text-center\">\n" +
            "			<td><a ng-click=\"incrementHours()\" class=\"btn btn-link\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
            "			<td>&nbsp;</td>\n" +
            "			<td><a ng-click=\"incrementMinutes()\" class=\"btn btn-link\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
            "			<td ng-show=\"showMeridian\"></td>\n" +
            "		</tr>\n" +
            "		<tr>\n" +
            "			<td style=\"width:50px;\" class=\"form-group\">\n" +
            "				<input type=\"text\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"form-control text-center\" ng-mousewheel=\"incrementHours()\" ng-readonly=\"readonlyInput\" >\n" +
            "			</td>\n" +
            "			<td>:</td>\n" +
            "			<td style=\"width:50px;\" class=\"form-group\">\n" +
            "				<input type=\"text\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"form-control text-center\" ng-readonly=\"readonlyInput\" >\n" +
            "			</td>\n" +
            "			<td ng-show=\"showMeridian\"><button type=\"button\" class=\"btn btn-default text-center\" ng-click=\"toggleMeridian()\">{{meridian}}</button></td>\n" +
            "		</tr>\n" +
            "		<tr class=\"text-center\">\n" +
            "			<td><a ng-click=\"decrementHours()\" class=\"btn btn-link\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
            "			<td>&nbsp;</td>\n" +
            "			<td><a ng-click=\"decrementMinutes()\" class=\"btn btn-link\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
            "			<td ng-show=\"showMeridian\"></td>\n" +
            "		</tr>\n" +
            "	</tbody>\n" +
            "</table>\n" +
            "");
}]);



;
(function () {
    var module = angular.module('emlogis.browser');

    var imagePath = "modules/browser/assets/images/";

    /**
     * Controller for Shifts grid
     */
    module.controller('ShiftsCtlr', ['$scope', '$stateParams', 'dataService', 'dialogs', '$rootScope', 'alertsManager',
        function ($scope, $stateParams, dataService, dialogs, $rootScope, alertsManager) {

            console.log("inside ShiftsCtlr");

            var shiftsctrl = new ShiftsBaseCtlr();
            shiftsctrl.init.call(shiftsctrl, $scope, $stateParams, dataService, dialogs, $rootScope, alertsManager);

        }
    ]);

    /**
     * Directive for creating dhtmlx scheduler component
     */
    module.directive('dhxBrowserScheduler', function ($rootScope) {
        return {
            restrict: 'A',
            transclude: true,
            template: '<div class="dhx_cal_navline" ng-transclude></div>' +
            '<div class="dhx_cal_header"></div>' +
            '<div class="dhx_cal_data"></div>' +
            '<div ng-show="displayLoadingIndicator" class="loadingIndicator"></div>',

            link: function ($scope, $element) {
                //default state of the scheduler

                if (!$rootScope.scheduler)
                    $rootScope.scheduler = {};
                $rootScope.scheduler.mode = "timeline";
                var scheduleStartDate = angular.element('form[name="form1"]').scope().elt.startDate;
                $rootScope.scheduler.date = scheduleStartDate || $rootScope.scheduler.date;
                $rootScope.scheduler.firstLoad = true;

                scheduler.config.dblclick_create = false;

                //mode or date
                $scope.$watch(function () {
                    return $rootScope.scheduler.mode + $rootScope.scheduler.date.toString();
                }, function (nv, ov) {
                    var mode = scheduler.getState();
                    if (nv.date != mode.date || nv.mode != mode.mode)
                        scheduler.setCurrentView($rootScope.scheduler.date, $rootScope.scheduler.mode);
                }, true);

                scheduler.dhtmlXTooltip.config.className = 'dhtmlXTooltip tooltip';
                scheduler.dhtmlXTooltip.config.timeout_to_display = 50;
                scheduler.dhtmlXTooltip.config.delta_x = 15;
                scheduler.dhtmlXTooltip.config.delta_y = -20;

                var format = scheduler.date.date_to_str("%Y-%m-%d %H:%i");
                scheduler.templates.tooltip_text = function (start, end, event) {

                    var employee = event.employeeId ? event.text : "not assigned";
                    var template = "<b>Employee:</b> " + employee + "<br/>" +
                        "<b>Start date:</b> " + format(new Date(event.startDateTime)) + "<br/>" +
                        "<b>End date:</b> " + format(new Date(event.endDateTime)) + "<br/>" +
                        "<b>Type:</b> " + event.shiftTypeName + "<br/>" +
                        "<b>Skill:</b> " + event.skillName + "<br/>" +
                        "<b>Team:</b> " + event.teamName;
                    return template;
                };

                //styling for dhtmlx scheduler
                $element.addClass("dhx_cal_container");

                scheduler.createTimelineView({
                    section_autoheight: false,
                    name: "timeline",
                    x_unit: "minute",//measuring unit of the X-Axis.
                    x_date: "%H:%i", //date format of the X-Axis
                    x_step: 60,      //X-Axis step in 'x_unit's
                    x_size: 24,      //X-Axis length specified as the total number of 'x_step's
                    x_start: 0,     //X-Axis offset in 'x_unit's
                    x_length: 24,    //number of 'x_step's that will be scrolled at a time
                    y_unit:         //sections of the view (titles of Y-Axis)
                        scheduler.serverList("sections"),
                    y_property: "sectionId", //mapped data property
                    render: "bar"             //view mode
                });

                scheduler.locale.labels.timeline_tab = "Day";


                if (!scheduler._is_initialized()) {
                    scheduler.attachEvent("onViewChange", function (nm, nd) {
                        if ($rootScope.scheduler.firstLoad || nd.getTime() != $rootScope.scheduler.date.getTime() || nm != $rootScope.scheduler.mode) {
                            $rootScope.getElements();
                            $rootScope.scheduler.firstLoad = false;
                        }
                        $rootScope.scheduler.mode = nm;
                        $rootScope.scheduler.date = nd;
                    });
                }

                scheduler.attachEvent("onBeforeDrag", function () {
                    return false;
                });


                var html = function (id) {
                    return document.getElementById(id);
                }; //just a helper


                scheduler.showLightbox = function (id) {
                    var ev = scheduler.getEvent(id);

                    scheduler.startLightbox(id, html("shift-edit-form"));

                    $rootScope.currentShift = ev;

                    $scope.$broadcast('event:showLightbox');
                    $scope.$apply();

                };

                $scope.close_form = function () {
                    scheduler.endLightbox(false, html("shift-edit-form"));
                    $rootScope.getElements();
                    $scope.removeWatchers();
                };


                $scope.test = function () {
                    console.log($scope.currentShift);
                };


                $scope.watchers = {};

                $scope.removeWatchers = function () {
                    for (var i in $scope.watchers) {
                        $scope.watchers[i]();
                    }
                };

                //init scheduler
                scheduler.init($element[0], $rootScope.scheduler.date, $rootScope.scheduler.mode);


            }
        };
    });

}());

var ShiftsBaseCtlr = function () {   // defining base constructor
    console.log("ShiftsBaseCtlr base constructor");
    return this;
};


ShiftsBaseCtlr.prototype.init = function ($scope, $stateParams, dataService, dialogs, $rootScope, alertsManager) {

    var entityId = $stateParams.id;

    $scope.colors = {
        openshift: '#FF5D5D',
        assignedshift: '#1796b0',
        splittedshift: '#014E5C'
    };

    $scope.openShifts = false;
    $scope.openShiftsFilter = "assignmentType is null";

    $scope.currentFilters = [];
    $scope.mainFilters = [];

    $scope.filters = [];

    $scope.addFilter = function () {
        $scope.filters.push({type: $scope.groups[0], value: ''});
    };

    $scope.removeFilter = function (elt) {
        var index = $scope.filters.indexOf(elt);
        $scope.filters.splice(index, 1);
    };

    $scope.go = function () {
        $scope.mainFilters.length = 0;
        angular.forEach($scope.filters, function (filter) {
            $scope.mainFilters.push(filter.type + "Name" + "='" + filter.value + "'");
        });
        $scope.getElements();
    };
    $scope.addOpenShiftsFilter = function () {
        $scope.currentFilters.push($scope.openShiftsFilter);
    };

    $scope.removeOpenShiftsFilter = function () {
        var index = $scope.currentFilters.indexOf($scope.openShiftsFilter);
        $scope.currentFilters.splice(index, 1);
    };

    $scope.switchOpen = function () {
        $scope.openShifts = !$scope.openShifts;
        if (!$scope.openShifts) {
            $scope.removeOpenShiftsFilter();
            $scope.selected = "";
        } else {
            $scope.addOpenShiftsFilter();
            $scope.selected = "btn-primary";
        }
        $scope.getElements();
    };

    $scope.events = [];

    $scope.groups = ['team', 'employee'];
    $scope.currentGroup = $scope.groups[0];
//            $rootScope.scheduler = { date: new Date() };

    $rootScope.getElements = function () {
        var startDate = scheduler.getState().min_date;
        var endDate = scheduler.getState().max_date;

        if (startDate && endDate) {
            var returnedFields = 'id,employeeId,employeeName,startDateTime,endDateTime,teamId,teamName,skillName';
            dataService.getScheduleShiftsByPeriod(entityId, startDate.getTime(), endDate.getTime(),
                $scope.currentFilters.concat($scope.mainFilters), returnedFields)
                .then(function (result) {
                    var data = result.data;

                    $scope.events = _.map(data, function (elt) {

                        var event = {};
                        event.mainId = elt[0];
                        event.employeeId = elt[1];
                        event.employeeName = elt[2];
                        event.start_date = new Date(elt[3]);
                        event.end_date = new Date(elt[4]);
                        event.startDateTime = elt[3];
                        event.endDateTime = elt[4];
                        event.teamId = elt[5];
                        event.teamName = elt[6];
                        event.skillName = elt[7];

                        event.sectionId = event[$scope.currentGroup + 'Id'] || 'Open';

                        var opened = false;
                        if (!event.employeeId) {
                            opened = true;
                        }
                        event.color = !opened ? $scope.colors.assignedshift : $scope.colors.openshift;
                        event.text = !opened ? event.employeeName : 'Open Shift';

                        return event;
                    });

                    $scope.events = splitShifts($scope.events);

                    $scope.sections = _.uniq(_.map(data, function (elt) {
                        var elem = {
                            employeeId: elt[1],
                            employeeName: elt[2],
                            teamId: elt[5],
                            teamName: elt[6]
                        };
                        return {
                            key: elem[$scope.currentGroup + 'Id'] || 'Open',
                            label: elem[$scope.currentGroup + 'Name'] || 'Open'
                        };

                    }), function (item) {
                        return item.key;
                    });
//                            $scope.sections = _.filter($scope.sections, function(n){ return n.key != null });

                    scheduler.updateCollection("sections", $scope.sections);
                    scheduler.clearAll();
                    var shifts = angular.copy($scope.events);
                    //updating shifts
                    scheduler.parse(shifts, "json");

                    $scope.displayLoadingIndicator = false;

                }, function (error) {
                    $scope.displayLoadingIndicator = false;
                    dialogs.error("Error", error.data.message, 'lg');
                });
            $scope.displayLoadingIndicator = true;
        }

    };

    //Spliting shifts which takes multiply days
    function splitShifts(shifts) {
        for (var i = 0; i < shifts.length; i++) {
            if (shifts[i].start_date.getDate() < shifts[i].end_date.getDate()) {
                shifts.splice(i + 1, 0, angular.copy(shifts[i]));
                shifts[i].end_date.setDate(shifts[i].start_date.getDate() + 1);
                shifts[i].end_date.setHours(0, 0, -1);
                shifts[i + 1].start_date.setDate(shifts[i + 1].start_date.getDate() + 1);
                shifts[i + 1].start_date.setHours(0, 0);

                shifts[i + 1].id = shifts[i + 1].id + '==' + i;

                shifts[i].notEnded = true;
                shifts[i + 1].continue = true;

                if (shifts[i].employeeId) {
                    shifts[i].color = $scope.colors.splittedshift;
                    shifts[i + 1].color = $scope.colors.splittedshift;
                }
            }
        }
        return shifts;
    }


    return this;
};

;
// TODO: allow the selection of more than one ShiftStructure on creation


(function () {

    var module =  angular.module('emlogis.browser');

    // Image Base folder path
    var imagePath = "modules/browser/assets/images/";


    /* 
     * Controller for a single ShiftStructure entity
     * Extends / Overrides the Generic 'EntityCtlr' to buid the create and update Dtos as per ShiftStructure API definition
     */
    module.controller(
        'ShiftstructureCtlr',
        ['$scope', '$stateParams', '$state', 'stateManager', '$filter', 'authService', 'appContext', 'dataService', '$modal', 'dialogs', 'alertsManager',
            function($scope, $stateParams, $state, stateManager, $filter, authService, appContext, dataService, $modal, dialogs, alertsManager) {

            console.log("ShiftstructureCtlr: " + _.values($stateParams));
            console.log("ShiftstructureCtlr: " + getScopeHierachy($scope));

            EditOrCreateEntityCtlr($scope, $stateParams, $state, stateManager, $filter, authService, appContext, dataService, dialogs, alertsManager);

            if ($stateParams.parentEntityId) {
                // we have a parentEntittyId specified in state. 
                $scope.parentEntityId = $stateParams.parentEntityId;
            }

            // Override the method to build the create and update Dtos

            /*
            * getCreateDto() method to be overriden in some controllers that need
            * to process the data to be sent to the backend on object create  
            */
            $scope.getCreateDto = function() {
                console.log('in ShiftstructureCtlr.getCreateDto()');
                // build the create Dto
                var elt = $scope.elt;

                 // base create dto  // d.toDateString() // Date.parse("March 21, 2012")
                var startDate = Date.parse(elt.startDate); 
                var dto = {clName: elt.clName, startDate: startDate, teamId: elt.teamId};
                return dto;
            };


            /*
            * getUpdateDto() method to be overriden in some controllers that need
            * to process the data to be sent to the backend on object update  
            */
            $scope.getUpdateDto = function() {
                console.log('in ShiftstructureCtlr.getUpdateDto()');
                var elt = $scope.elt;
                var dto =  _.pick( elt, 'clName', 'startDate');
                return dto;
            };

            $scope.vetoCreate = function() {
                if ($scope.elt.teamId && $scope.elt.startDate) {
                    // teamId is present, one can create the ShiftStructure
                    return false;
                }
                // needs to select a Team, unless parent team is specified
                if( !$scope.elt.teamId) {
                    if ($scope.parentEntityId) {
                        $scope.elt.teamId = $scope.parentEntityId;
                        return false;
                    }

                    $scope.opts = {
                        scope: $scope,  // use current scope for modal so as to get results more conveniently
                        backdrop: true,
                        backdropClick: true,
                        dialogFade: false,
                        keyboard: true,
                        templateUrl : 'modules/browser/partials/entity_selectentity.tpl.html',
                        controller : ModalInstanceCtrl,
                        size : 'lg',
                        resolve: {} // empty storage
                    };

                    var subctlrConfig = {
                        title: 'Please select a Team',
                        entity: $scope.entity,
                        relatedentity: 'team',
                        entityTypeLabel: '$scope.entityTypeLabel',
                        relatedentityTypeLabel: 'Team',
                        dataServiceResource: 'teams',
                        dataServiceGetEntitiesAPI: 'getElements',
                        columns: [ // grid columns
                            {
                                name: 'name',
                                label: 'Name',
                                sortable: true
                            }, {
                                name: 'abbreviation',
                                label: 'Abbreviation',
                                sortable: true
                            }, {
                                name: 'id',
                                label: 'Id',
                                sortable: true
                            }
                        ],
                        relatedEntityIcon: imagePath + 'glyphicons/png/team.png'
                    };

                    $scope.opts.resolve.item = function() {
                        return angular.copy(subctlrConfig); // pass params to Dialog
                    };

                    var modalInstance = $modal.open($scope.opts);

                    modalInstance.result.then(function(selectedEntity){
                        //on ok button press
                        $scope.elt.teamId = selectedEntity.id;
                        // how to trigger saveOrCreate() on base editCtlr ?
                        console.log("Fire create...");
                        $scope.saveOrCreate();
                    },function(){
                        //on cancel button press
                        $scope.elt.siteId = false;  // clear selection on cancel
                        console.log("Modal Closed");
                    });
                    return true;
                }
            };


    }]);

            
}());





;
/**
 * Created by emlogis on 10/15/14.
 */
(function () {
    var module =  angular.module('emlogis.browser');
    /*
     * Controller for a single Site entity
     * Extends / Overrides the Generic 'EntityCtlr' to buid the create and update Dtos as per Team API definition
     */
    module.controller(
        'SiteCtlr',
        ['$scope', '$stateParams', '$state', 'stateManager', '$filter', 'authService', 'appContext', 'dataService',
            'dialogs', 'alertsManager',
            function($scope, $stateParams, $state, stateManager, $filter, authService, appContext, dataService,
                     dialogs, alertsManager) {

                $scope.weekendDefinitions = [
                    {label:'SATURDAY_SUNDAY', val: 'SATURDAY_SUNDAY'},
                    {label:'FRIDAY_SATURDAY_SUNDAY', val: 'FRIDAY_SATURDAY_SUNDAY'},
                    {label:'FRIDAY_SATURDAY_SUNDAY_MONDAY', val: 'FRIDAY_SATURDAY_SUNDAY_MONDAY'},
                    {label:'SATURDAY_SUNDAY_MONDAY', val: 'SATURDAY_SUNDAY_MONDAY'}
                ];

                $scope.firstDayOfWeeks = [
                    {label:'SUNDAY', val: 'SUNDAY'},
                    {label:'MONDAY', val: 'MONDAY'},
                    {label:'TUESDAY', val: 'TUESDAY'},
                    {label:'WEDNESDAY', val: 'WEDNESDAY'},
                    {label:'THURSDAY', val: 'THURSDAY'},
                    {label:'FRIDAY', val: 'FRIDAY'},
                    {label:'SATURDAY', val: 'SATURDAY'}
                ];

                $scope.postGetElement = function() {
                    var elt = $scope.elt;
                    if (elt) {

                        var firstDayOfWeek = elt.firstDayOfWeek;
                        var firstDayOfWeeks = $scope.firstDayOfWeeks;
                        var i;
                        for (i=0 ; i < firstDayOfWeeks.length; i++) {
                            if (firstDayOfWeeks[i].val == firstDayOfWeek) {
                                $scope.firstDayOfWeek = firstDayOfWeeks[i];
                                break;
                            }
                        }
                        var weekendDefinition = elt.weekendDefinition;
                        var weekendDefinitions = $scope.weekendDefinitions;
                        for (i=0 ; i < weekendDefinitions.length; i++) {
                            if (weekendDefinitions[i].val == weekendDefinition) {
                                $scope.weekendDefinition = weekendDefinitions[i];
                                break;
                            }
                        }
                        var timeZone = elt.timeZone;
                        var timeZones = $scope.timeZones;
                        for (i=0 ; i < timeZones.length; i++) {
                            if (timeZones[i] == timeZone) {
                                $scope.timeZone = timeZones[i];
                                break;
                            }
                        }
                    }
                };

                EditOrCreateEntityCtlr($scope, $stateParams, $state, stateManager, $filter, authService, appContext,
                    dataService, dialogs, alertsManager);

                $scope.ctlr = 'SiteCtlr';
                // set some default values if create mode
                if (!$scope.elt || !$scope.elt.id) {
                    $scope.firstDayOfWeek = $scope.firstDayOfWeeks[0];
                    $scope.weekendDefinition = $scope.weekendDefinitions[0];
                }

                dataService.getTimeZones()
                    .then(function (responce) {
                        $scope.timeZones = responce;
                    });

                // Override the method to build the create and update Dtos

                /*
                 * getCreateDto() method to be overriden in some controllers that need
                 * to process the data to be sent to the backend on object create
                 */
                $scope.getCreateDto = function() {

                    // build the create Dto
                    var elt = $scope.elt;
                    var dto = _.pick( elt,  'clName', 'name', 'description', 'timeZone', 'weekendDefinition', 'firstDayOfWeek');
                    dto.weekendDefinition = $scope.weekendDefinition.val;
                    dto.firstDayOfWeek = $scope.firstDayOfWeek.val;
                    dto.timeZone = $scope.timeZone;
                    return dto;
                };


                /*
                 * getUpdateDto() method to be overriden in some controllers that need
                 * to process the data to be sent to the backend on object update
                 */
                $scope.getUpdateDto = function() {

                    var elt = $scope.elt;
                    var dto = _.pick( elt, 'clName', 'name', 'description', 'timeZone', 'weekendDefinition', 'firstDayOfWeek');
                    dto.weekendDefinition = $scope.weekendDefinition.val;
                    dto.firstDayOfWeek = $scope.firstDayOfWeek.val;
                    dto.timeZone = $scope.timeZone;
                    return dto;
                };

            }
        ]);
}());
;

(function () {

    var module =  angular.module('emlogis.browser');

    /* 
     * Controller for a single Team entity
     * Extends / Overrides the Generic 'EntityCtlr' to buid the create and update Dtos as per Team API definition
     */
    module.controller(
        'TeamCtlr',
        ['$scope', '$stateParams', '$state', 'stateManager', '$filter', 'authService', 'appContext', 'dataService', '$modal', 'dialogs', 'alertsManager',
        function($scope, $stateParams, $state, stateManager, $filter, authService, appContext, dataService, $modal, dialogs, alertsManager) {

            console.log("TeamCtlr: " + getScopeHierachy($scope));

            var editCtlr = EditOrCreateEntityCtlr($scope, $stateParams, $state, stateManager, $filter, authService, appContext, dataService, dialogs, alertsManager);

            if ($stateParams.parentEntityId) {
                // we have a parentEntittyId specified in state. 
                $scope.parentEntityId = $stateParams.parentEntityId;
            }

            // Override the method to build the create and update Dtos

            /*
            * getCreateDto() method to be overriden in some controllers that need
            * to process the data to be sent to the backend on object create  
            */
            $scope.getCreateDto = function() {
                console.log('in TeamCtlr.getCreateDto()');
                // build the create Dto
                var elt = $scope.elt;

                 // base create dto
                var dto = _.pick( elt, 'clName', 'siteId');
                // add update dto if relevant
                if (elt.name || elt.description) {
                    dto.updateDto =  _.pick( elt, 'name', 'description');
                } 
                return dto;
            };


            /*
            * getUpdateDto() method to be overriden in some controllers that need
            * to process the data to be sent to the backend on object update  
            */
            $scope.getUpdateDto = function() {
                console.log('in TeamCtlr.getUpdateDto()');
                var elt = $scope.elt;
                var dto = _.pick( elt, 'clName', 'name', 'description');
                return dto;
            };

            $scope.vetoCreate = function() {
                if ($scope.elt.siteId) {
                    // sideId is present, one can create the Team
                    return false;
                }
                // check if SiteId is provided as parent entity
                if ($scope.parentEntityId) {
                    $scope.elt.siteId = $scope.parentEntityId;
                    return false;
                }

                // needs to select a Site
                $scope.opts = {
                    scope: $scope,  // use current scope for modal so as to get results more conveniently
                    backdrop: true,
                    backdropClick: true,
                    dialogFade: false,
                    keyboard: true,
                    templateUrl : 'modules/browser/partials/entity_selectentity.tpl.html',
                    controller : ModalInstanceCtrl,
                    size : 'lg',
                    resolve: {} // empty storage
                };

                var subctlrConfig = {
                    title: 'Please select a Site',
                    columns:  [ // grid columns
                        {name: 'name', label: 'Name', sortable: true},
                        {name: 'description', label: 'Description', sortable: true},
                        {name: 'id', label: 'Id',sortable: true}
                    ],
                    relatedEntityIcon: './img/glyphicons/png/site.png',
                    entity: $scope.entity,
                    relatedentity: 'site',
                    entityTypeLabel: '$scope.entityTypeLabel',
                    relatedentityTypeLabel: 'Site',
                    dataServiceResource: 'sites',
                    dataServiceGetEntitiesAPI: 'getElements'
                };

                $scope.opts.resolve.item = function() {
                    return angular.copy(subctlrConfig); // pass params to Dialog
                };

                var modalInstance = $modal.open($scope.opts);

                modalInstance.result.then(function(selectedEntity){
                    //on ok button press
                    $scope.elt.siteId = selectedEntity.id;
                    // how to trigger saveOrCreate() on base editCtlr ?
                    console.log("Fire create...");
                    $scope.saveOrCreate();
                },function(){
                    //on cancel button press
                    $scope.elt.siteId = false;  // clear selection on cancel
                    console.log("Modal Closed");
                });
                return true;
            };


    }]);

    var ModalInstanceCtrl = function($scope, $modalInstance, $modal, item) {
        console.log("ModaCtlr: " + getScopeHierachy($scope));

        $scope.item = item;
        $scope.ctlr = 'ModalInstanceCtrl';
        $scope.ok = function () {
            if (! $scope.selectedEntity) {
                $scope.cancel();    // in case user has closed wo selecting any item
            }
            $modalInstance.close($scope.selectedEntity);
        };
        $scope.cancel = function () {
            $modalInstance.dismiss('cancel');
        };
    };

            
}());





;
(function () {

  //console.log('in commonservices.');

  angular.module('emlogis.commonDirectives', ['ui.bootstrap', 'ui.calendar', 'ngSlider']);
  angular.module('emlogis.commonControllers', ['ui.bootstrap']);

  angular.module('emlogis.commonservices', [])

  .factory('appContext', function () {
    var ctx = {
      entity2resource: {}
    };
    return {
      get: function (id, defaultEntry) {
        if (defaultEntry !== undefined) {
            return ctx[id] || (ctx[id] = defaultEntry);
        }
        return ctx[id];
      },
      set: function( id, entry) {
        ctx[id] = entry;
      }
    };
  })

  .factory('deepCopy', function () {
    return {
    };
  })

  .factory('alertsManager', function ($timeout) {
    return {
      alerts: [],
      addAlert: function(message, type) {

        this.alerts.push({type: type, msg: message});
        var that = this;
        $timeout(function(){
            that.closeAlert(that.alerts.length -1);
        }, 5000);
      },
      closeAlert: function(index) {
        this.alerts.splice(index, 1);
      }
    };
  })

  .factory('stateManager', function ($rootScope) {
    return {
      previousState: {},
      previousParams: {},
      currentState: {},
      currentParams: {},
      onStateChangeSuccess: function() {
        var that = this;
        $rootScope.$on('$stateChangeSuccess', function(ev, to, toParams, from, fromParams) {
          that.previousState = from.name;
          that.previousParams = fromParams;
          that.currentState = to.name;
          that.currentParams = toParams;
          //console.log('===>Previous state:'+that.previousState);
          //console.log('===>Current state:'+that.currentState);
        });
      }
    };
  })

  .service('appFunc', function ($q, $modal, $http, $interval, applicationContext) {

    var badgeObj, isManager = null;
    return {
      getSaveWorkDlg: function() {
        var working = applicationContext.getWorking();
        if (!working.option || working.option.editing === false) {
          var deferred = $q.defer();

          deferred.resolve(SKIP);
          return deferred.promise;

        }
        else {

          var dlg = $modal.open({
            templateUrl: 'modules/_layouts/partials/authenticated_save_work_modal.html',
            windowClass: 'schedule-builder',
            controller: function ($scope, $modalInstance) {

              // When we go to login page we have to dismiss the modal.
              $scope.$on('event:auth-loginRequired', function () {
                $modalInstance.dismiss('cancel');
              });

              // Save Action
              $scope.save = function () {
                $modalInstance.close(SAVE);
              };

              // Discard Action
              $scope.discard = function () {
                $modalInstance.close(DISCARD);
              };

              // Close Modal
              $scope.close = function () {
                $modalInstance.dismiss('cancel');
              };

              $scope.entityName = working.entityName;
            }

          });

          return dlg.result.then(function (reason) {

            /**
             * here we just need Save, we don't need Discard, since it will be reloading anyway
             */
            return reason;


          }, function (reason) {

            console.log('dismissed');
            return $q.reject(reason);
          });
        }
      },
      /**
       * This function is used to save the datetime value to DB
       * @param year
       * @param month
       * @param date
       * @param timezone
       * @returns {Date}
       */
      getDateWithTimezone: function(year, month, date, timeZone) {
        var dtFormat = [year, month, date];
        var dt = moment.tz(dtFormat, timeZone);
        return new Date(dt);
      },
      convertToBrowserTimezone: function(date,srcTimezone) {
        if (!date)
          return null;

        var dt = new Date(date);

        var diffMin = moment.tz(dt, srcTimezone).utcOffset() - (moment(dt)).utcOffset();

        return (new Date(dt.getTime() + diffMin * 60 * 1000));
      },
      /**
       * Get pending and new requests count
       */
      updatePendingAndNewRequests: function() {

        var url = '';
        var _this = this;

        if (isManager === true) {
          url = applicationContext.getBaseRestUrl() + 'requests/manager/pendingandnewrequestcounts?teamrequests=true';
//          "status": "SUCCESS",  "pendingManagerRequests": 123, "newManagerRequests":5, "pendingTeamRequests": 12, "newTeamRequests":2
        }
        else if (isManager === false){
          url = applicationContext.getBaseRestUrl() + 'requests/peer/pendingandnewrequestcounts';
//          "status": "SUCCESS",  "pendingTeamRequests": 12, "newTeamRequests":2
        }
        else {
          return;
        }


        $http.get(url, {})
          .then(function (response) {
            applicationContext.setBadgeMsg(response.data);
          }, function(error) {
            // unauthorized or insufficient permission
            // stop it in every error
//            if (error.status === 401 || error.status === 403) {
//
//            }
            //_this.stopBadgeRefresh();
            applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
          });
      },
      badgeRefresh: function(boolManager) {
        if (angular.isDefined(badgeObj)) return;
        isManager = boolManager;

        badgeObj = $interval(this.updatePendingAndNewRequests.bind(this), applicationContext.getBadgeRefreshInterval() * 1000);
        this.updatePendingAndNewRequests();
      },
      stopBadgeRefresh: function() {
        if (angular.isDefined(badgeObj)) {
          $interval.cancel(badgeObj);
          badgeObj = undefined;
          isManager = null;
        }
      },
      toShortest12TimeFormat: function (momentDateTime, hoursFormat, minutesFormat) {
        hoursFormat = hoursFormat || "h";
        minutesFormat = minutesFormat || "m";
        var timeFormatPattern = momentDateTime.minutes() > 0 ? (hoursFormat+':'+minutesFormat) : hoursFormat;
        return momentDateTime.format(timeFormatPattern) + (momentDateTime.hours() < 12 ? "a" : "p");
      }
    };
  })

  .service('applicationContext', function($timeout, $q) {

      // current username
    var username = '';
    // current filter for grid
    var entityFilter = {
        url: '',
        txt: '',
        searchFields: '',
        returnedFields: '',
        limit: 15,
        orderBy: '',
        orderDir: ''
    };

    // Entity Grid Page Item Size
    var gridPageItemSize = 20;

    // current grid list
    var browser = {totalRecords:0, showingRecords: 0 };
    // current module
    var module = {name: '',  icoClass: '',   href: '', disableModuleBreadcrumb: false};

    //base Rest Url
    var baseRestUrl = '../emlogis/rest/';

    //base Url
    var baseUrl = '../emlogis/';

    // afterLoginUrl
    var afterLoginUrl = '';

    //Notification Message
    var notificationMsg = {content: '', type: '', visible: false, entityName: '', param: {
            lostConnection: false
        }
    };

    /**
     * Info of editing section
     * @type {{status: boolean, restoreFunc: null, saveFunc: null}}
     */
    var working = {
      option: null,
      entityName: '',
      restoreFunc: null,
      saveFunc: null
    };

    /**
     * This variable indicates the interval which displays at the top right corner of the page.
     */
    var badgeRefreshInterVal = 30; // In sec
    var badgeMsg = {};

    return {

      getUsername: function(){
        return username;
      },
      setUsername: function(value){
        username = value;
      },
      getEntityFilter : function(){
        return entityFilter;
      },
      setEntityFilter: function(value){
        entityFilter = value;
      },
      getBrowser: function(){
        return browser;
      },
      setBrowser: function(value){
        browser = value;
      },
      getModule: function(){
        return module;
      },
      setModule: function(value){
        module = value;
      },
      getAfterLoginUrl: function(){
        return afterLoginUrl;
      } ,
      setAfterLoginUrl: function(value){
        afterLoginUrl = value;
      },
      getBaseRestUrl: function() {
        return baseRestUrl;
      } ,
      setBaseRestUrl: function(value){
        baseRestUrl = value;
      },
      getBaseUrl: function() {
        return baseUrl;
      } ,
      setBaseUrl: function(value){
        baseUrl = value;
      },
      getGridPageItemSize: function() {
        return gridPageItemSize;
      },
      setGridPageItemSize: function(value) {
        gridPageItemSize = value;
      },
      getNotificationMsg: function() {
        return notificationMsg;
      },
      setNotificationMsg: function(value) {
        notificationMsg = value;
          //notificationMsg.visible = true;
        var interval = 5;

        if (notificationMsg.type !== 'danger' && notificationMsg.type !== 'save' && notificationMsg.type !== 'login'){
          var _this = this;
          $timeout(function(){
            //notificationMsg.content = ''; don't change content, otherwise it will be automatically disappeared
            //notificationMsg.type = '';
            notificationMsg.visible = false;

            _this.updateNotificationArea();
          }, interval * 1000);
        }

        this.updateNotificationArea();

      },
      /**
       *
       * @param content
       * @param type
       * @param visible
       * @param entityName
       */
      setNotificationMsgWithValues: function(content, type, visible, entityName) {

        notificationMsg.content = content || "";
        notificationMsg.type = type || "";
        notificationMsg.visible = visible || false;
        notificationMsg.entityName = entityName || "";

        this.setNotificationMsg(notificationMsg);
      },
      updateNotificationArea: function() {

        // Notification Scope apply
        var notificationArea = angular.element('#notificationArea');

        // Page hasn't been fully loaded yet.
        if (typeof notificationArea.scope() === 'undefined') {
          return;
        }

        // Check digest is in the progress
        if(!notificationArea.scope().$$phase) {
          notificationArea.scope().$apply();
        }

      },
      getWorking: function() {
        return working;
      },
      setWorking: function(value) {
        working = value;
      },
      getBadgeRefreshInterval: function() {
        return badgeRefreshInterVal;
      },
      getBadgeMsg: function() {
        return badgeMsg;
      },
      setBadgeMsg: function(value) {
        angular.copy(value, badgeMsg);
      }

    };

  });

}());

;
angular.module('emlogis.commonControllers').controller('ScheduleSelectorModalInstanceCtrl', ['$scope', '$modalInstance', '$timeout',
  'applicationContext', 'dataService', 'uiGridConstants','checkboxModel','customFilter',
  function ($scope, $modalInstance, $timeout, applicationContext, dataService,
            uiGridConstants,checkboxModel,customFilter) {

    $scope.original = {
      schedules: [],
      sites: [],
      teams: []
    };

    $scope.loadingState = {
      schedulesLoaded: false
    };

    if (checkboxModel) {
      $scope.checkboxModel = checkboxModel;
    }
    else {
      $scope.checkboxModel = {
        simulationGenerated: false,
        production: true,
        posted: true
      };
    }

    function scheduleComparator(firstSchedule, secondSchedule) {
      if (firstSchedule.start < secondSchedule.start) {
        return 1;
      } else if (firstSchedule.start > secondSchedule.start) {
        return -1;
      } else {
        return 0;
      }
    }

    $scope.datePickerModel = {
      scheduleDate: null,
      datePickerOpened: false,
      datePickerOptions: {
        formatYear: 'yyyy',
        startingDay: 1
      },
      openDatePicker: function($event) {
        $event.preventDefault();
        $event.stopPropagation();

        $scope.datePickerModel.datePickerOpened = true;
      }
    };

    $scope.parseFilteredScheduleDate = function() {
      if (typeof $scope.datePickerModel.scheduleDate === 'undefined' || $scope.datePickerModel.scheduleDate === null) {
        $scope.filter.scheduleDate = null;
        $scope.filterSchedules();
        return;
      }

      var yearVal = $scope.datePickerModel.scheduleDate.getFullYear();
      var monthVal = $scope.datePickerModel.scheduleDate.getMonth();
      var dateVal = $scope.datePickerModel.scheduleDate.getDate();
      var dateInArrFormat = [yearVal, monthVal, dateVal];
      $scope.filter.scheduleDate = moment.tz(dateInArrFormat, $scope.filter.site.siteTimeZone).unix() * 1000;
      $scope.filterSchedules();
    };

    $scope.filter = {
      scheduleName: '',
      site: null,
      team: null,
      scheduleDate: null
    };

    $scope.sortOptions = {
      sortBy: null,
      sortDir: null
    };

    $scope.filterSchedules = function() {
      $scope.schedulesGridOptions.paginationCurrentPage = 1;
      $scope.getSchedules();
    };

    $scope.onSelectedSiteChanged = function() {
      if ($scope.filter.site === null) {
        $scope.original.teams = [];
      } else {
        $scope.original.teams = $scope.filter.site.children;
      }
      $scope.filter.team = null;
      $scope.datePickerModel.scheduleDate = null;
      $scope.filter.scheduleDate = null;
      $scope.filterSchedules();
    };

    $scope.onSelectedTeamChanged = function() {
      $scope.datePickerModel.scheduleDate = null;
      $scope.filter.scheduleDate = null;
      $scope.filterSchedules();
    };

    $scope.parseSchedule = function(schedule) {
      schedule.endDate--;
      var lengthInWeeks = moment.tz(schedule.endDate, schedule.site.siteTimeZone).week() - moment.tz(schedule.startDate, schedule.site.siteTimeZone).week() + 1;
      var teamsText = '';
      var teamsValues = '';

      if (schedule.teams.length === 0) {
        teamsText = '-';
      } else if (schedule.teams.length === 1) {
        teamsText = schedule.teams[0].teamName;
      } else {
        teamsText = schedule.teams.length + ' teams';
      }

      angular.forEach(schedule.teams, function(teamIterator, index) {
        if (index === schedule.teams.length -1 ) {
          teamsValues += teamIterator.teamName;
        } else {
          teamsValues += teamIterator.teamName + ',\r\n';
        }
      });


      var entity = {
        id: schedule.id,
        name: schedule.name,
        status: schedule.status,
        start: schedule.startDate,
        end: schedule.endDate,
        startDate: moment.tz(schedule.startDate, schedule.site.siteTimeZone).format('MMMM DD, YYYY'),
        endDate: moment.tz(schedule.endDate, schedule.site.siteTimeZone).format('MMMM DD, YYYY'),
        site: schedule.site.siteName,
        teamsValues: teamsValues,
        teams: teamsText,
        lengthInDays: schedule.lengthInDays,
        lengthInWeeks: lengthInWeeks,
        lengthInDaysString: schedule.lengthInDays + ' Days'
      };

      return entity;
    };

    $scope.selectSchedule = function(row) {
      $modalInstance.close(row.entity);
    };

    function rowTemplate() {
      return '<div ng-click="grid.appScope.selectSchedule(row)" ng-repeat="col in colContainer.renderedColumns track by col.colDef.name" class="ui-grid-cell" ui-grid-cell></div>';
    }

    $scope.processOnSortChanged = function(grid, sortColumns) {
      if (sortColumns.length === 0) {
        $scope.sortOptions.sortBy = null;
        $scope.sortOptions.sortDir = null;
      } else {
        $scope.sortOptions.sortBy = sortColumns[0].field;
        if (sortColumns[0].sort.direction === uiGridConstants.ASC) {
          $scope.sortOptions.sortDir = 'ASC';
        } else if (sortColumns[0].sort.direction === uiGridConstants.DESC) {
          $scope.sortOptions.sortDir = 'DESC';
        }
      }
      $scope.getSchedules();
    };

    $scope.schedulesGridOptions = {
      data: 'original.schedules',
      useExternalSorting: true,
      paginationPageSize: 10,
      paginationCurrentPage: 1,
      rowTemplate: rowTemplate(),
      enableColumnMenus: false,
      enableGridMenu: true,
      columnDefs: [
        { field: 'id', visible: false },
        { field: 'name' },
        { field: 'startDate' },
        { field: 'endDate' },
        { field: 'status' },
        { field: 'site', enableSorting: false },
        { field: 'teams',
          enableSorting: false,
          cellTooltip: function( row, col ) {
            return row.entity.teamsValues;
          }
        },
        { field: 'teamsValues', visible: false }
      ],
      onRegisterApi: function( gridApi ) {
        gridApi.core.on.sortChanged( $scope, $scope.processOnSortChanged );
      }
    };

    $scope.getSchedules = function() {
      $scope.loadingState.schedulesLoaded = false;
      $scope.original.schedules = [];
      var statusesVal = null;
      var scheduleDateVal = null;
      var sitesVal = null;
      var teamsVal = null;

      if ($scope.checkboxModel.simulationGenerated ||
        $scope.checkboxModel.production || $scope.checkboxModel.posted) {
        statusesVal = [];
        if ($scope.checkboxModel.simulationGenerated) {
          statusesVal.push(0);
        }
        if ($scope.checkboxModel.production) {
          statusesVal.push(1);
        }
        if ($scope.checkboxModel.posted) {
          statusesVal.push(2);
        }
      } else {
        $scope.schedulesGridOptions.totalItems = 0;
        $scope.loadingState.schedulesLoaded = true;
        $timeout(function () {
          $('.schedules-grid').resize();
        }, 0);
        return;
      }

      if ($scope.filter.site !== null) {
        sitesVal = [$scope.filter.site.id];
        scheduleDateVal = $scope.filter.scheduleDate;
        if ($scope.filter.team !== null) {
          teamsVal = [$scope.filter.team.id];
        }
      }

      var payLoad = {
        sites: sitesVal,
        teams: teamsVal,
        statuses: statusesVal,
        startDate: scheduleDateVal,
        search: $scope.filter.scheduleName,
        paging: {
          limit: $scope.schedulesGridOptions.paginationPageSize,
          offset: ($scope.schedulesGridOptions.paginationCurrentPage - 1) * $scope.schedulesGridOptions.paginationPageSize
        },
        ordering: {
          orderby: $scope.sortOptions.sortBy,
          orderdir: $scope.sortOptions.sortDir
        }
      };

      if ( customFilter) {
        payLoad[customFilter.key] = customFilter.value;
      }
      dataService.getSchedules(payLoad).then(function(response) {
        angular.forEach(response.data, function(scheduleIterator) {
          var entity = $scope.parseSchedule(scheduleIterator);
          $scope.original.schedules.push(entity);
        });
        $scope.original.schedules.sort(scheduleComparator);
        $scope.schedulesGridOptions.totalItems = response.total;
      }, function(err) {
        var message = err.data.message || JSON.stringify(err.data);
        applicationContext.setNotificationMsgWithValues(message, 'danger', true);
      }).finally(function() {
        $scope.loadingState.schedulesLoaded = true;
        $timeout(function () {
          $('.schedules-grid').resize();
        }, 0);
      });
    };

    $scope.navigateSchedulesPage = function() {
      $scope.getSchedules();
    };

    $scope.close = function () {
      $modalInstance.dismiss('cancel');
    };

    function siteTeamComparator(firstEntity, secondEntity) {
      if (firstEntity.name < secondEntity.name) {
        return -1;
      } else if (firstEntity.name > secondEntity.name) {
        return 1;
      } else {
        return 0;
      }
    }

    var initializeSitesTeams = function() {
      dataService.getSitesTeamsTree({}).then(function(response) {
        $scope.original.sites = response.data;
        $scope.original.sites.sort(siteTeamComparator);
        angular.forEach($scope.original.sites, function(site) {
          site.children.sort(siteTeamComparator);
        });
      }, function(err) {
        var message = err.data.message || JSON.stringify(err.data);
        applicationContext.setNotificationMsgWithValues(message, 'danger', true);
      });
    };

    initializeSitesTeams();
    $scope.getSchedules();
  }]);

;
angular.module('emlogis.commonDirectives').directive('availabilityCalendar',
  ['$modal', '$timeout', '$state', '$filter', 'dataService', 'uiCalendarConfig', 'applicationContext', 'appFunc',
  function ($modal, $timeout, $state, $filter, dataService, uiCalendarConfig, applicationContext, appFunc) {

    return {
      restrict: 'E',
      scope: {
        calendarMode: '@',
        employeeId: '=',
        siteTimeZone: '=',
        firstDayOfWeek: '=',
        absenceTypes: '=',
        previewParams: '='
      },
      controller: function($scope) {
        $scope.fakeModel = [[]];

        $scope.calendarModes = {
          MANAGER: "manager",
          EMPLOYEE: "employee",
          PREVIEW: "preview"
        };
      },
      templateUrl: 'modules/common/partials/availability-calendar/availability-calendar.html',
      link: function (scope) {

        if (_.values(scope.calendarModes).indexOf(scope.calendarMode) === -1) {
          throw "Unknown availability calendar mode: " + scope.calendarMode + ".";
        }

        scope.config = {
          calendar: {
            editable: false,
            columnFormat: "dddd",
            header:{
              left: '',
              center: '',
              right: ''
            }
          }
        };

        scope.datepicker = {
          model: null,
          opened: false,
          open: function($event) {
            $event.preventDefault();
            $event.stopPropagation();
            scope.datepicker.opened = true;
          }
        };

        scope.monthYearPicker = {
          year: new Date().getFullYear(),
          month: new Date().getMonth()
        };

        scope.dateRangeStart = 0;
        scope.dateRangeEnd = 0;
        //scope.maxDaysPerWeek = [];
        scope.coupleWeekends = {};
        scope.showAvailability = true;
        scope.showPreference = true;

        scope.$watch('showAvailability', function(show) {
          if (show) {
            $(".availability").show();
          } else {
            $(".availability").hide();
          }
        });

        scope.$watch('showPreference', function(show) {
          if (show) {
            $(".preference").show();
          } else {
            $(".preference").hide();
          }
        });

        scope.openEditAvailabilityModal = function() {
          var modalInstance = $modal.open({
            templateUrl: 'modules/common/partials/availability-calendar/edit-availability-modal.html',
            controller: 'EditAvailabilityModal',
            resolve: {
              managerView: function() {
                return scope.calendarMode === scope.calendarModes.MANAGER;
              },
              employeeId: function() {
                return scope.employeeId;
              },
              availabilityType: function() {
                return scope.availabilityType;
              },
              datesSelected: function() {
                return datesSelected();
              },
              timeZone: function() {
                return scope.siteTimeZone;
              },
              absenceTypes: function() {
                return scope.absenceTypes;
              },
              dateRangeStart: function() {
                return scope.dateRangeStart;
              },
              dateRangeEnd: function() {
                return scope.dateRangeEnd;
              }
            }
          });

          modalInstance.result.then(function (availability) {
            if (scope.calendarMode === scope.calendarModes.MANAGER) {
              scope.availability = availability;
              refreshCalendar(true);
            }
          });
        };

        scope.openEditPreferenceModal = function() {
          var modalInstance = $modal.open({
            templateUrl: 'modules/common/partials/availability-calendar/edit-preference-modal.html',
            controller: 'EditPreferenceModal',
            resolve: {
              employeeId: function() {
                return scope.employeeId;
              },
              availabilityType: function() {
                return scope.availabilityType;
              },
              datesSelected: function() {
                return datesSelected();
              },
              timeZone: function() {
                return scope.siteTimeZone;
              },
              dateRangeStart: function() {
                return scope.dateRangeStart;
              },
              dateRangeEnd: function() {
                return scope.dateRangeEnd;
              }
            }
          });

          modalInstance.result.then(function (availability) {
            scope.availability = availability;
            refreshCalendar(true);
          });
        };

        scope.openCopyAvailabilityModal = function() {
          var modalInstance = $modal.open({
            templateUrl: 'modules/common/partials/availability-calendar/copy-availability-modal.html',
            controller: 'CopyAvailabilityModal',
            resolve: {
              employeeId: function() {
                return scope.employeeId;
              },
              datesSelected: function() {
                return datesSelected();
              },
              timeZone: function() {
                return scope.siteTimeZone;
              },
              dateRangeStart: function() {
                return scope.dateRangeStart;
              },
              dateRangeEnd: function() {
                return scope.dateRangeEnd;
              }
            }
          });

          modalInstance.result.then(function (availability) {
            scope.availability = availability;
            refreshCalendar(true);
          });
        };

        function openEditRotationModal() {
          var modalInstance = $modal.open({
            templateUrl: 'modules/common/partials/availability-calendar/edit-rotation-modal.html',
            controller: 'EditRotationModal',
            resolve: {
              employeeId: function() {
                return scope.employeeId;
              },
              selectedDay: function() {
                return datesSelected()[0];
              },
              dateRangeStart: function() {
                return scope.dateRangeStart;
              },
              dateRangeEnd: function() {
                return scope.dateRangeEnd;
              }
            }
          });

          modalInstance.result.then(function () {
            refreshCalendar();
          });
        }

        scope.availabilityType = undefined;

        function updateAvailabilityType() {
          var selectedDays = $('.day-selected'),
              type;

          if (selectedDays.hasClass("ci-day")) type = "ci";
          if (selectedDays.hasClass("cd-day")) type = "cd";

          scope.$apply(function () {
            scope.availabilityType = type;
          });
        }

        function datesSelected() {
          var selectedDays = $('.day-selected'),
              dates = [],
              dateAttr = scope.availabilityType === "cd" ? "data-date" : "data-day";

          selectedDays.each(function() {
            var date = $(this).parent().attr(dateAttr);
            if (date) {
              dates.push(date);
            }
          });

          return dates;
        }

        function deselectDays(className) {
          if (!className) {
            $('.availability-container').removeClass('day-selected');
          } else {
            $('.availability-container.' + className).removeClass(className + ' day-selected');
          }
        }

        function initCalendar() {
          var daysInCalendar = $('.fc-day-grid .fc-bg td');

          function timeFormat(time) {
            return moment(time).minutes() === 0 ? "h a" : "h:mm a";
          }

          function titleAndClass4AvailabiliyTimeFrameContainer(timeFrame, availabilityType) {
            var title = "",
                className = "",
                timeFrameClass = "";

            switch (availabilityType) {
              case "AVAIL":
                title = moment(timeFrame.startDateTime).format(timeFormat(timeFrame.startDateTime)) + " - " +
                        moment(timeFrame.endDateTime).format(timeFormat(timeFrame.endDateTime));
                className = "partially-available";
                break;
              case "DAY_OFF":
                if (timeFrame.pto) {
                  title = timeFrame.absenceTypeName;
                  className = "holiday-vacation";
                } else {
                  title = $filter('translate')("availability.NOT_AVAILABLE");
                  className = "not-available";
                }
                break;
              default:
                title = $filter('translate')("availability.UNKNOWN_AVAILABILITY_TYPE") + " " + availabilityType;
            }

            if (timeFrame.preview === "REMOVED") {
              timeFrameClass = "remove-time-frame";
            } else if (timeFrame.preview === "ADDED") {
              timeFrameClass = "add-time-frame";
            }

            return {
              title: title,
              className: className,
              timeFrameClass: timeFrameClass
            };
          }

          function title4PreferenceTimeFrame(timeFrame, preferenceType) {
            var title = "";

            switch (preferenceType) {
              case "AVOID_TIMEFRAME":
                title = $filter('translate')("availability.AVOID") + " " +
                        moment(timeFrame.startDateTime).format(timeFormat(timeFrame.startDateTime)) + " - " +
                        moment(timeFrame.endDateTime).format(timeFormat(timeFrame.endDateTime));
                break;
              case "PREFER_TIMEFRAME":
                title = $filter('translate')("availability.PREFER") + " " +
                        moment(timeFrame.startDateTime).format(timeFormat(timeFrame.startDateTime)) + " - " +
                        moment(timeFrame.endDateTime).format(timeFormat(timeFrame.endDateTime));
                break;
              case "AVOID_DAY":
                title = $filter('translate')("availability.AVOID_DAY");
                break;
              case "PREFER_DAY":
                title = $filter('translate')("availability.PREFER_DAY");
                break;
              default:
                title = $filter('translate')("availability.UNKNOWN_PREFERENCE_TYPE") + " " + preferenceType;
            }

            return title;
          }

          function addAvailabilityContainers() {
            _.each(daysInCalendar, function(d) {
              $(d).append("<div class='availability-container'>" +
                            "<div class='availability'></div>" +
                            "<div class='preference'></div>" +
                          "</div>");

              if (scope.calendarMode !== scope.calendarModes.PREVIEW) {
                $(d).unbind();
                $(d).click(function () {
                  var availabilityContainer = $(this).find(".availability-container");
                  if (availabilityContainer.hasClass("day-selected")) {
                    if (availabilityContainer.hasClass("ci-day")) {
                      deselectDays('ci-day');
                      availabilityContainer.addClass("day-selected cd-day");
                    } else {
                      availabilityContainer.removeClass("day-selected cd-day");
                    }
                  } else {
                    deselectDays('ci-day');
                    availabilityContainer.addClass("day-selected cd-day");
                  }
                  updateAvailabilityType();
                });
              }

            });
          }

          function convertTimeFramesToBrowserTimeZone(timeFrames, type) {
            var convertedTimeFrames = _.clone(timeFrames);

            if (type === 'ci') {
              _.each(convertedTimeFrames, function(instance) {
                _.each(instance.timeFrameInstances, function (timeFrame) {
                  if (timeFrame.startDateTime) {
                    timeFrame.startDateTime = appFunc.convertToBrowserTimezone(timeFrame.startDateTime, scope.siteTimeZone);
                  }
                  if (timeFrame.endDateTime) {
                    timeFrame.endDateTime = appFunc.convertToBrowserTimezone(timeFrame.endDateTime, scope.siteTimeZone);
                  }
                });
              });
            } else {
              _.each(convertedTimeFrames, function(timeFrame) {
                  if (timeFrame.startDateTime) {
                    timeFrame.startDateTime = appFunc.convertToBrowserTimezone(timeFrame.startDateTime, scope.siteTimeZone);
                  }
                  if (timeFrame.endDateTime) {
                    timeFrame.endDateTime = appFunc.convertToBrowserTimezone(timeFrame.endDateTime, scope.siteTimeZone);
                  }
              });
            }

            return convertedTimeFrames;
          }

          function displayCITimeFrames() {
            var ciAvailTimeFrames = convertTimeFramesToBrowserTimeZone(scope.availability.availCITimeFrames, "ci"),
                ciPrefTimeFrames  = convertTimeFramesToBrowserTimeZone(scope.availability.prefCITimeFrames, "ci"),
                ciHeaderCell = null;

            _.each(daysInCalendar, function(d) {

              _.each(ciAvailTimeFrames, function (t) {
                var availTimeFrames = _.filter(t.timeFrameInstances, function(f) {
                  return moment(f.startDateTime).format("YYYY-MM-DD") === d.dataset.date;
                });

                _.each(availTimeFrames, function(timeFrame) {
                  var tc = titleAndClass4AvailabiliyTimeFrameContainer(timeFrame, t.availType);

                  $(d).find(".availability-container").
                    addClass(tc.className).
                    find(".availability").
                    append("<div class='time-frame " + tc.timeFrameClass + "'>" + tc.title + "</div>");

                  ciHeaderCell = $(".ci-header th[data-day='" + t.dayOfTheWeek.toLowerCase() + "'] .availability-container");

                  if (!ciHeaderCell.hasClass(tc.title.replace(/\s+/g, ''))) {
                    ciHeaderCell.
                    addClass(tc.className + " " + tc.title.replace(/\s+/g, '')).
                    find(".availability").
                    append("<div class='time-frame " + tc.timeFrameClass + "'>" + tc.title + "</div>");
                  }
                });
              });

              _.each(ciPrefTimeFrames, function (t) {
                var prefTimeFrames = _.filter(t.timeFrameInstances, function(f) {
                  return moment(f.startDateTime).format("YYYY-MM-DD") === d.dataset.date;
                });

                _.each(prefTimeFrames, function(p) {
                  var title = title4PreferenceTimeFrame(p, t.prefType);

                  $(d).find(".preference").
                    append("<div class='pref-time-frame'>" + title + "</div>");

                  ciHeaderCell = $(".ci-header th[data-day='" + t.dayOfTheWeek.toLowerCase() + "'] .availability-container");

                  if (!ciHeaderCell.hasClass(title.replace(/\s+/g, ''))) {
                    ciHeaderCell.
                      addClass(title.replace(/\s+/g, '')).
                      find(".preference").
                      append("<div class='pref-time-frame'>" + title + "</div>");
                  }
                });
              });
            });
          }

          function displayCDTimeFrames() {
            var cdAvailTimeFrames = convertTimeFramesToBrowserTimeZone(scope.availability.availCDTimeFrames, "cd"),
                cdPrefTimeFrames  = convertTimeFramesToBrowserTimeZone(scope.availability.prefCDTimeFrames, "cd");

            _.each(daysInCalendar, function(d) {
              var availTimeFrames = _.filter(cdAvailTimeFrames, function(t) {
                return moment(t.startDateTime).format("YYYY-MM-DD") === d.dataset.date;
              }),
                prefTimeFrames = _.filter(cdPrefTimeFrames, function(t) {
                  return moment(t.startDateTime).format("YYYY-MM-DD") === d.dataset.date;
                });

              _.each(availTimeFrames, function(a) {
                var tc = titleAndClass4AvailabiliyTimeFrameContainer(a, a.availType);

                $(d).find(".availability-container").
                  addClass(tc.className).
                  find(".availability").
                  append("<div class='time-frame " + tc.timeFrameClass + "'>" + tc.title + "</div>");
              });

              _.each(prefTimeFrames, function(p) {
                var title = title4PreferenceTimeFrame(p, p.prefType);

                $(d).find(".preference").
                  append("<div class='pref-time-frame'>" + title + "</div>");
              });
            });
          }

          function displayRotation() {
            $(".fc-row.fc-widget-header tr:first th").each(function() {
              var dayInRotationObj, rotation;
              switch ($(this)[0].classList[2]) {
                case "fc-sun":
                  dayInRotationObj = "sunday";
                  break;
                case "fc-mon":
                  dayInRotationObj = "monday";
                  break;
                case "fc-tue":
                  dayInRotationObj = "tuesday";
                  break;
                case "fc-wed":
                  dayInRotationObj = "wednesday";
                  break;
                case "fc-thu":
                  dayInRotationObj = "thursday";
                  break;
                case "fc-fri":
                  dayInRotationObj = "friday";
                  break;
                case "fc-sat":
                  dayInRotationObj = "saturday";
                  break;
              }

              switch (scope.availability.weekdayRotations[dayInRotationObj]) {
                case "NONE":
                  rotation = "1:1";
                  break;
                case "EVERY_OTHER":
                  rotation = "1:2";
                  break;
                case "EVERY_THIRD":
                  rotation = "1:3";
                  break;
                case "TWO_OF_EVERY_FOUR":
                  rotation = "2:4";
                  break;
              }

              $(this).empty();
              $(this).append("<span class='rotation-day-of-week'>" + dayInRotationObj + "</span>");
              if (scope.calendarMode !== scope.calendarModes.PREVIEW) {
                $(this).append("<span class='rotation'>" + rotation + "</span>");
              }
              $(this).wrapInner("<div class='availability-container'></div>");
            });
          }

          function addCIHeader() {
            function toggleDayOfWeekColumn(fcDay, select) {
              var dayOfWeekColumn = $(".fc-day." + fcDay + " .availability-container"),
                  dayHeader = $(".fc-day-header." + fcDay + " .availability-container");

              deselectDays('cd-day');
              select = typeof select === "boolean" ? select : !dayOfWeekColumn.hasClass("day-selected ci-day");

              if (select) {
                dayOfWeekColumn.addClass("day-selected ci-day");
                dayHeader.addClass("day-selected ci-day");
              } else {
                dayOfWeekColumn.removeClass("day-selected ci-day");
                dayHeader.removeClass("day-selected ci-day");
              }
              updateAvailabilityType();
            }

            if (scope.calendarMode !== scope.calendarModes.PREVIEW) {
              $(".fc-row.fc-widget-header thead th").click(function (e) {
                if (e.target.className === "rotation" && scope.calendarMode === scope.calendarModes.MANAGER) {
                  deselectDays();
                  toggleDayOfWeekColumn($(this)[0].classList[2], true);
                  openEditRotationModal();
                } else {
                  toggleDayOfWeekColumn($(this)[0].classList[2]);
                }
              });
            }

            var headerCells = [
              '<th class="fc-day fc-mon" data-day="monday"></th>',
              '<th class="fc-day fc-tue" data-day="tuesday"></th>',
              '<th class="fc-day fc-wed" data-day="wednesday"></th>',
              '<th class="fc-day fc-thu" data-day="thursday"></th>',
              '<th class="fc-day fc-fri" data-day="friday"></th>',
              '<th class="fc-day fc-sat" data-day="saturday"></th>'
            ];

            if (scope.firstDayOfWeek === 'MONDAY') {
              headerCells.push('<th class="fc-day fc-sun" data-day="sunday"></th>');
            } else {
              headerCells.unshift('<th class="fc-day fc-sun" data-day="sunday"></th>');
            }

            var ciHeader = '<tr class="ci-header">' + headerCells.toString() + '</tr>';
            $(".fc-row.fc-widget-header thead").append(ciHeader);

            $(".ci-header").children()
              .append("<div class='availability-container'>" +
                        "<div class='availability'></div>" +
                        "<div class='preference'></div>" +
                      "</div>");

            if (scope.calendarMode !== scope.calendarModes.PREVIEW) {
              $(".ci-header").children().click(function() {
                toggleDayOfWeekColumn($(this)[0].classList[1]);
              });
            }

            // hide last calendar row with days from the next month
            $(".fc-day-grid .fc-row.fc-week").last().css("display", "none");
          }

          function adjustCIHeaderHeight() {
            var headerHeightDelta = 28,
                thHeight = $(".ci-header th").height() - headerHeightDelta;
            $(".ci-header .availability-container").height(thHeight);
            $(".max-days-header").height(thHeight);
            $(".ci-header .availability-container .preference").css({"position": "absolute", "bottom": "5px"});

            //if (scope.calendarMode === scope.calendarModes.PREVIEW) {
            //  $(".fc-scroller").css("overflow-y", "hidden");
            //  $(".fc-row.fc-widget-header").css({
            //    "margin-right": "0",
            //    "border-right-width": "0"
            //  });
            //  $(window).resize();
            //}
          }

          function toggleView() {
            if (!scope.showAvailability) {
              $(".availability").hide();
            }
            if (!scope.showPreference) {
              $(".preference").hide();
            }
          }

          addAvailabilityContainers();
          addCIHeader();
          displayCITimeFrames();
          displayCDTimeFrames();
          displayRotation();
          adjustCIHeaderHeight();
          toggleView();
        }

        function displayAvailability() {
          if (!scope.availability) return;

          //var firstDayOfWeekInCalendar = moment([scope.monthYearPicker.year, scope.monthYearPicker.month]).startOf('week'),
          //    weekCounter = 0;

          //scope.maxDaysPerWeek = [];
          //
          //_.forIn(scope.availability.maxDaysPerWeek, function(value) {
          //  scope.maxDaysPerWeek.push({
          //    days: value,
          //    initialDays: value,
          //    startDateOfWeek: moment(firstDayOfWeekInCalendar).add(weekCounter, 'weeks').valueOf(),
          //    showActionButtons: false,
          //    update: function() {
          //      var _this = this;
          //      dataService.updateEmployeeMaxDaysPerWeek(scope.employeeId, {weekStartDate: this.startDateOfWeek, maxDays: this.days}).
          //        then(function() {
          //          applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', 'success', true);
          //          _this.initialDays = _this.days;
          //          _this.showActionButtons = false;
          //        }, function(err) {
          //          applicationContext.setNotificationMsgWithValues(err.data, 'danger', true);
          //        });
          //    },
          //    cancel: function() {
          //      this.days = this.initialDays;
          //      this.showActionButtons = false;
          //    }
          //  });
          //  weekCounter++;
          //});

          scope.coupleWeekends = {
            initialValue: scope.availability.coupleWeekends,
            value: scope.availability.coupleWeekends,
            update: function() {
              var _this = this;
              dataService.updateEmployeeCoupleWeekends(scope.employeeId, {coupleWeekends: this.value.toString()}).
                then(function() {
                  applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', 'success', true);
                  _this.initialValue = _this.value;
                }, function(err) {
                  applicationContext.setNotificationMsgWithValues(err.data, 'danger', true);
                });
            },
            cancel: function() {
              this.value = this.initialValue;
            }
          };

          initCalendar();
        }

        function getAvailability(startDate, endDate) {

          if ((scope.calendarMode === scope.calendarModes.MANAGER || scope.calendarMode === scope.calendarModes.PREVIEW) &&
              !scope.employeeId) {
            throw "Availability calendar directive missing employeeId!";
          }

          if (scope.calendarMode === scope.calendarModes.PREVIEW) {
            dataService.getEmployeeAvailabilityPreview(scope.employeeId, {
              workflowRequestId: scope.previewParams.requestId,
              dateRangeStart: startDate,
              dateRangeEnd: endDate
            }).then(function(res) {
              console.log("response", res);
              scope.availability = res.data;
              displayAvailability();
            }, function(err) {
              applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
            });
          } else {
            dataService.getEmployeeAvailabilityView(scope.employeeId, startDate, endDate).
              then(function(res) {
                scope.availability = res.data;
                displayAvailability();
              }, function(err) {
                applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
              });
          }
        }

        scope.$watch('datepicker.model', function(date) {
          if (date && uiCalendarConfig.calendars.availabilityCalendar) {
            var selectedDateInArrFormat = [date.getFullYear(), date.getMonth(), date.getDate()],
              localDate = moment.tz(selectedDateInArrFormat, scope.siteTimeZone),
              currentCalendarDate = uiCalendarConfig.calendars.availabilityCalendar.fullCalendar('getDate');

            if (localDate.format('YYYY-MM') !== currentCalendarDate.format('YYYY-MM')) {
              uiCalendarConfig.calendars.availabilityCalendar.fullCalendar('gotoDate', localDate);

              scope.monthYearPicker = {
                year: date.getFullYear(),
                month: date.getMonth()
              };
            }
          }
        });

        function refreshCalendar(dontQueryAvailability) {
          var firstDayOfMonth, lastDayOfMonth, firstDayInCalendar, lastDayInCalendar;

          if (scope.calendarMode === scope.calendarModes.PREVIEW) {
            firstDayOfMonth = moment([scope.previewParams.year, scope.previewParams.month]);
            lastDayOfMonth = moment(firstDayOfMonth).endOf('month');
            firstDayInCalendar = getFirstDayInCalendar();
            lastDayInCalendar = getLastDayInCalendar();
          } else {
            firstDayOfMonth = moment([scope.monthYearPicker.year, scope.monthYearPicker.month]);
            lastDayOfMonth = moment(firstDayOfMonth).endOf('month');
            firstDayInCalendar = getFirstDayInCalendar();
            lastDayInCalendar = getLastDayInCalendar();
          }

          scope.dateRangeStart = appFunc.getDateWithTimezone(
            firstDayInCalendar.getFullYear(),
            firstDayInCalendar.getMonth(),
            firstDayInCalendar.getDate(),
            scope.siteTimeZone
          ).valueOf();

          scope.dateRangeEnd = appFunc.getDateWithTimezone(
            lastDayInCalendar.getFullYear(),
            lastDayInCalendar.getMonth(),
            lastDayInCalendar.getDate(),
            scope.siteTimeZone
          ).valueOf();

          function getFirstDayInCalendar() {
            return scope.firstDayOfWeek === "SUNDAY" ? moment(firstDayOfMonth).startOf('week').toDate() : moment(firstDayOfMonth).startOf('isoweek').toDate();
          }

          function getLastDayInCalendar() {
            return scope.firstDayOfWeek === "SUNDAY" ? moment(lastDayOfMonth).endOf('week').toDate() : moment(lastDayOfMonth).endOf('isoweek').toDate();
          }

          function getFirstDayOfWeekNumber() {
            return scope.firstDayOfWeek === "SUNDAY" ? 0 : 1;
          }

          scope.config.calendar.firstDay = getFirstDayOfWeekNumber();

          $('.availability-container').not(".rotation-container").remove();
          $('.ci-header').remove();
          $(".fc-row.fc-widget-header thead th").unbind();
          scope.availabilityType = undefined;

          scope.datepicker.model = firstDayOfMonth.toDate();

          if (dontQueryAvailability) {
            displayAvailability();
          } else {
            getAvailability(scope.dateRangeStart, scope.dateRangeEnd);
          }
        }

        var removeTimeZoneListener = scope.$watch("siteTimeZone", function(t) {

          if (t) {
            if (scope.calendarMode === scope.calendarModes.PREVIEW) {
              refreshCalendar();
            } else {
              removeTimeZoneListener();
              scope.$watch("monthYearPicker.month", function() {
                refreshCalendar();
              });
            }
          }
        });

      }
    };
  }
]);


;
angular.module('emlogis.commonDirectives').controller('CopyAvailabilityModal',
  ['$scope', '$modalInstance', '$filter', '$timeout', 'dataService', 'applicationContext',
    'employeeId', 'datesSelected', 'dateRangeStart', 'dateRangeEnd', 'timeZone', 'appFunc',
    function ($scope, $modalInstance, $filter, $timeout, dataService, applicationContext,
              employeeId, datesSelected, dateRangeStart, dateRangeEnd, timeZone, appFunc) {

      $scope.datesToDisplay = _.map(datesSelected, function(d) {
        return moment(d).format("M/D");
      });

      datesSelected = _.map(datesSelected, function(d) {
        var date = moment(d);
        return appFunc.getDateWithTimezone(
          date.year(),
          date.month(),
          date.date(),
          timeZone
        ).getTime();
      });

      $scope.minDate = new Date(datesSelected[0]);
      $scope.maxDate = moment($scope.minDate).add(1, 'y').toDate();
      $scope.datesToDisplay = $scope.datesToDisplay.join(", ");

      $scope.startDate = {
        model: $scope.minDate,
        opened: false,
        open: function($event) {
          $event.preventDefault();
          $event.stopPropagation();
          $scope.startDate.opened = true;
        }
      };
      
      $scope.endDate = {
        model: $scope.maxDate,
        opened: false,
        open: function($event) {
          $event.preventDefault();
          $event.stopPropagation();
          $scope.endDate.opened = true;
        }
      };

      $scope.copyAvailability = true;
      $scope.copyPreference = true;
      $scope.repeatOptions = [{id: "EVERY_WEEK", label: $filter('translate')("availability.EVERY_WEEK")},
                              {id: "EVERY_OTHER_WEEK", label: $filter('translate')("availability.EVERY_OTHER_WEEK")},
                              {id: "EVERY_THIRD_WEEK", label: $filter('translate')("availability.EVERY_THIRD_WEEK")}];
      $scope.repeat = $scope.repeatOptions[0];
      $scope.repeatText = "REPEAT";

      $scope.copyEmployeeAvailability = function() {

        var startDate = appFunc.getDateWithTimezone(
            $scope.startDate.model.getFullYear(),
            $scope.startDate.model.getMonth(),
            $scope.startDate.model.getDate(),
            timeZone
          ).valueOf(),
          endDate = $scope.endDate.model && appFunc.getDateWithTimezone(
              $scope.endDate.model.getFullYear(),
              $scope.endDate.model.getMonth(),
              $scope.endDate.model.getDate(),
              timeZone
            ).valueOf();

        dataService.copyEmployeeAvailability(employeeId, dateRangeStart, dateRangeEnd, {
          selectedDates: datesSelected,
          effectiveStartDate: startDate,
          effectiveEndDate: endDate,
          availability: $scope.copyAvailability,
          preference: $scope.copyPreference,
          repeat: $scope.repeat.id
        }).then(function(res) {
          applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', 'success', true);
          $modalInstance.close(res.data);
        }, function(err) {
          applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
        });
      };

      $scope.cancel = function () {
        $modalInstance.dismiss('cancel');
      };

    }]);
;
angular.module('emlogis.commonDirectives').controller('EditAvailabilityModal',
  ['$scope', '$modalInstance', 'dataService', 'applicationContext', 'managerView', 'employeeId', 'availabilityType',
    'datesSelected', 'dateRangeStart', 'dateRangeEnd', 'timeZone', 'absenceTypes', 'appFunc',
    function ($scope, $modalInstance, dataService, applicationContext, managerView, employeeId, availabilityType,
              datesSelected, dateRangeStart, dateRangeEnd, timeZone, absenceTypes, appFunc) {

      $scope.managerView = managerView;
      $scope.availabilityType = availabilityType;
      $scope.datesToDisplay = "";

      if (managerView) {
        $scope.absenceTypes = absenceTypes;
        $scope.absenceType = absenceTypes[0];
      }

      if (availabilityType === "ci") {
        $scope.datesToDisplay = _.map(datesSelected, function(d) {
          return _.capitalize(d) + "s";
        });
      } else {
        $scope.datesToDisplay = _.map(datesSelected, function(d) {
          return moment(d).format("M/D");
        });
        datesSelected = _.map(datesSelected, function(d) {
          var date = moment(d);
          return appFunc.getDateWithTimezone(
            date.year(),
            date.month(),
            date.date(),
            timeZone
          ).getTime();
        });
      }

      $scope.datesToDisplay = $scope.datesToDisplay.join(", ");

      $scope.startDate = {
        model: new Date(),
        opened: false,
        open: function($event) {
          $event.preventDefault();
          $event.stopPropagation();
          $scope.startDate.opened = true;
        }
      };
      
      $scope.endDate = {
        model: null,
        opened: false,
        open: function($event) {
          $event.preventDefault();
          $event.stopPropagation();
          $scope.endDate.opened = true;
        }
      };

      $scope.action = "AVAILABLE_FOR_DAY";

      $scope.timeFrames = [{
        startTime: moment().hour(8).minute(0).toDate(),
        endTime:  moment().hour(16).minute(0).toDate()
      }];

      registerTimeFrameCorrector(0);

      function registerTimeFrameCorrector(index) {
        $scope.$watch("timeFrames[" + index + "].startTime", function(startTime) {
          if (!startTime) return;
          if ($scope.timeFrames[index].endTime < startTime) {
            $scope.timeFrames[index].endTime = startTime;
          }
        });

        //$scope.$watch("timeFrames[" + index + "].endTime", function(endTime) {
        //  if (!endTime) return;
        //
        //  if (endTime.getHours() === 0 && endTime.getMinutes() === 0) return;
        //
        //  if ($scope.timeFrames[index].startTime > endTime) {
        //    $scope.timeFrames[index].startTime = endTime;
        //  }
        //});
      }

      $scope.addTimeFrame = function() {
        if ($scope.timeFrames.length < 3) {
          $scope.timeFrames.push({
            startTime: moment().hour(8).minute(0).toDate(),
            endTime:  moment().hour(16).minute(0).toDate()
          });
          registerTimeFrameCorrector($scope.timeFrames.length - 1);
        }
      };

      $scope.removeTimeFrame = function(index) {
        $scope.timeFrames.splice(index, 1);
      };

      $scope.updateAvailability = function() {

        var timeFrames = _.map($scope.timeFrames, function(t) {
            return {
              startTime: moment.duration({ minutes: t.startTime.getMinutes(), hours: t.startTime.getHours()}).asMilliseconds(),
              endTime: moment.duration({ minutes: t.endTime.getMinutes(), hours: t.endTime.getHours()}).asMilliseconds()
            };
          }),
          startDate = appFunc.getDateWithTimezone(
            $scope.startDate.model.getFullYear(),
            $scope.startDate.model.getMonth(),
            $scope.startDate.model.getDate(),
            timeZone
          ).valueOf(),
          endDate = $scope.endDate.model && appFunc.getDateWithTimezone(
              $scope.endDate.model.getFullYear(),
              $scope.endDate.model.getMonth(),
              $scope.endDate.model.getDate(),
              timeZone
            ).valueOf();

        if ($scope.managerView) {
          if ($scope.availabilityType === "cd") {
            dataService.updateEmployeeCDAvailability(employeeId, dateRangeStart, dateRangeEnd, {
              action: $scope.action === "PTO" ? "UNAVAILABLE_FOR_DAY" : $scope.action,
              timeFrames: timeFrames,
              selectedDates: datesSelected,
              pto : $scope.action === "PTO",
              absenceTypeId : $scope.absenceType ? $scope.absenceType.id : null
            }).then(function(res) {
              applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', 'success', true);
              $modalInstance.close(res.data);
            }, function(err) {
              var message = err.data.message,
                  employeeAssignedSubstr = "Employee is already assigned to work on",
                  unformattedDate,
                  formattedDate;

              if (_.include(message, employeeAssignedSubstr)) {
                unformattedDate = _.last(_.words(message));
                formattedDate = moment(parseInt(unformattedDate)).format("dddd, MMMM D");
                message = employeeAssignedSubstr + " " + formattedDate;
              }

              applicationContext.setNotificationMsgWithValues(message, 'danger', true);
            });
          }
          else {
            dataService.updateEmployeeCIAvailability(employeeId, dateRangeStart, dateRangeEnd, {
              action: $scope.action,
              timeFrames: timeFrames,
              effectiveStartDate: startDate,
              effectiveEndDate: endDate,
              selectedDays: {
                sunday:     _.contains(datesSelected, "sunday"),
                monday:     _.contains(datesSelected, "monday"),
                tuesday:    _.contains(datesSelected, "tuesday"),
                wednesday:  _.contains(datesSelected, "wednesday"),
                thursday:   _.contains(datesSelected, "thursday"),
                friday:     _.contains(datesSelected, "friday"),
                saturday:   _.contains(datesSelected, "saturday")
              }
            }).then(function(res) {
              applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', 'success', true);
              $modalInstance.close(res.data);
            }, function(err) {
              applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
            });
          }
        } else {
          if ($scope.availabilityType === "cd") {
            dataService.requestAvailabilityChange({
              "type": "AVAILABILITY_REQUEST",
              "submitterId": employeeId,
              "expiration": 0,
              "availUpdate":{
                "type": "AvailcalUpdateParamsCDAvailDto",
                "action": $scope.action,
                timeFrames: timeFrames,
                selectedDates: datesSelected
              }
            }).then(function(res) {
              applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', 'success', true);
              $modalInstance.close(res.data.availCalDto);
            }, function(err) {
              applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
            });
          } else {
            dataService.requestAvailabilityChange({
              "type":"AVAILABILITY_REQUEST",
              "submitterId": employeeId,
              "expiration": 0,
              "availUpdate": {
                "type": "AvailcalUpdateParamsCIAvailDto",
                "action": $scope.action,
                "timeFrames": timeFrames,
                effectiveStartDate: startDate,
                effectiveEndDate: endDate,
                "selectedDays": {
                  "sunday":     _.contains(datesSelected, "sunday"),
                  "monday":     _.contains(datesSelected, "monday"),
                  "tuesday":    _.contains(datesSelected, "tuesday"),
                  "wednesday":  _.contains(datesSelected, "wednesday"),
                  "thursday":   _.contains(datesSelected, "thursday"),
                  "friday":     _.contains(datesSelected, "friday"),
                  "saturday":   _.contains(datesSelected, "saturday")
                }
              }
            }).then(function(res) {
              if (_.isEmpty(res.data.errors)) {
                applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', 'success', true);
                $modalInstance.close(res.data.availCalDto);
              } else {
                applicationContext.setNotificationMsgWithValues(res.data.errors[0].message, 'danger', true);
              }
            }, function(err) {
              applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
            });
          }
        }
      };

      $scope.cancel = function () {
        $modalInstance.dismiss('cancel');
      };

    }]);
;
angular.module('emlogis.commonDirectives').controller('EditPreferenceModal',
  ['$scope', '$modalInstance', 'dataService', 'applicationContext', 'employeeId', 'availabilityType',
    'datesSelected', 'dateRangeStart', 'dateRangeEnd', 'timeZone', 'appFunc',
    function ($scope, $modalInstance, dataService, applicationContext, employeeId, availabilityType,
              datesSelected, dateRangeStart, dateRangeEnd, timeZone, appFunc) {

      $scope.availabilityType = availabilityType;
      $scope.datesSelected = datesSelected;
      $scope.datesToDisplay = "";

      if (availabilityType === "ci") {
        $scope.datesToDisplay = _.map(datesSelected, function(d) {
          return _.capitalize(d) + "s";
        });
      } else {
        $scope.datesToDisplay = _.map(datesSelected, function(d) {
          return moment(d).format("M/D");
        });
        datesSelected = _.map(datesSelected, function(d) {
          var date = moment(d);
          return appFunc.getDateWithTimezone(
            date.year(),
            date.month(),
            date.date(),
            timeZone
          ).getTime();
        });
      }

      $scope.datesToDisplay = $scope.datesToDisplay.join(", ");

      $scope.startDate = {
        model: new Date(),
        opened: false,
        open: function($event) {
          $event.preventDefault();
          $event.stopPropagation();
          $scope.startDate.opened = true;
        }
      };
      
      $scope.endDate = {
        model: null,
        opened: false,
        open: function($event) {
          $event.preventDefault();
          $event.stopPropagation();
          $scope.endDate.opened = true;
        }
      };

      $scope.action = "PREFER_DAY";

      $scope.preferTimeframes = [{
        startTime: moment().hour(8).minute(0).toDate(),
        endTime:  moment().hour(16).minute(0).toDate()
      }];

      $scope.avoidTimeframes = [{
        startTime: moment().hour(8).minute(0).toDate(),
        endTime:  moment().hour(16).minute(0).toDate()
      }];

      registerTimeFrameCorrector("preferTimeframes", 0);
      registerTimeFrameCorrector("avoidTimeframes", 0);

      function registerTimeFrameCorrector(timeFrameName, index) {
        $scope.$watch(timeFrameName + "[" + index + "]" + ".startTime", function(startTime) {
          if (!startTime) return;
          if ($scope[timeFrameName][index].endTime < startTime) {
            $scope[timeFrameName][index].endTime = startTime;
          }
        });

        //$scope.$watch(timeFrameName + "[" + index + "]" + ".endTime", function(endTime) {
        //  if (!endTime) return;
        //
        //  if (endTime.getHours() === 0 && endTime.getMinutes() === 0) return;
        //
        //  if ($scope[timeFrameName][index].startTime > endTime) {
        //    $scope[timeFrameName][index].startTime = endTime;
        //  }
        //});
      }

      $scope.addTimeframe = function(type) {
        var timeframes, timeFrameName;

        if (type === "prefer") {
          timeframes = $scope.preferTimeframes;
          timeFrameName = "preferTimeframes";
        } else {
          timeframes = $scope.avoidTimeframes;
          timeFrameName = "avoidTimeframes";
        }

        if (timeframes.length < 3) {
          timeframes.push({
            startTime: moment().hour(8).minute(0).toDate(),
            endTime:  moment().hour(16).minute(0).toDate()
          });
          registerTimeFrameCorrector(timeFrameName, timeframes.length - 1);
        }
      };

      $scope.removeTimeframe = function(type, index) {
        var timeframes = type === "prefer" ? $scope.preferTimeframes : $scope.avoidTimeframes;
        timeframes.splice(index, 1);
      };

      $scope.updatePreference = function() {

        var avoidTimeFrames, preferTimeFrames;

        if ($scope.action === "preferTimeframe") {
          preferTimeFrames = _.map($scope.preferTimeframes, function(t) {
            return {
              startTime: moment.duration({ minutes: t.startTime.getMinutes(), hours: t.startTime.getHours()}).asMilliseconds(),
              endTime: moment.duration({ minutes: t.endTime.getMinutes(), hours: t.endTime.getHours()}).asMilliseconds()
            };
          });
        }

        if ($scope.action === "avoidTimeframe") {
          avoidTimeFrames = _.map($scope.avoidTimeframes, function(t) {
            return {
              startTime: moment.duration({ minutes: t.startTime.getMinutes(), hours: t.startTime.getHours()}).asMilliseconds(),
              endTime: moment.duration({ minutes: t.endTime.getMinutes(), hours: t.endTime.getHours()}).asMilliseconds()
            };
          });
        }

        if ($scope.availabilityType === "cd") {
          dataService.updateEmployeeCDPreference(employeeId, dateRangeStart, dateRangeEnd, {
            action: ($scope.action === "preferTimeframe" || $scope.action === "avoidTimeframe") ? "TIMEFRAMES" : $scope.action,
            preferTimeFrames: preferTimeFrames,
            avoidTimeFrames: avoidTimeFrames,
            selectedDates: datesSelected
          }).then(function(res) {
            applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', 'success', true);
            $modalInstance.close(res.data);
          }, function(err) {
            applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
          });
        }
        else {
          var startDate = appFunc.getDateWithTimezone(
              $scope.startDate.model.getFullYear(),
              $scope.startDate.model.getMonth(),
              $scope.startDate.model.getDate(),
              timeZone
            ).valueOf(),
            endDate = $scope.endDate.model && appFunc.getDateWithTimezone(
                $scope.endDate.model.getFullYear(),
                $scope.endDate.model.getMonth(),
                $scope.endDate.model.getDate(),
                timeZone
              ).valueOf();
          dataService.updateEmployeeCIPreference(employeeId, dateRangeStart, dateRangeEnd, {
            action: ($scope.action === "preferTimeframe" || $scope.action === "avoidTimeframe") ? "TIMEFRAMES" : $scope.action,
            preferTimeFrames: preferTimeFrames,
            avoidTimeFrames: avoidTimeFrames,
            effectiveStartDate: startDate,
            effectiveEndDate: endDate,
            "selectedDays": {
              "sunday":     _.contains(datesSelected, "sunday"),
              "monday":     _.contains(datesSelected, "monday"),
              "tuesday":    _.contains(datesSelected, "tuesday"),
              "wednesday":  _.contains(datesSelected, "wednesday"),
              "thursday":   _.contains(datesSelected, "thursday"),
              "friday":     _.contains(datesSelected, "friday"),
              "saturday":   _.contains(datesSelected, "saturday")
            }
          }).then(function(res) {
            applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', 'success', true);
            $modalInstance.close(res.data);
          }, function(err) {
            applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
          });
        }
      };

      $scope.cancel = function () {
        $modalInstance.dismiss('cancel');
      };

    }]);
;
angular.module('emlogis.commonDirectives').controller('EditRotationModal',
  ['$scope', '$modalInstance', 'dataService', 'dateRangeStart', 'dateRangeEnd', 'applicationContext', 'employeeId', 'selectedDay',
    function ($scope, $modalInstance, dataService, dateRangeStart, dateRangeEnd, applicationContext, employeeId, selectedDay) {

      $scope.selectedDay = _.capitalize(selectedDay) + "s";
      $scope.rotation = "NONE";

      $scope.updateWeekdayRotation = function() {
        dataService.updateWeekdayRotation(employeeId, dateRangeStart, dateRangeEnd, {
          dayOfWeek: selectedDay.toUpperCase(),
          weekdayRotationValue: $scope.rotation
        }).then(function() {
          applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', 'success', true);
          $modalInstance.close("updated");
        }, function(err) {
          applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
          $modalInstance.dismiss('cancel');
        });
      };

      $scope.cancel = function () {
        $modalInstance.dismiss('cancel');
      };

  }]);
;
(function () {
  "use strict";

  //
  // This directive is build upon
  // Bootstrap component Panel (.panel)
  // and Bootstrap UI component Collapse (ui.bootstrap.collapse)

  var collapsablePanel = function () {

    return {
      restrict: 'EA',
      replace: true,
      scope: {
        isCollapsable: '=',
        isCollapsed: '=',
        name: '='
      },
      transclude: true,
      templateUrl: 'modules/common/partials/collapsable-panel.tmpl.html',
      link: function(scope, element, attrs, controller, transclude){
        //console.log('+++ Inside Collapsable Panel directive...');

        //
        // Watch for
        // Panel changes its collapsing state
        // to change the collapsing icon

        scope.$watch('isCollapsed', function(newValue) {
          if ( newValue ) {                                                       // If Panel becomes collapsed
            element.find('.collapse-icon-minus').css('opacity', '0')              // hide "minus" icon
                   .parent()
                   .find('.collapse-icon-plus').css('opacity','1');               // and display "plus" icon
            element.find('.panel-heading').css('background-color', '#fff');       // make panel heading white
          } else {                                                                // If Panel becomes open
            element.find('.collapse-icon-plus').css('opacity', '0')               // hide "plus" icon
                   .parent()
                   .find('.collapse-icon-minus').css('opacity','1');              // and display "minus" icon
            element.find('.panel-heading').css('background-color', '#f5f5f5');    // make panel heading grey
          }
        }, true);


        //
        // Custom transclusion
        // for 2 transcluded  areas:
        // Panel Body and addition to Panel Header (optional)

        transclude(function(clone){
          angular.forEach(clone, function(cloneEl){
            if (cloneEl.nodeType === 1 && cloneEl.attributes['transclude-to']){

              var tId = cloneEl.attributes['transclude-to'].value;                // get desired target id
              var target = element.find('[transclude-id="' + tId + '"]');         // find target element with this id
              target.append(cloneEl);                                             // append element to target
            }
          });
        });


        //
        // Avoid collapsing a Panel
        // on a .checkbox click in its header

        $('.eml-panel-header-right').find('.fa, .checkbox, .checkbox-inline').on('click', function(e){
          e.stopPropagation();
        });
      }
    };
  };


  collapsablePanel.$inject = [];
  angular.module('emlogis.commonDirectives').directive('collapsablePanel', collapsablePanel);

}());
;
angular.module('emlogis.commonDirectives').directive('dashboardCalendar', ['$modal', '$timeout', '$filter', 'uiCalendarConfig', 'applicationContext', 'loadDisplay', 'wsService',
  function ($modal, $timeout, $filter, uiCalendarConfig, applicationContext, loadDisplay, wsService) {

    return {
      restrict: 'E',
      scope: {
        getAccountInfo: '&',
        getShifts: '&',
        managerView: '=',
        getEligibleEntities: '&',
        getOpenShifts: '&',
        submitSelectedEligibleEntities: '&',
        submitSelectedOpenShifts: '&',
        submitPtoRequest: '&'
      },
      controller: function($scope) {
        $scope.shiftsLoaded = false;
        $scope.shiftsSource = [];
        $scope.ticksInfo = [];
        $scope.requestsInfo = [];
        $scope.accountInfo = {};
        $scope.selectedDate = null;
        $scope.datePickerOpened = false;
        $scope.syncCalendarToolTip = 'Synch your calendar with your email apps like iCalendar, Outlook, or Gmail.';

        $scope.openDatePicker = function($event) {
          $event.preventDefault();
          $event.stopPropagation();
          $scope.datePickerOpened = true;
        };

        $scope.datePickerOptions = {
          formatYear: 'yyyy',
          startingDay: 1
        };

        $scope.openSyncCalendarPopup = function() {
          $modal.open({
            templateUrl: 'syncCalendarPopupModal.html',
            controller: 'SyncCalendarPopupModalInstanceCtrl',
            windowClass: 'sync-calendar-modal',
            resolve: {
              calendarSyncUrl: function() {
                var fullUrl = 'webcal://';
                fullUrl += location.host + '/scheduler-server/emlogis' + $scope.accountInfo.calendarSyncUrl;

                return fullUrl;
              }
            }
          });
        };

        $scope.populateShiftsSource = function(responseData) {
          var shift = {};
          var teams = $scope.accountInfo.teams;
          var className = '';
          var localTodayDate = moment.tz(new Date(), $scope.accountInfo.timezone);
          localTodayDate.hours(0);
          localTodayDate.minutes(0);
          localTodayDate.seconds(0);
          localTodayDate.milliseconds(0);
          var todayStartTime = localTodayDate.unix() * 1000;
          var todayEndTime = todayStartTime + 24 * 3600 * 1000;
          angular.forEach(responseData.shifts.result, function(row) {
            var typeStr = '';
            if (row[3] === true) {
              typeStr = 'extra';
            } else if (row[3] === false) {
              typeStr = 'regular';
            } else {
              typeStr = 'overtime';
            }
            if (row[1] < todayStartTime) {
              className = 'fc-past';
            } else if (row[1] > todayEndTime) {
              className = 'fc-future';
            } else {
              className = 'fc-today';
            }
            shift = {
              id: row[0],
              title: 'Shift',
              start: moment.tz(row[1], $scope.accountInfo.timezone),
              end: moment.tz(row[2], $scope.accountInfo.timezone),
              type: typeStr,
              skillAbbrev: row[4],
              skill: row[5],
              assignment: '',
              team: row[6],
              comment: row[7],
              className: className
            };
            var findTeam = _.find(teams, function(team) { return team.name === row[6]; });
            if (typeof findTeam === 'undefined') {
              shift.isHomeTeam = false;
            } else {
              shift.isHomeTeam = findTeam.isHomeTeam;
            }
            $scope.shiftsSource.push(shift);
          });
          angular.forEach(responseData.empUnavailabilities, function(empUnavailability) {
            shift = {
              title: 'PTO Vacation',
              start: moment.tz(empUnavailability.startDate, $scope.accountInfo.timezone),
              end: moment.tz(empUnavailability.endDate, $scope.accountInfo.timezone),
              className: 'pto-vacation-container',
              type: 'pto-vacation',
              status: empUnavailability.status || ""
            };
            $scope.shiftsSource.push(shift);
          });
          angular.forEach(responseData.orgHolidays, function(orgHoliday) {
            shift = {
              title: 'Company Holiday',
              name: orgHoliday.name,
              start: moment.tz(orgHoliday.startDate, $scope.accountInfo.timezone),
              end: moment.tz(orgHoliday.endDate, $scope.accountInfo.timezone),
              className: 'company-holiday-container',
              type: 'company-holiday'
            };
            $scope.shiftsSource.push(shift);
          });
        };

        $scope.populateOpenShiftsTicks = function(responseData) {
          var tickInfo = {};

          angular.forEach(responseData.openShiftsByDays, function(shiftsNumber, shiftsDuration) {
            var startDateInMilliseconds = parseInt(shiftsDuration.substring(0, shiftsDuration.indexOf('-')));
            var endDateInMilliseconds = parseInt(shiftsDuration.substring(shiftsDuration.indexOf('-') + 1));
            tickInfo = {
              title: 'OS ' + shiftsNumber,
              date: moment.tz(startDateInMilliseconds, $scope.accountInfo.timezone).format('YYYY-MM-DD'),
              start: startDateInMilliseconds,
              end: endDateInMilliseconds,
              className: 'open-shifts-tick-container',
              openShiftsNumber: shiftsNumber
            };
            $scope.ticksInfo.push(tickInfo);
          });
        };

        $scope.populateRequestsInfo = function(responseData) {
          var requestInfo = {};

          angular.forEach(responseData.submittedWipSwapRequestInfos, function(info) {
            if (info.requestStatus !== 'PEER_PENDING' && info.requestStatus !== 'ADMIN_PENDING') {
              return;
            }
            var originatorShift = _.find(responseData.shifts.result, function(iterator) {
              return (iterator[0] === info.shiftId);
            });
            if (typeof originatorShift === 'undefined' || originatorShift === null) {
              console.log('------------Submitted shift is no longer available.-------------\n');
              console.log(info);
              return;
            }
            requestInfo = {
              type: 'submitted-wip-swap-request',
              title: (info.requestType === 'SHIFT_SWAP_REQUEST')? 'SWAP->': 'WIP->',
              subType: (info.requestType === 'SHIFT_SWAP_REQUEST')? 'submitted-swap-request': 'submitted-wip-request',
              date: moment.tz(originatorShift[1], $scope.accountInfo.timezone).format('YYYY-MM-DD'),
              originatorShiftId: originatorShift[0],
              className: 'submitted-wip-swap-info'
            };
            $scope.requestsInfo.push(requestInfo);
          });

          angular.forEach(responseData.peerSwapRequestInfos, function(info) {
            if (info.peerStatus !== 'PEER_PENDING' && info.peerStatus !== 'PEER_APPROVED') {
              return;
            }
            var peerShift = _.find(responseData.shifts.result, function(iterator) {
              return (iterator[0] === info.peerShiftId);
            });
            if (typeof peerShift === 'undefined' || peerShift === null) {
              console.log('------------Peer swap requested shift is no longer available.-------------\n');
              console.log(info);
              return;
            }
            requestInfo = {
              type: 'peer-swap-request',
              title: 'SWAP<-',
              date: moment.tz(peerShift[1], $scope.accountInfo.timezone).format('YYYY-MM-DD'),
              peerShiftId: peerShift[0],
              className: 'peer-swap-info'
            };
            $scope.requestsInfo.push(requestInfo);
          });

          angular.forEach(responseData.peerWipRequestInfos, function(info) {
            if (info.peerStatus !== 'PEER_PENDING' && info.peerStatus !== 'PEER_APPROVED') {
              return;
            }
            requestInfo = {
              type: 'peer-wip-request',
              title: 'WIP<-',
              date: moment.tz(info.submitterShiftStartDateTime, $scope.accountInfo.timezone).format('YYYY-MM-DD'),
              className: 'peer-wip-info'
            };
            $scope.requestsInfo.push(requestInfo);
          });

          angular.forEach(responseData.submittedTimeOffRequestInfos, function(info) {
            if (info.requestStatus !== 'PEER_PENDING' && info.requestStatus !== 'ADMIN_PENDING') {
              return;
            }
            requestInfo = {
              type: 'submitted-time-off-request',
              title: 'Time Off',
              date: moment.tz(info.requestDate, $scope.accountInfo.timezone).format('YYYY-MM-DD'),
              className: 'submitted-time-off-info'
            };
            $scope.requestsInfo.push(requestInfo);
          });

          angular.forEach(responseData.submittedOsRequestInfos, function(info) {
            if (info.requestStatus !== 'PEER_PENDING' && info.requestStatus !== 'ADMIN_PENDING') {
              return;
            }
            requestInfo = {
              type: 'submitted-os-request',
              title: 'OS',
              date: moment.tz(info.requestDate, $scope.accountInfo.timezone).format('YYYY-MM-DD'),
              className: 'submitted-os-info'
            };
            $scope.requestsInfo.push(requestInfo);
          });
        };

        $scope.renderOpenShiftsTicks = function() {
          $('.date-header-os-tick').remove();
          angular.forEach($scope.ticksInfo, function(tickInfo) {
            var date = tickInfo.date;
            var dateHeaderElement = $('.fc-day-number[data-date="' + date + '"]');
            var dateText = moment.tz(date, $scope.accountInfo.timezone).format('D');
            var innerHTML = '';

            if (dateHeaderElement.children('.date-header-val').length === 0) {
              innerHTML = '<div class="date-header-val">' + dateText + '</div>';
              dateHeaderElement.html(innerHTML);
            }

            innerHTML = '<div class="date-header-os-tick text-right"><span class="open-shifts-tick">' +
              '<a id="os-link-' + date + '" href>' + tickInfo.title + '</a></span></div>';
            dateHeaderElement.append(innerHTML);

            angular.element('#os-link-' + date).click(function(e) {
              e.preventDefault();
              angular.element(this).scope().openRequestOpenShiftsModal(tickInfo.start, tickInfo.end);
            });
          });
        };

        $scope.renderRequestsInfo = function() {
          // Prepare rendering data
          var requestsInfo = {};
          angular.forEach($scope.requestsInfo, function(requestInfo) {
            if (typeof requestsInfo[requestInfo.date] === 'undefined') {
              requestsInfo[requestInfo.date] = {};
            }
            if (requestInfo.type === 'submitted-wip-swap-request') {
              if (typeof requestsInfo[requestInfo.date][requestInfo.subType] === 'undefined') {
                requestsInfo[requestInfo.date][requestInfo.subType] = [requestInfo.originatorShiftId];
              } else {
                if (requestsInfo[requestInfo.date][requestInfo.subType].indexOf(requestInfo.originatorShiftId) < 0) {
                  requestsInfo[requestInfo.date][requestInfo.subType].push(requestInfo.originatorShiftId);
                }
              }
            } else if (requestInfo.type === 'peer-swap-request') {
              if (typeof requestsInfo[requestInfo.date][requestInfo.type] === 'undefined') {
                requestsInfo[requestInfo.date][requestInfo.type] = [requestInfo.peerShiftId];
              } else {
                if (requestsInfo[requestInfo.date][requestInfo.type].indexOf(requestInfo.peerShiftId) < 0) {
                  requestsInfo[requestInfo.date][requestInfo.type].push(requestInfo.peerShiftId);
                }
              }
            } else {
              requestsInfo[requestInfo.date][requestInfo.type] = true;
            }
          });

          // Draw actual requests info
          $('.date-header-requests-info').remove();
          angular.forEach(requestsInfo, function(dateRequestsInfo, date) {
            var dateHeaderElement = $('.fc-day-number[data-date="' + date + '"]');
            var dateText = moment.tz(date, $scope.accountInfo.timezone).format('D');
            var dateTableElement = dateHeaderElement.parent().parent().parent();
            var innerHTML = '';

            // Date header requests info rendering
            if (dateHeaderElement.children('.date-header-val').length === 0) {
              innerHTML = '<div class="date-header-val">' + dateText + '</div>';
              dateHeaderElement.html(innerHTML);
            }

            innerHTML = '<div class="date-header-requests-info text-center"></div>';
            dateHeaderElement.children('.date-header-val').after(innerHTML);

            innerHTML = '';
            if (dateRequestsInfo['peer-wip-request']) {
              innerHTML += '<span class="peer-wip-request request-icon-container"><img src="/scheduler-server/emlogis/img/peer-wip-request.svg" width="18"></span>';
            }
            if (dateRequestsInfo['submitted-os-request']) {
              innerHTML += '<span class="submitted-os-request request-icon-container"><img src="/scheduler-server/emlogis/img/submitted-os-request.svg" width="18"></span>';
            }
            if (dateRequestsInfo['submitted-time-off-request']) {
              innerHTML += '<span class="submitted-time-off-request request-icon-container"><img src="/scheduler-server/emlogis/img/submitted-time-off-request.svg" width="18"></span>';
            }
            dateHeaderElement.children('.date-header-requests-info').html(innerHTML);

            // Date body requests info rendering
            $timeout(function() {
              if (typeof dateRequestsInfo['submitted-swap-request'] !== 'undefined') {
                angular.forEach(dateRequestsInfo['submitted-swap-request'], function(originatorShiftId) {
                  var originatorShiftElement = dateTableElement.find('.' + originatorShiftId);
                  var originalShiftRequestInfoElement = originatorShiftElement.find('.fc-request-info');
                  originalShiftRequestInfoElement.append('<span class="submitted-swap-request request-icon-container"><img src="/scheduler-server/emlogis/img/submitted-swap-request.svg" width="18"></span>');
                });
              }
              if (typeof dateRequestsInfo['submitted-wip-request'] !== 'undefined') {
                angular.forEach(dateRequestsInfo['submitted-wip-request'], function(originatorShiftId) {
                  var originatorShiftElement = dateTableElement.find('.' + originatorShiftId);
                  var originalShiftRequestInfoElement = originatorShiftElement.find('.fc-request-info');
                  originalShiftRequestInfoElement.append('<span class="submitted-wip-request request-icon-container"><img src="/scheduler-server/emlogis/img/submitted-wip-request.svg" width="18"></span>');
                });
              }
              if (typeof dateRequestsInfo['peer-swap-request'] !== 'undefined') {
                angular.forEach(dateRequestsInfo['peer-swap-request'], function(peerShiftId) {
                  var peerShiftElement = dateTableElement.find('.' + peerShiftId);
                  var peerShiftRequestInfoElement = peerShiftElement.find('.fc-request-info');
                  peerShiftRequestInfoElement.append('<span class="peer-swap-request request-icon-container"><img src="/scheduler-server/emlogis/img/peer-swap-request.svg" width="18"></span>');
                });
              }
            }, 500);
          });
        };

        $scope.initializeShifts = function() {
          var selectedMonthFirstDateInArrFormat = [$scope.selectedDate.getFullYear(), $scope.selectedDate.getMonth(), 1];
          var localSelectedMonthFirstDate = moment.tz(selectedMonthFirstDateInArrFormat, $scope.accountInfo.timezone);
          var nextMonthFirstDateInArrFormat = [$scope.selectedDate.getFullYear(), $scope.selectedDate.getMonth() + 1, 1];
          var localNextMonthFirstDate = moment.tz(nextMonthFirstDateInArrFormat, $scope.accountInfo.timezone);

          var startDate = localSelectedMonthFirstDate.subtract(7, 'days').unix() * 1000;
          var endDate = localNextMonthFirstDate.add(7, 'days').unix() * 1000;

          $scope.shiftsSource = [];
          $scope.ticksInfo = [];
          $scope.requestsInfo = [];
          $scope.getShifts({startDate: startDate, endDate: endDate}).then(function(response) {
            uiCalendarConfig.calendars.dashboardCalendar.fullCalendar('removeEvents');

            // Populate Data
            $scope.populateShiftsSource(response.data);
            $scope.populateOpenShiftsTicks(response.data);
            $scope.populateRequestsInfo(response.data);

            $scope.shiftsLoaded = true;

            // Render Data
            angular.forEach($scope.shiftsSource, function(shift) {
              uiCalendarConfig.calendars.dashboardCalendar.fullCalendar('renderEvent', shift);
            });
            $scope.renderOpenShiftsTicks();
            $scope.renderRequestsInfo();

            $timeout(function() {
              $scope.styleShifts();
            }, 0);
          }, function(err) {
            uiCalendarConfig.calendars.dashboardCalendar.fullCalendar('removeEvents');
            var message = err.data.message || JSON.stringify(err.data);
            applicationContext.setNotificationMsgWithValues(message, 'danger', true);
          }).finally(function() {
            uiCalendarConfig.calendars.dashboardCalendar.fullCalendar('unselect');
            $(window).resize();
          });
        };

        $scope.styleShifts = function() {
          var fillBackgroundOfElements = function(containerType) {
            var containerElements = angular.element('.' + containerType);
            angular.forEach(containerElements, function(container) {
              var classList = container.classList;
              var dateClass = _.find(classList, function(classItem) { return classItem.indexOf('shift-start-') > -1; });
              var shiftStartDate = dateClass.substring(12);
              var bgElement = container.parentElement.parentElement.parentElement.parentElement.parentElement.parentElement.children[0];
              var matchingBg = _.find(bgElement.children[0].children[0].children[0].children, function(child) {
                return child.getAttribute('data-date') === shiftStartDate;
              });
              if (typeof matchingBg !== 'undefined' && matchingBg !== null) {
                matchingBg.className = matchingBg.className + ' ' + containerType + '-bg';
              }
            });
          };
          fillBackgroundOfElements('company-holiday-container');
          fillBackgroundOfElements('pto-vacation-container');

          var positionCompanyHolidays = function() {
            var containerElements = angular.element('.company-holiday-container');
            angular.forEach(containerElements, function(container) {
              var tr = container.parentElement.parentElement;
              //TODO: This is a quick fix to the NPE but this code needs to be changed for the 
              //correct one in order to keep the old beheavior.
              if(tr.offsetParent){
	              var trOffsetTop = tr.offsetTop;
	              var cellHeight = angular.element(tr.offsetParent.parentElement.parentElement).height();
	              var offsetTop = cellHeight - trOffsetTop - 59;
	              container.style.top = offsetTop + 'px';
	              container.style.left = '0';
              }
            });
          };
          positionCompanyHolidays();
        };

        $scope.requestTimeOff = function() {
          var modalInstance = $modal.open({
            templateUrl: 'ptoRequestPopupModal.html',
            controller: 'PtoRequestPopupModalInstanceCtrl',
            windowClass: 'pto-request-modal',
            resolve: {
              siteId: function() {
                return $scope.accountInfo.siteId;
              },
              timezone: function() {
                return $scope.accountInfo.timezone;
              }
            }
          });

          modalInstance.result.then(function(modalResult) {
            var results = [];

            $scope.submitPtoRequest({requestData: modalResult.ptoRequest}).then(function(response) {
              angular.forEach(response.data.data.errors, function(error) {
                var identifier = error.identifier;
                var dateVal = moment.tz(parseInt(identifier.substr(5)), $scope.accountInfo.timezone).format('YYYY-MM-DD');
                var message = dateVal + ': ' + $filter('translate')("home.ERROR_OCCURRED");
                results.push({identifier: identifier, message: message});
              });

              angular.forEach(response.data.data.created, function(createdItem) {
                var identifier = createdItem.identifier;
                var dateVal = moment.tz(parseInt(identifier.substr(5)), $scope.accountInfo.timezone).format('YYYY-MM-DD');
                var requestStatusMessage = $filter('translate')("app." + createdItem.requestStatus);
                var message = dateVal + ': ' + requestStatusMessage;
                results.push({identifier: identifier, message: message});
              });

              hideFutureMonthWeeks();
              $scope.initializeShifts();
              $scope.applyTodayStyle('.fc-bg');
              $scope.applyTodayStyle('.fc-content-skeleton');
              $modal.open({
                templateUrl: 'actionResultPopupModal.html',
                controller: 'ActionResultPopupModalInstanceCtrl',
                windowClass: 'action-result-modal',
                resolve: {
                  results: function() {
                    return results;
                  }
                }
              });
            }, function(err) {
              var message = err.data.message || JSON.stringify(err.data);
              applicationContext.setNotificationMsgWithValues(message, 'danger', true);
            });
          });
        };

        $scope.openRequestOpenShiftsModal = function(start, end) {
          var tickInfo = {
            start: start,
            end: end
          };

          var modalInstance = $modal.open({
            templateUrl: 'openShiftsPopupModal.html',
            controller: 'OpenShiftsPopupModalInstanceCtrl',
            size: 'lg',
            windowClass: 'open-shifts-modal',
            resolve: {
              tickInfo: function() {
                return tickInfo;
              },
              getOpenShifts: function() {
                return $scope.getOpenShifts;
              },
              timezone: function() {
                return $scope.accountInfo.timezone;
              }
            }
          });
          modalInstance.result.then(function(modalResult) {
            var results = [];
            var promise = $scope.submitSelectedOpenShifts({tickInfo: tickInfo, selectedOpenShifts: modalResult.selectedOpenShifts});

            loadDisplay.addDisplay(promise, "Please wait...");
            promise.then(function(response) {
              angular.forEach(response.data.data.errors, function(error) {
                var identifier = error.identifier;
                var openShiftId = identifier.substr(8);
                var errorOpenShift = _.find(modalResult.selectedOpenShifts, 'shiftId', openShiftId);
                var message = errorOpenShift.date + ' ' + errorOpenShift.shift + ' ' + errorOpenShift.team + ' ' + errorOpenShift.skill + ': ' + $filter('translate')("home.ERROR_OCCURRED");
                results.push({identifier: identifier, message: message});
              });

              angular.forEach(response.data.data.created, function(createdItem) {
                var identifier = createdItem.identifier;
                var openShiftId = identifier.substr(8);
                var openShiftItem = _.find(modalResult.selectedOpenShifts, 'shiftId', openShiftId);
                var requestStatusMessage = $filter('translate')("app." + createdItem.requestStatus);
                var message = openShiftItem.date + ' ' + openShiftItem.shift + ' ' + openShiftItem.team + ' ' + openShiftItem.skill + ': ' + requestStatusMessage;
                results.push({identifier: identifier, message: message});
              });

              hideFutureMonthWeeks();
              $scope.initializeShifts();
              $scope.applyTodayStyle('.fc-bg');
              $scope.applyTodayStyle('.fc-content-skeleton');
              $modal.open({
                templateUrl: 'actionResultPopupModal.html',
                controller: 'ActionResultPopupModalInstanceCtrl',
                windowClass: 'action-result-modal',
                resolve: {
                  results: function() {
                    return results;
                  }
                }
              });
            }, function(error) {
              applicationContext.setNotificationMsgWithValues(JSON.stringify(error.data), 'danger', true);
            });
          });
        };

        $scope.onShiftClick = function(shift, jsEvent, view) {
          if (shift.className.indexOf('fc-past') > -1 ||
            shift.type === 'pto-vacation' || shift.type === 'company-holiday') {
            return;
          }

          var modalInstance = $modal.open({
            templateUrl: 'manageShiftPopupModal.html',
            controller: 'ManageShiftPopupModalInstanceCtrl',
            size: 'lg',
            windowClass: 'manage-shift-modal',
            resolve: {
              originatorShift: function () {
                return shift;
              },
              getEligibleEntities: function() {
                return $scope.getEligibleEntities;
              },
              timezone: function() {
                return $scope.accountInfo.timezone;
              }
            }
          });
          modalInstance.result.then(function(modalResult) {
            var promise = $scope.submitSelectedEligibleEntities({tabType: modalResult.tabType, originatorShift: shift, selectedEligibleEntities: modalResult.selectedEligibleEntities});

            loadDisplay.addDisplay(promise, "Please wait...");
            promise.then(function(response) {
              var tabTypeMessage = '';
              var message = '';
              if (modalResult.tabType === 'swap') {
                tabTypeMessage = $filter('translate')('home.SHIFT_SWAP_REQUEST');
              } else if (modalResult.tabType === 'wip') {
                tabTypeMessage = $filter('translate')('home.WORK_IN_PLACE_REQUEST');
              }
              if (response.data.data.errors.length > 0) {
                message = tabTypeMessage + ': ' + $filter('translate')("home.ERROR_OCCURRED");
                applicationContext.setNotificationMsgWithValues(message, 'danger', true);
              } else {
                message = tabTypeMessage + ': ' + response.data.data.created[0].requestStatus;
                applicationContext.setNotificationMsgWithValues(message, 'success', true);
              }

              hideFutureMonthWeeks();
              $scope.initializeShifts();
              $scope.applyTodayStyle('.fc-bg');
              $scope.applyTodayStyle('.fc-content-skeleton');
            }, function(error) {
              applicationContext.setNotificationMsgWithValues(JSON.stringify(error.data), 'danger', true);
            });
          });
        };

        $scope.eventRender = function(event, element, view) {
          var innerHTML = '';
          var simpleDateStr = event.start.format('YYYY-MM-DD');
          var shift = event;

          if (shift.type === 'company-holiday') {
            element.parent().css('position', 'relative');
            element.css('position', 'absolute');
            element.addClass('shift-start-' + simpleDateStr);
            innerHTML = '<div class="fc-content fc-content-type-' + shift.type + '"><div class="fc-title">' +
              shift.title + '</div><div class="fc-name">' + shift.name + '</div></div>';
          } else if (shift.type === 'pto-vacation') {
            element.addClass('shift-start-' + simpleDateStr);
            innerHTML = '<div class="fc-content fc-content-type-' + shift.type + '"><div class="fc-title">' +
              shift.title + '</div><div class="fc-status">' + shift.status + '</div></div>';
          } else {
            var shiftTypeLabel;
            var startTime = moment.tz(shift.start, $scope.accountInfo.timezone);
            var endTime = moment.tz(shift.end, $scope.accountInfo.timezone);
            var startTimeLabel = '';
            var endTimeLabel = '';
            var hasComment = (typeof shift.comment !== 'undefined' && shift.comment !== null)? 'has-comment': '';

            if (shift.type === 'regular') {
              shiftTypeLabel = '';
            } else if (shift.type === 'extra') {
              shiftTypeLabel = 'Extra';
            } else if (shift.type === 'overtime') {
              shiftTypeLabel = 'OT';
            }

            if (startTime.minutes() > 0) {
              startTimeLabel = startTime.format('h:mma');
            } else {
              startTimeLabel = startTime.format('ha');
            }
            startTimeLabel = startTimeLabel.substr(0, startTimeLabel.length - 1);
            if (endTime.minutes() > 0) {
              endTimeLabel = endTime.format('h:mma');
            } else {
              endTimeLabel = endTime.format('ha');
            }
            endTimeLabel = endTimeLabel.substr(0, endTimeLabel.length - 1);

            var dateLabel = startTime.format('YYYY-MM-DD');
            var titleStr = '';
            if (typeof shift.comment !== 'undefined' && shift.comment !== null) {
              titleStr = ' title="' + shift.comment + '"';
            }
            innerHTML = '<div' + titleStr + ' class="fc-content fc-content-type-' + shift.type + ' ' + dateLabel + ' ' + shift.id + ' ' + hasComment + '"><div class="fc-info-block fc-info-block-normal"><div class="fc-time-type-skill fc-info-row"><span class="fc-time">' + startTimeLabel + '-' + endTimeLabel +
              '</span><span class="fc-type"> ' + shiftTypeLabel + '</span><span class="fc-skill">' + shift.skillAbbrev + '</span></div><div class="fc-assignment fc-info-row">' + shift.assignment +
              '</div></div><div class="fc-info-block fc-info-block-highlight"><div class="fc-team fc-info-row"><i class="fa fa-home team-home-' + shift.isHomeTeam + '"></i> ' + shift.team + '</div></div><div class="fc-request-info text-center"></div></div>';
          }

          element.html(innerHTML);
        };

        $scope.applyTodayStyle = function(selector) {
          var localTodayDate = moment.tz(new Date(), $scope.accountInfo.timezone);
          var localTodayDateStr = localTodayDate.format('YYYY-MM-DD');
          var bgTaggedAsToday = angular.element(selector + ' .fc-today');
          if (bgTaggedAsToday.length > 0) {
            if (new Date(bgTaggedAsToday.attr('data-date')) < new Date(localTodayDateStr)) {
              bgTaggedAsToday.removeClass('fc-today');
              bgTaggedAsToday.removeClass('fc-state-highlight');
              bgTaggedAsToday.addClass('fc-past');
            } else if (new Date(bgTaggedAsToday.attr('data-date')) > new Date(localTodayDateStr)) {
              bgTaggedAsToday.removeClass('fc-today');
              bgTaggedAsToday.removeClass('fc-state-highlight');
              bgTaggedAsToday.addClass('fc-future');
            }
          }
          _.forEach(angular.element(selector), function(rowBg) {
            var todayBg = _.find(rowBg.children[0].children[0].children[0].children, function(dayBg) {
              return dayBg.getAttribute('data-date') === localTodayDateStr;
            });
            if (typeof todayBg !== 'undefined' && todayBg !== null) {
              todayBg.classList.remove('fc-past');
              todayBg.classList.remove('fc-future');
              todayBg.classList.add('fc-today');
              todayBg.classList.add('fc-state-highlight');
              if (selector === '.fc-bg') {
                todayBg.style['background-color'] = '#fff';
                todayBg.style['box-shadow'] = '0 0 40px #555';
              }
              return false;
            }
          });
        };

        $scope.calendarConfig = {
          calendar: {
            height: 1011,
            header:{
              left: 'title',
              center: '',
              right: ''
            },
            eventClick: $scope.managerView ? function() {} : $scope.onShiftClick,
            eventRender: $scope.eventRender
          }
        };

        var hideFutureMonthWeeks = function() {
          var weekRows = angular.element('.fc-widget-content .fc-week');
          angular.forEach(weekRows, function(weekRow) {
            var futureMonthElements = angular.element(weekRow).children('.fc-bg').find('.fc-other-month');
            if (futureMonthElements.length === 7) {
              angular.element(weekRow).css('display', 'none');
            }
          });
        };

        $scope.drawCalendar = function() {
          if (typeof uiCalendarConfig.calendars.dashboardCalendar !== 'undefined' && uiCalendarConfig.calendars.dashboardCalendar !== null) {
            if (typeof $scope.selectedDate !== 'undefined' && $scope.selectedDate !== null) {
              var selectedDateInArrFormat = [$scope.selectedDate.getFullYear(), $scope.selectedDate.getMonth(), $scope.selectedDate.getDate()];
              var localDate = moment.tz(selectedDateInArrFormat, $scope.accountInfo.timezone);
              var currentCalendarDate = uiCalendarConfig.calendars.dashboardCalendar.fullCalendar('getDate');
              if (!$scope.shiftsLoaded || localDate.format('YYYY-MM') !== currentCalendarDate.format('YYYY-MM')) {
                $scope.shiftsLoaded = false;
                uiCalendarConfig.calendars.dashboardCalendar.fullCalendar('gotoDate', localDate);

                hideFutureMonthWeeks();
                $scope.initializeShifts();
                $scope.applyTodayStyle('.fc-bg');
                $scope.applyTodayStyle('.fc-content-skeleton');
              }
            }
          }
        };

        $scope.$watch('selectedDate', $scope.drawCalendar);

        $scope.$watch('shiftsLoaded', function(newValue) {
          if (newValue) {
            angular.element('.fc-prev-button').prop('disabled', false);
            angular.element('.fc-next-button').prop('disabled', false);
          } else {
            angular.element('.fc-prev-button').prop('disabled', true);
            angular.element('.fc-next-button').prop('disabled', true);
          }
        });
      },
      link: function(scope, element, attrs) {
        function parseShift(shift) {
          var shiftObj = {};
          var teams = scope.accountInfo.teams;
          var typeStr = '';
          var className = '';
          var localTodayDate = moment.tz(new Date(), scope.accountInfo.timezone);
          localTodayDate.hours(0).minutes(0).seconds(0).milliseconds(0);
          var todayStartTime = localTodayDate.unix() * 1000;
          var todayEndTime = todayStartTime + 24 * 3600 * 1000;

          if (shift.excess) {
            typeStr = 'extra';
          } else {
            typeStr = 'regular';
          }

          if (shift.startDateTime < todayStartTime) {
            className = 'fc-past';
          } else if (shift.startDateTime > todayEndTime) {
            className = 'fc-future';
          } else {
            className = 'fc-today';
          }

          shiftObj = {
            id: shift.id,
            title: 'Shift',
            start: moment.tz(shift.startDateTime, scope.accountInfo.timezone),
            end: moment.tz(shift.endDateTime, scope.accountInfo.timezone),
            type: typeStr,
            skillAbbrev: shift.skillAbbrev,
            skill: shift.skillName,
            assignment: '',
            team: shift.teamName,
            comment: shift.comment,
            className: className
          };
          var foundTeam = _.find(teams, function(team) { return team.id === shift.teamId; });
          if (typeof foundTeam === 'undefined') {
            shiftObj.isHomeTeam = false;
          } else {
            shiftObj.isHomeTeam = foundTeam.isHomeTeam;
          }

          return shiftObj;
        }

        function checkIfExistingShift(shiftObj) {
          var foundIndex = _.findIndex(scope.shiftsSource, 'id', shiftObj.id);

          return (foundIndex > -1);
        }

        function arrangeShift(arrangeType, shiftObj) {
          if (checkIfExistingShift(shiftObj)) {
            if (arrangeType === 'add') {
              return;
            }
            _.remove(scope.shiftsSource, 'id', shiftObj.id);
            uiCalendarConfig.calendars.dashboardCalendar.fullCalendar('removeEvents', shiftObj.id);
          } else {
            if (arrangeType === 'replace') {
              return;
            }
          }

          if (arrangeType === 'remove') {
            return;
          }

          scope.shiftsSource.push(shiftObj);
          uiCalendarConfig.calendars.dashboardCalendar.fullCalendar('renderEvent', shiftObj);
        }

        scope.getAccountInfo().then(function(response) {
          scope.accountInfo = response;
          scope.calendarConfig.calendar.timezone = scope.accountInfo.timezone;
          var firstDayNumber = 0;
          switch (scope.accountInfo.siteFirstDayOfweek.toLowerCase()) {
            case 'sunday':
              firstDayNumber = 0;
              break;
            case 'monday':
              firstDayNumber = 1;
              break;
            case 'tuesday':
              firstDayNumber = 2;
              break;
            case 'wednesday':
              firstDayNumber = 3;
              break;
            case 'thursday':
              firstDayNumber = 4;
              break;
            case 'friday':
              firstDayNumber = 5;
              break;
            case 'saturday':
              firstDayNumber = 6;
              break;
            default:
              firstDayNumber = 0;
              break;
          }
          scope.calendarConfig.calendar.firstDay = firstDayNumber;

          $timeout(function() {
            angular.element('.fc-toolbar .fc-left').prepend('<button class="fc-prev-button fc-nav-button btn eml-btn-grey-lightest">' + '<' + '</button>');
            angular.element('.fc-toolbar .fc-left').append('<button class="fc-next-button fc-nav-button btn eml-btn-grey-lightest">' + '>' + '</button>');
            angular.element('.fc-prev-button').click(function() {
              var selectedYear = scope.selectedDate.getFullYear();
              var selectedMonth = scope.selectedDate.getMonth();
              scope.selectedDate = new Date(selectedYear, selectedMonth - 1, 1);
              scope.$apply();
            });
            angular.element('.fc-next-button').click(function() {
              var selectedYear = scope.selectedDate.getFullYear();
              var selectedMonth = scope.selectedDate.getMonth();
              scope.selectedDate = new Date(selectedYear, selectedMonth + 1, 1);
              scope.$apply();
            });
            var localTodayDate = moment.tz(new Date(), scope.accountInfo.timezone);
            scope.selectedDate = new Date(localTodayDate.year(), localTodayDate.month(), localTodayDate.date());
            scope.applyTodayStyle('.fc-bg');
            scope.applyTodayStyle('.fc-content-skeleton');
          }, 0);

          wsService.registerConsumer({
            id: 'calendarShiftsEventHandler',
            selector: function(key) {
              if (scope.shiftsLoaded) {
                var keySelector = '<ObjLifecycle><.*><><Shift><.*><.*>';
                return key.match(keySelector);
              }
              return false;
            },
            callback: function(key, serverEvent) {
              var shiftObj = parseShift(serverEvent);
              switch (key.eventType) {
                case 'Create':
                  if (serverEvent.employeeId !== scope.accountInfo.employeeId) {
                    break;
                  }
                  arrangeShift('add', shiftObj);
                  break;
                case 'Update':
                  if (checkIfExistingShift(shiftObj)) {
                    if (serverEvent.employeeId !== scope.accountInfo.employeeId) {
                      arrangeShift('remove', shiftObj);
                      break;
                    }
                    arrangeShift('replace', shiftObj);
                    break;
                  }
                  if (serverEvent.employeeId !== scope.accountInfo.employeeId) {
                    break;
                  }

                  arrangeShift('add', shiftObj);
                  break;
                case 'Delete':
                  arrangeShift('remove', shiftObj);
                  break;
                default:
                  break;
              }
            },
            scope: scope,
            params: []
          });

          wsService.registerConsumer({
            id: 'calendarAvailabilityEventHandler',
            selector: function(key) {
              if (scope.shiftsLoaded) {
                var keySelector = '<Employee><.*><' + scope.accountInfo.employeeId + '><.*><AvailabilityChange><.*>';
                return key.match(keySelector);
              }
              return false;
            },
            callback: function(key, serverEvent) {
              switch (key.eventType) {
                case 'AvailabilityChange':
                  if (serverEvent !== null) {
                    scope.drawCalendar();
                  }
                  break;
                default:
                  break;
              }
            },
            scope: scope,
            params: []
          });

          wsService.registerConsumer({
            id: 'calendarPostedOpenShiftsEventHandler',
            selector: function(key) {
              if (scope.shiftsLoaded) {
                var keySelector = '<Employee><.*><' + scope.accountInfo.employeeId + '><.*><PostedOSChange><.*>';
                return key.match(keySelector);
              }
              return false;
            },
            callback: function(key, serverEvent) {
              switch (key.eventType) {
                case 'PostedOSChange':
                  if (serverEvent !== null) {
                    var selectedMonthFirstDateInArrFormat = [scope.selectedDate.getFullYear(), scope.selectedDate.getMonth(), 1];
                    var localSelectedMonthFirstDate = moment.tz(selectedMonthFirstDateInArrFormat, scope.accountInfo.timezone);
                    var nextMonthFirstDateInArrFormat = [scope.selectedDate.getFullYear(), scope.selectedDate.getMonth() + 1, 1];
                    var localNextMonthFirstDate = moment.tz(nextMonthFirstDateInArrFormat, scope.accountInfo.timezone);

                    var startDate = localSelectedMonthFirstDate.subtract(7, 'days').unix() * 1000;
                    var endDate = localNextMonthFirstDate.add(7, 'days').unix() * 1000;

                    scope.ticksInfo = [];
                    scope.getShifts({startDate: startDate, endDate: endDate}).then(function(response) {
                      scope.populateOpenShiftsTicks(response.data);
                      scope.renderOpenShiftsTicks();
                    }, function(err) {
                      var message = err.data.message || JSON.stringify(err.data);
                      applicationContext.setNotificationMsgWithValues(message, 'danger', true);
                    }).finally(function() {
                      $(window).resize();
                    });
                  }
                  break;
                default:
                  break;
              }
            },
            scope: scope,
            params: []
          });
        });
      },
      templateUrl: 'modules/common/partials/dashboard-calendar.html'
    };
  }
]);

angular.module('emlogis.commonDirectives').controller('ManageShiftPopupModalInstanceCtrl', ['$scope', '$modalInstance', '$timeout', 'originatorShift', 'getEligibleEntities', 'timezone', 'applicationContext',
  function ($scope, $modalInstance, $timeout, originatorShift, getEligibleEntities, timezone, applicationContext) {

    var weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    $scope.originatorShift = originatorShift;
    $scope.originatorShiftDate = weekdays[parseInt(originatorShift.start.format('e'))] + ', ' +
      originatorShift.start.format('MM/DD/YYYY');
    var startTimeStr = originatorShift.start.format('h:mma');
    startTimeStr = startTimeStr.substr(0, startTimeStr.length - 1);
    var endTimeStr = originatorShift.end.format('h:mma');
    endTimeStr = endTimeStr.substr(0, endTimeStr.length - 1);
    $scope.originatorShiftStartEndTime = '(' + startTimeStr + ' - ' + endTimeStr + ')';
    $scope.originatorShiftDuration = ((originatorShift.end.diff(originatorShift.start))/(3600 * 1000)) + 'hrs';

    $scope.original = {
      swapEligibleShifts: [],
      swapEligibleShiftsCount: 0,
      wipEligibleEmployees: [],
      wipEligibleEmployeesCount: 0
    };

    $scope.filtered = {
      swapEligibleShifts : [],
      swapEligibleShiftsCount: 0,
      wipEligibleEmployees: [],
      wipEligibleEmployeesCount: 0
    };

    $scope.selected = {
      swapEligibleShifts: [],
      wipEligibleEmployees: []
    };

    $scope.loadingState = {
      swapEligibleShiftsLoaded: false,
      wipEligibleEmployeesLoaded: false
    };

    $scope.parseSwapEligibleShiftForGrid = function(eligibleEntity) {
      var entity = {
        id: eligibleEntity.shiftId,
        teamMemberId: eligibleEntity.employeeId,
        teamMember: eligibleEntity.employeeName,
        team: eligibleEntity.teamName,
        skill: eligibleEntity.skillName,
        date: moment.tz(eligibleEntity.startDateTime, timezone).format('MM/DD/YYYY'),
        shift: moment.tz(eligibleEntity.startDateTime, timezone).format('hh:mma') + ' - ' +
          moment.tz(eligibleEntity.endDateTime, timezone).format('hh:mma')
      };

      return entity;
    };

    $scope.parseWipEligibleEmployeeForGrid = function(eligibleEntity) {
      var entity = {
        id: eligibleEntity.employeeId,
        teamMember: eligibleEntity.employeeName
      };

      return entity;
    };

    $scope.initializeEligibleEntities = function(type, eligibleEntities) {
      if (type === 'swap') {
        if (eligibleEntities.length === 0) {
          $scope.filterConf.swap.dateFrom = null;
          $scope.filterConf.swap.dateTo = null;
        } else {
          var minDate = eligibleEntities[0].startDateTime;
          var maxDate = eligibleEntities[0].startDateTime;
          angular.forEach(eligibleEntities, function(swapEligibleShift) {
            if (minDate > swapEligibleShift.startDateTime) {
              minDate = swapEligibleShift.startDateTime;
              return;
            }
            if (maxDate < swapEligibleShift.startDateTime) {
              maxDate = swapEligibleShift.startDateTime;
            }
          });
          minDate = moment.tz(minDate, timezone);
          maxDate = moment.tz(maxDate, timezone);
          $scope.filterConf.swap.dateFrom = new Date(minDate.year(), minDate.month(), minDate.date());
          $scope.filterConf.swap.dateTo = new Date(maxDate.year(), maxDate.month(), maxDate.date());
        }

        $scope.original.swapEligibleShifts = eligibleEntities;
        $scope.original.swapEligibleShiftsCount = eligibleEntities.length;
        $scope.onSwapFilterChange();
      } else {
        $scope.original.wipEligibleEmployees = eligibleEntities;
        $scope.original.wipEligibleEmployeesCount = eligibleEntities.length;
        $scope.onWipFilterChange();
      }
    };

    $scope.tabs = [{
      selected: false,
      heading: 'home.SHIFT_SWAP_REQUEST',
      submitLabel: 'home.SEND_SWAP_REQUEST'
    }, {
      selected: false,
      heading: 'home.WORK_IN_PLACE_REQUEST',
      submitLabel: 'home.SEND_WIP_REQUEST'
    }];
    $scope.selectedTab = null;

    $scope.selectSubTab = function (tab) {
      angular.forEach($scope.tabs, function (item) {
        item.selected = false;
      });

      tab.selected = true;
      $scope.selectedTab = tab;
    };

    $scope.toggleRequestButton = function(requestType) {
      if (requestType === 'swap') {
        $scope.selectSubTab($scope.tabs[0]);
      } else if (requestType === 'wip') {
        $scope.selectSubTab($scope.tabs[1]);
      }
    };

    $scope.$watch('selectedTab', function() {
      if ($scope.selectedTab === $scope.tabs[0]) {
        if (!$scope.loadingState.swapEligibleShiftsLoaded) {
          getEligibleEntities({tabType: 'swap', shiftId: originatorShift.id}).then(function(response) {
            $scope.initializeEligibleEntities('swap', response.data.swappableShifts);
          }, function(err) {
            $scope.initializeEligibleEntities('swap', []);
            applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
          }).finally(function() {
            $scope.loadingState.swapEligibleShiftsLoaded = true;
          });
        }
      } else if ($scope.selectedTab === $scope.tabs[1]) {
        if (!$scope.loadingState.wipEligibleEmployeesLoaded) {
          getEligibleEntities({tabType: 'wip', shiftId: originatorShift.id}).then(function(response) {
            $scope.initializeEligibleEntities('wip', response.data.eligibleTeammates);
          }, function(err) {
            $scope.initializeEligibleEntities('wip', []);
            applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
          }).finally(function() {
            $scope.loadingState.wipEligibleEmployeesLoaded = true;
          });
        }
      }
    });

    $scope.datePickerConf = {
      opened: {
        from: false,
        to: false
      },
      options: {
        formatYear: 'yyyy',
        startingDay: 1
      }
    };

    $scope.openDatePicker = function($event, selector) {
      $event.preventDefault();
      $event.stopPropagation();

      $scope.datePickerConf.opened[selector] = true;
    };

    var now = new Date();
    $scope.filterConf = {
      swap: {
        teamMemberName: '',
        dateFrom: null,
        dateTo: null,
        time: '0;1440',
        sliderOptions: {
          from: 0,
          to: 1440,
          step: 30,
          dimension: '',
          scale: ['0', '|', '|', '|', '|', '|', '3', '|', '|', '|', '|', '|', '6',
            '|', '|', '|', '|', '|', '9', '|', '|', '|', '|', '|', '12',
            '|', '|', '|', '|', '|', '15', '|', '|', '|', '|', '|', '18',
            '|', '|', '|', '|', '|', '21', '|', '|', '|', '|', '|', '24'],
          calculate: function(value) {
            var hours = Math.floor( value / 60 );
            var mins = ( value - hours*60 );
            return (hours < 10 ? "0"+hours : hours) + ":" + ( mins === 0 ? "00" : mins );
          },
          css: {
            pointer: { 'background-color': '#0e9ac9' },
            background: { 'background-color': '#899498' },
            range: { 'background-color': '#0e9ac9' }
          }
        }
      },
      wip: {
        teamMemberName: ''
      }
    };

    $scope.swapListGridOptions = {
      data: 'filtered.swapEligibleShifts',
      enableRowSelection: true,
      enableSelectAll: true,
      multiSelect: true,
      columnDefs: [
        {field: 'id', visible: false },
        {field: 'teamMemberId', visible: false },
        {field: 'teamMember'},
        {field: 'team'},
        {field: 'skill'},
        {field: 'date'},
        {field: 'shift'}
      ],
      onRegisterApi: function(gridApi) {
        gridApi.selection.on.rowSelectionChanged($scope, function(row) {
          if (row.isSelected) {
            $scope.selected.swapEligibleShifts.push(row.entity);
          } else {
            $scope.selected.swapEligibleShifts = _.filter($scope.selected.swapEligibleShifts, function(entity) {return entity.id !== row.entity.id;});
          }
        });

        gridApi.selection.on.rowSelectionChangedBatch($scope, function(rows) {
          angular.forEach(rows, function(row) {
            if (row.isSelected) {
              $scope.selected.swapEligibleShifts.push(row.entity);
            } else {
              $scope.selected.swapEligibleShifts = _.filter($scope.selected.swapEligibleShifts, function(entity) {return entity.id !== row.entity.id;});
            }
          });
        });
      }
    };

    $scope.wipListGridOptions = {
      data: 'filtered.wipEligibleEmployees',
      enableRowSelection: true,
      enableSelectAll: true,
      multiSelect: true,
      columnDefs: [
        {field: 'id', visible: false},
        {field: 'teamMember'}
      ],
      onRegisterApi: function(gridApi) {
        gridApi.selection.on.rowSelectionChanged($scope, function(row) {
          if (row.isSelected) {
            $scope.selected.wipEligibleEmployees.push(row.entity);
          } else {
            $scope.selected.wipEligibleEmployees = _.filter($scope.selected.wipEligibleEmployees, function(entity) {return entity.id !== row.entity.id;});
          }
        });

        gridApi.selection.on.rowSelectionChangedBatch($scope, function(rows) {
          angular.forEach(rows, function(row) {
            if (row.isSelected) {
              $scope.selected.wipEligibleEmployees.push(row.entity);
            } else {
              $scope.selected.wipEligibleEmployees = _.filter($scope.selected.wipEligibleEmployees, function(entity) {return entity.id !== row.entity.id;});
            }
          });
        });
      }
    };

    $scope.$watch('filterConf.swap.time', function() {
      $scope.onSwapFilterChange();
    });

    $scope.onSwapFilterChange = function() {
      $scope.filtered.swapEligibleShifts = [];
      angular.forEach($scope.original.swapEligibleShifts, function(shiftIterator) {
        var shiftStartDateTime = moment.tz(shiftIterator.startDateTime, timezone);
        var shiftStartDate = moment.tz([shiftStartDateTime.year(), shiftStartDateTime.month(), shiftStartDateTime.date()], timezone);
        var shiftStartTimeInMinutes = parseInt(shiftStartDateTime.format('H')) * 60 + parseInt(shiftStartDateTime.format('m'));

        var filterTimeFrom = parseInt($scope.filterConf.swap.time.substring(0, $scope.filterConf.swap.time.indexOf(';')));
        var filterTimeTo = parseInt($scope.filterConf.swap.time.substring($scope.filterConf.swap.time.indexOf(';') + 1));
        var dateFromInArrFormat = [$scope.filterConf.swap.dateFrom.getFullYear(), $scope.filterConf.swap.dateFrom.getMonth(),
          $scope.filterConf.swap.dateFrom.getDate()];
        var filterDateFrom = moment.tz(dateFromInArrFormat, timezone);
        var dateToInArrFormat = [$scope.filterConf.swap.dateTo.getFullYear(), $scope.filterConf.swap.dateTo.getMonth(),
          $scope.filterConf.swap.dateTo.getDate()];
        var filterDateTo = moment.tz(dateToInArrFormat, timezone);

        if (shiftStartDate.unix() >= filterDateFrom.unix() && shiftStartDate.unix() <= filterDateTo.unix()) {
          if (shiftStartTimeInMinutes >= filterTimeFrom && shiftStartTimeInMinutes <= filterTimeTo) {
            if ($scope.filterConf.swap.teamMemberName === '' ||
              shiftIterator.employeeName.indexOf($scope.filterConf.swap.teamMemberName) > -1) {
              var shift = $scope.parseSwapEligibleShiftForGrid(shiftIterator);
              $scope.filtered.swapEligibleShifts.push(shift);
            }
          }
        }
      });
      $scope.filtered.swapEligibleShiftsCount = $scope.filtered.swapEligibleShifts.length;
      $timeout(function () {
        angular.element('.swap-list-grid').resize();
      }, 0);
    };

    $scope.onWipFilterChange = function() {
      $scope.filtered.wipEligibleEmployees = [];
      angular.forEach($scope.original.wipEligibleEmployees, function(employeeIterator) {
        if ($scope.filterConf.wip.teamMemberName === '' ||
          employeeIterator.employeeName.indexOf($scope.filterConf.wip.teamMemberName) > -1) {
          var employee = $scope.parseWipEligibleEmployeeForGrid(employeeIterator);
          $scope.filtered.wipEligibleEmployees.push(employee);
        }
      });
      $scope.filtered.wipEligibleEmployeesCount = $scope.filtered.wipEligibleEmployees.length;
      $timeout(function() {
        angular.element('.wip-list-grid').resize();
      }, 0);
    };

    $scope.submitRequest = function() {
      if ($scope.selectedTab === $scope.tabs[0]) {
        $modalInstance.close({tabType: 'swap', selectedEligibleEntities: $scope.selected.swapEligibleShifts});
      } else {
        $modalInstance.close({tabType: 'wip', selectedEligibleEntities: $scope.selected.wipEligibleEmployees});
      }
    };

    $scope.close = function () {
      $modalInstance.dismiss('cancel');
    };
  }]);

angular.module('emlogis.commonDirectives').controller('OpenShiftsPopupModalInstanceCtrl', ['$scope', '$modalInstance', '$timeout', 'applicationContext', 'tickInfo', 'getOpenShifts', 'timezone',
  function ($scope, $modalInstance, $timeout, applicationContext, tickInfo, getOpenShifts, timezone) {

    $scope.original = {
      openShifts: []
    };

    $scope.selected = {
      openShifts: []
    };

    $scope.loadingState = {
      openShiftsLoaded: false
    };

    $scope.parseOpenShiftForGrid = function(openShift) {
      var entity = {
        id: openShift.id,
        shiftId: openShift.shiftId,
        start: openShift.startDateTime,
        end: openShift.endDateTime,
        date: moment.tz(openShift.startDateTime, timezone).format('MM/DD/YYYY'),
        team: openShift.teamName,
        skill: openShift.skillName,
        shift: moment.tz(openShift.startDateTime, timezone).format('hh:mma') + ' - ' + moment.tz(openShift.endDateTime, timezone).format('hh:mma'),
        terms: openShift.terms,
        deadline: moment.tz(openShift.deadline, timezone).format('MM/DD/YYYY'),
        comment: openShift.comments
      };

      return entity;
    };

    $scope.openShiftsGridOptions = {
      data: 'original.openShifts',
      enableRowSelection: true,
      enableSelectAll: true,
      multiSelect: true,
      columnDefs: [
        {field: 'id', visible: false},
        {field: 'shiftId', visible: false},
        {field: 'start', visible: false},
        {field: 'end', visible: false},
        {field: 'date'},
        {field: 'team'},
        {field: 'skill'},
        {field: 'shift'},
        {field: 'terms'},
        {field: 'deadline'},
        {field: 'comment'}
      ],
      onRegisterApi: function(gridApi) {
        gridApi.selection.on.rowSelectionChanged($scope, function(row) {
          if (row.isSelected) {
            $scope.selected.openShifts.push(row.entity);
          } else {
            $scope.selected.openShifts = _.filter($scope.selected.openShifts, function(entity) {return entity.id !== row.entity.id;});
          }
        });

        gridApi.selection.on.rowSelectionChangedBatch($scope, function(rows) {
          angular.forEach(rows, function(row) {
            if (row.isSelected) {
              $scope.selected.openShifts.push(row.entity);
            } else {
              $scope.selected.openShifts = _.filter($scope.selected.openShifts, function(entity) {return entity.id !== row.entity.id;});
            }
          });
        });
      }
    };

    getOpenShifts({startDate: tickInfo.start, endDate: tickInfo.end}).then(function(response) {
      angular.forEach(response.data, function(shiftIterator) {
        var entity = $scope.parseOpenShiftForGrid(shiftIterator);
        $scope.original.openShifts.push(entity);
      });
    }, function(err) {
      var message = err.data.message || JSON.stringify(err.data);
      applicationContext.setNotificationMsgWithValues(message, 'danger', true);
    }).finally(function() {
      $scope.loadingState.openShiftsLoaded = true;
      $timeout(function () {
        $('.open-shifts-grid').resize();
      }, 0);
    });

    $scope.submitOpenShiftsRequest = function() {
      $modalInstance.close({selectedOpenShifts: $scope.selected.openShifts});
    };

    $scope.close = function () {
      $modalInstance.dismiss('cancel');
    };
  }]);

angular.module('emlogis.commonDirectives').controller('PtoRequestPopupModalInstanceCtrl', ['$scope', '$modalInstance', '$translate', 'DashboardService', 'applicationContext', 'siteId', 'timezone',
  function ($scope, $modalInstance, $translate, DashboardService, applicationContext, siteId, timezone) {
    var tomorrowInLocalTime = moment.tz(new Date(), timezone).add(1, 'days');
    tomorrowInLocalTime.hours(0).minutes(0).seconds(0);
    var dayInMilliseconds = 24 * 3600000;
    var selYear = tomorrowInLocalTime.year();
    var selMonth = tomorrowInLocalTime.month();
    var selDate = tomorrowInLocalTime.date();
    var consts = {
      invalidType: {
        nonDateValues: 0,
        startDateInPast: 1,
        endDateEarlierThanStartDate: 2
      }
    };

    $scope.dateInputsValidation = true;
    $scope.dateInputsInvalidMsg = '';
    $scope.modelList = {
      timeOffTypes: []
    };

    $scope.datePickerModel = {
      startDate: new Date(selYear, selMonth, selDate),
      endDate: new Date(new Date(selYear, selMonth, selDate).getTime() + dayInMilliseconds),
      startDateOpened: false,
      endDateOpened: false,
      datePickerOptions: {
        formatYear: 'yyyy',
        startingDay: 1
      },
      openDatePicker: function($event, selector) {
        $event.preventDefault();
        $event.stopPropagation();

        if (selector === 'startDate') {
          $scope.datePickerModel.startDateOpened = true;
        } else {
          $scope.datePickerModel.endDateOpened = true;
        }
      }
    };

    $scope.data = {
      timeOffType: null,
      timeOffStartDate: tomorrowInLocalTime.unix() * 1000,
      lengthInDays: 2,
      note: ''
    };

    var onInvalidDateInputs = function(invalidType) {
      $scope.dateInputsValidation = false;
      $scope.data.timeOffStartDate = null;
      $scope.data.lengthInDays = 0;
      if (invalidType === consts.invalidType.nonDateValues) {
        $translate('home.invalid_dates_msg.NON_DATE_VALUES').then(function(translation) {
          $scope.dateInputsInvalidMsg = translation;
        });
      } else if (invalidType === consts.invalidType.startDateInPast) {
        $translate('home.invalid_dates_msg.START_DATE_IN_PAST').then(function(translation) {
          $scope.dateInputsInvalidMsg = translation;
        });
      } else if (invalidType === consts.invalidType.endDateEarlierThanStartDate) {
        $translate('home.invalid_dates_msg.END_DATE_EARLIER_THAN_START_DATE').then(function(translation) {
          $scope.dateInputsInvalidMsg = translation;
        });
      }
    };

    var onValidDateInputs = function() {
      var yearVal = $scope.datePickerModel.startDate.getFullYear();
      var monthVal = $scope.datePickerModel.startDate.getMonth();
      var dateVal = $scope.datePickerModel.startDate.getDate();
      var lengthInDays = ($scope.datePickerModel.endDate.getTime() - $scope.datePickerModel.startDate.getTime())/dayInMilliseconds + 1;
      $scope.dateInputsValidation = true;
      $scope.data.timeOffStartDate = moment.tz([yearVal, monthVal, dateVal], timezone).unix() * 1000;
      $scope.data.lengthInDays = lengthInDays;
    };

    var compareLocalTimeWithTomorrow = function(localTime) {
      var localYear = localTime.getFullYear();
      var localMonth = localTime.getMonth();
      var localDate = localTime.getDate();
      if (moment.tz([localYear, localMonth, localDate], timezone).unix() < tomorrowInLocalTime.unix()) {
        return false;
      }

      return true;
    };

    $scope.onSelectedDateChanged = function(selector) {
      if (typeof $scope.datePickerModel.startDate === 'undefined' || $scope.datePickerModel.startDate === null ||
        typeof $scope.datePickerModel.endDate === 'undefined' || $scope.datePickerModel.endDate === null) {
        onInvalidDateInputs(consts.invalidType.nonDateValues);
        return;
      }
      if (!compareLocalTimeWithTomorrow($scope.datePickerModel.startDate)) {
        onInvalidDateInputs(consts.invalidType.startDateInPast);
        return;
      }
      if ($scope.datePickerModel.startDate > $scope.datePickerModel.endDate) {
        if (selector === 'start') {
          $scope.datePickerModel.endDate = $scope.datePickerModel.startDate;
        } else {
          $scope.datePickerModel.startDate = $scope.datePickerModel.endDate;
        }
      }
      onValidDateInputs();
    };

    $scope.submitPtoRequest = function() {
      $modalInstance.close({ptoRequest: $scope.data});
    };

    $scope.close = function () {
      $modalInstance.dismiss('cancel');
    };

    DashboardService.getAbsenceTypes(siteId).then(function(response) {
      $scope.modelList.timeOffTypes = response.data.result;
    }, function(err) {
      var message = err.data.message || JSON.stringify(err.data);
      applicationContext.setNotificationMsgWithValues(message, 'danger', true);
    });
  }]);

angular.module('emlogis.commonDirectives').controller('SyncCalendarPopupModalInstanceCtrl', ['$scope', '$modalInstance', 'calendarSyncUrl',
  function ($scope, $modalInstance, calendarSyncUrl) {

    $scope.calendarSyncUrl = calendarSyncUrl;

    $scope.close = function () {
      $modalInstance.dismiss('cancel');
    };

  }]);

angular.module('emlogis.commonDirectives').controller('ActionResultPopupModalInstanceCtrl', ['$scope', '$modalInstance', 'results',
  function ($scope, $modalInstance, results) {

    $scope.results = results;

    $scope.close = function () {
      $modalInstance.dismiss('cancel');
    };

  }]);
;
(function () {
  "use strict";

  //
  // This directive is build upon
  // Bootstrap component Well (.well)
  // and Bootstrap UI component Collapse (ui.bootstrap.collapse)
  
  var editWell = function () {

    return {
      restrict: 'EA',
      replace: true,
      scope: {
        isCollapsable: '=',
        isCollapsed: '=',
        name: '@'
      },
      transclude: true,
      templateUrl: 'modules/common/partials/edit-well.include.html',
      link: function(scope, element, attributes, controller, transclude){
        //console.log('+++ Inside Edit-Well directive...');

        //
        // Custom transclusion
        // for 2 transcluded  areas:
        // Well Body and addition to Well Header (optional)

        transclude(function(clone){
          angular.forEach(clone, function(cloneEl){
            if (cloneEl.nodeType === 1 && cloneEl.attributes['transclude-to']){

              var tId = cloneEl.attributes['transclude-to'].value;                // get desired target id
              var target = element.find('[transclude-id="' + tId + '"]');         // find target element with this id
              target.append(cloneEl);                                             // append element to target
            }
          });
        });
      }
    };
  };


  editWell.$inject = [];
  angular.module('emlogis.commonDirectives').directive('editWell', editWell);

}());

;
(function () {
  "use strict";

  var emlDropdown = function ($timeout) {

    return {
      restrict: 'E',
      replace: true,
      scope: {
        model: '=',
        options: '=',
        property: '@',
        leftText: '=',
        topText: '=',
        leftTextWidth: '@',
        disabled: '=',
        keepTopTextHeight: '@',
        onSelect: "&"
      },
      templateUrl: 'modules/common/partials/eml-dropdown.html',
      link: function(scope) {

        var DEFAULT_LEFT_TEXT_WIDTH = 50,
          DEFAULT_TOP_TEXT_MARGIN_LEFT = 9,
          DEFAULT_TOP_TEXT_HEIGHT = 18,

          leftTextWidth     = scope.leftTextWidth || (scope.leftText ? DEFAULT_LEFT_TEXT_WIDTH : 0),
          topTextMarginLeft = leftTextWidth || DEFAULT_TOP_TEXT_MARGIN_LEFT,
          topTextHeight     = (scope.keepTopTextHeight || scope.topText) ? DEFAULT_TOP_TEXT_HEIGHT : 0;

        scope.leftTextBlockWidth = {width: leftTextWidth + 'px'};
        scope.topTextMargin = {marginLeft: topTextMarginLeft + 'px', height: topTextHeight};

        scope.selectOption = function(opt) {
          scope.model = opt;
          if (_.isFunction(scope.onSelect)) {
            $timeout(function() {
              scope.onSelect();
            });
          }
        };

        scope.getDisplayValue = function (model) {
          if (!model) return '...';
          return (scope.property && model[scope.property]) ? model[scope.property] : model;
        };
      }
    };
  };

  emlDropdown.$inject = ['$timeout'];
  angular.module('emlogis.commonDirectives').directive('emlDropdown', emlDropdown);

}());

;
angular.module('emlogis.commonDirectives').directive('ngEnter', function () {
    return function (scope, element, attrs) {
        element.bind("keydown keypress", function (event) {
            if(event.which === 13) {
                scope.$apply(function (){
                    scope.$eval(attrs.ngEnter);
                });
                event.preventDefault();
            }
        });
    };
});

;
angular.module('emlogis.commonDirectives').directive('ngEscape', function () {
    return function (scope, element, attrs) {
        element.bind("keydown keypress", function (event) {
            if(event.which === 27) {
                scope.$apply(function (){
                    scope.$eval(attrs.ngEscape);
                });
                event.preventDefault();
            }
        });
    };
});

;
(function () {
  "use strict";

  var filteringDirective = function () {

    return {
      restrict: 'E',
      replace: true,
      scope: {
        list: '=',
        filters: '='   // [{name: 'active', value: 'true', buttonLabel: 'ACTIVE'}]
      },
      templateUrl: 'modules/common/partials/filtering-directive.html',
      link: function(scope){

        scope.showControl = false;

        var checkList = scope.$watch('list', function(list) {
          if (_.isEmpty(list)) return;
          checkList(); // would clear the watch
          scope.showControl = true;
          scope.filter(null);
        });

        scope.filter = function(filter) {
          scope.selectedFilter = filter;

          _.each(scope.list, function(item) {
            item.filteredOut = filter && (item[filter.name] !== filter.value);
          });
        };

      }
    };
  };

  filteringDirective.$inject = [];
  angular.module('emlogis.commonDirectives').directive('filteringDirective', filteringDirective);

}());

;
angular.module('emlogis.commonDirectives').directive('focusMe', ['$timeout', '$parse',
  function($timeout, $parse) {
    return {
      link: function(scope, element, attrs) {
        var model = $parse(attrs.focusMe),
            resetOnBlur = attrs.resetOnBlur;
        scope.$watch(model, function(value) {
          if(value === true) {
            $timeout(function() {
              element[0].focus();
            });
          }
        });

        if (resetOnBlur) {
          element.bind('blur', function() {
            console.log("resetOnBlur catched");
            scope.$apply(model.assign(scope, false));
          });
        }
      }
    };
}]);
;
(function () {
  "use strict";

  //
  // Spin loader element
  // to be used across the app
  // SCSS is placed in emlogis-animation.scss

  var loader = function () {
    return {
      restrict: 'EA',
      replace: true,
      template: '<div class="circularG">' +
                  '<div class="circularG_1 circularG_0"></div>' +
                  '<div class="circularG_2 circularG_0"></div>' +
                  '<div class="circularG_3 circularG_0"></div>' +
                  '<div class="circularG_4 circularG_0"></div>' +
                  '<div class="circularG_5 circularG_0"></div>' +
                  '<div class="circularG_6 circularG_0"></div>' +
                  '<div class="circularG_7 circularG_0"></div>' +
                  '<div class="circularG_8 circularG_0"></div>' +
                '</div>'
    };
  };

  loader.$inject = [];
  angular.module('emlogis.commonDirectives').directive('loader', loader);

}());
;
(function () {
  "use strict";
  
  var monthYearPicker = function () {

    return {

      restrict: 'E',
      replace: true,
      scope: {
        year: '=',
        minYear: '=',
        maxYear: '=',
        month: '='
      },
      templateUrl: 'modules/common/partials/month-year-picker.html',
      link: function(scope) {

        var months = {
          0: "January",
          1: "February",
          2: "March",
          3: "April",
          4: "May",
          5: "June",
          6: "July",
          7: "August",
          8: "September",
          9: "October",
          10: "November",
          11: "December"
        };

        function maxYearReached() {
          return scope.maxYear && scope.year === scope.maxYear;
        }

        function minYearReached() {
          return scope.minYear && scope.year === scope.minYear;
        }

        function nextYear() {
          if (!maxYearReached()) {
            scope.year++;
          }
        }

        function prevYear() {
          if (!minYearReached()) {
            scope.year--;
          }
        }

        function nextMonth() {
          if (scope.month == 11) {
            if (maxYearReached()) return;
            scope.month = 0;
            scope.year++;
          } else {
            scope.month++;
          }
        }

        function prevMonth() {
          if (scope.month === 0) {
            if (minYearReached()) return;
            scope.month = 11;
            scope.year--;
          } else {
            scope.month--;
          }
        }

        scope.year = scope.year || moment().year();

        scope.next = function() {
          if (typeof scope.month === "number") {
            nextMonth();
          } else {
            nextYear();
          }
        };

        scope.previous = function() {
          if (typeof scope.month === "number") {
            prevMonth();
          } else {
            prevYear();
          }
        };

        scope.valueToDisplay = function() {
          if (typeof scope.month === "number") {
            return months[scope.month] + " " + scope.year;
          } else {
            return scope.year;
          }
        };
      }
    };
  };


  monthYearPicker.$inject = [];
  angular.module('emlogis.commonDirectives').directive('monthYearPicker', monthYearPicker);

}());

;
(function () {
  "use strict";

  var sortingDirective = function () {

    return {
      restrict: 'E',
      replace: true,
      scope: {
        list: '=',
        fields: '=',   // [{name: 'abbreviation', buttonLabel: 'ABBREVIATION'}]
        defaultField: '@',
        defaultOrder: '='
      },
      templateUrl: 'modules/common/partials/sorting-directive.html',
      link: function(scope){

        scope.showControl = false;

        var checkList = scope.$watch('list', function(list) {
          if (_.isEmpty(list)) return;
          checkList(); // would clear the watch
          scope.showControl = true;
          init();
        });

        function init() {
          scope.order = scope.defaultOrder || true;
          scope.selectedField = scope.defaultField || scope.fields[0];
          scope.sort();
        }

        scope.selectField = function(field) {
          scope.selectedField = field;
        };

        scope.sort = function() {
          scope.list = _.sortByOrder(scope.list, scope.selectedField.name, scope.order);
        };

      }
    };
  };


  sortingDirective.$inject = [];
  angular.module('emlogis.commonDirectives').directive('sortingDirective', sortingDirective);

}());

;
(function () {
  "use strict";

  //
  // This directive is build upon
  // Bootstrap component Label (.label)
  //
  // all Tags must have "id" and "name" properties
  // for the current implementation of this directive to work

  var tags = function ($filter) {

    return {
      restrict: 'EA',
      replace: true,
      scope: {
        readonly: '=',
        tagslist: '=tagslist',              // array of Tags to display
        deletetag: '&',                     // method to remove Tag from displayed list
        addtagslist: '=addtagslist',        // array of all Tags that can potentially be added (directive will filter it out)
        addtag: '&'                         // method to trigger when Tag is being added to displayed list
      },
      templateUrl: 'modules/common/partials/tags.include.html',
      link: function(scope, element, attrs){
        // console.log('+++ Inside TAGS directive...');                    // DEV mode

        scope.isDropdownnOpen = false;                                     // Hide Dropdown list

        scope.allTags = scope.tagslist.concat(scope.addtagslist);          // Combine all Tags into one array

        var deleteDuplicatesFromArray = function(arr) {
          var cleaned = [];
          arr.forEach(function(itm) {
            var unique = true;
            cleaned.forEach(function(itm2) {
              //if ( _.isEqual(itm, itm2) ) unique = false;
              if ( itm.id === itm2.id ) unique = false;
            });
            if (unique) cleaned.push(itm);
          });
          return cleaned;
        };

        scope.allTags = deleteDuplicatesFromArray(scope.allTags);          // Delete duplicates from array of Tags
        scope.allTags = $filter('orderBy')(scope.allTags, 'name');         // Rearrange the list ABC order by name prop

        scope.$watch('tagslist', function(newValue) {
          if ( newValue )
            // console.log("~~~ I see a data change in Tags component!");  // DEV mode
            // console.log(scope.addtagslist);                             // DEV mode

            scope.tagslist = $filter('orderBy')(scope.tagslist, 'name');   // Display Tags in ABC order by name prop

            //
            // Check if Tags to display array (tagslist) is the same
            // as array of all potential Tags to add (addtagslist)

            if ( angular.equals(scope.tagslist, scope.addtagslist) ) {     // If arrays are equal, meaning all Tags are displayed
              scope.noMoreTagsToAdd = true;                                // hide "plus" button

            } else {                                                       // If arrays differ,
              scope.dropDownList = [];                                     // create an empty array for Tags to be added, and

              //
              // Filter out already displayed Tags
              // from the array of all Tags that can potentially be added

              scope.dropDownList = scope.allTags.filter(function(newTag){
                return scope.tagslist.filter(function(displayedTag){
                    return displayedTag.id == newTag.id;
                  }).length === 0;
              });

              scope.noMoreTagsToAdd = scope.dropDownList < 1;              // Hide "plus" btn, if dropDown list is empty
            }
          }, true)
        ;
      }
    };
  };


  tags.$inject = ['$filter'];
  angular.module('emlogis.commonDirectives').directive('tags', tags);

}());
;
(function () {
  "use strict";

  var injectParams = ['$document', 'UtilsService'];

  var validateMessages = function () {

    return {
      restrict: 'AE',
      replace: true,
      scope: {
        messagesFor: '=',
        submitted: '=',
        patternRegExp: '@',
        patternErrorMessage: '@',
        watchValue: '@'
      },
      templateUrl: 'modules/common/partials/validate-messages.include.html',
      link: function (scope, element) {

        var watchValue = scope.watchValue ? scope.watchValue : 'messagesFor.$error';

        //
        // Add 'eml-form-to-validate'
        // for multiple forms on a page

        var ngForm = element.closest('ng-form');
        var ngFormAttr = element.closest('[ng-form]');

        if (ngForm.length > 0) {
          ngForm.addClass('eml-form-to-validate');
        } else if (ngFormAttr.length > 0) {
          ngFormAttr.addClass('eml-form-to-validate');
        } else {
          element.closest('form').addClass('eml-form-to-validate');
        }

        //
        // On submit
        // check every required field in a form whether it's valid or not.

        scope.$watch('submitted', function (submitted) {
          var hasPatternErrorButPatternIsValid = scope.messagesFor.$error.pattern &&
            scope.watchValue &&
            scope.patternRegExp &&
            new RegExp(scope.patternRegExp).test(scope.$eval(watchValue));

          if (submitted && scope.messagesFor.$invalid && !hasPatternErrorButPatternIsValid) {

            // If this field is invalid,
            // add Bootstrap class 'has-error' to the 'form-group' it belongs to.
            // This will trigger CSS styling for notification icons and border color.

            element.parent('.form-group').addClass('has-error');

            // Show error message for only the first invalid field in a form
            // to avoid messy and frustrating user experience

            element.closest('.eml-form-to-validate').find('.validate-message').css("opacity", "0").first().css("opacity", "1");
          }
        }, true);


        //
        // When watchValue for this field is being changed
        scope.$watch(watchValue, function (newValue) {
          setTimeout(function () {

            // Check the DOM
            // to show error message for only the first invalid field in a form
            // to avoid messy and frustrating user experience
            element.closest('.eml-form-to-validate').find('.validate-message').css("opacity", "0").first().css("opacity", "1");

            // in case you have a pattern and you want to check it by different field then the $modelValue (like in case of Dates)
            // pattern should be checked manually
            if (scope.patternRegExp && scope.watchValue) {
              element.closest('.eml-form-to-validate').find("div[ng-message='pattern'] .validate-message").css("opacity", "0");
              element.parents('.form-group').removeClass('has-error');
              if (!new RegExp(scope.patternRegExp).test(newValue)) {
                element.closest('.form-group').find(".validate-message").css("opacity", "1");
                element.parents('.form-group').addClass('has-error');
              }
            }

            // And if $error object is empty,
            // meaning that there is no more errors for this field,
            // remove 'has-error' class from 'form-group'
            if (_.isEmpty(scope.messagesFor.$error)) {
              element.parents('.form-group').removeClass('has-error');
              element.closest('.form-group').find(".validate-message").css("opacity", "0");
            }
          }, 200);
        }, true);


      }
    };
  };


  validateMessages.$inject = injectParams;
  angular.module('emlogis.commonDirectives').directive('validateMessages', validateMessages);

}());
;


//====================================================================
// Service in charge of doing base CRUD operations against REST resources
//
// TODO: make it generic and reusable so that we can have specialized dataServices that just extend that one
// TODO: add methods for getting one object, updating and creating objects

(function () {
  //console.log('in crudDataService.');

  angular.module('emlogis.commonservices')
    .factory('crudDataService', ['$http', '$q', function($http, $q) {

      //console.log('creating crudDataService...');

      var factory = {},
        baseUrl = '../emlogis/rest/';

      /* metamodel holds some information for each class of the model (defined in dataService)
       * each class defines the list of attributes that need a mapping via a 'ttype' value.
       * ttype values are:
       *  tdate (maps a long into a Date object)
       *  time (maps a int or long into a Date object, with only Time relevant attributes)
       *
       * metamodel also contains 2 methods to convert an entity attributes from their Dto type to a 'UI' type
       * and vice versa.
       */
      var metamodel = {
        // mapping methods. fromDto() convert a Dto element to a 'UI' object
        // toDto() convert a 'UI' object to a Dto element
        fromDto: function(elt){
          return this.map(elt,'fromDto');
        },

        toDto: function(elt){
          return this.map(elt,'toDto');
        },

        // attribute type converter methods
        // eacch attribute type must come with 2 converters: one to convert from the dto attribute type to the UI type
        // and one for the inverse transformation (UI type to dto)
        fromDtoMappers:{
          tdate: function(dateAsLong) {
            return new Date(dateAsLong);
          },
          ttime: function(timeAsSecs) {
            var date = new Date(timeAsSecs);
            var correctdate = new Date(date.getTime() + date.getTimezoneOffset()*60000);
            return correctdate;
          },
          tjson: function(jsonstring) {
            if (jsonstring && jsonstring.length > 0) {
              return angular.fromJson(jsonstring);
            }
            return undefined;
          }
        },
        // converter methods: Javascript to Dto
        toDtoMappers:{
          tdate: function(dateAsDate) {
            return dateAsDate.getTime();
          },
          ttime: function(timeAsDate) {
            return timeAsDate.getTime();
          }
        },

        map: function(elt, direction){
          var clModel = this[elt.clName];
          if (!clModel) {
            // return directly the element if no mapping configured
            return elt;
          }
          var result = {};
          if (direction == 'fromDto' && clModel.fromDto) {
            // we have custom fromDto mapping function
            result = clModel.fromDto(elt);
          }
          else if (direction == 'toDto' && clModel.toDto) {
            // we have custom toDto mapping function
            result = clModel.toDto(elt);
          }
          // use attribute based mapping (can be in addition to custom mapping)
          for (var k in elt) {
            if (clModel[k]) {
              var mapper;
              if (direction == 'fromDto') {
                mapper = this.fromDtoMappers[clModel[k]];
              }
              else {
                mapper = this.toDtoMappers[clModel[k]];
              }
              var mappedvalue = mapper(elt[k]);
              result[k] = mappedvalue;
            }
            else {
              result[k] = elt[k];
            }
          }
          if (direction != 'fromDto') {
            delete result.clName;  // remove clName from Dto as backend would reject request
          }
          return result;
        }
      };



      //====================================================================
      // public methods

      /*
       * get the list of elements with paging for a specified REST resource
       *
       * expected  queryParams format is {
       *    filter: <filter expression>,
       *    orderby: <attribute name>,
       *    orderdir: <'ASC' | 'DESC'>
       * }
       * paging is optional (leave it undefined or specify pageIndex < 0) to skip paging
       * if pecified, paging starts at 0
       * returns the object  {
       *   data: <array of records>,
       *   total: <total nb of records for that resource>
       * }
       */
      factory.getElements = function (resource, queryParams, pageIndex, pageSize, cache) {

        var params = factory.prepareQueryParams(queryParams, pageIndex, pageSize);
        var url = baseUrl + resource;
        //console.log('dataService --> querying( ' + url + ' q=' + params.filter
        //    + " orderby: " + params.orderby + '(' + params.orderdir
        //    + ') from: ' + params.offset + '[' + params.limit + ']'
        //);
        var cacheVal = cache && cache !== undefined ? cache : false;

        return $http.get(url, {params: params, cache: cacheVal}).then(function (response) {
          return factory.toResultSet(response);
        });
      };

      /*
       * Get the list of elements with paging for a specified REST resource by using POST request
       */
      factory.getElementsByPost = function(resource, payLoad) {
        var url = baseUrl + resource;

        return $http.post(url, payLoad).then(function (response) {
          return factory.toResultSet(response);
        });
      };

      /*
       * get one element with optionally  parameters specified in a urlParams object;
       * returns the received object
       */
      factory.getElement = function (resource, resourceId, urlParams) {

        var params = urlParams || {};
        var url = baseUrl + resource + '/' + resourceId;
        //console.log('dataService --> getting( ' + url + ' params=' + params);

        return $http.get(url, {params: params}).then(function (response) {
          return factory.toObjectResult(response);
        });
      };

      /*
       * upadte one element with optionally parameters specified in a urlParams object;
       *
       * NOTE: urlParams NOT IMPLEMENTED YET
       *
       * returns the updated object
       */
      factory.updateElement = function (resource, resourceId, resourceElt, urlParams) {

        var url = baseUrl + resource + '/' + resourceId;
        ////console.log('--> updating( ' + url + ' params=' + urlParams);
        //console.log('--> updating( ' + url + ') with:' + resourceElt);

        var dto = metamodel.toDto(resourceElt);
        return $http.put(url, dto).then(function (response) {
          return factory.toObjectResult(response);
        });
      };


      /*
       * Create one element with optionally parameters specified in a urlParams object;
       *
       * NOTE: urlParams NOT IMPLEMENTED YET
       *
       * returns the updated object
       */
      factory.createElement = function (resource, resourceElt, urlParams) {

        var url = baseUrl + resource + '/';
        ////console.log('--> creating( ' + url + ' params=' + urlParams);
        //console.log('dataService --> creating( ' + url + ') with:' + resourceElt);

        var dto = metamodel.toDto(resourceElt);
        return $http.post(url, dto).then(function (response) {
          return factory.toObjectResult(response);
        });
      };

      /*
       * delete one element with optionally parameters specified in a urlParams object;
       *
       * NOTE: urlParams NOT IMPLEMENTED YET
       *
       * returns the updated object
       */
      factory.deleteElement = function (resource, resourceId, urlParams) {

        var params = urlParams || {};
        var url = baseUrl + resource + '/' + resourceId;
        ////console.log('--> deleting( ' + url + ' params=' + urlParams);
        //console.log('dataService --> deleting( ' + url + ')');

        return $http.delete(url, {params: params}).then(function (response) {
          return factory.toObjectResult(response);
        });
      };


      factory.toResultSet = function (response) {

        // we expect a result that is a result set ie {result:[records], total:count}
        // however we accomodate some APIs that directly return a list of records
        var result;
        if (Array.isArray(response.data)) {
          result = {
            data: response.data,
            total: response.data.length
          };
        }
        else {
          result = {
            data: response.data.result,
            total: response.data.total
          };
        }
        //console.log('dataService --> ' + response.config.method + ':' + response.config.url + ' -> [' + result.data.length + '] records out of: ' + result.total);
        result.data.forEach(function(elt, idx, array){
          array[idx] = metamodel.fromDto(elt);
        });
        return result;
      };


      factory.toObjectResult = function (response) {

        //var s = console.log('dataService --> ' + response.config.method + ':' + response.config.url + ' -> ');
        // we expect a result that is an object
        if (response.data) {
          //console.log( s + '[' + response.data + ']');

          return metamodel.fromDto(response.data);
//                return response.data;
        }
        else {
          //console.log( s + '[EMPTY RESULT]');
          return null;
        }
      };


      factory.prepareQueryParams = function (queryParams, pageIndex, pageSize) {

        var params = queryParams || {};
        if (pageIndex !== undefined && pageIndex >= 0) {
          // set offset & limit params if required (pageIndex >= 0)
          pageSize = (pageSize ? pageSize : 20);
          params.offset = (pageIndex-1) * pageSize;
          params.limit = pageSize;
        }
        return params;
      };

      //====================================================================
      // MetaModel configuration

      _.defaults(metamodel, {

        fromDto: function(elt){
          var clModel = this[elt.clName];
          if (clModel) {
            var result = {};
            for (var k in elt) {
              if (clModel[k]) {
                var mapper = this.fromDtoMappers[clModel[k]];
                var mappedvalue = mapper(elt[k]);
                result[k] = mappedvalue;
              }
              else {
                result[k] = elt[k];
              }
            }
            return result;
          }
          else {
            return elt;
          }
        },

        toDto: function(elt){
          var clModel = this[elt.clName];
          if (clModel) {
            var result = {};
            for (var k in elt) {
              if (clModel[k]) {
                var mapper = this.toDtoMappers[clModel[k]];
                var mappedvalue = mapper(elt[k]);
                result[k] = mappedvalue;
              }
              else {
                result[k] = elt[k];
              }
            }
            return result;
          }
          else {
            return elt;
          }
        }
      });

      factory.metamodel = metamodel;

      //====================================================================
      // private methods

      // addUrlParams()


      //
      //console.log('crudDataService created.');
      return factory;

    }]);

}());


;
//=============================================================================
// Service in charge of handling communication with REST resources
//

(function () {
  //console.log('in accountService.');
  /*
   var svc = angular.copy(

   var dataService = function (config, customersService, customersBreezeService) {
   return (config.useBreeze) ? customersBreezeService : customersService;
   };
   // _.extend(destination, *sources)

   */

  angular.module('emlogis.commonservices')
    .factory('dataService', ['crudDataService', '$http', '$q',
      function(crudDataService, $http, $q) {

        //console.log('creating dataService...');

        var factory = _.clone(crudDataService),     // clone dataService to extend it.
          baseUrl = '../emlogis/rest/';


        //====================================================================
        // public methods

        //--------------------------------------------------------------------
        // Account related methods
        //--------------------------------------------------------------------

        /*
         * get the list of roles associated to user or group account
         * Note: query parameters and paging parameters are present BUT NOT IMPLEMENTED TODAY
         *
         * expected  queryParams format is {
         *    filter: <filter expression>,
         *    orderby: <attribute name>,
         *    orderdir: <'ASC' | 'DESC'>
         * }
         * paging is optional (leave it undefined or specify pageIndex < 0) to skip paging
         * if pecified, paging starts at 0
         * returns the object  {
         *   data: <array of records>,
         *   total: <total nb of records for that resource>
         * }
         */
        factory.getAccountRoles = function(resource, accountId, queryParams, pageIndex, pageSize) {

          var params = factory.prepareQueryParams(queryParams, pageIndex, pageSize);
          var url = baseUrl + resource + '/' + accountId + '/roles';
          //console.log('--> querying( ' + url + ' q=' + params.filter
          //    + " orderby: " + params.orderby + '(' + params.orderdir
          //    + ') from: ' + params.offset + '[' + params.limit + ']'
          //);

          return $http.get(url, {params: params}).then(function (response) {
            return factory.toResultSet(response);
          });
        };

        /*
         * get the list of roles  NOT associated to an account

         */
        factory.getUnassociatedGroupAccountRoles = function(resource, groupId, queryParams, pageIndex, pageSize) {

          return factory.getElements(resource+'/'+groupId+'/unassociatedroles', queryParams, pageIndex, pageSize);

        };

        /*
         * add a Role to an account
         *
         */
        factory.addRoleToAccount = function(resource, accountId, roleId) {

          var url = baseUrl + resource + '/' + accountId + '/ops/addrole';
          //console.log('--> posting( ' + url + ')');
          return $http.post(url, roleId).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * remove a Role from an account
         *
         */
        factory.removeRoleFromAccount = function(resource, accountId, roleId) {

          var url = baseUrl + resource + '/' + accountId + '/ops/removerole';
          //console.log('--> posting( ' + url + ')');
          return $http.post(url, roleId).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * get the list of groups NOT associated to an account
         */
        factory.getUnassociatedAccountGroups = function(accountId, queryParams, pageIndex, pageSize) {

          var params = factory.prepareQueryParams(queryParams, pageIndex, pageSize);
          return $http.get(baseUrl + "useraccounts/" + accountId + '/unassociatedgroups', {params: params});
        };

        /*
         * get the list of roles NOT associated to an account
         */
        factory.getUnassociatedAccountRoles = function(accountId) {
          return $http.get(baseUrl + "useraccounts/" + accountId + '/unassociatedroles');
        };

        /*
         * create userAccount
         */
        factory.createUserAccount = function(dto) {
          return $http.post(baseUrl + "useraccounts", dto);
        };

        /*
         * update userAccount
         */
        factory.updateUserAccount = function(accountId, dto) {
          return $http.put(baseUrl + "useraccounts/" + accountId, dto);
        };

        /*
         * delete userAccount
         */
        factory.deleteUserAccount = function(accountid) {
          return $http.delete(baseUrl + "useraccounts/" + accountid);
        };

        /*
         * add group to userAccount
         */
        factory.addGroupsToUserAccount = function(accountId, dto) {
          return $http.post(baseUrl + "useraccounts/" + accountId + "/ops/addgroups", dto);
        };

        /*
         * remove group from userAccount
         */
        factory.removeGroupsFromUserAccount = function(accountId, dto) {
          return $http.post(baseUrl + "useraccounts/" + accountId + "/ops/removegroups", dto);
        };


        /*
         * get the list of groups NOT associated to an account
         */
        factory.getUnassociatedRolesGroups = function(resource, roleId, queryParams, pageIndex, pageSize) {

          return factory.getElements(resource+'/'+roleId+'/unassociatedgroupaccounts', queryParams, pageIndex, pageSize);

        };

        factory.getUnassociatedRolesUsers = function(resource, roleId, queryParams, pageIndex, pageSize) {
          return factory.getElements(resource+'/'+roleId+'/unassociateduseraccounts', queryParams, pageIndex, pageSize);
        };

        factory.getUnassociatedRolesPermissions = function(resource, roleId, queryParams, pageIndex, pageSize) {
          return factory.getElements(resource+'/'+roleId+'/unassociatedpermissions', queryParams, pageIndex, pageSize);
        };

        /*
         * add a userAccounts to a group
         *
         */
        factory.addRolesToGroup = function(groupId, dto) {
          return $http.post(baseUrl + "groupaccounts/" + groupId + "/ops/addroles", dto);
        };

        /*
         * add role to userAccount
         */
        factory.addRolesToUserAccount = function(accountId, dto) {
          return $http.post(baseUrl + "useraccounts/" + accountId + "/ops/addroles", dto);
        };

        /*
         * remove role from userAccount
         */
        factory.removeRolesFromUserAccount = function(accountId, dto) {
          return $http.post(baseUrl + "useraccounts/" + accountId + "/ops/removeroles", dto);
        };

        /*
         * delete Role
         */
        factory.deleteRole = function(roleId) {
          return $http.delete(baseUrl + "roles/" + roleId);
        };

        /*
         * request password reset for user
         */
        factory.requestPasswordReset = function(dto) {
          return $http.post(baseUrl + "useraccounts/ops/resetpassword", dto);
        };

        /*
         * request password for User
         */
        factory.requestUserPasswordReset = function(userId) {
          return $http.post(baseUrl + "useraccounts/" + userId + "/ops/resetpassword");
        };

        /*
         * Toggle notifications for User
         */
        factory.toggleUserNotifications = function(userId, enable) {
          return $http.post(baseUrl + "useraccounts/" + userId + "/ops/enablenotification", enable);
        };


        //--------------------------------------------------------------------
        // GroupAccount related methods
        //--------------------------------------------------------------------

        /*
         * get the list of user accounts in a group
         */
        factory.getGroupMembers = function(groupId, queryParams, pageIndex, pageSize) {

          var params = factory.prepareQueryParams(queryParams, pageIndex, pageSize);
          var url = baseUrl + 'groupaccounts/' + groupId + '/users';
          //console.log('--> querying( ' + url + ' q=' + params.filter
          //    + " orderby: " + params.orderby + '(' + params.orderdir
          //    + ') from: ' + params.offset + '[' + params.limit + ']'
          //);

          return $http.get(url, {params: params}).then(function (response) {
            return factory.toResultSet(response);
          });
        };

        /*
         * get the list of user accounts NOT belonging to a group
         */
        factory.getUnassociatedGroupMembers = function(groupId, queryParams, pageIndex, pageSize) {

          return factory.getElements('groupaccounts/'+groupId+'/unassociatedusers', queryParams, pageIndex, pageSize);
        };

        /*
         * add a userAccount to a group
         *
         */
        factory.addMemberToGroup = function(groupId, userAccountId) {

          var url = baseUrl + 'groupaccounts/' + groupId + '/ops/adduser';
          //console.log('--> posting( ' + url + ')');
          return $http.post(url, userAccountId).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * add a userAccounts to a group
         *
         */
        factory.addMembersToGroup = function(groupId, dto) {

          var url = baseUrl + 'groupaccounts/' + groupId + '/ops/addusers';
          //console.log('--> posting( ' + url + ')');
          return $http.post(url, dto).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * remove a userAccount from a group
         *
         */
        factory.removeMemberFromGroup = function(groupId, userAccountId) {

          var url = baseUrl + 'groupaccounts/' + groupId + '/ops/removeuser';
          //console.log('--> posting( ' + url + ')');
          return $http.post(url, userAccountId).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * remove a Role from an group
         *
         */
        factory.removeRoleFromGroup = function(groupId, roleId) {

          var url = baseUrl + 'groupaccounts/' + groupId + '/ops/removerole';
          //console.log('--> posting( ' + url + ')');
          return $http.post(url, roleId).then(function (response) {
            return factory.toObjectResult(response);
          });
        };


        //--------------------------------------------------------------------
        // UserAccount related methods
        //--------------------------------------------------------------------

        /*
         * get UserAccountViewDto with user account entity attributes, list of groups and roles
         */
        factory.getUserAccountView = function(userAccountId) {
          return $http.get(baseUrl + "useraccounts/" + userAccountId + "/userview");
        };

        /*
         * get the list of Groups a user account belongs to
         */
        factory.getUserGroups = function(useraccountId, queryParams, pageIndex, pageSize) {

          var params = factory.prepareQueryParams(queryParams, pageIndex, pageSize);
          var url = baseUrl + 'useraccounts/' + useraccountId + '/groups';
          //console.log('--> querying( ' + url + ' q=' + params.filter
          //    + " orderby: " + params.orderby + '(' + params.orderdir
          //    + ') from: ' + params.offset + '[' + params.limit + ']'
          //);

          return $http.get(url, {params: params}).then(function (response) {
            return factory.toResultSet(response);
          });
        };


        //--------------------------------------------------------------------
        // Role related methods
        //--------------------------------------------------------------------

        /*
         * get the list of permissions accounts in a Role
         */
        factory.getRolePermissions = function(roleId, queryParams, pageIndex, pageSize) {

          var params = factory.prepareQueryParams(queryParams, pageIndex, pageSize);
          var url = baseUrl + 'roles/' + roleId + '/permissions';
          //console.log('--> querying( ' + url + ' q=' + params.filter
          //    + " orderby: " + params.orderby + '(' + params.orderdir
          //    + ') from: ' + params.offset + '[' + params.limit + ']'
          //);

          return $http.get(url, {params: params}).then(function (response) {
            return factory.toResultSet(response);
          });
        };

        /*
         * get the list of permissions  NOT belonging to a role
         */
        factory.getUnassociatedRolePermissions = function(roleId, queryParams, pageIndex, pageSize) {

          return factory.getElements('roles/' + roleId + '/unassociatedpermissions', queryParams, pageIndex, pageSize);
        };

        /*
         * add a Permission to a Role
         */
        factory.addPermissionToRole = function(roleId, permissionId) {

          var url = baseUrl + 'roles/' + roleId + '/ops/addpermission';
          //console.log('--> posting( ' + url + ')');
          return $http.post(url, permissionId).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * remove a Permission from a Role
         *
         */
        factory.removePermissionFromRole = function(roleId, permissionId) {

          var url = baseUrl + 'roles/' + roleId + '/ops/removepermission';
          //console.log('--> posting( ' + url + ')');
          return $http.post(url, permissionId).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * remove groups from role
         */
        factory.removeGroupsFromRole = function(roleId, dto) {
          return $http.post(baseUrl + "roles/" + roleId + "/ops/removegroups", dto);
        };

        /*
         * remove users from role
         */
        factory.removeUsersFromRole = function(roleId, dto) {
          return $http.post(baseUrl + "roles/" + roleId + "/ops/removeusers", dto);
        };

        /*
         * add groups to role
         */
        factory.addGroupsToRole = function(roleId, dto) {
          return $http.post(baseUrl + "roles/" + roleId + "/ops/addgroups", dto);
        };

        /*
         * add a userAccounts to a role
         */
        factory.addUsersToRole = function(roleId, dto) {

          var url = baseUrl + 'roles/' + roleId + '/ops/addusers';

          return $http.post(url, dto).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * add a Permissions to a Role
         */
        factory.addPermissionsToRole = function(roleId, dto) {

          var url = baseUrl + 'roles/' + roleId + '/ops/addpermissions';

          return $http.post(url, dto).then(function (response) {
            return factory.toObjectResult(response);
          });
        };




        //--------------------------------------------------------------------
        // Site related methods
        //--------------------------------------------------------------------

        /*
         * Get Sites
         */

        factory.getSites = function() {
          var url = baseUrl + 'sites';

          return $http.get(url).then(function(response) {
            return factory.toResultSet(response);
          });
        };

        /*
         * delete Site
         */

        factory.deleteSite = function(siteId) {

          var url = baseUrl + 'sites/' + siteId + '/ops/softdelete/';
          return $http.post(url).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * get the list of Teams associated to a Site
         */
        factory.getSiteTeams = function(siteId, queryParams, pageIndex, pageSize, cache) {

          var params = factory.prepareQueryParams(queryParams, pageIndex, pageSize);
          var url = baseUrl + 'sites/' + siteId + '/teams';
          //console.log('--> querying( ' + url + ' q=' + params.filter
          //    + " orderby: " + params.orderby + '(' + params.orderdir
          //    + ') from: ' + params.offset + '[' + params.limit + ']'
          //);
          var cacheVal = cache && cache !== undefined ? cache : false;

          return $http.get(url, {params: params, cache: cacheVal}).then(function (response) {
            return factory.toResultSet(response);
          });
        };

        /*
         *  GET Sites+Teams tree
         */

        factory.getSitesTeamsTree = function(queryParams){
          return $http.get(baseUrl + 'sites/siteteamskills', queryParams).then(function(res){
            return factory.toResultSet(res);
          });
        };

        /*
         * get the list of Teams  NOT belonging to a Site
         */
        // TODO remove this method below once teams are built as per 'specified' APIs
        factory.getUnassociatedSiteTeams = function(siteId, queryParams, pageIndex, pageSize) {

          // TODO replace this temporary impl that returns all teams
          // TEMPORARY IMPL
          return factory.getElements('teams', queryParams, pageIndex, pageSize);
        };

        /*
         * get the list of skills associated to a Site
         */
        factory.getSiteSkills = function(siteId, queryParams, pageIndex, pageSize) {

          return factory.getElements('sites/' + siteId + '/skills', queryParams, pageIndex, pageSize);
        };

        /*
         * get the list of skills  NOT belonging to a Site
         */
        factory.getUnassociatedSiteSkills = function(siteId, queryParams, pageIndex, pageSize) {

          return factory.getElements('sites/'+siteId+'/unassociatedskills', queryParams, pageIndex, pageSize);
        };

        /*
         * add a Skill to a Site
         *
         */
        factory.addSiteSkill = function(siteId, skillId) {

          var url = baseUrl + 'sites/' + siteId + '/ops/addskill?skillId=' + skillId;
          //console.log('--> posting( ' + url + ')');
          return $http.post(url).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * remove a Skill from a Site
         *
         */
        factory.removeSkillFromSite = function(siteId, skillId) {

          var url = baseUrl + 'sites/' + siteId + '/ops/removeskill?skillId=' + skillId;
          //console.log('--> posting( ' + url + ')');
          return $http.post(url).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * get list of Timezones
         *
         */
        factory.getTimeZones = function () {

          var url = baseUrl + 'sites/timezones';
          return $http.get(url).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        //--------------------------------------------------------------------
        // Scheduling Settings on Site level
        //--------------------------------------------------------------------

        // GET Scheduling Settings for a Site

        factory.getSiteSchedulingSettings = function (siteId, queryParams, pageIndex, pageSize) {
          //return factory.getElements('sites/' + siteId + '/schedulingsettings', queryParams, pageIndex, pageSize);
          return $http.get(baseUrl + 'sites/' + siteId + '/schedulingsettings/');
        };

        // Create Scheduling Settings for a Site

        factory.createSiteSchedulingSettings = function (siteId, dto) {
          return $http.post(baseUrl + 'sites/' + siteId + '/schedulingsettings/', dto);
        };

        // Update Scheduling Settings for a Site

        factory.updateSiteSchedulingSettings = function (siteId, dto) {
          return $http.put(baseUrl + 'sites/' + siteId + '/schedulingsettings/', dto);
        };

        // Delete Scheduling Settings for a Site

        factory.deleteSiteSchedulingSettings = function (siteId) {
          return $http.delete(baseUrl + 'sites/' + siteId + '/schedulingsettings/');
        };

        //--------------------------------------------------------------------
        // Absence Types methods
        //--------------------------------------------------------------------

        // GET Absence Types

        factory.getAbsenceTypes = function (siteId, queryParams, pageIndex, pageSize) {

          return factory.getElements('sites/'+siteId+'/absencetypes', queryParams, pageIndex, pageSize);
        };

        // GET drop shift reasons and absence types

        factory.getDropShiftReasonsAndAbsenceTypes = function(siteId, queryParams, pageIndex, pageSize) {

          return factory.getElements('sites/' + siteId + '/dropshiftreasonsandabsencetypes', queryParams, pageIndex, pageSize);
        };

        // DELETE Absence Type

        factory.deleteAbsenceType = function (siteId, typeId) {
          return $http.delete(baseUrl + 'sites/' + siteId + '/absencetypes/' + typeId);
        };

        // UPDATE Absence Type

        factory.updateAbsenceType = function (siteId, typeId, dto) {
          return $http.put(baseUrl + 'sites/' + siteId + '/absencetypes/' + typeId, dto);
        };

        // ADD Absence Type

        factory.addAbsenceType = function (siteId, dto) {
          return $http.post(baseUrl + 'sites/' + siteId + '/absencetypes', dto);
        };

        //--------------------------------------------------------------------
        // Shift Lengths & Types methods
        //--------------------------------------------------------------------

        // GET Shift Lengths

        factory.getShiftLengths = function (siteId, queryParams, pageIndex, pageSize) {

          return factory.getElements('sites/'+siteId+'/shiftlengths', queryParams, pageIndex, pageSize);
        };

        // Update

        factory.updateShiftLength = function (siteId, lengthId, dto) {
          return $http.put(baseUrl + 'sites/' + siteId + '/shiftlengths/' + lengthId, dto);
        };

        // Multi Add New Shift Lengths

        factory.addNewShiftLengths = function (siteId, dto) {
          return $http.post(baseUrl + 'sites/' + siteId + '/shiftlengths/ops/createmultiple', dto);
        };

        /* Shift Types */

        // GET Shift Types belonging to a Shift Length

        factory.getShiftTypesForLength = function(siteId, shiftLengthId, queryParams, pageIndex, pageSize) {
          return factory.getElements('sites/' + siteId + '/shiftlengths/' + shiftLengthId + '/shifttypes', queryParams, pageIndex, pageSize);
        };

        // Upd multi Shift Types activation

        factory.updShiftTypesActivation = function(siteId, dto) {
          return $http.post(baseUrl + 'sites/' + siteId + '/shifttypes/ops/updateactivation', dto);
        };

        // Update a Type

        factory.updateShiftType = function(siteId, typeId, dto) {
          return $http.put(baseUrl + 'sites/' + siteId + '/shifttypes/' + typeId, dto);
        };

        // Delete a Type

        factory.deleteShiftType = function(siteId, typeId) {
          return $http.delete(baseUrl + 'sites/' + siteId + '/shifttypes/' + typeId);
        };

        // Add a Type

        factory.addShiftType = function(siteId, dto) {
          return $http.post(baseUrl + 'sites/' + siteId + '/shifttypes', dto);
        };

        // Bulk Add Shift Types

        factory.bulkAddNewShiftTypes = function(siteId, dto) {
          return $http.post(baseUrl + 'sites/' + siteId + '/shifttypes/ops/createmultiple', dto);
        };


        //--------------------------------------------------------------------
        // Team related methods
        //--------------------------------------------------------------------

        /*
         * Get Teams
         */

        factory.getTeams = function() {
          var url = baseUrl + 'teams';

          return $http.get(url).then(function(response) {
            return factory.toResultSet(response);
          });
        };

        /*
         * delete Team
         *
         */
        factory.deleteTeam = function(teamId) {

          var url = baseUrl + 'teams/' + teamId + '/ops/softdelete/';
          return $http.post(url).then(function (response) {
            return factory.toObjectResult(response);
          });
        };


        /*
         * get the list of skills associated to a Team
         */
        factory.getTeamSkills = function(teamId, queryParams, pageIndex, pageSize) {

          return factory.getElements('teams/' + teamId + '/skills', queryParams, pageIndex, pageSize);
        };

        /*
         * get the list of skills  NOT belonging to a Team
         */
        factory.getUnassociatedTeamSkills = function(teamId, queryParams, pageIndex, pageSize) {

          return factory.getElements('teams/' + teamId + '/unassociatedskills', queryParams, pageIndex, pageSize);
        };

        /*
         * add a Skill to a Team
         *
         */
        factory.addTeamSkill = function(teamId, skillId) {

          var url = baseUrl + 'teams/' + teamId + '/ops/addskill?skillId=' + skillId;
          //console.log('--> posting( ' + url + ')');
          return $http.post(url).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * remove a Skill from a Team
         *
         */
        factory.removeSkillFromTeam = function(teamId, skillId) {

          var url = baseUrl + 'teams/' + teamId + '/ops/removeskill?skillId=' + skillId;
          //console.log('--> posting( ' + url + ')');
          return $http.post(url).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * get the list of employees associated to a Team
         */
        factory.getTeamEmployees = function(teamId, queryParams, pageIndex, pageSize) {

          return factory.getElements('teams/' + teamId + '/employees', queryParams, pageIndex, pageSize);
        };

        /*
         * get the list of skills  NOT belonging to a Team
         */
        factory.getUnassociatedTeamEmployees = function(teamId, queryParams, pageIndex, pageSize) {

          return factory.getElements('teams/' + teamId + '/unassociatedemployees', queryParams, pageIndex, pageSize);
        };

        /*
         * add Employee to team
         *
         */
        factory.addEmployeeToTeam = function(teamId, employeeId, createDto) {

          return factory.addTeamToEmployee(employeeId, teamId, createDto);
        };

        /*
         * remove an Employee from a Team
         *
         */
        factory.removeEmployeeFromTeam = function(teamId, employeeId) {

          return factory.removeEmployeeFromTeam(employeeId, teamId);
        };

        /*
         * upadte a Team-Employee relationship
         *
         * returns the updated object
         */
        factory.updateTeamEmployee = function (teamId, employeeId, updateDto) {

          return factory.updateEmployeeTeam(employeeId, teamId, updateDto);
        };

        /*
         * get the list of shiftStructures associated to a Team
         */
        factory.getShiftStructures = function(teamId, queryParams, pageIndex, pageSize) {

          return factory.getElements('teams/' + teamId + '/shiftstructures', queryParams, pageIndex, pageSize);
        };

        /*
         * create and add a ShiftStructure to a Team
         *
         */
        factory.createShiftStructure = function(teamId, createDto) {

          var url = baseUrl + 'teams/' + teamId + '/shiftstructures';
          //console.log('--> posting( ' + url + ')');
          var dto = factory.metamodel.toDto(createDto);
          return $http.post(url, dto).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * get a ShiftStructure
         *
         */
        factory.getShiftStructure = function(teamId, shiftStructureId) {

          var url = baseUrl + 'teams/' + teamId + '/shiftstructures/' + shiftStructureId;
          //console.log('--> getting( ' + url + ')');
          return $http.get(url).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * update a ShiftStructure
         *
         */
        factory.updateShiftStructure = function(teamId, shiftStructureId, updateDto) {

          var url = baseUrl + 'teams/' + teamId + '/shiftstructures/' + shiftStructureId;
          //console.log('--> updating( ' + url + ')');
          var dto = factory.metamodel.toDto(updateDto);
          return $http.put(url, dto).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * delete and remove a ShiftStructure from a Team
         *
         */
        factory.deleteShiftStructure = function(teamId, shiftStructureId) {

          var url = baseUrl + 'teams/' + teamId + '/shiftstructures/' + shiftStructureId;
          //console.log('--> posting( ' + url + ')');
          return $http.delete(url).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * get the list of Schedule associated to a Team
         */
        factory.getTeamSchedules = function(teamId, queryParams, pageIndex, pageSize) {

          return factory.getElements('teams/' + teamId + '/schedules', queryParams, pageIndex, pageSize);
        };

        /*
         * Get Schedules
         */
        factory.getSchedules = function(payLoad) {
          return factory.getElementsByPost('schedules/ops/querynew', payLoad);
        };

        //--------------------------------------------------------------------
        // Team-Employee membership related methods
        //--------------------------------------------------------------------

        /*
         Get the list of team membership objects
         */

        factory.getTeamMembership = function(teamId, queryParams, pageIndex, pageSize) {
          return factory.getElements('teams/' + teamId + '/membership', queryParams, pageIndex, pageSize);
        };


        /*
         Removes association between a team and specified employees
         */

        factory.removeEmployeesTeamMembership = function(teamId, emplIdsList) {
          //return factory.createElement('teams/' + teamId + '/membership/ops/removeemployees', emplIdsList);

          return factory.createElement('teams/' + teamId + '/membership/ops/removeemployees', emplIdsList);
        };



        //--------------------------------------------------------------------
        // Shift ShiftStructure related methods
        //--------------------------------------------------------------------

        /*
         * get the list of Team associated to a ShiftStructure
         * Note: query parameters and paging parameters are present BUT NOT IMPLEMENTED TODAY
         *
         */
        factory.getShiftStructureTeams = function(shiftStructureId, queryParams, pageIndex, pageSize) {

          return factory.getElements('shiftstructures/' + shiftStructureId + '/teams', queryParams, pageIndex, pageSize);
        };

        //--------------------------------------------------------------------
        // Shift Requirement related methods
        //--------------------------------------------------------------------

        /*
         * get the list of shiftReqs associated to a ShiftStructure
         */
        factory.getShiftReqs = function(shiftStructureId, queryParams, pageIndex, pageSize) {

          return factory.getElements('shiftstructures/' + shiftStructureId + '/shiftreqs', queryParams, pageIndex, pageSize);
        };

        /*
         * create and add a ShiftReq to a ShiftStructure
         *
         */
        factory.createShiftReq = function(shiftStructureId, createDto) {

          var url = baseUrl + 'shiftstructures/' + shiftStructureId + '/shiftreqs';
          //console.log('--> posting( ' + url + ')');
          var dto = factory.metamodel.toDto(createDto);
          return $http.post(url, dto).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * get a ShiftReq
         *
         */
        factory.getShiftReq = function(shiftStructureId, shiftReqId) {

          var url = baseUrl + 'shiftstructures/' + shiftStructureId + '/shiftreqs/' + shiftReqId;
          //console.log('--> loading( ' + url + ')');
          return $http.get(url).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * Update a ShiftReq
         *
         */
        factory.updateShiftReq = function(shiftStructureId, shiftReqId, updateDto) {

          var url = baseUrl + 'shiftstructures/' + shiftStructureId + '/shiftreqs/' + shiftReqId;
          //console.log('--> updating( ' + url + ')');
          var dto = factory.metamodel.toDto(updateDto);
          return $http.put(url, dto).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * delete and remove a ShiftReq from a ShiftStructure
         *
         */
        factory.deleteShiftReq = function(shiftStructureId, shiftReqId) {

          var url = baseUrl + 'shiftstructures/' + shiftStructureId + '/shiftreqs/' + shiftReqId;
          //console.log('--> deleting( ' + url + ')');
          return $http.delete(url).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        //--------------------------------------------------------------------
        // Employee related methods
        //--------------------------------------------------------------------

        /*
         * get list of Employees
         */
        factory.getEmployees = function(queryParams, pageIndex, pageSize) {
          return factory.getElements('employees/ops/query/', queryParams, pageIndex, pageSize);
        };

        /*
         * search for Employee
         */
        factory.searchEmployees = function(queryParams) {
          return factory.getElements('employees/ops/quicksearch', queryParams);
        };

        /*
         * Get Employee details
         */
        factory.getEmployeeDetails = function(employeeId, queryParams) {
          return $http.get(baseUrl + 'employees/' + employeeId + '/managerdetailsview', queryParams).then(function(res){
            return res;
          });
        };

        /*
         * update Employee
         */
        factory.updateEmployee = function(employeeId, dto) {

          return factory.updateElement('employees', employeeId, dto);
        };

        /*
         * delete Employee
         */
        factory.deleteEmployee = function(employeeId) {

          var url = baseUrl + 'employees/' + employeeId + '/ops/softdelete/';
          return $http.post(url).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * create Employee
         */
        factory.createEmployee = function(dto) {

            var url = baseUrl + 'employees/';
            return $http.post(url, dto).then(function (response) {
                return factory.toObjectResult(response);
            });
        };

        /*
         * get Employee picture
         */
        factory.getEmployeePicture = function(employeeId, queryParams) {
          return $http.get(baseUrl + 'employees/' + employeeId + '/picture', queryParams).then(function(res){
            return res;
          });
        };

        /*
         * NEW get Employee picture via useraccount
         */
        factory.getUserPicture = function(userId) {
          return $http.get(baseUrl + 'useraccounts/' + userId + '/picture').then(function(res){
            return res;
          });
        };

        /*
         * update Employee picture
         */
        factory.uploadUserPicture = function(userId, fd) {
            return $http.put(baseUrl + 'useraccounts/' + userId + '/picture', fd).then(function(res){
                return res;
            });
        };

        /*
         * update Employee picture
         */
        factory.uploadEmployeePicture = function(employeeId, fd) {
            return $http.put(baseUrl + 'employees/' + employeeId + '/picture', fd).then(function(res){
                return res;
            });
        };

        /*
         * Get Employee autoapprovals
         */
        factory.getEmployeeAutoapprovals = function(employeeId, queryParams) {
          return $http.get(baseUrl + 'employees/' + employeeId + '/autoapprovals', queryParams).then(function(res){
            return res;
          })
            ;
        };

        /*
         * update Employee autoapprovals settings
         */
        factory.updateEmployeeAutoapprovals = function(employeeId, dto) {

          //return factory.updateElement('employees', employeeId, '/autoapprovals', dto);

          var url = baseUrl + 'employees/' + employeeId + '/autoapprovals';
          return $http.put(url, dto).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * update Employee's Skills
         */
        factory.updateEmployeeSkills = function(employeeId, dto) {
          var url = baseUrl + 'employees/' + employeeId + '/ops/updateemployeeskills';
          return $http.post(url, dto).then(function(res){
            return factory.toObjectResult(res);
          });
        };

        /*
         * update Employee's Teams
         */
        factory.updateEmployeeTeams = function(employeeId, dto) {
          var url = baseUrl + 'employees/' + employeeId + '/ops/updateemployeeteams';
          return $http.post(url, dto).then(function(res){
            return factory.toObjectResult(res);
          });
        };

        /*
         * get Employee preferences
         */
        factory.getEmployeePreferences = function(userId) {
          return $http.get(baseUrl + 'useraccounts/' + userId + '/notificationsettings');
        };

        /*
         * update Employee preferences
         */
        factory.updateEmployeePreferences = function(userId, dto) {
          return $http.put(baseUrl + 'useraccounts/' + userId + '/notificationsettings', dto);
        };

        /*
         * get Employee hours and overtime
         */
        factory.getEmployeeHoursAndOvertime = function(employeeId) {
          return $http.get(baseUrl + 'employees/' + employeeId + '/hoursandovertime');
        };

        /*
         * update Employee hours and overtime
         */
        factory.updateEmployeeHoursAndOvertime = function(employeeId, dto) {
          return $http.put(baseUrl + 'employees/' + employeeId + '/hoursandovertime', dto);
        };

        /*
         * get Employee calendar view
         */
        factory.getEmployeeCalendarView = function(employeeId, queryParams) {
          return $http.get(baseUrl + 'employees/' + employeeId + '/calendarview', queryParams);
        };

        /*
         * Get Employee Calendar and Availability View
         */
        factory.getEmployeeCalendarAndAvailabilityView = function(scheduleId, employeeId, queryParams) {
          return $http.get(baseUrl + 'schedules/' + scheduleId + '/employees/' + employeeId + '/calendarandavailabilityview', queryParams);
        };

        /*
         * get Employee availability/preferences view
         */
        factory.getEmployeeAvailabilityView = function(employeeId, startDate, endDate) {
          var employeeIdPart = employeeId ? ("/" + employeeId) : "";
          return $http.post(baseUrl + 'employees' + employeeIdPart + '/ops/availcal/view?daterangestart=' + startDate + '&daterangeend=' + endDate);
        };

        /*
         * get Employee availability preview
         */
        factory.getEmployeeAvailabilityPreview = function(employeeId, dto) {
          return $http.post(baseUrl + 'employees/' + employeeId + '/ops/availcal/workflowrequestpreview', dto);
        };

        /*
         * update Employee cd availability
         */
        factory.updateEmployeeCDAvailability = function(employeeId, dateRangeStart, dateRangeEnd, dto) {
          return $http.post(baseUrl + 'employees/' + employeeId +
            '/ops/availcal/cdavailupdate?daterangestart=' + dateRangeStart + '&daterangeend=' + dateRangeEnd, dto);
        };

        /*
         * update Employee ci availability
         */
        factory.updateEmployeeCIAvailability = function(employeeId, dateRangeStart, dateRangeEnd, dto) {
          return $http.post(baseUrl + 'employees/' + employeeId +
            '/ops/availcal/ciavailupdate?daterangestart=' + dateRangeStart + '&daterangeend=' + dateRangeEnd, dto);
        };

        /*
         * update Employee cd preference
         */
        factory.updateEmployeeCDPreference = function(employeeId, dateRangeStart, dateRangeEnd, dto) {
          return $http.post(baseUrl + 'employees/' + employeeId +
            '/ops/availcal/cdprefupdate?daterangestart=' + dateRangeStart + '&daterangeend=' + dateRangeEnd, dto);
        };

        /*
         * update Employee ci preference
         */
        factory.updateEmployeeCIPreference = function(employeeId, dateRangeStart, dateRangeEnd, dto) {
          return $http.post(baseUrl + 'employees/' + employeeId +
            '/ops/availcal/ciprefupdate?daterangestart=' + dateRangeStart + '&daterangeend=' + dateRangeEnd, dto);
        };

        /*
         * Update a Weekday Rotation
         */
        factory.updateWeekdayRotation = function(employeeId, dateRangeStart, dateRangeEnd, dto) {
          return $http.post(baseUrl + 'employees/' + employeeId +
            '/ops/availcal/rotationupdate?daterangestart=' + dateRangeStart + '&daterangeend=' + dateRangeEnd, dto);
        };

        /*
         * Copy employee availability
         */
        factory.copyEmployeeAvailability = function(employeeId, dateRangeStart, dateRangeEnd, dto) {
          return $http.post(baseUrl + 'employees/' + employeeId +
            '/ops/availcal/cdcopy?daterangestart=' + dateRangeStart + '&daterangeend=' + dateRangeEnd, dto);
        };

        /*
         * Update a specific week's Max Days Per Week
         */
        factory.updateEmployeeMaxDaysPerWeek = function(employeeId, dto) {
          return $http.post(baseUrl + 'employees/' + employeeId + '/ops/availcal/maxdaysupdate', dto);
        };

        /*
         * Update employee availability couple weekends option
         */
        factory.updateEmployeeCoupleWeekends = function(employeeId, dto) {
          return $http.post(baseUrl + 'employees/' + employeeId + '/ops/availcal/coupleweekendsupdate', dto);
        };

        /*
         * Request availability change (Employee view)
         */
        factory.requestAvailabilityChange = function(dto) {
          return $http.post(baseUrl + 'requests/submitter/', dto);
        };

        /*
         * get the list of Calendar Dependent Availability records associated to an Employee
         */
        factory.getEmployeeCDAvailabilities = function(employeeId, queryParams, pageIndex, pageSize) {

          return factory.getElements('employees/' + employeeId + '/cdavailability', queryParams, pageIndex, pageSize);
        };

        /*
         * get the list of Teams  an Employee belongs to
         */
        factory.getEmployeeTeams = function(employeeId, queryParams, pageIndex, pageSize) {
          return factory.getElements('employees/' + employeeId + '/teams', queryParams, pageIndex, pageSize);
        };

        /*
         * get the list of Teams an Employee DOESN't belong to
         */
        factory.getUnassociatedEmployeeTeams = function(employeeId, queryParams, pageIndex, pageSize) {

          return factory.getElements('employees/' + employeeId + '/unassociatedteams', queryParams, pageIndex, pageSize);
        };

        /*
         * add Employee to team
         *
         */
        factory.addTeamToEmployee = function(employeeId, teamId, createDto) {

          if (createDto === undefined) {
            // assume we get a teamId only instead of a createDto
            // in that case, set  default values for dto attributes
            createDto = {
              isFloating: false,
              isHomeTeam: false,
              isSchedulable: true,
              teamId: teamId
            };
          }
          var url = baseUrl + 'employees/' + employeeId + '/teams/';
          //console.log('--> posting( ' + url + ')');
          var dto = factory.metamodel.toDto(createDto);
          return $http.post(url, dto).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * remove an Employee from a Team
         *
         */
        factory.removeTeamFromEmployee = function(employeeId, teamId) {

          var url = baseUrl + 'employees/' + employeeId + '/teams/' + teamId;
          //console.log('--> posting( ' + url + ')');
          return $http.delete(url).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * upadte a Team-Employee relationship
         *
         * returns the updated object
         */
        factory.updateEmployeeTeam = function (employeeId, teamId, updateDto) {

          var url = baseUrl + resource + 'employees/' + employeeId + '/teams/' + teamId;
          ////console.log('--> updating( ' + url + ' params=' + urlParams);
          //console.log('--> updating( ' + url + ') with:' + updateDto);
          var dto = factory.metamodel.toDto(updateDto);
          return $http.put(url, dto).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        factory.updateEmployeeHomeTeam = function (employeeId, teamId, updateDto) {

          var url = baseUrl + 'employees/' + employeeId + '/teams/' + teamId;
          return $http.put(url, updateDto).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * get the list of skills associated to an Employee

         */

        factory.getEmployeeSkills = function(employeeId, queryParams, pageIndex, pageSize) {

          return factory.getElements('employees/' + employeeId + '/skills',queryParams, pageIndex, pageSize);
        };


        /*
         * get the list of skills  NOT belonging to a Employee
         */
        factory.getUnassociatedEmployeeSkills = function(employeeId, queryParams, pageIndex, pageSize) {

          return factory.getElements('employees/' + employeeId + '/unassociatedskills', queryParams, pageIndex, pageSize);
        };

        /*
         * add a Skill to an Employee
         *
         */
        factory.addSkillToEmployee = function(employeeId, skillId, createDto) {

          if (createDto === undefined) {
            // assume we get a skillId only instead of a createDto
            // in that case, set  default values for dto attributes
            createDto = {
              isPrimarySkill: false,
              skillScore: 3,
              skillId: skillId
            };
          }

          var url = baseUrl + 'employees/' + employeeId + '/skills/';
          //console.log('--> posting( ' + url + ')');
          var dto = factory.metamodel.toDto(createDto);
          return $http.post(url, dto).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * remove a Skill from an Employee
         *
         */
        factory.removeSkillFromEmployee = function(employeeId, skillId) {

          var url = baseUrl + 'employees/' + employeeId + '/skills/' + skillId;
          //console.log('--> posting( ' + url + ')');
          return $http.delete(url).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * upadate a Skill-Employee relationship
         *
         * returns the updated object
         */
        factory.updateEmployeeSkill = function (employeeId, skillId, updateDto) {

          var url = baseUrl + 'employees/' + employeeId + '/skills/' + skillId;
          ////console.log('--> updating( ' + url + ' params=' + urlParams);
          //console.log('--> updating( ' + url + ') with:' + updateDto);
          var dto = factory.metamodel.toDto(updateDto);
          return $http.put(url, dto).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         *  get Employee Account
         *
         * returns the associated account object
         */
        factory.getEmployeeAccount = function (employeeId) {

          var url = baseUrl + 'employees/' + employeeId + '/useraccount';
          //console.log('--> getting account( ' + url + ')');
          return $http.get(url).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        factory.updateEmployeeAccount = function (employeeId, dto) {

          var url = baseUrl + 'employees/' + employeeId + '/useraccount';
          //console.log('--> getting account( ' + url + ')');
          return $http.put(url, dto).then(function (response) {
            return factory.toObjectResult(response);
          });
        };


        /*
         * get the list of Contracts associated to an Employee
         *
         */
        factory.getEmployeeContracts = function(employeeId, queryParams, pageIndex, pageSize) {

          return factory.getElements('employees/' + employeeId + '/contracts', queryParams, pageIndex, pageSize);
        };


        /*
         * Get eligible shifts for selected shift
         */
        factory.getSwapEligibleShiftsForShift = function(employeeId, shiftId) {
          var payLoad = {
            shiftId: shiftId
          };

          return $http.post(baseUrl + 'employees/' + employeeId + '/ops/getswapeligibleshifts', payLoad);
        };

        /*
         * Get eligible employees for proposed open shift
         */
        factory.getWipEligibleEmployeesForProposedOpenShift = function(scheduleId, shiftInfo, overrideOptions) {
          var payLoad = {
            includeConstraintViolationSummary: true,
            teamId: shiftInfo.teamId,
            skillId: shiftInfo.skillId,
            startDateTime: shiftInfo.start,
            endDateTime: shiftInfo.end
          };
          if (overrideOptions !== null) {
            payLoad.overrideOptions = overrideOptions;
          }

          return $http.post(baseUrl + 'schedules/' + scheduleId + '/ops/getproposedopeneshifteligibleemployees', payLoad);
        };

        /*
         * Get drop shift reasons for site
         */
        factory.getDropShiftReasons = function(siteId) {
          return $http.get(baseUrl + "sites/" + siteId + "/dropshiftreasonsandabsencetypes");
        };

        //--------------------------------------------------------------------
        // Schedule related methods
        //--------------------------------------------------------------------

        /*
         * get the list of ShiftStructures associated to a Schedule
         * Note: query parameters and paging parameters are present BUT NOT IMPLEMENTED TODAY
         *
         */
        factory.getScheduleShiftStructures = function(scheduleId, queryParams, pageIndex, pageSize) {

          return factory.getElements('schedules/' + scheduleId + '/shiftstructures', queryParams, pageIndex, pageSize);
        };

        /*
         * get schedule exceptions info
         */
        factory.getScheduleExceptions = function(scheduleId) {

          return $http.get(baseUrl + 'schedules/' + scheduleId + '/exceptions');
        };

        /*
         * get the list of Team associated to a Schedule
         * Note: query parameters and paging parameters are present BUT NOT IMPLEMENTED TODAY
         *
         */
        factory.getScheduleTeams = function(scheduleId, queryParams, pageIndex, pageSize) {

          return factory.getElements('schedules/' + scheduleId + '/teams', queryParams, pageIndex, pageSize);
        };

        /*
         * get the list of Shifts associated to a Schedule
         * Note: query parameters and paging parameters are present BUT NOT IMPLEMENTED TODAY
         *
         */
        factory.getScheduleShifts = function(scheduleId, queryParams, pageIndex, pageSize) {

          return factory.getElements('schedules/' + scheduleId + '/shifts', queryParams, pageIndex, pageSize);
        };

        /*
         * get the list of Shifts associated to a Schedule using additional filters
         * Note: query parameters and paging parameters are present BUT NOT IMPLEMENTED TODAY
         *
         */
        factory.getScheduleShiftsOps = function(scheduleId, queryParams) {

          var url = baseUrl + 'schedules/' + scheduleId + '/shifts/ops';
          return $http.get(url, {params: queryParams})
            .then(function (response) {
              return response;
            });
        };

        /**
         * get list of Shifts associated to a Schedule and specified by time period
         * filter - array of filters
         */
        factory.getScheduleShiftsByPeriod = function (scheduleId, startDate, endDate, filter, returnedFields) {

          var url = baseUrl + 'schedules/' + scheduleId + '/shifts/ops/get';
          filter = filter.join(';');
          return $http.get(url, {params: {startdate: startDate, enddate: endDate, filter: filter, returnedfields: returnedFields}})
            .then(function (response) {
              return factory.toResultSet(response);
            });
        };

        /*
         * Execute a Schedule        *
         */
        factory.executeSchedule = function(scheduleId, dto) {

          var url = baseUrl + 'schedules/' + scheduleId + '/ops/execute';
          //console.log('--> executing( ' + url + ')');
          return $http.post(url, dto).then(function (response) {
            return factory.toObjectResult(response);
          });
        };


        factory.duplicateSchedule = function (scheduleId, dto) {

          var url = baseUrl + 'schedules/' + scheduleId + '/ops/duplicate';
          return $http.post(url, dto).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * promote a Schedule
         */
        factory.promoteSchedule = function(scheduleId) {

          var url = baseUrl + 'schedules/' + scheduleId + '/ops/promote';
          //console.log('--> executing( ' + url + ')');
          return $http.post(url).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * delete a schedule
         */
        factory.deleteSchedule = function(scheduleId) {
          var url = baseUrl + 'schedules/' + scheduleId;

          return $http.delete(url).then(function(response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * reset a Schedule state
         */
        factory.resetScheduleState = function(scheduleId) {

          var url = baseUrl + 'schedules/' + scheduleId + '/ops/resetstate';
          //console.log('--> executing( ' + url + ')');
          return $http.post(url).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * generate Schedule  Shifts
         */
        factory.generateShifts = function(scheduleId) {

          var url = baseUrl + 'schedules/' + scheduleId + '/ops/generateshifts';
          //console.log('--> executing( ' + url + ')');
          return $http.post(url).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * Abort a Schedule        *
         */
        factory.abortSchedule = function(scheduleId) {

          var url = baseUrl + 'schedules/' + scheduleId + '/ops/abort';
          //console.log('--> posting( ' + url + ')');
          return $http.post(url).then(function (response) {
            return factory.toObjectResult(response);
          });
        };


        /*
         * get the list of Changes associated to a Schedule
         * Note: queryParams has optional extra parameters specific to that API
         *
         */
        factory.getScheduleChanges = function(scheduleId, queryParams, pageIndex, pageSize) {

          return factory.getElements('schedules/' + scheduleId + '/changes', queryParams, pageIndex, pageSize);
          /*
           var params = factory.prepareQueryParams(queryParams, pageIndex, pageSize);
           var specificParams = _.pick(queryParams, 'startdate', 'enddate', 'type', 'employees');
           _.defaults(params, specificParams);
           var url = baseUrl + resource;
           //console.log('dataService --> querying( ' + url + ' q=' + params.filter
           + " orderby: " + params.orderby + '(' + params.orderdir
           + ') from: ' + params.offset + '[' + params.limit + ']'
           + ' between: ' + params.startdate + ' and ' + params.enddate
           + ' for type: ' + params.type + ' and employees: ' + params.employees
           );
           return $http.get(url, {params: params}).then(function (response) {
           return factory.toResultSet(response);
           });
           */
        };

        /*
         * get the list of Eployees associated to a Schedule
         *
         */
        factory.getScheduleEmployees = function(scheduleId, queryParams, pageIndex, pageSize) {

          return factory.getElements('schedules/' + scheduleId + '/employees', queryParams, pageIndex, pageSize);
        };

        /*
         * get the list of ScheduleOptions
         *
         */
        factory.getScheduleOptions = function(scheduleId) {

          var url = baseUrl + 'schedules/' + scheduleId + '/options';
          //console.log('--> getting( ' + url + ')');
          return $http.get(url).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * update ScheduleOptions
         *
         */
        factory.updateScheduleOptions = function(scheduleId, updateDto) {

          var url = baseUrl + 'schedules/' + scheduleId + '/options';
          //console.log('--> updating( ' + url + ')');
          var dto = factory.metamodel.toDto(updateDto);
          return $http.put(url, dto).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * get Execution report of Schedule
         */
        factory.getScheduleReport = function (scheduleId) {

          var url = baseUrl + 'schedules/' + scheduleId + '/executionreport';
          //console.log('--> getting( ' + url + ')');
          return $http.get(url).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        factory.getScheduleReportExt = function (scheduleId) {

          var url = baseUrl + 'schedules/' + scheduleId + '/executionreportext';
          //console.log('--> getting( ' + url + ')');
          return $http.get(url).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * get Schedule Settings for settings dialog in schedule builder
         */
        factory.getScheduleSettings = function (scheduleId) {

          var url = baseUrl + 'schedules/' + scheduleId + '/ops/getsettings';
          //console.log('--> getting( ' + url + ')');
          return $http.get(url).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * update Schedule Settings for settings dialog in schedule builder
         */
        factory.updateScheduleSettings = function (scheduleId, updateDto) {

          var url = baseUrl + 'schedules/' + scheduleId + '/ops/setsettings';
          //console.log('--> updating( ' + url + ')');
          var dto = factory.metamodel.toDto(updateDto);
          return $http.put(url, dto).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * reset Schedule Settings for settings dialog in schedule builder
         */
        factory.resetScheduleSettings = function (scheduleId) {
          var url = baseUrl + 'schedules/' + scheduleId + '/ops/resetschedulingoptions';
          return $http.post(url).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        //--------------------------------------------------------------------
        // Shifts related methods
        //--------------------------------------------------------------------

        factory.deleteShift = function (scheduleId, shiftId) {
          var url = baseUrl + 'schedules/' + scheduleId + '/shifts/' + shiftId;
          //console.log('--> deleting( ' + url + ')');
          return $http.delete(url).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        factory.createShift = function (scheduleId, shiftDto) {
          var url = baseUrl + 'schedules/' + scheduleId + '/shifts';
          //console.log('--> posting( ' + url + ')');
          return $http.post(url, shiftDto).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        factory.updateShift = function (scheduleId, shiftId, updateDto) {
          var url = baseUrl + 'schedules/' + scheduleId + '/shifts/' + shiftId;
          //console.log('--> updating( ' + url + ')');
          return $http.put(url, updateDto).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        factory.dropShift = function (scheduleId, shiftId, reasonId) {
          var url = baseUrl + 'schedules/' + scheduleId + '/shifts/' + shiftId + '/ops/drop';
          //console.log('--> posting( ' + url + ')');

          console.log(scheduleId, shiftId, reasonId);

          return $http.post(url, reasonId).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        factory.assignShift = function (scheduleId, shiftId, employeeId) {
          //TODO: This still uses the deprecated API. It should be changed to use the new API...
          var url = baseUrl + 'schedules/' + scheduleId + '/shifts/' + shiftId + '/ops/deprecatedassign';
          //console.log('--> posting( ' + url + ')');
          return $http.post(url, employeeId).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        // Work in place
        factory.wipShift = function (scheduleId, shiftId, wipEmployeeId) {
          //TODO: This still uses the deprecated API. It should be changed to use the new API...
          var url = baseUrl + 'schedules/' + scheduleId + '/shifts/' + shiftId + '/ops/deprecatedwip';
          //console.log('--> posting( ' + url + ')');
          return $http.post(url, wipEmployeeId).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        factory.swapShift = function (scheduleId, shiftAId, shiftBId) {
          //TODO: This still uses the deprecated API. It should be changed to use the new API...
          var url = baseUrl + 'schedules/' + scheduleId + '/shifts/' + shiftAId + '/ops/deprecatedswap';
          //console.log('--> posting( ' + url + ')');
          return $http.post(url, shiftBId).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        factory.submitSelectedEligibleEntities = function(eligibleEntityType, scheduleId, originatorShift, selectedEligibleEntity, comment) {
          var urlPart = null;
          var payLoad = null;

          if (eligibleEntityType === 'swap') {
            urlPart = 'schedules/' + scheduleId + '/shifts/' + originatorShift.id + '/ops/swap';
            payLoad = {
              shiftBId: selectedEligibleEntity.shiftId,
              reason: comment
            };
          } else if (eligibleEntityType === 'wip') {
            urlPart = 'schedules/' + scheduleId + '/shifts/' + originatorShift.id + '/ops/wip';
            payLoad = {
              wipEmployeeId: selectedEligibleEntity.employeeId,
              reason: comment
            };
          }

          return $http.post(baseUrl + urlPart, payLoad).then(function(response) {
            return factory.toObjectResult(response);
          });
        };

        factory.manageShift = function(scheduleId, shiftId, comment, shiftInfo, osShiftInfo) {
          var urlPart = 'schedules/' + scheduleId + '/shifts/' + shiftId + '/ops/manage';
          var payLoad = {
            comment: comment,
            force: false,
            overrideOptions: null,
            shiftInfo: shiftInfo,
            osShiftInfo: osShiftInfo
          };

          return $http.post(baseUrl + urlPart, payLoad).then(function(response) {
            return factory.toObjectResult(response);
          });
        };

        factory.manageOpenShift = function(scheduleId, shiftId, payLoad) {
          var urlPart = 'schedules/' + scheduleId + '/shifts/' + shiftId + '/ops/openshiftmanage';

          return $http.post(baseUrl + urlPart, payLoad).then(function(response) {
            return factory.toObjectResult(response);
          });
        };

        factory.createShiftByAction = function(scheduleId, shiftInfo, action, employeeId) {
          var urlPart = 'schedules/' + scheduleId + '/ops/createshift';
          var payLoad = {
            shiftInfo: shiftInfo,
            action: action,
            employeeId: employeeId
          };

          return $http.post(baseUrl + urlPart, payLoad).then(function(response) {
            return factory.toObjectResult(response);
          });
        };

        factory.assignShiftToEmployee = function(scheduleId, shiftId, employeeId) {
          var urlPart = 'schedules/' + scheduleId + '/shifts/' + shiftId + '/ops/assign';
          var payLoad = {
            employeeId: employeeId
          };

          return $http.post(baseUrl + urlPart, payLoad).then(function(response) {
            return factory.toObjectResult(response);
          });
        };

        factory.deleteOS = function(scheduleId, shiftId) {
          var urlPart = 'schedules/' + scheduleId + '/shifts/' + shiftId;

          return $http.delete(baseUrl + urlPart).then(function(response) {
            return factory.toObjectResult(response);
          });
        };

        //--------------------------------------------------------------------
        // Contract Line  related methods
        //--------------------------------------------------------------------

        /*
         * get the list of contractLines associated to a Contract
         */
        factory.getContractLines = function(contractId, queryParams, pageIndex, pageSize) {

          return factory.getElements('contracts/' + contractId + '/contractlines', queryParams, pageIndex, pageSize);
        };

        /*
         * create and add a ContractLine to a Contract
         *
         */
        factory.createContractLine = function(contractId, createDto) {

          var url = baseUrl + 'contracts/' + contractId + '/contractlines';
          //console.log('--> posting( ' + url + ')');
          var dto = factory.metamodel.toDto(createDto);
          return $http.post(url, dto).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * get a ContractLine
         *
         */
        factory.getContractLine = function(contractId, contractLineId) {

          var url = baseUrl + 'contracts/' + contractId + '/contractlines/' + contractLineId;
          //console.log('--> loading( ' + url + ')');
          return $http.get(url).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * Update a ContractLine
         *
         */
        factory.updateContractLine = function(contractId, contractLineId, updateDto) {

          var url = baseUrl + 'contracts/' + contractId + '/contractlines/' + contractLineId;
          //console.log('--> updating( ' + url + ')');
          var dto = factory.metamodel.toDto(updateDto);
          return $http.put(url, dto).then(function (response) {
            return factory.toObjectResult(response);
          });
        };

        /*
         * delete and remove a ContractLine from a Contract
         *
         */
        factory.deleteContractLine = function(contractId, contractLineId) {

          var url = baseUrl + 'contracts/' + contractId + '/contractlines/' + contractLineId;
          //console.log('--> deleting( ' + url + ')');
          return $http.delete(url).then(function (response) {
            return factory.toObjectResult(response);
          });
        };



        //--------------------------------------------------------------------
        // Organization level methods
        //--------------------------------------------------------------------


        /* ----------------------      ORGANIZATION settings   -------------------------------*/

        //
        // Get Org details

        factory.getOrgDetails = function(){
          return factory.getElement('org', '');
        };


        //
        // Update Org details
        factory.updOrgDetails = function(dto){
          return factory.updateElement('org', '', dto);
        };


        //
        // Update /org/schedulesettings

        factory.updScheduleSettings = function(dto){
          return factory.updateElement('org', 'schedulingsettings', dto);
        };


        //
        // Get Org summary counters

        factory.getOrgCounters = function(){
          return factory.getElement('org/summary', '');
        };


        //
        // Get service provider summary counters

        factory.getServiceProviderCounters = function(){
          return factory.getElement('serviceproviders/summary', '');
        };


        /* ----------------------      HOLIDAYS   -------------------------------*/


        /*
         * Get the list of Holiday definitions associated to the 'current' organization.
         *
         */
        factory.getHolidays = function() {
          return $http.get(baseUrl + 'org/holiday/');
        };

        /*
         * Updates a Holiday element
         *
         */
        factory.updateHoliday = function(id, dto) {
          return $http.put(baseUrl + 'org/holiday/' + id, dto);
        };

        /*
         * Created a new Holiday element and adds it to the list of Holiday elements associated to the Organization
         *
         */
        factory.createHoliday = function(dto) {
          return $http.post(baseUrl + 'org/holiday/', dto);
        };

        /*
         * Removes a Holiday element specified by its id
         *
         */
        factory.deleteHoliday = function(id) {
          return $http.delete(baseUrl + 'org/holiday/' + id);
        };

        /*
         * Duplicate holidays from one year to another
         *
         */
        factory.duplicateYear = function(from, to) {
          return $http.post(baseUrl + "org/holidays/ops/duplicateyear", {
            yearFrom : from,
            yearTo : to
          });
        };


        /* ----------------------      SKILLS   -------------------------------*/


        /*
         * Get list of all skills
         *
         */
        factory.getSkills = function(queryParams, pageIndex, pageSize, cache) {
          return factory.getElements('skills', queryParams, pageIndex, pageSize, cache);
        };

        /*
         * Gets list of sites with the skill specified by skillId
         *
         */
        factory.getSitesBySkillId = function(skillId) {
          return $http.get(baseUrl + 'skills/' + skillId + "/sites");
        };

        /*
         * Get list of teams with the skill specified by skillId
         *
         */
        factory.getTeamsBySkillId = function(skillId) {
          return $http.get(baseUrl + 'skills/' + skillId + "/teams");
        };

        /*
         * Get list of team associations for skill
         *
         */
        factory.getTeamAssociations = function(skillId) {
          return $http.get(baseUrl + 'skills/' + skillId + "/teamassociations");
        };

        /*
         * Update team associations
         *
         */
        factory.updateTeamAssociations = function(skillId, dto) {
          return $http.post(baseUrl + 'skills/' + skillId + "/teamassociations/ops/update", dto);
        };

        /*
         * Get list of site/team associations for skill
         *
         */
        factory.getSiteTeamAssociations = function(skillId) {
          return $http.get(baseUrl + 'skills/' + skillId + "/siteteamassociations");
        };

        /*
         * Update the Skill identified by skillId
         *
         */
        factory.updateSkill = function(id, dto) {
          return $http.put(baseUrl + 'skills/' + id, dto);
        };

        /*
         * Delete a Skill specified by its id
         *
         */
        factory.deleteSkill = function(id) {
          return $http.delete(baseUrl + 'skills/' + id);
        };

        /*
         * Create a new Skill
         *
         */
        factory.createSkill = function(dto) {
          return $http.post(baseUrl + 'skills', dto);
        };


        //
        // Change Password

        factory.changePassword = function(currentPassword, newPassword) {
          return $http.post('../emlogis/rest/useraccounts/ops/chgpassword', {
            currentPassword: currentPassword,
            newPassword: newPassword
          });
        };


        //====================================================================
        // MetaModel configuration

        // defines for each class attributes that need a mapping between Dto and UI object.
        var metamodel = factory.metamodel;
        metamodel.BaseEntity = {
          created: 'tdate',
          updated: 'tdate'
        };

        metamodel.UserAccount = factory.metamodel.BaseEntity;
        metamodel.GroupAccount = metamodel.BaseEntity;
        metamodel.Role = metamodel.BaseEntity;
        metamodel.Permission = metamodel.BaseEntity;

        metamodel.Site = metamodel.BaseEntity;
        metamodel.Team = metamodel.BaseEntity;
        metamodel.Skill = metamodel.BaseEntity;
        metamodel.ShiftType = metamodel.BaseEntity;
        metamodel.AbsenceType = metamodel.BaseEntity;

        metamodel.Employee = _.defaults({},
          metamodel.BaseEntity,
          {startDate: 'tdate'}
        );

        metamodel.Schedule = _.defaults({},
          metamodel.BaseEntity,
          {
            startDate: 'tdate',
            endDate: 'tdate',
            executionStartDate: 'tdate',
            requestSentDate: 'tdate',
            executionAckDate: 'tdate',
            responseReceivedDate: 'tdate',
            executionEndDate: 'tdate',
            completionReport: 'tjson'
          }
        );
        metamodel.ShiftStructure = _.defaults({},
          metamodel.BaseEntity,
          {startDate: 'tdate'}
        );
        metamodel.ShiftReq = _.defaults({},
          metamodel.BaseEntity,
          {startTime: 'ttime'}
        );

        metamodel.CIAvailabilityTimeFrame = _.defaults({},
          metamodel.BaseEntity,
          {
            startTime: 'ttime',
            startDate: 'tdate',
            endDate: 'tdate'
          }
        );

        metamodel.CDAvailabilityTimeFrame = _.defaults({},
          metamodel.BaseEntity,
          {
            startTime: 'ttime',
            startDate: 'tdate'
          }
        );

        metamodel.IntMinMaxCL = _.defaults({},
          metamodel.BaseEntity,{
            fromDto: function(elt){
              var descr = '';
              if (elt.minimumEnabled) {
                descr += "Min: " + elt.minimumValue;
                if (elt.minimumWeight > 0) {
                  descr += '(w:' + elt.minimumWeight + ')';
                }
              }
              descr += ' ';
              if (elt.maximumEnabled) {
                descr += "Max: " + elt.maximumValue;
                if (elt.maximumWeight > 0) {
                  descr += '(w:' + elt.maximumWeight + ')';
                }
              }
              return {description: descr};
            }
          }
        );

        metamodel.BooleanCL = _.defaults({},
          metamodel.BaseEntity,{
            fromDto: function(elt){
              var descr = (elt.enabled ? 'On' : 'Off');
              if (elt.weight > 0) {
                descr += '(w: ' + elt.weight + ')';
              }
              return {description: descr};
            }
          }
        );


        //====================================================================
        // private methods


        //
        //console.log('dataService created.');
        return factory;

      }]);

}());



;
angular.module('emlogis.commonservices')
  .service('loadDisplay', ['$rootElement', '$q', 'loadTemplate', function($rootElement, $q, loadTemplate) {
    var self = this;

    function getNewTemplate() {
      var template = angular.element(loadTemplate);
      return template;
    }

    var counter = 0;
    var _Promises = {};
    var _PromiseStack = [];

    self.addDisplay = function(promise, msg, id) {
      var myClone = getNewTemplate();
      var parent;

      if(id === undefined) {
        parent = $rootElement.find("body");
        parent.append(myClone);
      } else {
        parent = $rootElement.find("#"+id);
        parent.append(myClone);
      }
      var asyncDefer = $q.defer();
      asyncDefer.promise.then(function(response) {
        startDisplay(response.id, response.promise, response.msg, response.template);
      });
      var count = counter;
      counter += 1;
      asyncDefer.resolve({id : count, promise : promise, msg : msg, template : myClone});
    };

    // function meant to be called asyncly
    function startDisplay(id, promise, msg, template) {
      _PromiseStack.push(id);
      _Promises[id] = {msg : msg, template : template};
      promise.then(function() {
        removeDisplay(id);
      }, function() {
        removeDisplay(id);
      });
      displayTop();
    }

    function removeDisplay(id) {
      _Promises[id].template.remove();
      delete _Promises[id];
      var index = _PromiseStack.indexOf(id);
      _PromiseStack.splice(index, 1);
      displayTop();
    }

    function displayTop() {
      for(var i = 0; i < _PromiseStack.length; i++) {
        var lastIndex = i;
        var topId = _PromiseStack[lastIndex];
        var msg = _Promises[topId].msg;
        var template = _Promises[topId].template;

        //hide any loading dialogs being displayed in the children
        var displayed = angular.element(template.parent()).find(".show-background");
        if(displayed.length > 0) {
          hideDisplay(displayed);
        }
        if(!window.jQuery || !ancestorHasLoading(template.parent())) {
          template.find('span').text(msg);
          template.addClass("show-background");
          template.removeClass("hide-background");
        }
      }
    }

    function ancestorHasLoading(temp) {
      var parent = temp.parent();
      var foundLoading = false;
      while(parent.length > 0) {
        if(parent.children(".show-background").length > 0) {
          foundLoading = true;
          break;
        }
        parent = parent.parent();
      }
      return foundLoading;
    }

    function hideDisplay(template) {
      template.removeClass("show-background");
      template.addClass("hide-background");
    }
  }]);

angular.module('emlogis.commonservices').value('loadTemplate',
    "<div id='load-background' class='hide-background'>" +
    "<div class='loading-display'>"+
    "<img src='/scheduler-server/emlogis/img/ajax-loader.gif' height='46' width='46'><br><span>Please wait...</span></div>"+
    "</div>"+
    "</div>"
);
;
// ********************  NOT MOVED TO COMMON YET ***************
// SEE working source in manage.js


;


(function () {
    //console.log('in sseService.');

    angular.module('emlogis.commonservices')
    .factory('sseService', ['$http', '$rootScope', '$sessionStorage', 'applicationContext',
            function($http, $rootScope, $sessionStorage, applicationContext) {
        var factory = {};
        var idx = 0;
        var consumers = {};
        var totalConnectionRefused = 0;
        /**
         * if we have more than 30 times of connection refused, then go to login page
         * @type {number}
         */
        var limitConnectionRefused = 30;
        var callingLogout = false;
        var source = null;

        //console.log('creating sseService...');


        factory.startSSElistener = function (baseurl, tokenId) {

            var url = baseurl + 'sse?tokenId=' + tokenId;
            //console.log('sseService  startSSElistener: ' + url);
            callingLogout = false;

            console.log("***************************** DISABLING SSE EVENTS *****************************");
            if (true) return;

            if(typeof(EventSource) !== "undefined") {

                // Store eventsource in rootScope as well
                $rootScope.sseService = source = new EventSource(url + '&action=subscribe');


                source.addEventListener('open', function (e) {
                    //console.log("sseevent open");
                }, false);

                source.addEventListener('error', function (e) {
                    //console.log("SSE event error occured ,event source state :" + this.readyState);

                    // Connectin Refused Response
                    if (this.readyState === 0){
                        totalConnectionRefused++;
                        // If it happens for a specific period of time, move to first page
                        if (totalConnectionRefused > limitConnectionRefused && callingLogout === false){
                            //console.log("Keep having connection refused response, log out");
                            //alert("Connection is lost.");

                            var notificationMsg = applicationContext.getNotificationMsg();
                            notificationMsg.param.lostConnection = true;
                            notificationMsg.type = 'danger';
                            notificationMsg.visible = true;
                            notificationMsg.content = 'Connection is lost.';
                            applicationContext.setNotificationMsg(notificationMsg);

                            //var param = {lostConnection : true};
                            callingLogout = true;
                            source.close();
                            //$rootScope.logout(param);

                        }
                    }
                }, false);

                source.onmessage = function(event) {
                    //console.log('got Event ! :' + event.data);

                    // clear connection refused = 0
                    totalConnectionRefused = 0;

                    // go through list of selectors and invoke consumers
                    for (var consumerId in consumers) { 
                        var consumer = consumers[consumerId];
                        try{
                            var serverEvent = JSON.parse(event.data);
                            if (consumer.selector(serverEvent.key)) {
                                // process event
                                var params = consumer.params || [];
                                params.unshift(serverEvent.key, serverEvent.data);
                                if (consumer.scope) {
                                      consumer.callback.apply(consumer.scope, params);
                                }
                                else {
                                    consumer.callback.apply(params); 
                                }
                            }
                        }
                        catch(error){
                            console.error('error while processing SSE consumer id:' + consumerId + " error: " + error);
                        }
                    }
                //  $scope.$apply(function () {     // use $scope.$apply to refresh the view
                //      $scope.event = event.data;
                //      $scope.eventCnt++;
                //    });
                };
            }
            else {
                console.error('SSE is not supported on this browser. unable to display real time information.');
            }

        };

        //====================================================================
        // public methods

        /*
        * public registerConsumer() register an SSE consumer
        * a consumer is defined by an object with following attributes:
        * - selector a function that must return true or false. it is invoked with the event 'key' as parameter
        * - callback a function invoked if selector() returns true. invoked with event.key and event.data, as parameters
        * - an optional id. if unspecified, an id is generated autmatically and returned in object + as return value.
        * followed by optional parameters sepcified in consumer.params attributes
        * - scope (optional) scope for the callback ftn
        * - params (optional) and array of params passed to the callback, right after the event data 
        * returns a registration id if success / null otherwise
        */ 
        factory.registerConsumer = function (consumer) {
            if (consumer && consumer.selector !== undefined && consumer.callback !== undefined) {
                idx++;
                // as id, either use consumer specified id, or generate one
                var consumerId = consumer.id || 'c' + idx;
                consumers[consumerId] = consumer;
                consumer.id = consumerId;
                return consumerId;
            }
            else {
                return null;
            }
        };

        factory.unregisterConsumer = function (consumerId) {
            consumers.delete(consumerId);
        };


        //====================================================================
        // private methods

        //console.log('sseService created.');
        return factory;

    }]);

    var y =1;

}());


;
angular.module('emlogis.commonservices')
  .service('UtilsService', ['$http', 'applicationContext',
    function($http, applicationContext) {
      var baseUrl = applicationContext.getBaseRestUrl();

      function sendRequest(urlPart, method, requestPayload) {
        var apiUrl = baseUrl + urlPart;
        var req = {
          method: method,
          url: apiUrl
        };
        if (method === 'POST' || method === 'PUT') {
          req.data = requestPayload;
        }

        return $http(req);
      }

      this.getAvailableTimeZones = function() {
        var urlPart = 'sites/timezones';

        return sendRequest(urlPart, 'GET', null);
      };

      this.checkEmpty = function(variable) {
        if (typeof variable === 'undefined' || variable === null || variable === '') {
          return true;
        } else {
          return false;
        }
      };
      
      this.isObjEmpty = function(obj) {
        // null and undefined are "empty"
        if (obj === null) return true;

        // Assume if it has a length property with a non-zero value
        // that that property is correct.
        if (obj.length > 0)    return false;
        if (obj.length === 0)  return true;

        // Otherwise, does it have any properties of its own?
        // Note that this doesn't handle
        // toString and valueOf enumeration bugs in IE < 9
        for (var key in obj) {
          if (hasOwnProperty.call(obj, key)) return false;
        }
        return true;
      };
    }
  ]);
;


(function () {
    console.log('in WebSocketService.');

    angular.module('emlogis.commonservices')
    .factory('wsService', ['$http', function($http) {
        var factory = {};
        var idx = 0;
        var consumers = {};
        var url;
        var websocket;
        var expectedActive = false;
        var connectionStatusListener;
        var connectionOpenAt;                   // date time the connection has been opened
        var connectionClosedAt = 0;             // date time the connection has been closed
        var logEvents = false;

        console.log('creating wsService...');


        //====================================================================
        // public methods


        factory.startWSlistener = function (baseurl, tokenId) {

            expectedActive = true;  // indicate that WebSocket connection shoudl be up from now
            console.log('==> WebSocketService  startWSlistener: ' + baseurl + ' token=' + tokenId);

            // TODO IMPROVE THIS (also may need a chnage for HTTPS)
            // pb, base url is a relative path, like ../emlogis => have to use document attributes
            // as the prtocol is different for WebSocket

     //       if (document.location.protocol.startsWith("https")) {     // startsWith doesn't seem to be supported on all browsers, use indexOf() instead
            if (document.location.protocol.indexOf("https") === 0) {
                  //  url = "wss://" + document.location.host + document.location.pathname + 'events?EmlogisToken=' + tokenId;
                // ugly temporary patch because document.location.pathname doesn't always return same value
                url = "wss://" + document.location.host  + '/scheduler-server/emlogis/events?EmlogisToken=' + tokenId;

            }
            else {
                // url = "ws://" + document.location.host + document.location.pathname + 'events?EmlogisToken=' + tokenId;
                // ugly temporary patch because document.location.pathname doesn't always return same value
                url = "ws://" + document.location.host  + '/scheduler-server/emlogis/events?EmlogisToken=' + tokenId;
            }
/*
            url = "ws://" 
                + (document.location.hostname === "" ? "localhost" : document.location.hostname) 
                + ":" + (document.location.port === "" ? "8080" : document.location.port)
                + '/scheduler-server/events?EmlogisToken=' + tokenId;
*/
            factory.startOrRestartWSlistener();
        };


        factory.stopWSlistener = function () {

            expectedActive = false;       // indicate that WebSocket connection shoudl be down now
            console.log('==> WebSocketService  stopWSlistener: ' + url);
            if (websocket) {
                try {
                    var ws = websocket;
                    websocket = null;
                    ws.close();
                }
                catch(err) {
                    console.error('Failed to close WebSocket: ' + err);
                }
            }

            // TODO add cleanup code

        };

        /*
        * public registerConsumer() register an WS consumer
        * a consumer is defined by an object with following attributes:
        * - selector a function that must return true or false. it is invoked with the event 'key' as parameter
        * - callback a function invoked if selector() returns true. invoked with event.key and event.data, as parameters
        * - an optional id. if unspecified, an id is generated autmatically and returned in object + as return value.
        * followed by optional parameters sepcified in consumer.params attributes
        * - scope (optional) scope for the callback ftn
        * - params (optional) and array of params passed to the callback, right after the event data 
        * returns a registration id if success / null otherwise
        */ 

        factory.registerConsumer = function (consumer) {
            if (consumer && consumer.selector !== undefined && consumer.callback !== undefined) {
                idx++;
                // as id, either use consumer specified id, or generate one
                var consumerId = consumer.id || 'c' + idx;
                consumers[consumerId] = consumer;
                consumer.id = consumerId;
                console.log("==> WebSocketService has registered an event Consumer, id: " + consumerId);
                return consumerId;
            }
            else {
                return null;
            }
        };

        factory.unregisterConsumer = function (consumerId) {
            consumers.delete(consumerId);
            console.log("==> WebSocketService has UN-registered the event Consumer id: " + consumerId);
        };

        /*
        * public registerConnectionStatusListener() register a WS connection status listener
        * a listener is defined by an object with following attributes:
        *   - callback (function invoked on satus change) 
        *   - scope (optional) scope for the callback ftn
        *   - params (optional) and array of params passed to the callback, right after the event status 
        * the callback is  invoked with a 
        *   - status param that can be: Active|Inactive|Reconnecting
        *   - date the connection has been successfully opeeed for the last time
        *   - date the connection has been closed for the last time
        *   - optional scope
        *   - optional params 
        */ 
        factory.registerConnectionStatusListener = function (listener) {
            connectionStatusListener = listener;
            console.log("==> WebSocketService has registered a Status Listener.");
        };



        //====================================================================
        // private methods

        factory.startOrRestartWSlistener = function () {

            console.log('==> WebSocketService  startOrRestartWSlistener: ' + url);
            var wsActive = (websocket !== undefined && websocket !== null && websocket.readyState === 1);
            if (!expectedActive || (expectedActive &&  wsActive)) {
                // seems this can happen if we have a delayed call arriving a bit late ??
                console.log('==> WebSocketService  startOrRestartWSlistener CANCEL due to : Open invoked when we don t actually want to open it, or Open invoked on a connexion Already active');
                return;
            }

            websocket = new WebSocket(url);


            websocket.onopen = function(evt) {
                console.log("==> WebSocketService WebSocket OPEN at " + new Date().toLocaleString() + " !");
                connectionOpenAt = Date.now();
                connectionClosedAt = 0;

                // TODO indicate websocket connection is Active
                // onOpen(evt)
                factory.notifyStatusChange('Active', '');
            };

            websocket.onerror = function(evt) {
                console.error('==> WebSocketService ERROR Event !');
                // TODO indicate websocket connection is Active
                //onError(evt)
            };

            websocket.onclose = function(evt) {
                console.log('==> WebSocketService Close Event at ' + new Date().toLocaleString() + " !");
                if (connectionClosedAt === 0) {
                    connectionClosedAt = Date.now();
                }
                if (expectedActive) {
                    console.error('==> WebSocketService ********* WebSocket Unexpected Close ! , will try to REOPEN the Connection later ************');
                    // TODO try to reestablish it periodically
                    var delay = 30000;
                    var nextTryDate = new Date(Date.now() + delay);
                    factory.notifyStatusChange('Reconnecting', ' Will try to Reconnect at ' + nextTryDate.toLocaleString());
                    setTimeout(factory.startOrRestartWSlistener, delay);
                }
                else {
                    console.log('==> WebSocketService ********* WebSocket expected Close !  ************');
                    factory.notifyStatusChange('Inactive', '');
                }
                // TODO indicate websocket connection is Inactive
                // onClose(evt)
            };

            websocket.onmessage = function(evt) {
                if (logEvents) {
                    console.log('==> WebSocketService got Event ! :' + evt.data);
                }
                var getKeyAsObject = function(keyAsString) {

                    keyAsString = keyAsString.split('><').join(','); // = replaceAll('><', ',');
                    keyAsString = keyAsString.split('<').join('');                   // = replaceAll('<', '');
                    keyAsString = keyAsString.split('>').join('');                   // = replaceAll('>', '');
                    var keyAr = keyAsString.split(',');
                    if (keyAr.length == 6) {
                        // key seems to be well formed
                        return {
                            topic: keyAr[0],
                            tenantId: keyAr[1],
                            accountId: keyAr[2],
                            entityClass: keyAr[3],
                            eventType: keyAr[4],
                            entityId: keyAr[5]
                        };
                    }
                    else {
                        // key doesn't have expected format, return it as is
                        return keyAsString;
                    }

                };  

                // decode event
                var serverEvent = JSON.parse(evt.data);
                var keyObj = getKeyAsObject(serverEvent.key);
                // go through list of selectors and invoke consumers
                for (var consumerId in consumers) { 
                    var consumer = consumers[consumerId];
                    var consumerparams = consumer.params || [];
                    //params.unshift(serverEvent.key, serverEvent.data);
                    var params = [keyObj, serverEvent.data].concat(consumerparams);
                    try {
                        if (consumer.selector(serverEvent.key)) {
                            // process event
                            if (consumer.scope) {
                                consumer.callback.apply(consumer.scope, params); 
                            }
                            else {
                                consumer.callback.apply(params); 
                            }
                        }
                    }
                    catch(error){
                        console.error('error while processing WS consumer id:' + consumerId + " error: " + error);
                    }
                }             
            };
        };


        factory.notifyStatusChange = function(status, message) {

            var listener = connectionStatusListener;
            if (listener !== undefined && listener !== null) {
                var listenerparams = listener.params || [];
                var params = [status, connectionOpenAt, connectionClosedAt, message].concat(listenerparams);
                try {
                    if (listener.scope) {
                        listener.callback.apply(listener.scope, params); 
                    }
                    else {
                        listener.callback.apply(params); 
                    }
                }
                catch(err) {
                    console.error('Failed to notify WebSocket Listener on connexion status change: ' + err);
                }
            }
        };


        console.log('WebSocketService created.');
        return factory;

    }]);

}());


;
angular.module('emlogis.dashboard', ['ui.bootstrap', 'ui.router', 'http-auth-interceptor'])
  .config(
  function ($stateProvider, $urlRouterProvider, $locationProvider, $httpProvider) {

    function goToDefaultTab($state, authService) {
      // check calendar is enabled or not
      if (hasEmployeePermissions(authService)) {
        $state.go('authenticated.dashboard.calendar');
      } else {
        $state.go('authenticated.dashboard.manager_approvals');
      }
    }

    $urlRouterProvider.when('/dashboard', ['$state', 'authService', function ($state, authService) {
      goToDefaultTab($state, authService);
    }]);

    $urlRouterProvider.when('/dashboard/', ['$state', 'authService', function ($state, authService) {
      goToDefaultTab($state, authService);
    }]);

    function hasEmployeePermissions(authService) {
      return authService.hasRoles("employeerole") && authService.isTenantType('Customer')
          && (authService.isSchedulableEmployee()
                || authService.hasPermissionIn(['Availability_RequestMgmt', 'Shift_RequestMgmt']));
    }

    function dashboardPermissions(authService) {
      return authService.isTenantType('Customer') && (authService.isUserAnEmployee() ||
        authService.hasPermissionIn(['Availability_RequestMgmt', 'Shift_RequestMgmt']));
    }

    $stateProvider.state('authenticated.dashboard', {
      url: '/dashboard',
//      abstract: true,
      views: {
        "content@authenticated": {
          templateUrl: "modules/dashboard/partials/dashboard.html",
          controller: 'DashboardCtrl'
        },
        "breadcrumb@authenticated": {
          templateUrl: "modules/dashboard/partials/dashboard_breadcrumb.html",
          controller: 'DashboardBreadcrumbCtrl'
        }
      },
      data: {
        ncyBreadcrumbLabel: '{{"home.MY_DASHBOARD" | translate}}',
        permissions: dashboardPermissions
      }
    })
      .state('authenticated.dashboard.calendar', {
        url: '/calendar',
        data: {
          permissions: function (authService) {
            return hasEmployeePermissions(authService);
          }
        }
      })
      .state('authenticated.dashboard.manager_approvals', {
        url: '/manager_approvals',
        data: {
          permissions: function (authService) {
            return dashboardPermissions(authService) && authService.hasPermissionIn(['Shift_Mgmt',
                'Availability_RequestMgmt', 'Shift_RequestMgmt']);
          }
        }
      })
      .state('authenticated.dashboard.team_member_requests', {
        url: '/team_member_requests',
        data: {
          permissions: function (authService) {
            return hasEmployeePermissions(authService);
          }
        }
      })
      .state('authenticated.dashboard.my_requests', {
        url: '/my_requests',
        data: {
          permissions: function (authService) {
            return hasEmployeePermissions(authService);
          }
        }
      })
      .state('authenticated.dashboard.my_availability', {
        url: '/my_availability',
        data: {
          permissions: function (authService) {
            return hasEmployeePermissions(authService);
          }
        }
      });
      //.state('authenticated.dashboard.team_member_requests2', {
      //  url: '/team_member_requests2',
      //  data: {
      //    permissions: function (authService) {
      //      return dashboardPermissions(authService) && authService.isUserAnEmployee() &&
      //        authService.isSchedulableEmployee();
      //    }
      //  }
      //});
  }
);



;
angular.module('emlogis.dashboard').controller('AvailabilityPreviewModalCtrl',
  ['$scope', '$timeout', '$modalInstance', 'dataService', 'applicationContext', 'employeeId', 'siteTimeZone', 'firstDayOfWeek', 'previewParams',
    function ($scope, $timeout, $modalInstance, dataService, applicationContext, employeeId, siteTimeZone, firstDayOfWeek, previewParams) {

      $scope.employeeId = employeeId;
      $scope.siteTimeZone = siteTimeZone;
      $scope.firstDayOfWeek = firstDayOfWeek;
      $scope.previewParams = previewParams;
      $scope.monthName = new Date($scope.previewParams.year, $scope.previewParams.month).toLocaleString("en-us", { month: "long" });

      $scope.cancel = function () {
        $modalInstance.dismiss('cancel');
      };
    }]);
;
var dashboard = angular.module('emlogis.dashboard');

dashboard.controller('DashboardApprovalsTimeOffMsgCtrl',
  [
    '$http',
    '$scope',
    '$modalInstance',
    'shift',
    function($http, $scope, $modalInstance, shift) {

      /**
       * Use shift name
       */
      $scope.shift = shift;
      // Close Modal
      $scope.close = function () {
        $modalInstance.dismiss('cancel');
      };
    }
  ]
);

dashboard.controller('DashboardApprovalsCtrl',
  [
    '$http',
    '$scope',
    '$state',
    '$q',
    '$sessionStorage',
    '$filter',
    '$timeout',
    '$modal',
    'appFunc',
    'applicationContext',
    'dataService',
    'crudDataService',
    'uiGridConstants',
    'DashboardService',
    function($http, $scope, $state, $q, $sessionStorage, $filter, $timeout, $modal,
             appFunc, applicationContext, dataService, crudDataService,
             uiGridConstants, DashboardService) {

      /**
      /**
       * Variables in Dashboard Approvals
       * 1. $scope.days: Filter Dropdown list in Filter
       * 2. $scope.filter.siteTeams: Filter Dropdown tree list in Filter
       * 3. $scope.filter.statuses: Filter Dropdown Statuses
       * 4. $scope.filter.dayLength: Filter ng-model of days
       */

      $scope.days = [
        {day: 7, title: 'LAST 7 DAYS'},
        {day: 14, title: 'LAST 14 DAYS'},
        {day: 30, title: 'LAST 30 DAYS'},
        {day: 0, title: 'ALL'}
      ];


      /**
       *
       * For the MultiSelect Dropdown
       */
      $scope.localLang = {
        selectAll  : 'Select All',
        selectNone : 'Select None',
        reset : 'Reset',
        search : 'Search...',
        nothingSelected : 'Nothing is selected'         //default-label is deprecated and replaced with this.
      };

      var baseUrl = applicationContext.getBaseRestUrl();
      var factory = _.clone(crudDataService);
      var numOfRows = 25;

      /*
       *This header cell template is almost same as default cell template except
       * it has translate directive inside so grid header will support i18n as well
       */
      var headerCellTemplate = function(){
        return "<div ng-class=\"{ 'sortable': sortable }\">" +
          "<div class=\"ui-grid-vertical-bar\">&nbsp;</div>" +
          "<div class=\"ui-grid-cell-contents\" col-index=\"renderIndex\" ><span translate>{{ col.name CUSTOM_FILTERS }} </span>" +
          "<span ui-grid-visible=\"col.sort.direction\" ng-class=\"{ 'ui-grid-icon-up-dir': col.sort.direction == asc, 'ui-grid-icon-down-dir': col.sort.direction == desc, 'ui-grid-icon-blank': !col.sort.direction }\">&nbsp;</span>" +
          "</div>" +
          "<div class=\"ui-grid-column-menu-button\" ng-if=\"grid.options.enableColumnMenus && !col.isRowHeader  && col.colDef.enableColumnMenu !== false\" class=\"ui-grid-column-menu-button\" ng-click=\"toggleMenu($event)\">" +
          "<i class=\"ui-grid-icon-angle-down\">&nbsp;</i>" +
          "</div>" +
          "<div ng-if=\"filterable\" class=\"ui-grid-filter-container\" ng-repeat=\"colFilter in col.filters\">" +
          "<input type=\"text\" class=\"ui-grid-filter-input\" ng-model=\"colFilter.term\" ng-click=\"$event.stopPropagation()\" ng-attr-placeholder=\"{{colFilter.placeholder || ''}}\">" +
          "<div class=\"ui-grid-filter-button\" ng-click=\"colFilter.term = null\">" +
          "<i class=\"ui-grid-icon-cancel right\" ng-show=\"!!colFilter.term\">&nbsp;</i> <!-- use !! because angular interprets 'f' as false -->" +
          "</div>" +
          "</div>" +
          "</div>";
      };

      // Row Template: Homepage Dashboard Manager Request Approval
      function rowTemplate() {

          return '<div ng-class="{\'row-hovered\' : hover}" ' +
            '     ng-mouseenter="hover = true" ' +
            '     ng-mouseleave="hover = false" ' +
            '     ng-style="{ \'font-weight\': row.entity.isRead !== true ? \'bold\' : \'normal\' }" ' +
//            '     ng-click="grid.appScope.loadCurRequest(row.entity.requestId)">' +
            '     >' +
            '  <div ng-repeat="(colRenderIndex, col) in colContainer.renderedColumns track by col.colDef.name" ' +
            '       class="ui-grid-cell" ' +
            '       ng-class="{ \'ui-grid-row-header-cell\': col.isRowHeader }"  ' +
            '       ui-grid-cell>' +
            '  </div>' +
            '</div>' ;
      }

      // Header Template
      function headerTemplate() {
        return '<div ng-style="{ height: col.headerRowHeight }" ng-repeat="col in renderedColumns" ng-class="col.colIndex()" class="ngHeaderCell" ng-header-cell></div>';
      }

      // ColumnDef Info
      // The columns with empty filed will not work for sort as of now
      $scope.columnDef = [
        {
          name: 'home.TEAM',
          field: 'submitterTeamName',
          headerCellTemplate: headerCellTemplate()
        },
        {
          name: 'home.EMPLOYEE',
          field: 'submitterName',
          headerCellTemplate: headerCellTemplate()
        },
        {
          name: 'home.START_DATE',
          field: 'employeeStartDate',
          headerCellTemplate: headerCellTemplate(),
          dateFormat: 'M/d/yy'
        },
        {
          name: 'home.REQ_TYPE',
          field: 'type',
          headerCellTemplate: headerCellTemplate(),
          transPrefix: 'home'
        },
        {
          name: 'home.SUBMITTED',
          field: 'submitDate',
          headerCellTemplate: headerCellTemplate(),
          dateFormat: 'M/d/yy - hh:mm a'
        },
        {
          name: 'home.REQ_DATE',
          field: 'reqDate',
          headerCellTemplate: headerCellTemplate(),
          dateFormat: 'M/d/yy'
        },
        {
          name: 'home.DESCRIPTION',
          field: 'description',
          headerCellTemplate: headerCellTemplate()
        },
        {
          name: 'home.EXPIRES',
          field: 'expirationDate',
          headerCellTemplate: headerCellTemplate(),
          dateFormat: 'M/d/yy'
        },
        {
          name: 'home.STATUS',
          field: 'status',
          transPrefix: 'app',
          width: '20%',
          headerCellTemplate: headerCellTemplate()
        }
      ];

      // External Scope Module, This variable will be used when we have an action inside grid row
      $scope.gridModel = {

        // On a double click event , it will move to employee detail page to show employee detail
        onClickRow : function(row){
          row.isSelected = true;
        }

      };

      $scope.gridOptions = {

        enableColumnResizing: true,
        enableRowHeaderSelection: false,
        modifierKeysToMultiSelect: false,
        noUnselect: true,
//        enableGridMenu: true,
        minRowsToShow: numOfRows,
        columnDefs: $scope.columnDef, //
        rowTemplate: rowTemplate(), //Row Template,
        enableHorizontalScrollbar: 0,
        enableVerticalScrollbar: 0,
        enableColumnMenus: false,

//        enableFiltering: true,
        multiSelect: false,
        useExternalFiltering: true,

        enableSorting: true,
        useExternalSorting: true,

        needPagination: true,
        useExternalPagination: true,
        enablePaginationControls: false,
        paginationPageSize: numOfRows,
        paginationCurrentPage: 1,
        enableFullRowSelection: true,

        //enableSelectAll: true,
        enableRowSelection: true,
//        enableColumnMenus: true,
//        gridMenuTitleFilter: $translate, // Translate Grid Menu column name

        onRegisterApi: function( gridApi ) {
          $scope.gridApi = gridApi;

          gridApi.selection.on.rowSelectionChanged($scope, function (row) {
            if (row.isSelected) {
              $scope.loadCurRequest(row.entity.requestId)
                .then(function onSuccess(request) {
                  $scope.curRequest = prepareRequest(request);
                  $scope.reloadRequestInGrid(request);
                }, function onError(error) {
                  applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
                  console.error(error);
                });
            }
          });


          /**
           *  Dashboard Manager Approval Sort Changed
           */
          $scope.gridApi.core.on.sortChanged( $scope, function( grid, sortColumns ) {

            if (sortColumns.length === 0) {
              $scope.gridOptions.queryParams.orderdir = 'asc';
              $scope.gridOptions.queryParams.orderby = 'TEAM';
            } else {
              $scope.gridOptions.queryParams.orderdir = sortColumns[0].sort.direction;

              switch (sortColumns[0].field) {
                case "submitterTeamName":
                  $scope.gridOptions.queryParams.orderby = 'TEAM';
                  break;
                case "submitterName":
                  $scope.gridOptions.queryParams.orderby = 'EMPLOYEE';
                  break;
                case "employeeStartDate":
                  $scope.gridOptions.queryParams.orderby = 'EMPLOYEE_START_DATE';
                  break;
                case "type":
                  $scope.gridOptions.queryParams.orderby = 'REQ_TYPE';
                  break;
                case "submitDate":
                  $scope.gridOptions.queryParams.orderby = 'SUBMITTED';
                  break;
                case "reqDate":
                  $scope.gridOptions.queryParams.orderby = 'REQ_DATE';
                  break;
                case "expirationDate":
                  $scope.gridOptions.queryParams.orderby = 'EXPIRES';
                  break;
                case "status":
                  $scope.gridOptions.queryParams.orderby = 'REQ_STATUS';
                  break;
                case "description":
                  $scope.gridOptions.queryParams.orderby = 'DESCRIPTION';
                  break;
              }

            }
            getPage();

          });

          //
          // Back-end pagination

          $scope.gridApi.pagination.on.paginationChanged($scope, function (newPage, pageSize) {
            $scope.gridOptions.paginationCurrentPage = newPage;
            getPage();
          });

          var getPage = function() {
            return $scope.loadRequests($scope.gridOptions.paginationCurrentPage);
          };
        }
      };

      $scope.gridOptions.queryParams = {
        orderby:'SUBMITTED',
        orderdir:'desc'
      };

      $scope.isPendingRecipientAndNotApprovedRequest = DashboardService.isPendingRecipientAndNotApprovedRequest;

      //API CALL sites/ops/siteteams
      $scope.loadSiteTeams = function() {

        var deferred = $q.defer();

        factory.getElements('sites/ops/siteteams',{})
          .then(function(res){

            var entities = res.data;

            $scope.filter.siteTeams = [];
            var sites = [];
            var site = null;

            /**
             * Build tree structure
             */
            for (var i=0; i<entities.length; i++) {

              var entity = entities[i];
              site = _.findWhere(sites, {'id': entity.siteId});

              if (!site) {
                site = {id: entity.siteId, name: entity.siteName, teams: []};
                sites.push(site);
              }

              site.teams.push(entity);

            }

            /**
             * Build siteTeams array for dropdown list
             */
            for (i=0; i<sites.length; i++) {
              site = sites[i];

              // group start
              $scope.filter.siteTeams.push({
                searchBy: site.name,
                name: '<strong>' + site.name + '</strong>',
                siteId: site.id,
                msSite: true
              });

              for (var j=0; j<site.teams.length; j++) {
                var team = site.teams[j];

                $scope.filter.siteTeams.push({
                  searchBy: team.teamName,
                  searchBySite: site.name,
                  name: team.teamName,
                  teamId: team.teamId,
                  ticked: true
                });

              }

              // group end
              $scope.filter.siteTeams.push({
                msSite: false
              });

            }

            deferred.resolve(entities); // it will be not useful purpose

          },function(error) {
            applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
            deferred.reject(error);
          });

        return deferred.promise;

      };

      /**
       * Searches the requests and updates the grid: manager approval
       * @param pageNum
       * @returns {*}
       */
      $scope.loadRequests = function(pageNum) {
        //[POST] /requests/manager/ops/query
        var deferred = $q.defer();
        var selectedTeamIds = getSelectedTeamIds();
        var selectedStatusIds = getSelectedStatusIds();
        var selectedReqTypesIds = getSelectedReqTypeIds();
        var startTime = null;
        var requestUrl = 'requests/manager/ops/query';

        //Apply "Last # days" filter - prepare startTime to load requests. Subtracts selected days from current time.
        if ($scope.filter.dayLength.day !== 0) {
          startTime = moment().subtract($scope.filter.dayLength.day, 'days').toDate().getTime();
        }

        var urlParam = factory.prepareQueryParams(
            $scope.gridOptions.queryParams,
            pageNum ? pageNum : 1,
            numOfRows);

        var param = {
          sites: null,
          teams: selectedTeamIds.length === 0 ? null : selectedTeamIds,
          types: selectedReqTypesIds.length === 0 ? null : selectedReqTypesIds,
          statuses: selectedStatusIds.length === 0 ? null : selectedStatusIds,
          dateFrom: startTime,
          dateTo: null,
          fullTextSearch: $scope.filter.searchTxt,
          offset: urlParam.offset,
          limit: urlParam.limit,
          orderBy: urlParam.orderby,
          orderDir: urlParam.orderdir.toUpperCase()
        };

        $http.post(baseUrl+requestUrl, param)
          .then(function (response) {
            var approvals = response.data;

            //Prepare approval rows to display
            angular.forEach(approvals.data, function(entity) {
              prepareRequestToDisplayInGrid(entity, $scope.columnDef);
            });

            $scope.gridOptions.data = approvals.data;
            $scope.gridOptions.totalItems = approvals.total;

            deferred.resolve(approvals.data);
//          clear curDetail View
            $scope.curRequest = null;
          }, function(error) {
            applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
            deferred.reject(error);
          });

        return deferred.promise;
      };

      function prepareRequestToDisplayInGrid(request, gridColumnDefs) {
        var requestTz = request.submitterTz;

        //Create new fields which is not present in request (which is present in gridColumnDefs)
        request.reqDate = request.eventDate;

        angular.forEach(gridColumnDefs, function(column) {
          switch(column.field) {
            case 'type':
              request[column.field] = $filter('translate')(column.transPrefix+'.'+request[column.field]);
              break;
            case 'status':
              request[column.field] = $filter('translate')(column.transPrefix+'.'+request[column.field]);
              break;
          }
          //If current column is Date
          if(column.dateFormat) {
            request[column.field] = $filter('date')(
                appFunc.convertToBrowserTimezone(request[column.field], requestTz), column.dateFormat
            );
          }
        });
      }

      function updateCurrentGridRowAccordingToGridColumnDef(curRow, request, gridColumnDefs) {
        curRow.submitterTeamName = request.submitterTeamName;
        curRow.submitterName = request.submitterName;
        curRow.type = $filter('translate')('home.'+request.type);
        curRow.description = request.description;
        curRow.status = $filter('translate')('app.'+request.status);
        curRow.isRead = request.isRead;

        var submitDateColumnDef = _.findWhere(gridColumnDefs, {'field': 'submitDate'});
        curRow.submitDate = $filter('date')(request.submitDate, submitDateColumnDef.dateFormat);

        var reqDateColumnDef = _.findWhere(gridColumnDefs, {'field': 'reqDate'});
        curRow.reqDate = $filter('date')(request.eventDate, reqDateColumnDef.dateFormat);

        var expirationDateColumnDef = _.findWhere(gridColumnDefs, {'field': 'expirationDate'});
        curRow.expirationDate = $filter('date')(request.expirationDate, expirationDateColumnDef.dateFormat);
      }

      $scope.loadStatuses = function() {

        //rest/workflow/dashboard/tasks/manager?offset=0&limit=20&orderby=submitted&orderdir=asc
        var deferred = $q.defer();
        $http.get(baseUrl + 'workflow/dashboard/statuses', {})
          .then(function (response) {
            var result = response.data;
            $scope.filter.statuses = result.data;

            _.each($scope.filter.statuses, function(status) {status.ticked = true;});

            deferred.resolve(response.data);

          }, function(error) {
            applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
            deferred.reject(error);
          });

        return deferred.promise;
      };

      $scope.loadReqTypes = function() {
        // WIP_REQUEST , SHIFT_SWAP_REQUEST , OPEN_SHIFT_REQUEST, PTO_REQUEST, AVAILABILITY_REQUEST
        $scope.filter.reqTypes = [
          {
            name:'WIP_REQUEST',
            id:'WIP_REQUEST',
            ticked: true
          },
          {
            name:'SHIFT_SWAP_REQUEST',
            id:'SHIFT_SWAP_REQUEST',
            ticked: true
          },
          {
            name:'OPEN_SHIFT_REQUEST',
            id:'OPEN_SHIFT_REQUEST',
            ticked: true
          },
          {
            name:'PTO_REQUEST',
            id:'PTO_REQUEST',
            ticked: true
          },
          {
            name:'AVAILABILITY_REQUEST',
            id:'AVAILABILITY_REQUEST',
            ticked: true
          }
        ];
//        var deferred = $q.defer();
//        $http.get(baseUrl + 'workflow/dashboard/types?orderby=name&orderdir=ASC', {})
//          .then(function (response) {
//            var result = response.data;
//            $scope.filter.reqTypes = result.data;
//
//            _.each($scope.filter.reqTypes, function(reqType) {reqType.ticked = true;});
//
//            deferred.resolve(response.data);
//
//          }, function(error) {
//            deferred.reject(error);
//          });
//
//        return deferred.promise;

      };

      /**
       * Load specific request detail: manager approvals
       * @param requestId
       * @returns {*}
       */
      $scope.loadCurRequest = function (requestId) {
        var deferred = $q.defer();
        $http.get(baseUrl + 'requests/manager/'+requestId, {})
          .then(function (response) {
            var request = response.data.data;
            if(request) {
              deferred.resolve(response.data.data);
            } else {
              console.error("Invalid json received! Cannot get the request object.");
              deferred.reject(response);
            }
          }).catch(function(error) {
              deferred.reject(error);
          });
        return deferred.promise;
      };

      /**
       * Init function: manager approval
       */

      $scope.init = function() {


        $scope.filter = {
          dayLength: null,
          statuses: DashboardService.getRequestStatuses(),
          reqTypes: DashboardService.getRequestTypes(),
          searchTxt: ''
        };

        /**
         * enable all reqTypes in manager approval
         */

        $scope.filter.reqTypes[0]['ticked'] = true;
        $scope.filter.reqTypes[1]['ticked'] = true;

        $scope.filter.dayLength = $scope.days[2]; // load last 30 days

        $scope.currentAccountInfo = JSON.parse($sessionStorage.info);

        /**
         * get Current Account Info
         */
//        DashboardService.getCurrentAccountInfo($scope.currentAccountType).then(function(response) {
//          if ($scope.currentAccountType === 'Employee') {
//            $scope.currentAccountInfo.accountId = response.data.employeeDto.id;
//          }
//          $scope.currentAccountInfo.timezone = response.data.siteTz.id;
//          $scope.currentAccountInfo.siteId = response.data.siteId;
//          $scope.currentAccountInfo.siteFirstDayOfweek = response.data.siteFirstDayOfweek;
//          $scope.currentAccountInfo.teams = response.data.teams;
//
//        }, function(err) {
//          applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
//          deferred.reject(error);
//        });


        $scope.loadSiteTeams()
          .then(function() {
            return DashboardService.getCurrentAccountInfo($scope.currentAccountType);
          })
          .then(function(response) {

            if ($scope.currentAccountType === 'Employee') {
              $scope.currentAccountInfo.accountId = response.data.employeeDto.id;
              $scope.currentAccountInfo.timezone = response.data.siteTz.id;
              $scope.currentAccountInfo.siteId = response.data.siteId;
              $scope.currentAccountInfo.siteFirstDayOfweek = response.data.siteFirstDayOfweek;
              $scope.currentAccountInfo.teams = response.data.teams;
            }
            else {
              $scope.currentAccountInfo.timezone = response.data.actualTimeZone.id;
            }

            return $scope.loadRequests();
          })
          .catch(function(error) {
            if (error.message) {
              applicationContext.setNotificationMsgWithValues(error.message, '', true, '');
            }
            else {
              applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
            }

          });



      };

      /**
       * :Manager Approval
       */
      $scope.delayedLoadRequests = function() {
        $timeout(function() {$scope.loadRequests();}, 1000); //wait for the dropdown list update their selectedOutputs
      };

      /**
       * check today is just one day before to specific date
       * @param date
       * @returns {boolean}
       */
      $scope.isTomorrow = function(date){
        var tomorrow = new Date(new Date().getTime() + 24 * 60 * 60 * 1000);
        var day = tomorrow.getDate();
        var month = tomorrow.getMonth();
        var year = tomorrow.getFullYear();
        var dateT = new Date(date);

        if (day === dateT.getDate() && month === dateT.getMonth() && year === dateT.getFullYear()) {
          return true;
        }

        return false;


      };

      /**
       * Update Request Status: Manager Approval
       * @param status
       */
      $scope.updateRequest = function(status) {

        var url = 'requests/manager/' +$scope.curRequest.requestId +'/ops/'+status;
        var param = {
          type: $scope.curRequest.type,
          comment: $scope.curRequest.comment
        };

        if ($scope.curRequest.type === 'SHIFT_SWAP_REQUEST') {

          if (status === 'approve' && !$scope.curRequest.curRecipient) {
            applicationContext.setNotificationMsgWithValues('Please select the recipient', '', true);
            return;
          }
          else if (status === 'approve'){
            param.employeeId = $scope.curRequest.curRecipient.peerId;
            param.shiftId = $scope.curRequest.curRecipient.recipientShift.id;
          }

        }
        else if ($scope.curRequest.type === 'WIP_REQUEST') {

          if (status === 'approve' && !$scope.curRequest.curRecipient) {
            applicationContext.setNotificationMsgWithValues('Please select the recipient', '', true);
            return;
          }
          else if (status === 'approve'){
            param.employeeId = $scope.curRequest.curRecipient.peerId;
          }

        }
        else if ($scope.curRequest.type === 'TIME_OFF_REQUEST') {

          param.shiftActions = [];

          for (var i =0; i<$scope.curRequest.shifts.length; i++) {
            var shift = $scope.curRequest.shifts[i];

            var employeeIds = null;
            var errMsg = '';

            if (shift.action === 'ASSIGN_SHIFT') {
              if (shift.teamMate) {
                employeeIds = [shift.teamMate.employeeId];
              }
              else {
                employeeIds = null;
              }

              errMsg = 'Assign Failed: ' + shift.id;
            }

            else if (shift.action === 'POST_AS_OPEN_SHIFT') {
              employeeIds = _.pluck(shift.eligibleTeammates, 'employeeId');
              errMsg = 'POST Failed: ' + shift.id;
            }

            /**
             * Display Dialog box when no employees selected in POST & FIll option
             */
            if ((shift.action === 'POST_AS_OPEN_SHIFT' || shift.action === 'ASSIGN_SHIFT') && (employeeIds === null || employeeIds.length === 0)) {

              break;

            }


            param.shiftActions.push({
                shiftId: shift.id,
                action: shift.action,
                employeeIds: employeeIds
              }
            );

          }

          /**
           * abnormally returned;
           */
          if (i < $scope.curRequest.shifts.length) {
            var dlg = $modal.open({
              templateUrl: 'modules/dashboard/partials/dashboard_approvals_timeoff_msg_dlg.html',
              controller: 'DashboardApprovalsTimeOffMsgCtrl',
              windowClass: 'dashboard-approvals',
              resolve: {
                shift: function() {
                  return $scope.curRequest.shifts[i];
                }
              }
            });

            return dlg;

          }

        }

        $http.post(
          baseUrl + url , param)
          .then(function (response) {
            if (response.data.status === 'SUCCESS') {
              $scope.loadCurRequest($scope.curRequest.requestId)
                .then(function onSuccess(request) {
                  $scope.curRequest = prepareRequest(request);
                  $scope.reloadRequestInGrid(request);
                }, function onError(error) {
                  applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
                  console.error(error);
                });
            } else {
              console.error("Data loaded with invalid status: ", response.data);
            }
          }, function(error) {
            applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
            console.error(error);
          });
      };
      
      function prepareRequest(request) {
        function toSubmitterTz(date) {
          return appFunc.convertToBrowserTimezone(date, request.submitterTz);
        }

        //Prepare request data
        request.dateOfAction = toSubmitterTz(request.dateOfAction);
        request.eventDate = toSubmitterTz(request.eventDate);
        request.expirationDate = toSubmitterTz(request.expirationDate);
        request.submitDate = toSubmitterTz(request.submitDate);

        request.isRead = true;

        if (request.commentary.commentary) {
          _.each(request.commentary.commentary, function (comment) {
            comment.datetime = toSubmitterTz(comment.datetime);
          });
        }

        if (request.submitterShift) {
          request.submitterShift.endDateTime = toSubmitterTz(request.submitterShift.endDateTime);
          request.submitterShift.startDateTime = toSubmitterTz(request.submitterShift.startDateTime);
        }

        // Prepare request recipients and shifts
        switch (request.type) {
          case 'SHIFT_SWAP_REQUEST':
          //go down
          case 'WIP_REQUEST':
          {
            //Load Eligible Teammates
            var counts = _.countBy(request.recipients, function (recipient) {
              recipient.dateActed = toSubmitterTz(recipient.dateActed);
              if (recipient.recipientShift) {
                recipient.recipientShift.endDateTime = toSubmitterTz(recipient.recipientShift.endDateTime);
                recipient.recipientShift.startDateTime = toSubmitterTz(recipient.recipientShift.startDateTime);
              }
              if (recipient.status === 'PEER_APPROVED') {
                return 'accepted';
              }
            });
            request.acceptedRecipientCount = counts.accepted ? counts.accepted : 0;
            request.showAcceptedRecipientsOnly = true; // default : only shows accepted
            break;
          }
          case 'TIME_OFF_REQUEST':
          {
            _.each(request.shifts, function (shift) {
              shift.action = 'DROP_SHIFT';//select Drop by default
              shift.endDateTime = toSubmitterTz(shift.endDateTime);
              shift.startDateTime = toSubmitterTz(shift.startDateTime);
            });
            break;
          }
        }
        return request;
      }

      $scope.previewChange = function(request) {

        $modal.open({
          templateUrl: 'modules/dashboard/partials/availability_preview_modal.html',
          controller: 'AvailabilityPreviewModalCtrl',
          size: 'lg',
          resolve: {
            employeeId: function() {
              return request.submitterId;
            },
            siteTimeZone: function() {
              return $scope.currentAccountInfo.timezone;
            },
            firstDayOfWeek: function() {
              return $scope.currentAccountInfo.siteFirstDayOfweek;
            },
            previewParams: function() {
              var firstDate;
              if (request.availUpdate.effectiveStartDate) {
                // for ci timeframes
                firstDate = request.availUpdate.effectiveStartDate;
              } else {
                // for cd timeframes
                firstDate = request.availUpdate.selectedDates[0];
              }

              return {
                requestId: request.requestId,
                year: new Date(firstDate).getFullYear(),
                month: new Date(firstDate).getMonth()
              };
            }
          }
        });
      };

      $scope.showPreviewButton = function(request) {
        return request && request.type === "AVAILABILITY_REQUEST";
      };

      /**
       * return boolean whether action buttons can be shown or not.
       * @param request
       */
      $scope.canShowApproveButton = function(request) {

        if (!request) {
          return false;
        }

        if (request.type=== 'WIP_REQUEST' || request.type=== 'SHIFT_SWAP_REQUEST') {

          if (request.status !=='ADMIN_PENDING') {
            return false;
          }

          var approvedRecipient = _.findWhere(request.recipients, {'status': 'PEER_APPROVED'});

          if (approvedRecipient) {
            return true;
          }
          else {
            return false;
          }

        }
        else if (request.type=== 'TIME_OFF_REQUEST' || request.type=== 'OPEN_SHIFT_REQUEST' || request.type=== 'AVAILABILITY_REQUEST') {

          if (request.status ==='ADMIN_PENDING') {
            return true;
          }
          return false;
        }

      };

      /**
       * return boolean whether action buttons can be shown or not.
       * @param request
       * @returns {boolean}
       */
      $scope.canShowDeclineButton = function(request) {

        if (!request) {
          return false;
        }

        if (request.status ==='ADMIN_PENDING') {
          return true;
        }
        return false;

      };

      /**
       * Update
       * @param recipient
       */
      $scope.setCurRecipient = function(recipient) {
        $scope.curRequest.curRecipient = recipient;
      };


      /**
       * Get Request Employees from Shift : Manager Approval
       * @returns {*}
       */
      $scope.loadEligibleTeammates = function(shift) {

        if (shift.eligibleTeammates) {
          /**
           * Do not call again
           */
          return;
        }

        shift.callInProcess = true;

        shift.eligibleTeammates = [];
        var url = 'employees/' + shift.employeeId + '/ops/getwipeligibleemployees';

        var param = {
          shiftId: shift.id
        };

        $http.post(
            baseUrl + url , param)
          .then(function (response) {

            var result = response.data;
            shift.eligibleTeammates = result.eligibleTeammates;
            shift.callInProcess = false;

            /**
             * No Eligible teammates, switch to 'drop'
             */
            if (shift.eligibleTeammates.length < 1) {
              shift.action = 'DROP_SHIFT';
            }

          }, function(error) {
            shift.eligibleTeammates = null;
            shift.callInProcess = false;
            shift.action = 'DROP_SHIFT';
            applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
            console.log(error);
          });


      };

      /**
       * Update one grid row data
       */
      $scope.reloadRequestInGrid = function(request) {
        var curRow = _.findWhere($scope.gridOptions.data, {'requestId': request.requestId});
        if (!curRow) {
          applicationContext.setNotificationMsgWithValues("can't find the request in the grid", '', true, 'error');
          return;
        }
        updateCurrentGridRowAccordingToGridColumnDef(curRow, request, $scope.columnDef);
      };

      function getSelectedTeamIds() {
        var selectedTeams = [];
        _.each($scope.filter.selectedSiteTeams, function(team) {
              if (team !== null && team.teamId !== null){
                selectedTeams.push(team.teamId);}
            }
        );
        return selectedTeams;
      }

      function getSelectedStatusIds() {
        var selectedStatusIds = [];
        _.each($scope.filter.selectedStatuses, function(status) {selectedStatusIds.push(status.id);});
        return selectedStatusIds;
      }

      function getSelectedReqTypeIds() {
        var selectedReqTypesIds = [];
        _.each($scope.filter.selectedReqTypes, function(type) {selectedReqTypesIds.push(type.id);});
        return selectedReqTypesIds;
      }

    }
  ]
);

dashboard.directive('printRequestStatus', ['$filter', function($filter) {
  var statuses = {
    PEER_PENDING: {
      name: "PEER_PENDING",
      imgPath: "/scheduler-server/emlogis/img/dashboard/peer_pending.png",
      css: "peer-pending"
    },
    ADMIN_PENDING: {
      name: "ADMIN_PENDING",
      imgPath: "/scheduler-server/emlogis/img/dashboard/admin_pending.png",
      css: "admin-pending"
    },
    PEER_APPROVED: {
      name: "PEER_APPROVED",
      imgPath: "/scheduler-server/emlogis/img/mark_as_read_opt1.svg",
      imgStyle: "width: 16px;",
      css: "approved"
    },
    APPROVED: {
      name: "APPROVED",
      imgPath: "/scheduler-server/emlogis/img/mark_as_read_opt1.svg",
      imgStyle: "width: 16px;",
      css: "approved"
    },
    PEER_DECLINED: {
      name: "PEER_DECLINED",
      imgPath: "/scheduler-server/emlogis/img/dashboard/declined.png",
      css: "declined"
    },
    DECLINED: {
      name: "DECLINED",
      imgPath: "/scheduler-server/emlogis/img/dashboard/declined.png",
      css: "declined"
    },
    DELETED: {
      name: "DELETED",
      imgPath: "/scheduler-server/emlogis/img/dashboard/deleted.png",
      css: "deleted"
    },
    EXPIRED: {
      name: "EXPIRED",
      imgPath: "/scheduler-server/emlogis/img/dashboard/expired.png",
      css: "expired"
    },
    WITHDRAWN: {
      name: "WITHDRAWN",
      imgPath: "/scheduler-server/emlogis/img/dashboard/withdrawn.png",
      css: "withdrawn"
    },
    UNKNOWN: {
      name: "UNKNOWN",
      imgPath: "/scheduler-server/emlogis/img/dashboard/unknown.png",
      css: "unknown"
    }
  };

  function getCurrentStatus(statusName) {
    for(var status in statuses){
      if(statuses[status].name == statusName) {
        return statuses[status];
      }
    }
    return statuses.UNKNOWN;
  }

  return {
    restrict: 'A',
    link: function($scope, element, attrs) {
      $scope.$watch(attrs.printRequestStatus, function(value){
        var currentStatus = getCurrentStatus(value);
        if(currentStatus) {
          var imgStyle = currentStatus.imgStyle ? ("style='" + currentStatus.imgStyle + "'") : "";
          var cssClasses = currentStatus.css ? ("class='" + currentStatus.css + "'") : "";
          element.html(
              "<em " + cssClasses + ">" +
              "<img src='" + currentStatus.imgPath + "' " + imgStyle + ">" +
              $filter('translate')('app.'+currentStatus.name) +
              "</em>"
          );
        }
      });
    }
  };
}]);


;
var dashboard = angular.module('emlogis.dashboard');

dashboard.controller('DashboardBreadcrumbCtrl', ['$scope', '$translate', 'applicationContext',
  function ($scope, $translate, applicationContext) {

    //// Update Module Information
    //var module = applicationContext.getModule();
    //
    //// Call translate directive function. Put translated text;
    //$translate('nav.DASHBOARD')
    //  .then(function (translation) {
    //    module.name = translation;
    //  });
    //
    //
    //module.href = '/dashboard';
    //module.icoClass = '';
    //module.disableModuleBreadcrumb = false;
    //applicationContext.setModule(module);

    //console.log('home dashboard breadcrumb controller');
    //
    //// These variables are used in entities-list-breadcrumb.js file
    //
    //$scope.newEntity = "employees.NEW_EMPLOYEE";
    //$scope.entity = "employees.EMPLOYEE";
    //$scope.entityResource = "employees";


    if (applicationContext.getUsername() === ""){
      applicationContext.setUsername($sessionStorage.username);
    }

    $scope.username = applicationContext.getUsername();

    // Set Variables for accordion
    $scope.sideBar = {
      isManager_ApprovalsOpen : true,
      isTeam_Member_RequestsOpen : true
    };

    // Update Module Information

    var module = applicationContext.getModule();

    // Call translate directive function. Put translated text;
    $translate('nav.HOME')
      .then(function (translation) {
        module.name =  translation;
      });


    module.href = '/dashboard';
    module.icoClass = '';
    module.disableModuleBreadcrumb = false;
    applicationContext.setModule(module);

  }
]);

;
var dashboard = angular.module('emlogis.dashboard');

dashboard.controller('DashboardMyRequestsCtrl',
  [
    '$http',
    '$scope',
    '$state',
    '$q',
    '$filter',
    '$sessionStorage',
    '$timeout',
    'appFunc',
    'applicationContext',
    'crudDataService',
    'uiGridConstants',
    'DashboardService',
    function($http, $scope, $state, $q, $filter, $sessionStorage, $timeout,
             appFunc, applicationContext, crudDataService,
             uiGridConstants, DashboardService) {

      /**
       * Variables in Dashboard Approvals
       * 1. $scope.days: Filter Dropdown list in Filter
       * 2. $scope.filter.siteTeams: Filter Dropdown tree list in Filter
       * 3. $scope.filter.statuses: Filter Dropdown Statuses
       * 4. $scope.filter.dayLength: Filter ng-model of days
       */

      $scope.days = [
        {day: 7, title: 'LAST 7 DAYS'},
        {day: 14, title: 'LAST 14 DAYS'},
        {day: 30, title: 'LAST 30 DAYS'},
        {day: 0, title: 'ALL'}
      ];

      var baseUrl = applicationContext.getBaseRestUrl();
      var factory = _.clone(crudDataService);
      var numOfRows = 25;

      /*
       *This header cell template is almost same as default cell template except
       * it has translate directive inside so grid header will support i18n as well
       */
      var headerCellTemplate = function(){
        return "<div ng-class=\"{ 'sortable': sortable }\">" +
          "<div class=\"ui-grid-vertical-bar\">&nbsp;</div>" +
          "<div class=\"ui-grid-cell-contents\" col-index=\"renderIndex\" ><span translate>{{ col.name CUSTOM_FILTERS }} </span>" +
          "<span ui-grid-visible=\"col.sort.direction\" ng-class=\"{ 'ui-grid-icon-up-dir': col.sort.direction == asc, 'ui-grid-icon-down-dir': col.sort.direction == desc, 'ui-grid-icon-blank': !col.sort.direction }\">&nbsp;</span>" +
          "</div>" +
          "<div class=\"ui-grid-column-menu-button\" ng-if=\"grid.options.enableColumnMenus && !col.isRowHeader  && col.colDef.enableColumnMenu !== false\" class=\"ui-grid-column-menu-button\" ng-click=\"toggleMenu($event)\">" +
          "<i class=\"ui-grid-icon-angle-down\">&nbsp;</i>" +
          "</div>" +
          "<div ng-if=\"filterable\" class=\"ui-grid-filter-container\" ng-repeat=\"colFilter in col.filters\">" +
          "<input type=\"text\" class=\"ui-grid-filter-input\" ng-model=\"colFilter.term\" ng-click=\"$event.stopPropagation()\" ng-attr-placeholder=\"{{colFilter.placeholder || ''}}\">" +
          "<div class=\"ui-grid-filter-button\" ng-click=\"colFilter.term = null\">" +
          "<i class=\"ui-grid-icon-cancel right\" ng-show=\"!!colFilter.term\">&nbsp;</i> <!-- use !! because angular interprets 'f' as false -->" +
          "</div>" +
          "</div>" +
          "</div>";
      };

      // Row Template: Homepage Dashboard Manager Request Approval
      function rowTemplate() {

          return '<div ng-class="{\'row-hovered\' : hover}" ' +
            '     ng-mouseenter="hover = true" ' +
            '     ng-mouseleave="hover = false" ' +
//            '     ng-click="grid.appScope.loadCurRequest(row.entity.requestId)">' +
            '     >' +
            '  <div ng-repeat="(colRenderIndex, col) in colContainer.renderedColumns track by col.colDef.name" ' +
            '       class="ui-grid-cell" ' +
            '       ng-class="{ \'ui-grid-row-header-cell\': col.isRowHeader }"  ' +
            '       ui-grid-cell>' +
            '  </div>' +
            '</div>';
      }

      // Header Template
      function headerTemplate() {
        return '<div ng-style="{ height: col.headerRowHeight }" ng-repeat="col in renderedColumns" ng-class="col.colIndex()" class="ngHeaderCell" ng-header-cell></div>';
      }


      $scope.loadRequests = function(pageNum) {

        //[POST] /requests/submitter/ops/query
        var deferred = $q.defer();
        var selectedStatusIds = [];
        var selectedReqTypesIds = [];
        var startTime = null;
        var requestUrl = 'requests/submitter/ops/query';


        _.each($scope.filter.selectedStatuses, function(status) {selectedStatusIds.push(status.id);});
        _.each($scope.filter.selectedReqTypes, function(type) {selectedReqTypesIds.push(type.id);});

        if ($scope.filter.dayLength.day !== 0) {
          startTime = moment().subtract($scope.filter.dayLength.day, 'days').toDate().getTime();  // subtracts days
        }


        if (!pageNum) {
          pageNum = 1;
        }

        var urlParam = factory.prepareQueryParams($scope.gridOptions.queryParams,pageNum, numOfRows);

        if (selectedReqTypesIds.length === 0) {
          selectedReqTypesIds = null;
        }

        if (selectedStatusIds.length === 0) {
          selectedStatusIds = null;
        }

        var param = {
          types: selectedReqTypesIds,
          statuses: selectedStatusIds,
          dateFrom: startTime,
          dateTo: null,
          fullTextSearch: $scope.filter.searchTxt,
          offset: urlParam.offset,
          limit: urlParam.limit,
          orderBy: urlParam.orderby,
          orderDir: urlParam.orderdir.toUpperCase()
        };

        console.log(urlParam);

        $http.post(
          baseUrl+requestUrl, param)
          .then(function (response) {

            var approvals = response.data;

//            / Convert appropriate result.
            angular.forEach(approvals.data, function(entity) {
              var requestTz = entity.submitterTz;
              
              entity.reqDate=entity.eventDate;

              //iterate columns
              angular.forEach($scope.columnDef, function(column) {

                if (column.field === 'type') {
                  entity[column.field] = $filter('translate')(column.transPrefix+'.'+entity[column.field]);
                }
                else if (column.field === 'status') {
                  entity[column.field] = $filter('translate')(column.transPrefix+'.'+entity[column.field]);
                }

                if (!column.dateFormat) {
                  return;
                }

                var timezoneDate = appFunc.convertToBrowserTimezone(entity[column.field], requestTz);
                entity[column.field] = $filter('date')(timezoneDate, column.dateFormat);

              });
            });

            $scope.gridOptions.data = approvals.data;
            $scope.gridOptions.totalItems = approvals.total;

            deferred.resolve(approvals.data);

            //clear curDetail View
            $scope.curRequest = null;

          }, function(error) {
            deferred.reject(error);
            applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
          });

        return deferred.promise;
      };


      $scope.loadStatuses = function() {

        //rest/workflow/dashboard/tasks/manager?offset=0&limit=20&orderby=submitted&orderdir=asc
        var deferred = $q.defer();
        $http.get(baseUrl + 'workflow/dashboard/statuses', {})
          .then(function (response) {
            var result = response.data;
            $scope.filter.statuses = result.data;

            _.each($scope.filter.statuses, function(status) {status.ticked = true;});

            deferred.resolve(response.data);

          }, function(error) {
            deferred.reject(error);
            applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
          });

        return deferred.promise;
      };

      $scope.loadReqTypes = function() {
        // WIP_REQUEST , SHIFT_SWAP_REQUEST , OPEN_SHIFT_REQUEST, PTO_REQUEST, AVAILABILITY_REQUEST
        $scope.filter.reqTypes = [
          {
            name:'WIP_REQUEST',
            id:'WIP_REQUEST',
            ticked: true
          },
          {
            name:'SHIFT_SWAP_REQUEST',
            id:'SHIFT_SWAP_REQUEST',
            ticked: true
          },
          {
            name:'OPEN_SHIFT_REQUEST',
            id:'OPEN_SHIFT_REQUEST',
            ticked: true
          },
          {
            name:'PTO_REQUEST',
            id:'PTO_REQUEST',
            ticked: true
          },
          {
            name:'AVAILABILITY_REQUEST',
            id:'AVAILABILITY_REQUEST',
            ticked: true
          }
        ];
//        var deferred = $q.defer();
//        $http.get(baseUrl + 'workflow/dashboard/types?orderby=name&orderdir=ASC', {})
//          .then(function (response) {
//            var result = response.data;
//            $scope.filter.reqTypes = result.data;
//
//            _.each($scope.filter.reqTypes, function(reqType) {reqType.ticked = true;});
//
//            deferred.resolve(response.data);
//
//          }, function(error) {
//            deferred.reject(error);
//          });
//
//        return deferred.promise;

      };

      $scope.loadCurRequest = function(requestId) {

        var deferred = $q.defer();
        $http.get(baseUrl + 'requests/submitter/'+requestId, {})
          .then(function (response) {

            var result = response.data;

            $scope.curRequest = result.data;
            function toSubmitterTz(date) {
              return appFunc.convertToBrowserTimezone(date, $scope.curRequest.submitterTz);
            }

            if ($scope.curRequest) {
              /**
               * Converts the Dates
               */
              $scope.curRequest.dateOfAction = toSubmitterTz($scope.curRequest.dateOfAction);
              $scope.curRequest.eventDate = toSubmitterTz($scope.curRequest.eventDate);
              $scope.curRequest.expirationDate = toSubmitterTz($scope.curRequest.expirationDate);
              $scope.curRequest.submitDate = toSubmitterTz($scope.curRequest.submitDate);

              if ($scope.curRequest.commentary.comments) {
                _.each($scope.curRequest.commentary.comments, function(comment) {
                  comment.datetime = toSubmitterTz(comment.datetime);
                });
              }

              /**
               * Convert Commentary Date to Proper Timezone
               */
              if ($scope.curRequest.submitterShift) {
                $scope.curRequest.submitterShift.endDateTime= toSubmitterTz($scope.curRequest.submitterShift.endDateTime);
                $scope.curRequest.submitterShift.startDateTime = toSubmitterTz($scope.curRequest.submitterShift.startDateTime);
              }


              if ($scope.curRequest.type === 'SHIFT_SWAP_REQUEST' || $scope.curRequest.type === 'WIP_REQUEST') {
//                 Load EligibleTeammates

                /**
                 * Convert the timezones
                 */
                var counts = _.countBy($scope.curRequest.recipients, function (recipient) {

                  if (recipient.status=='PEER_APPROVED') {
                    recipient.checked = true;
                  }

                  recipient.dateActed = toSubmitterTz(recipient.dateActed);

                  if (recipient.recipientShift) {
                    recipient.recipientShift.endDateTime = toSubmitterTz(recipient.recipientShift.endDateTime);
                    recipient.recipientShift.startDateTime = toSubmitterTz(recipient.recipientShift.startDateTime);
                  }

                  if (recipient.status === 'PEER_APPROVED')
                    return 'accepted';
                });

                $scope.curRequest.acceptedRecipientCount = counts.accepted ? counts.accepted : 0;
                $scope.curRequest.showAcceptedRecipientsOnly = false; // default : only shows approved

              }
              else if ($scope.curRequest.type === 'TIME_OFF_REQUEST') {

                _.each($scope.curRequest.shifts, function(shift) {
                  shift.action = 'DROP_SHIFT';//select Drop by default
                  shift.endDateTime = toSubmitterTz(shift.endDateTime);
                  shift.startDateTime = toSubmitterTz(shift.startDateTime);
                });
              }
            }

            deferred.resolve(response.data);

          }, function(error) {
            applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
            deferred.reject(error);
          });

        return deferred.promise;
      };

      /**
       * Init function: My Requests
       */
      $scope.init = function() {

        $scope.currentAccountInfo = JSON.parse($sessionStorage.info);

        // ColumnDef Info
        // The columns with empty filed will not work for sort as of now
        $scope.columnDef = [
          {
            name: 'home.REQ_TYPE',
            field: 'type',
            headerCellTemplate: headerCellTemplate(),
            transPrefix: 'home'
          },
          {
            name: 'home.SUBMITTED',
            field: 'submitDate',
            headerCellTemplate: headerCellTemplate(),
            dateFormat: 'M/d/yy - hh:mm a'
          },
          {
            name: 'home.REQ_DATE',
            field: 'reqDate',
            headerCellTemplate: headerCellTemplate(),
            dateFormat: 'M/d/yy'
          },
          {
            name: 'home.DESCRIPTION',
            field: 'description',
            headerCellTemplate: headerCellTemplate()
          },
          {
            name: 'home.EXPIRES',
            field: 'expirationDate',
            headerCellTemplate: headerCellTemplate(),
            dateFormat: 'M/d/yy'
          },
          {
            name: 'home.STATUS',
            field: 'status',
            transPrefix: 'app',
            width: '20%',
            headerCellTemplate: headerCellTemplate()
          }
        ];

        // External Scope Module, This variable will be used when we have an action inside grid row
        $scope.gridModel = {

          // On a double click event , it will move to employee detail page to show employee detail
          onClickRow : function(row){
            row.isSelected = true;
          }

        };


        $scope.gridOptions = {

          enableColumnResizing: true,
          enableRowHeaderSelection: false,
          modifierKeysToMultiSelect: false,
          noUnselect: true,
//        enableGridMenu: true,
          minRowsToShow: numOfRows,
          columnDefs: $scope.columnDef, //
          rowTemplate: rowTemplate(), //Row Template,
          enableHorizontalScrollbar: 0,
          enableVerticalScrollbar: 0,
          enableColumnMenus: false,

//        enableFiltering: true,
          multiSelect: false,
          useExternalFiltering: true,

          enableSorting: true,
          useExternalSorting: true,

          needPagination: true,
          useExternalPagination: true,
          enablePaginationControls: false,
          paginationPageSize: numOfRows,
          paginationCurrentPage: 1,
          enableFullRowSelection: true,

          //enableSelectAll: true,
          enableRowSelection: true,
//        enableColumnMenus: true,
//        gridMenuTitleFilter: $translate, // Translate Grid Menu column name

          onRegisterApi: function( gridApi ) {
            $scope.gridApi = gridApi;

            gridApi.selection.on.rowSelectionChanged($scope, function (row) {

              if (row.isSelected) {
                console.log('selected');
                $scope.loadCurRequest(row.entity.requestId)
                  .then(function(response) {
                    $scope.reloadRequestInGrid($scope.curRequest);
                    console.log('one request in grid is updated');
                  }, function(error) {
                    applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
                    console.log(error);
                  });
              }

            });


            /**
             * Dashboard My Requests Sort Changed
             */

            $scope.gridApi.core.on.sortChanged( $scope, function( grid, sortColumns ) {

              if (sortColumns.length === 0) {
                $scope.gridOptions.queryParams.orderdir = 'asc';
                $scope.gridOptions.queryParams.orderby = 'REQ_TYPE';
              } else {
                $scope.gridOptions.queryParams.orderdir = sortColumns[0].sort.direction;

                switch (sortColumns[0].field) {
                  case "type":
                    $scope.gridOptions.queryParams.orderby = 'REQ_TYPE';
                    break;
                  case "submitDate":
                    $scope.gridOptions.queryParams.orderby = 'SUBMITTED';
                    break;
                  case "reqDate":
                    $scope.gridOptions.queryParams.orderby = 'REQ_DATE';
                    break;
                  case "expirationDate":
                    $scope.gridOptions.queryParams.orderby = 'EXPIRES';
                    break;
                  case "status":
                    $scope.gridOptions.queryParams.orderby = 'REQ_STATUS';
                    break;
                  case "description":
                    $scope.gridOptions.queryParams.orderby = 'DESCRIPTION';
                    break;
                }
              }
              getPage();

            });

            //
            // Back-end pagination

            $scope.gridApi.pagination.on.paginationChanged($scope, function (newPage, pageSize) {
              $scope.gridOptions.paginationCurrentPage = newPage;
              getPage();
            });

            var getPage = function() {
              return $scope.loadRequests($scope.gridOptions.paginationCurrentPage);
            };
          }
        };

        $scope.gridOptions.queryParams = {
          orderby:'SUBMITTED',
          orderdir:'DESC'
        };

        $scope.isPendingRecipientAndNotApprovedRequest = DashboardService.isPendingRecipientAndNotApprovedRequest;

        $scope.filter = {
          dayLength: null,
          statuses: DashboardService.getRequestStatuses(),
          reqTypes: DashboardService.getRequestTypes(),
          searchTxt: ''
        };

        _.each($scope.filter.reqTypes, function(reqType) {
          reqType.ticked = true;
        });

        $scope.filter.dayLength = $scope.days[2]; // load last 30 days

        DashboardService.getCurrentAccountInfo($scope.currentAccountType)
          .then(function(response) {
            if ($scope.currentAccountType === 'Employee') {
              $scope.currentAccountInfo.accountId = response.data.employeeDto.id;
              $scope.currentAccountInfo.timezone = response.data.siteTz.id;
              $scope.currentAccountInfo.siteId = response.data.siteId;
              $scope.currentAccountInfo.siteFirstDayOfweek = response.data.siteFirstDayOfweek;
              $scope.currentAccountInfo.teams = response.data.teams;
            }
            else {
              $scope.currentAccountInfo.timezone = response.data.timezone.id;
            }

            return $scope.loadRequests();
          })
          .catch(function(error) {
            if (error.message) {
              applicationContext.setNotificationMsgWithValues(error.message, '', true, '');
            }
            else {
              applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
            }
          });

      };

      /**
       * : My Requests
       */
      $scope.delayedLoadRequests = function() {
        $timeout(function() {$scope.loadRequests();}, 1000); //wait for the dropdown list update their selectedOutputs
      };

      $scope.isTomorrow = function(date){
        var tomorrow = new Date(new Date().getTime() + 24 * 60 * 60 * 1000);
        var day = tomorrow.getDate();
        var month = tomorrow.getMonth();
        var year = tomorrow.getFullYear();
        var dateT = new Date(date);

        if (day === dateT.getDate() && month === dateT.getMonth() && year === dateT.getFullYear()) {
          return true;
        }

        return false;


      };

      /**
       * Update Request Status: My Requests
       * @param status
       */
      $scope.updateRequest = function(status) {


        var url = 'requests/submitter/' +$scope.curRequest.requestId +'/ops/'+status;
        var param = {
          type: $scope.curRequest.type,
          comment: $scope.curRequest.comment
        };

        if ($scope.curRequest.type === 'SHIFT_SWAP_REQUEST') {
          param.employeeId = $scope.curRequest.curRecipient.peerId;
          param.shiftIdList = [];
          param.shiftIdList.push($scope.curRequest.curRecipient.recipientShift.id);
        }
        else if ($scope.curRequest.type === 'WIP_REQUEST') {
          param.employeeId = $scope.curRequest.curRecipient.peerId;
        }
        else if ($scope.curRequest.type === 'TIME_OFF_REQUEST') {

          param.shiftActions = [];

          _.each($scope.curRequest.shifts, function(shift) {

              var employeeIds = null;

              if (shift.action === 'ASSIGN_SHIFT') {
                employeeIds = [shift.teamMate.employeeId];
              }

              param.shiftActions.push({
                  shiftId: shift.id,
                  action: shift.action,
                  employeeIds: employeeIds
                }
              );
            }
          );
        }

        $http.post(
          baseUrl + url , param)
          .then(function (response) {
            /**45656456456456464
             * Reload Status
             */
            if (response.data.status === 'SUCCESS') {
              $scope.loadCurRequest($scope.curRequest.requestId)
                .then(function(response) {
                  $scope.reloadRequestInGrid($scope.curRequest);
                  console.log('one request in grid is updated');
                }, function(error) {
                  applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
                  console.log(error);
                });


            }
            console.log(response);

          }, function(error) {
            applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
            console.log(error);
          });

      };

      /**
       * return boolean whether action buttons can be shown or not.
       * @param request
       */
      $scope.canShowApproveButton = function(request) {

        if (!request) {
          return false;
        }

        if (request.type=== 'WIP_REQUEST' || request.type=== 'SHIFT_SWAP_REQUEST') {

          if (request.status !=='ADMIN_PENDING') {
            return false;
          }

          var approvedRecipient = _.findWhere(request.recipients, {'status': 'PEER_APPROVED'});

          if (approvedRecipient) {
            return true;
          }
          else {
            return false;
          }

        }
        else if (request.type=== 'TIME_OFF_REQUEST' || request.type=== 'OPEN_SHIFT_REQUEST' || request.type=== 'AVAILABILITY_REQUEST') {

          if (request.status ==='ADMIN_PENDING') {
            return true;
          }
          return false;
        }

      };

      /**
       * return boolean whether action buttons can be shown or not.
       * @param request
       * @returns {boolean}
       */
      $scope.canShowDeclineButton = function(request) {

        if (!request) {
          return false;
        }

        if (request.status ==='ADMIN_PENDING') {
          return true;
        }
        return false;

      };

      /**
       * Update
       * @param recipient
       */
      $scope.setCurRecipient = function(recipient) {
        $scope.curRequest.curRecipient = recipient;
      };

      /**
       *
       * @param request
       */
      $scope.cancelRequest = function(request) {

//        /requests/submitter/{requestId}?

        return $http.delete(baseUrl + 'requests/submitter/' + request.requestId, {})
          .then(function (response) {

            /**
             * Reload Status
             */
            if (response.data.status === 'SUCCESS') {
              $scope.loadCurRequest($scope.curRequest.requestId)
                .then(function(response) {
                  $scope.reloadRequestInGrid($scope.curRequest);
                  console.log('one request in grid is updated');
                }, function(error) {
                  applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
                  console.log(error);
                });


            }
            console.log(response);


          }, function(error) {
            applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
            console.log(error);
          });
      };


      /**
       * Update one grid row after approve/deny the request
       */
      $scope.reloadRequestInGrid = function(request) {

        var curRow = _.findWhere($scope.gridOptions.data, {'requestId': request.requestId});

        if (!curRow) {
          applicationContext.setNotificationMsgWithValues("can't find the request in the grid", '', true, 'error');
          return;
        }

        /**
         * update the fields
         */

        curRow.submitterTeamName = request.submitterTeamName;
        curRow.submitterName = request.submitterName;
        curRow.type = $filter('translate')('home.'+request.type);
        curRow.description = request.description;
        curRow.status = $filter('translate')('app.'+request.status);
        curRow.isRead = request.isRead;

        var submitDateColumnDef = _.findWhere($scope.columnDef, {'field': 'submitDate'});
        curRow.submitDate = $filter('date')(request.submitDate, submitDateColumnDef.dateFormat);

        var reqDateColumnDef = _.findWhere($scope.columnDef, {'field': 'reqDate'});
        curRow.reqDate = $filter('date')(request.eventDate, reqDateColumnDef.dateFormat);

        var expirationDateColumnDef = _.findWhere($scope.columnDef, {'field': 'expirationDate'});
        curRow.expirationDate = $filter('date')(request.expirationDate, expirationDateColumnDef.dateFormat);
      };



    }
  ]
);

;
var dashboard = angular.module('emlogis.dashboard');

dashboard.controller('DashboardTeamRequestsCtrl',
  [
    '$http',
    '$scope',
    '$state',
    '$q',
    '$filter',
    '$sessionStorage',
    '$timeout',
    'appFunc',
    'applicationContext',
    'crudDataService',
    'uiGridConstants',
    'DashboardService',
    function($http, $scope, $state, $q, $filter, $sessionStorage, $timeout,
             appFunc, applicationContext, crudDataService,
             uiGridConstants, DashboardService) {

      /**
       * Variables in Dashboard Approvals
       * 1. $scope.days: Filter Dropdown list in Filter
       * 2. $scope.filter.siteTeams: Filter Dropdown tree list in Filter
       * 3. $scope.filter.statuses: Filter Dropdown Statuses
       * 4. $scope.filter.dayLength: Filter ng-model of days
       */

      $scope.days = [
        {day: 7, title: 'LAST 7 DAYS'},
        {day: 14, title: 'LAST 14 DAYS'},
        {day: 30, title: 'LAST 30 DAYS'},
        {day: 0, title: 'ALL'}
      ];

      var baseUrl = applicationContext.getBaseRestUrl();
      var factory = _.clone(crudDataService);
      var numOfRows = 25;

      /*
       *This header cell template is almost same as default cell template except
       * it has translate directive inside so grid header will support i18n as well
       */
      var headerCellTemplate = function(){
        return "<div ng-class=\"{ 'sortable': sortable }\">" +
          "<div class=\"ui-grid-vertical-bar\">&nbsp;</div>" +
          "<div class=\"ui-grid-cell-contents\" col-index=\"renderIndex\" ><span translate>{{ col.name CUSTOM_FILTERS }} </span>" +
          "<span ui-grid-visible=\"col.sort.direction\" ng-class=\"{ 'ui-grid-icon-up-dir': col.sort.direction == asc, 'ui-grid-icon-down-dir': col.sort.direction == desc, 'ui-grid-icon-blank': !col.sort.direction }\">&nbsp;</span>" +
          "</div>" +
          "<div class=\"ui-grid-column-menu-button\" ng-if=\"grid.options.enableColumnMenus && !col.isRowHeader  && col.colDef.enableColumnMenu !== false\" class=\"ui-grid-column-menu-button\" ng-click=\"toggleMenu($event)\">" +
          "<i class=\"ui-grid-icon-angle-down\">&nbsp;</i>" +
          "</div>" +
          "<div ng-if=\"filterable\" class=\"ui-grid-filter-container\" ng-repeat=\"colFilter in col.filters\">" +
          "<input type=\"text\" class=\"ui-grid-filter-input\" ng-model=\"colFilter.term\" ng-click=\"$event.stopPropagation()\" ng-attr-placeholder=\"{{colFilter.placeholder || ''}}\">" +
          "<div class=\"ui-grid-filter-button\" ng-click=\"colFilter.term = null\">" +
          "<i class=\"ui-grid-icon-cancel right\" ng-show=\"!!colFilter.term\">&nbsp;</i> <!-- use !! because angular interprets 'f' as false -->" +
          "</div>" +
          "</div>" +
          "</div>";
      };

      // Row Template: Homepage Dashboard Manager Request Approval
      function rowTemplate() {

        return '<div ng-class="{\'row-hovered\' : hover}" ' +
          '     ng-mouseenter="hover = true" ' +
          '     ng-mouseleave="hover = false" ' +
          '     ng-style="{ \'font-weight\': row.entity.isRead !== true ? \'bold\' : \'normal\' }" ' +
//            '     ng-click="grid.appScope.loadCurRequest(row.entity.requestId)">' +
          '     >' +
          '  <div ng-repeat="(colRenderIndex, col) in colContainer.renderedColumns track by col.colDef.name" ' +
          '       class="ui-grid-cell" ' +
          '       ng-class="{ \'ui-grid-row-header-cell\': col.isRowHeader }"  ' +
          '       ui-grid-cell>' +
          '  </div>' +
          '</div>';
      }

      // Header Template
      function headerTemplate() {
        return '<div ng-style="{ height: col.headerRowHeight }" ng-repeat="col in renderedColumns" ng-class="col.colIndex()" class="ngHeaderCell" ng-header-cell></div>';
      }


      $scope.loadRequests = function(pageNum) {

        //[POST] /requests/peer/ops/query
        var deferred = $q.defer();
        var selectedStatusIds = [];
        var selectedReqTypesIds = [];
        var startTime = null;
        var requestUrl = 'requests/peer/ops/query';


        _.each($scope.filter.selectedStatuses, function(status) {selectedStatusIds.push(status.id);});

        if ($scope.filter.reqTypes.wip && $scope.filter.reqTypes.wip.ticked === true ) {
          selectedReqTypesIds.push('WIP_REQUEST');
        }

        if ($scope.filter.reqTypes.swap && $scope.filter.reqTypes.swap.ticked === true ) {
          selectedReqTypesIds.push('SHIFT_SWAP_REQUEST');
        }

        if ($scope.filter.dayLength.day !== 0) {
          startTime = moment().subtract($scope.filter.dayLength.day, 'days').toDate().getTime();  // subtracts days
        }


        if (!pageNum) {
          pageNum = 1;
        }

        var urlParam = factory.prepareQueryParams($scope.gridOptions.queryParams,pageNum, numOfRows);

        if (selectedReqTypesIds.length === 0) {
          selectedReqTypesIds = null;
        }

        if (selectedStatusIds.length === 0) {
          selectedStatusIds = null;
        }

        var param = {
          types: selectedReqTypesIds,
          statuses: selectedStatusIds,
          dateFrom: startTime,
          dateTo: null,
          fullTextSearch: $scope.filter.searchTxt,
          offset: urlParam.offset,
          limit: urlParam.limit,
          orderBy: urlParam.orderby,
          orderDir: urlParam.orderdir.toUpperCase()
        };

        console.log(urlParam);

        $http.post(
          baseUrl+requestUrl, param)
          .then(function (response) {

            var approvals = response.data;

//            / Convert appropriate result.
            angular.forEach(approvals.data, function(entity) {
              var requestTz = entity.submitterTz;
              
              entity.reqDate=entity.eventDate;

              //iterate columns
              angular.forEach($scope.columnDef, function(column) {

                if (column.field === 'type') {
                  entity[column.field] = $filter('translate')(column.transPrefix+'.'+entity[column.field]);
                }
                else if (column.field === 'status') {
                  if ('PEER_APPROVED' === entity[column.field]) {
                    entity[column.field] = $filter('translate')('app.ACCEPTED');
                  }
                  else {
                    entity[column.field] = $filter('translate')(column.transPrefix+'.'+entity[column.field]);
                  }

                }

                if (!column.dateFormat) {
                  return;
                }

                var timezoneDate = appFunc.convertToBrowserTimezone(entity[column.field], requestTz);
                entity[column.field] = $filter('date')(timezoneDate, column.dateFormat);

              });
            });

            $scope.gridOptions.data = approvals.data;
            $scope.gridOptions.totalItems = approvals.total;

            deferred.resolve(approvals.data);

            //clear curDetail View
            $scope.curRequest = null;

          }, function(error) {
            deferred.reject(error);
            applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
          });

        return deferred.promise;
      };

      /**
       * Load Statues from backend: team requests
       * @returns {*}
       */
      $scope.loadStatuses = function() {

        var deferred = $q.defer();
        $http.get(baseUrl + 'workflow/dashboard/statuses', {})
          .then(function (response) {
            var result = response.data;
            $scope.filter.statuses = result.data;

            _.each($scope.filter.statuses, function(status) {status.ticked = true;});

            deferred.resolve(response.data);

          }, function(error) {
            deferred.reject(error);
            applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
          });

        return deferred.promise;
      };



      $scope.loadCurRequest = function(requestId) {

        var deferred = $q.defer();
        $http.get(baseUrl + 'requests/peer/'+requestId, {})
          .then(function (response) {

            var result = response.data;

            $scope.curRequest = result.data;
            function toSubmitterTz(date) {
              return appFunc.convertToBrowserTimezone(date, $scope.curRequest.submitterTz);
            }

            if ($scope.curRequest) {
              /**
               * Converts the Dates
               */
              $scope.curRequest.dateOfAction = toSubmitterTz($scope.curRequest.dateOfAction);
              $scope.curRequest.eventDate = toSubmitterTz($scope.curRequest.eventDate);
              $scope.curRequest.expirationDate = toSubmitterTz($scope.curRequest.expirationDate);
              $scope.curRequest.submitDate = toSubmitterTz($scope.curRequest.submitDate);

              //update isread
              $scope.curRequest.isRead = true;

              if ($scope.curRequest.commentary.comments) {
                _.each($scope.curRequest.commentary.comments, function(comment) {
                  comment.datetime = toSubmitterTz(comment.datetime);
                });
              }

              /**
               * Convert Commentary Date to Proper Timezone
               */
              if ($scope.curRequest.submitterShift) {
                $scope.curRequest.submitterShift.endDateTime= toSubmitterTz($scope.curRequest.submitterShift.endDateTime);
                $scope.curRequest.submitterShift.startDateTime = toSubmitterTz($scope.curRequest.submitterShift.startDateTime);
              }


              if ($scope.curRequest.type === 'SHIFT_SWAP_REQUEST' || $scope.curRequest.type === 'WIP_REQUEST') {
//                 Load EligibleTeammates

                /**
                 * Convert the timezones
                 */
                var counts = _.countBy($scope.curRequest.recipients, function (recipient) {

                  if ($scope.curRequest.type === 'SHIFT_SWAP_REQUEST' && recipient.status!='PEER_PENDING') {
                    recipient.checked = true;
                  }

                  recipient.dateActed = toSubmitterTz(recipient.dateActed);

                  if (recipient.recipientShift) {
                    recipient.recipientShift.endDateTime = toSubmitterTz(recipient.recipientShift.endDateTime);
                    recipient.recipientShift.startDateTime = toSubmitterTz(recipient.recipientShift.startDateTime);
                  }

                  if (recipient.status === 'PEER_APPROVED')
                    return 'accepted';
                });

                $scope.curRequest.acceptedRecipientCount = counts.accepted ? counts.accepted: 0;

              }
              else if ($scope.curRequest.type === 'TIME_OFF_REQUEST') {

                _.each($scope.curRequest.shifts, function(shift) {
                  shift.action = 'DROP_SHIFT';//select Drop by default
                  shift.endDateTime = toSubmitterTz(shift.endDateTime);
                  shift.startDateTime = toSubmitterTz(shift.startDateTime);
                });
              }
            }

            deferred.resolve(response.data);

          }, function(error) {
            applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
            deferred.reject(error);
          });

        return deferred.promise;
      };

      /**
       * Init function: My Requests
       */
      $scope.init = function() {

        $scope.currentAccountInfo = JSON.parse($sessionStorage.info);

        // ColumnDef Info
        // The columns with empty filed will not work for sort as of now
        $scope.columnDef = [
          {
            name: 'home.REQUESTOR_NAME',
            field: 'submitterName',
            headerCellTemplate: headerCellTemplate(),
            transPrefix: 'home'
          },
          {
            name: 'home.REQ_TYPE',
            field: 'type',
            headerCellTemplate: headerCellTemplate(),
            transPrefix: 'home'
          },
          {
            name: 'home.SUBMITTED',
            field: 'submitDate',
            headerCellTemplate: headerCellTemplate(),
            dateFormat: 'M/d/yy - hh:mm a' //
          },
          {
            name: 'home.REQ_DATE',
            field: 'reqDate',
            headerCellTemplate: headerCellTemplate(),
            dateFormat: 'M/d/yy'
          },
          {
            name: 'home.DESCRIPTION',
            field: 'description',


            headerCellTemplate: headerCellTemplate()
          },
          {
            name: 'home.EXPIRES',
            field: 'expirationDate',
            headerCellTemplate: headerCellTemplate(),
            dateFormat: 'M/d/yy'
          },
          {
            name: 'home.STATUS',
            field: 'status',
            transPrefix: 'app',
//            width: '10%',
            headerCellTemplate: headerCellTemplate()
          }
        ];

        // External Scope Module, This variable will be used when we have an action inside grid row
        $scope.gridModel = {

          // On a double click event , it will move to employee detail page to show employee detail
          onClickRow : function(row){
            row.isSelected = true;
          }

        };


        $scope.gridOptions = {

          enableColumnResizing: true,
          enableRowHeaderSelection: false,
          modifierKeysToMultiSelect: false,
          noUnselect: true,
//        enableGridMenu: true,
          minRowsToShow: numOfRows,
          columnDefs: $scope.columnDef, //
          rowTemplate: rowTemplate(), //Row Template,
          enableHorizontalScrollbar: 0,
          enableVerticalScrollbar: 0,
          enableColumnMenus: false,

//        enableFiltering: true,
          multiSelect: false,
          useExternalFiltering: true,

          enableSorting: true,
          useExternalSorting: true,

          needPagination: true,
          useExternalPagination: true,
          enablePaginationControls: false,
          paginationPageSize: numOfRows,
          paginationCurrentPage: 1,
          enableFullRowSelection: true,

          //enableSelectAll: true,
          enableRowSelection: true,
//        enableColumnMenus: true,
//        gridMenuTitleFilter: $translate, // Translate Grid Menu column name

          onRegisterApi: function( gridApi ) {
            $scope.gridApi = gridApi;

            gridApi.selection.on.rowSelectionChanged($scope, function (row) {

              if (row.isSelected) {
                console.log('selected');
                $scope.loadCurRequest(row.entity.requestId)
                  .then(function(response) {
                    $scope.reloadRequestInGrid($scope.curRequest);
                    console.log('one request in grid is updated');
                  }, function(error) {
                    applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
                    console.log(error);
                  });
              }

            });


            /**
             * Dashboard My Requests Sort Changed
             */

            $scope.gridApi.core.on.sortChanged( $scope, function( grid, sortColumns ) {

              if (sortColumns.length === 0) {
                $scope.gridOptions.queryParams.orderdir = 'asc';
                $scope.gridOptions.queryParams.orderby = 'REQ_TYPE';
              } else {
                $scope.gridOptions.queryParams.orderdir = sortColumns[0].sort.direction;

                switch (sortColumns[0].field) {
                  case "type":
                    $scope.gridOptions.queryParams.orderby = 'REQ_TYPE';
                    break;
                  case "submitDate":
                    $scope.gridOptions.queryParams.orderby = 'SUBMITTED';
                    break;
                  case "reqDate":
                    $scope.gridOptions.queryParams.orderby = 'REQ_DATE';
                    break;
                  case "expirationDate":
                    $scope.gridOptions.queryParams.orderby = 'EXPIRES';
                    break;
                  case "status":
                    $scope.gridOptions.queryParams.orderby = 'REQ_STATUS';
                    break;
                  case "description":
                    $scope.gridOptions.queryParams.orderby = 'DESCRIPTION';
                    break;
                }
              }
              getPage();

            });

            //
            // Back-end pagination

            $scope.gridApi.pagination.on.paginationChanged($scope, function (newPage, pageSize) {
              $scope.gridOptions.paginationCurrentPage = newPage;
              getPage();
            });

            var getPage = function() {
              return $scope.loadRequests($scope.gridOptions.paginationCurrentPage);
            };
          }
        };

        $scope.gridOptions.queryParams = {
          orderby:'SUBMITTED',
          orderdir:'DESC'
        };


        $scope.filter = {
          dayLength: null,
          statuses: DashboardService.getTeamRequestStatuses(),
//          reqTypes: DashboardService.getRequestTypes(),
          reqTypes: {
            wip: {
              ticked: true
            },
            swap: {
              ticked: true
            }
          },
          searchTxt: ''
        };



        $scope.filter.dayLength = $scope.days[2]; // load last 30 days

        DashboardService.getCurrentAccountInfo($scope.currentAccountType)
          .then(function(response) {
              if ($scope.currentAccountType === 'Employee') {
                  $scope.currentAccountInfo.accountId = response.data.employeeDto.id;
                  $scope.currentAccountInfo.timezone = response.data.siteTz.id;
                  $scope.currentAccountInfo.siteId = response.data.siteId;
                  $scope.currentAccountInfo.siteFirstDayOfweek = response.data.siteFirstDayOfweek;
                  $scope.currentAccountInfo.teams = response.data.teams;
                }
                else {
                  $scope.currentAccountInfo.timezone = response.data.actualTimeZone.id;
                }

              return $scope.loadRequests();
          })
          .catch(function(error) {
            if (error.message) {
              applicationContext.setNotificationMsgWithValues(error.message, '', true, '');
            }
            else {
              applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
            }
          });

      };

      /**
       * : My Requests
       */
      $scope.delayedLoadRequests = function() {
        $timeout(function() {$scope.loadRequests();}, 1000); //wait for the dropdown list update their selectedOutputs
      };

      $scope.isTomorrow = function(date){
        var tomorrow = new Date(new Date().getTime() + 24 * 60 * 60 * 1000);
        var day = tomorrow.getDate();
        var month = tomorrow.getMonth();
        var year = tomorrow.getFullYear();
        var dateT = new Date(date);

        if (day === dateT.getDate() && month === dateT.getMonth() && year === dateT.getFullYear()) {
          return true;
        }

        return false;


      };

      /**
       * Update Request Status: teamrequests
       * @param status
       */
      $scope.updateRequest = function(status) {


        var url = 'requests/peer/' +$scope.curRequest.requestId +'/ops/'+status;
        var param = {
          type: 'PEER',
          comment: $scope.curRequest.comment
        };

// $scope.curRequest.type === 'WIP_REQUEST'

        if (($scope.curRequest.type === 'SHIFT_SWAP_REQUEST'  ) && 'approve' === status) {
          param.shiftIdList = [];

          _.each($scope.curRequest.recipients, function(recipient) {
              if (true === recipient.checked) {
                param.shiftIdList.push(recipient.recipientShift.id);
              }
            });

        }
//        else if ($scope.curRequest.type === 'WIP_REQUEST') {
//          param.employeeId = $scope.curRequest.curRecipient.peerId;
//        }


        $http.post(
          baseUrl + url , param)
          .then(function (response) {
            /**
             * Reload Status
             */
            if (response.data.status === 'SUCCESS') {
              $scope.loadCurRequest($scope.curRequest.requestId)
                .then(function(response) {
                  $scope.reloadRequestInGrid($scope.curRequest);
                  console.log('one request in grid is updated');
                }, function(error) {
                  applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
                  console.log(error);
                });


            }
            console.log(response);

          }, function(error) {
            applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
            console.log(error);
          });

      };

      /**
       * return boolean whether action buttons can be shown or not.
       * team member requests
       * @param request
       */
      $scope.canShowApproveButton = function(request) {

        if (!request) {
          return false;
        }

        if (request.type=== 'WIP_REQUEST' || request.type=== 'SHIFT_SWAP_REQUEST') {

          if (request.status ==='PEER_PENDING') {
            return true;
          }
          return false;

        }


      };

      /**
       * return boolean whether action buttons can be shown or not.
       * decline button: team member requests
       * @param request
       * @returns {boolean}
       */
      $scope.canShowDeclineButton = function(request) {

        if (!request) {
          return false;
        }

        if (request.status ==='PEER_PENDING') {
          return true;
        }
        return false;

      };

//      /**
//       * Update
//       * @param recipient
//       */
//      $scope.setCurRecipient = function(recipient) {
//        $scope.curRequest.curRecipient = recipient;
//      };

      /**
       *
       * @param request: team requests
       */
      $scope.cancelRequest = function(request) {
        $scope.curRequest = null;
      };

      /**
       * Update one grid row after approve/deny the request
       */
      $scope.reloadRequestInGrid = function(request) {

        var curRow = _.findWhere($scope.gridOptions.data, {'requestId': request.requestId});

        if (!curRow) {
          applicationContext.setNotificationMsgWithValues("can't find the request in the grid", '', true, 'error');
          return;
        }

        /**
         * update the fields
         */

        curRow.submitterTeamName = request.submitterTeamName;
        curRow.submitterName = request.submitterName;
        curRow.type = $filter('translate')('home.'+request.type);
        curRow.description = request.description;
        if ('PEER_APPROVED' === request.status) {
          curRow.status = $filter('translate')('app.ACCEPTED');
        }
        else {
          curRow.status = $filter('translate')('app.'+request.status);
        }
        curRow.isRead = request.isRead;

        var submitDateColumnDef = _.findWhere($scope.columnDef, {'field': 'submitDate'});
        curRow.submitDate = $filter('date')(request.submitDate, submitDateColumnDef.dateFormat);

        var reqDateColumnDef = _.findWhere($scope.columnDef, {'field': 'reqDate'});
        curRow.reqDate = $filter('date')(request.eventDate, reqDateColumnDef.dateFormat);

        var expirationDateColumnDef = _.findWhere($scope.columnDef, {'field': 'expirationDate'});
        curRow.expirationDate = $filter('date')(request.expirationDate, expirationDateColumnDef.dateFormat);
      };



    }
  ]
);

;
var dashboard = angular.module('emlogis.dashboard');

dashboard.controller('DashboardCtrl',
  [
    '$scope',
    '$state',
    '$q',
    '$http',
    '$sessionStorage',
    'applicationContext',
    'crudDataService',
    'uiGridConstants',
    'DashboardService',
    'authService',
    function ($scope, $state, $q, $http, $sessionStorage, applicationContext, crudDataService,
              uiGridConstants, DashboardService, authService) {

      console.log('dashboard controller');

      // Entities List Url

      //$scope.entitiesListUrl = "../emlogis/rest/employees"
      var baseUrl = applicationContext.getBaseRestUrl();
      $scope.entityResource = "employees";
      $scope.filterField = "lastName";

      /* Link scope browser variable with globalproperties so that whenever there is an update
       * from entitiesListCtrl it will reflect this Controller browser variable as well.
       */
      $scope.browser = applicationContext.getBrowser();

      /*
       * Multi Select All Dropdown list
       */

      $scope.button = {
        toggle: false

      };

      $scope.filter = {
        activeEmployees: false
      };


      $scope.tabs = [
        {
          heading: 'home.MY_CALENDAR',
          selected: true,
          route: 'authenticated.dashboard.calendar'
        }, {
          heading: 'home.MANAGER_APPROVALS',
          selected: false,
          route: 'authenticated.dashboard.manager_approvals'
        }, {
          heading: 'home.TEAM_MEMBER_REQUESTS',
          selected: false,
          route: 'authenticated.dashboard.team_member_requests'
        }, {
          heading: 'home.MY_REQUESTS',
          selected: false,
          route: 'authenticated.dashboard.my_requests'
        }, {
          heading: 'home.MY_AVAILABILITY',
          selected: false,
          route: 'authenticated.dashboard.my_availability'
        }
      ];

      $scope.tabs.forEach(function (tab) {
        tab.visible = $scope.hasStatePermissionsByName(tab.route);
      });

      //$scope.selectedTab = $scope.tabs[0];

      $scope.selectSubTab = function (tab) {
        $state.go(tab.route);
      };

      $scope.active = function (route) {
        return $state.is(route);
      };

      $scope.$on("$stateChangeSuccess", function () {
        $scope.selectedTab = null;
        $scope.tabs.forEach(function (tab) {
          tab.selected = $scope.active(tab.route);
          if (tab.selected && !$scope.selectedTab) {
            $scope.selectedTab = tab;
          }
        });
      });

      /*
       *This header cell template is almost same as default cell template except
       * it has translate directive inside so grid header will support i18n as well
       */
      var headerCellTemplate = function () {
        return "<div ng-class=\"{ 'sortable': sortable }\">" +
          "<div class=\"ui-grid-vertical-bar\">&nbsp;</div>" +
          "<div class=\"ui-grid-cell-contents\" col-index=\"renderIndex\" ><span translate>{{ col.name CUSTOM_FILTERS }} </span>" +
          "<span ui-grid-visible=\"col.sort.direction\" ng-class=\"{ 'ui-grid-icon-up-dir': col.sort.direction == asc, 'ui-grid-icon-down-dir': col.sort.direction == desc, 'ui-grid-icon-blank': !col.sort.direction }\">&nbsp;</span>" +
          "</div>" +
          "<div class=\"ui-grid-column-menu-button\" ng-if=\"grid.options.enableColumnMenus && !col.isRowHeader  && col.colDef.enableColumnMenu !== false\" class=\"ui-grid-column-menu-button\" ng-click=\"toggleMenu($event)\">" +
          "<i class=\"ui-grid-icon-angle-down\">&nbsp;</i>" +
          "</div>" +
          "<div ng-if=\"filterable\" class=\"ui-grid-filter-container\" ng-repeat=\"colFilter in col.filters\">" +
          "<input type=\"text\" class=\"ui-grid-filter-input\" ng-model=\"colFilter.term\" ng-click=\"$event.stopPropagation()\" ng-attr-placeholder=\"{{colFilter.placeholder || ''}}\">" +
          "<div class=\"ui-grid-filter-button\" ng-click=\"colFilter.term = null\">" +
          "<i class=\"ui-grid-icon-cancel right\" ng-show=\"!!colFilter.term\">&nbsp;</i> <!-- use !! because angular interprets 'f' as false -->" +
          "</div>" +
          "</div>" +
          "</div>";
      };


      // ColumnDef Info
      // The columns with empty filed will not work for sort as of now
      $scope.columnDef = [
        {
          name: 'app.LAST_NAME',
          field: 'lastName',
          headerCellTemplate: headerCellTemplate()
        },
        {
          name: 'app.FIRST_NAME',
          field: 'firstName',
          headerCellTemplate: headerCellTemplate()
        },
        {
          name: 'Primary Job Role',
          field: ''
        },
        {
          name: 'Home Site',
          field: ''
        },
        {
          name: 'Home Team',
          field: ''
        },
        {
          name: 'Primary Shift',
          field: ''
        },
        {
          name: 'Hire Date',
          field: ''
        },
        {
          name: 'Work Email',
          field: ''
        },
        {
          name: 'Mobile Phone',
          field: ''
        }
      ];


      // External Scope Module, This variable will be used when we have an action inside grid row
      $scope.gridModel = {

        // On a double click event , it will move to employee detail page to show employee detail
        onDblClickRow: function (entity) {
          $state.go('authenticated.employees.detail', {id: entity.id});
        }

      };

      $scope.currentAccountInfo = JSON.parse($sessionStorage.info);
      $scope.currentAccountType = '';
      if ($scope.currentAccountInfo.roles.employeerole) {
        $scope.currentAccountType = 'Employee';
      } else {
        $scope.tabs[0].visible = false;
      }
      $scope.teamMemberRequests = [];
      $scope.teamMemberRequestsLoaded = false;

      $scope.getAccountInfo = function () {
        var deferred = $q.defer();

        DashboardService.getCurrentAccountInfo($scope.currentAccountType).then(function (response) {
          
          if ($scope.currentAccountType === 'Employee') {
              $scope.currentAccountInfo.accountId = response.data.employeeDto.id;
              $scope.currentAccountInfo.timezone = response.data.siteTz.id;
              $scope.currentAccountInfo.calendarSyncUrl = response.data.calendarSyncUrl;
              $scope.currentAccountInfo.siteId = response.data.siteId;
              $scope.currentAccountInfo.siteFirstDayOfweek = response.data.siteFirstDayOfweek;
              $scope.currentAccountInfo.teams = response.data.teams;
            }
            else {
              $scope.currentAccountInfo.timezone = response.data.actualTimeZone.id;
            }
          
          	deferred.resolve($scope.currentAccountInfo);
          	
        }, function (err) {
          deferred.reject(err);
        });

        return deferred.promise;
      };

      $scope.getAccountAvailability = function (startDate, endDate) {
        var options = {
          scheduleStatus: 'Posted',
          startDate: startDate,
          endDate: endDate
        };

        if ($scope.currentAccountType === 'Employee') {
          options.returnedFields = 'empUnavailabilities, orgHolidays';
        }

        return DashboardService.getCurrentAccountAvailability($scope.currentAccountType, options);
      };

      $scope.getAccountShifts = function (startDate, endDate) {
        var options = {
          scheduleStatus: 'Posted',
          startDate: startDate,
          endDate: endDate
        };

        if ($scope.currentAccountType === 'Employee') {
          options.returnedFields = 'id,startDateTime,endDateTime,excess,skillAbbrev,skillName,teamName';
        }

        return DashboardService.getAccountShifts($scope.currentAccountType, $scope.currentAccountInfo.accountId, options);
      };

      $scope.getAccountAvailabilityAndShifts = function (startDate, endDate) {
        var options = {
          scheduleStatus: 'Posted',
          startDate: startDate,
          endDate: endDate,
          timezone: $scope.currentAccountInfo.timezone
        };

        if ($scope.currentAccountType === 'Employee') {
          options.returnedFields = 'id,startDateTime,endDateTime,excess,skillAbbrev,skillName,teamName,comment';
        }

        return DashboardService.getAccountAvailabilityAndShifts($scope.currentAccountType, $scope.currentAccountInfo.accountId, options);
      };

      $scope.getEligibleEntities = function (tabType, shiftId) {
        return DashboardService.getEligibleEntities(tabType, $scope.currentAccountType,
          $scope.currentAccountInfo.accountId, shiftId);
      };

      $scope.processSubmittedEligibleEntities = function (tabType, originatorShift, selectedEligibleEntities) {
        return DashboardService.submitSelectedEligibleEntities(tabType, $scope.currentAccountType,
          $scope.currentAccountInfo.accountId, originatorShift, selectedEligibleEntities);
      };

      $scope.getAccountOpenShifts = function (startDate, endDate) {
        var options = {
          startDate: startDate,
          endDate: endDate
        };

        return DashboardService.getCurrentAccountOpenShifts($scope.currentAccountType, options);
      };

      $scope.processSubmittedOpenShifts = function (tickInfo, selectedOpenShifts) {
        return DashboardService.submitSelectedOpenShifts($scope.currentAccountType,
          $scope.currentAccountInfo.accountId, tickInfo, selectedOpenShifts);
      };

      $scope.processSubmittedPtoRequest = function (requestData) {
        return DashboardService.submitPtoRequest($scope.currentAccountType,
          $scope.currentAccountInfo.accountId, requestData);
      };

      $scope.teamMemberRequestsShowConf = {
        sortOptions: {
          by: 'SUBMITTED',
          order: 'DESC'
        },
        filterOptions: {
          period: 'ALL',
          status: 'ALL'
        }
      };

      $scope.teamMemberRequestsPaginationOptions = {
        totalItems: 0,
        paginationPageSize: 20,
        paginationCurrentPage: 1,
        numPages: 0
      };

      $scope.$watch('teamMemberRequestsShowConf.sortOptions.by', function (newValue, oldValue) {
        if (typeof oldValue !== 'undefined' && oldValue !== null && newValue !== oldValue) {
          $scope.getAccountTeamMemberRequests();
        }
      });

      $scope.$watch('teamMemberRequestsShowConf.sortOptions.order', function (newValue, oldValue) {
        if (typeof oldValue !== 'undefined' && oldValue !== null && newValue !== oldValue) {
          $scope.getAccountTeamMemberRequests();
        }
      });

      $scope.$watch('teamMemberRequestsShowConf.filterOptions.period', function (newValue, oldValue) {
        if (typeof oldValue !== 'undefined' && oldValue !== null && newValue !== oldValue) {
          $scope.getAccountTeamMemberRequests();
        }
      });

      $scope.$watch('teamMemberRequestsShowConf.filterOptions.status', function (newValue, oldValue) {
        if (typeof oldValue !== 'undefined' && oldValue !== null && newValue !== oldValue) {
          $scope.getAccountTeamMemberRequests();
        }
      });

      $scope.getStatusLabelOfTeamMemberRequest = function (status) {
        return DashboardService.getStatusLabelOfTeamMemberRequest(status);
      };

      $scope.getAccountTeamMemberRequests = function () {
        var statusesVal = null;
        var dateFromVal = null;
        var dateToVal = null;
        var orderByVal = null;
        var orderDirVal = null;

        if ($scope.teamMemberRequestsShowConf.filterOptions.status !== 'ALL') {
          statusesVal = DashboardService.getStatusValuesOfTeamMemberRequests($scope.teamMemberRequestsShowConf.filterOptions.status);
        }

        var currentDate = moment.tz(new Date().getTime(), $scope.currentAccountInfo.timezone);
        if ($scope.teamMemberRequestsShowConf.filterOptions.period === 'LAST_MONTH') {
          dateFromVal = currentDate.month(currentDate.month() - 1).date(1).unix() * 1000;
        } else if ($scope.teamMemberRequestsShowConf.filterOptions.period === 'LAST_WEEK') {
          dateFromVal = currentDate.day(-7).unix() * 1000;
        }

        orderByVal = $scope.teamMemberRequestsShowConf.sortOptions.by;
        orderDirVal = $scope.teamMemberRequestsShowConf.sortOptions.order;

        var payLoad = {
          types: ['SHIFT_SWAP_REQUEST', 'WIP_REQUEST'],
          statuses: statusesVal,
          dateFrom: dateFromVal,
          dateTo: dateToVal,
          fullTextSearch: null,
          limit: $scope.teamMemberRequestsPaginationOptions.paginationPageSize,
          offset: ($scope.teamMemberRequestsPaginationOptions.paginationCurrentPage - 1) * $scope.teamMemberRequestsPaginationOptions.paginationPageSize,
          orderBy: orderByVal,
          orderDir: orderDirVal
        };

        $scope.teamMemberRequestsLoaded = false;
        DashboardService.getAccountTeamMemberRequests(payLoad).then(function (response) {
          $scope.teamMemberRequestsPaginationOptions.totalItems = response.data.total;
          $scope.teamMemberRequests = [];
          angular.forEach(response.data.data, function (teamMemberRequest) {
            teamMemberRequest.isCollapsed = true;

            teamMemberRequest.submitterShift.start = teamMemberRequest.submitterShift.startDateTime;
            teamMemberRequest.submitterShift.end = teamMemberRequest.submitterShift.endDateTime;
            teamMemberRequest.submitterShift.start = moment.tz(teamMemberRequest.submitterShift.start, $scope.currentAccountInfo.timezone);
            teamMemberRequest.submitterShift.end = moment.tz(teamMemberRequest.submitterShift.end, $scope.currentAccountInfo.timezone);
            teamMemberRequest.submitterShift.date = teamMemberRequest.submitterShift.start.format('MMMM DD, YYYY');
            teamMemberRequest.submitterShift.timeDuration = teamMemberRequest.submitterShift.start.format('hh A') +
              ' - ' + teamMemberRequest.submitterShift.end.format('hh A');
            if (teamMemberRequest.type === 'SHIFT_SWAP_REQUEST' && typeof teamMemberRequest.recipientShift !== 'undefined' && teamMemberRequest.recipientShift !== null) {
              teamMemberRequest.recipientShift.start = teamMemberRequest.recipientShift.startDateTime;
              teamMemberRequest.recipientShift.end = teamMemberRequest.recipientShift.endDateTime;
              teamMemberRequest.recipientShift.start = moment.tz(teamMemberRequest.recipientShift.start, $scope.currentAccountInfo.timezone);
              teamMemberRequest.recipientShift.end = moment.tz(teamMemberRequest.recipientShift.end, $scope.currentAccountInfo.timezone);
              teamMemberRequest.recipientShift.date = teamMemberRequest.recipientShift.start.format('MMMM DD, YYYY');
              teamMemberRequest.recipientShift.timeDuration = teamMemberRequest.recipientShift.start.format('hh A') +
                ' - ' + teamMemberRequest.recipientShift.end.format('hh A');
            }
            teamMemberRequest.requestDateFormatted = moment.tz(teamMemberRequest.submitDate, $scope.currentAccountInfo.timezone).format('MM/DD/YYYY');
            $scope.teamMemberRequests.push(teamMemberRequest);
          });
        }, function (err) {
          var message = err.data.message || JSON.stringify(err.data);
          applicationContext.setNotificationMsgWithValues(message, 'danger', true);
        }).finally(function () {
          $scope.teamMemberRequestsLoaded = true;
        });
      };

      //$scope.$watch('selectedTab', function () {
      //  if ($scope.selectedTab === $scope.tabs[2]) {
      //    $scope.getAccountTeamMemberRequests();
      //  }
      //});

      $scope.respondToAccountTeamMemberRequest = function (teamMemberRequest, acceptance) {
        DashboardService.respondToAccountTeamMemberRequest(teamMemberRequest, acceptance).then(function (response) {
          applicationContext.setNotificationMsgWithValues('home.REQUEST_SUBMITTED_SUCCESSFULLY', 'success', true);
          if (acceptance) {
            teamMemberRequest.status = response.data.data.status;
          } else {
            $scope.getAccountTeamMemberRequests();
          }
        }, function (err) {
          var message = err.data.message || JSON.stringify(err.data);
          applicationContext.setNotificationMsgWithValues(message, 'danger', true);
        });
      };

      $scope.hasPermission = function (perm) {
        return authService.hasPermission(perm);
      };

      $scope.hasPermissionIn = function (perms) {
        return authService.hasPermissionIn(perms);
      };

      $scope.badgeMsg = applicationContext.getBadgeMsg();


      // Save Filter Info as GlobalPropertiesV1brant15!
      var entityFilter = applicationContext.getEntityFilter();
      entityFilter.url = $scope.entitiesListUrl;
      entityFilter.field = $scope.filterField;
      applicationContext.setEntityFilter(entityFilter);
    }
  ]
);

;
angular.module('emlogis.dashboard')
  .service('DashboardService', ['$http', '$q', '$interval', 'applicationContext',
    'UtilsService', 'authService',
    function ($http, $q, $interval, applicationContext, UtilsService, authService) {
      var baseUrl = applicationContext.getBaseRestUrl();
      var statusValuesOfTeamMemberRequests = {
        PENDING: ['PEER_PENDING'],
        ACCEPTED: ['PEER_APPROVED'],
        APPROVED: ['APPROVED'],
        OTHERS: ['PEER_DECLINED', 'DECLINED', 'WITDRAWN', 'DELETED', 'EXPIRED']
      };
      var statusLabelsOfTeamMemberRequests = {
        PEER_PENDING: 'PENDING',
        PEER_APPROVED: 'ACCEPTED',
        PEER_DECLINED: 'DENIED',
        APPROVED: 'APPROVED',
        DECLINED: 'DECLINED',
        WITHDRAWN: 'WITHDRAWN',
        DELETED: 'DELETED',
        EXPIRED: 'EXPIRED'
      };

      function sendRequest(urlPart, method, requestPayload) {
        var apiUrl = baseUrl + urlPart;
        var req = {
          method: method,
          url: apiUrl
        };
        if (method === 'POST' || method === 'PUT') {
          req.data = requestPayload;
        }

        return $http(req);
      }

      this.getCurrentAccountInfo = function(accountType) {
        var urlPart = '';
        if (accountType === 'Employee') {
          urlPart = 'employees/info';
        }
        else {
          urlPart = 'useraccounts/info';
        }

        return sendRequest(urlPart, 'GET', null);
      };

      this.getCurrentAccountAvailability = function(accountType, options) {
        var urlPart = '';
        if (accountType === 'Employee') {
          urlPart = 'useraccounts/employeeavailability?schedulestatus=' +
            options.scheduleStatus + '&startdate=' + options.startDate +
            '&enddate=' + options.endDate + '&returnedfields=' + options.returnedFields;
        }

        return sendRequest(urlPart, 'GET', null);
      };

      this.getAccountShifts = function(accountType, accountId, options) {
        var urlPart = '';
        if (accountType === 'Employee') {
          urlPart = 'employees/' + accountId + '/shifts?schedulestatus=' +
            options.scheduleStatus + '&startdate=' + options.startDate +
            '&enddate=' + options.endDate + '&returnedfields=' + options.returnedFields;
        }

        return sendRequest(urlPart, 'GET', null);
      };

      this.getAccountAvailabilityAndShifts = function(accountType, accountId, options) {
        var urlPart = '';
        if (accountType === 'Employee') {
          urlPart = 'employees/' + accountId + '/calendarview?schedulestatus=' +
            options.scheduleStatus + '&startdate=' + options.startDate +
            '&enddate=' + options.endDate + '&timezone=' + options.timezone + '&returnedfields=' + options.returnedFields +
            '&requestinfo=true';
        }

        return sendRequest(urlPart, 'GET', null);
      };

      this.getEligibleEntities = function(tabType, accountType, accountId, shiftId) {
        var urlPart = '';
        if (accountType === 'Employee') {
          if (tabType === 'swap') {
            urlPart = 'employees/' + accountId + '/ops/getswapeligibleshifts';
          } else if (tabType === 'wip') {
            urlPart = 'employees/' + accountId + '/ops/getwipeligibleemployees';
          }
        }

        var payLoad = {
          shiftId: shiftId
        };

        return sendRequest(urlPart, 'POST', payLoad);
      };

      this.submitSelectedEligibleEntities = function(tabType, accountType, accountId, originatorShift, selectedEligibleEntities) {
        var type = (tabType === 'swap')? 'SHIFT_SWAP_REQUEST': 'WIP_REQUEST';
        var dayInMilliseconds = 24 * 3600000;
        var recipients = [];
        var payLoad = {
          type: type,
          submitterId: accountId,
          expiration: originatorShift.start.unix() * 1000 - dayInMilliseconds,
          submitterShiftId: originatorShift.id,
          comment: ''
        };

        if (accountType === 'Employee') {
          if (tabType === 'swap') {
            angular.forEach(selectedEligibleEntities, function(entityIterator) {
              recipients.push(
                {
                  shiftId: entityIterator.id,
                  employeeId: entityIterator.teamMemberId
                });
            });
            payLoad.assignments = recipients;
          } else {
            angular.forEach(selectedEligibleEntities, function(entityIterator) {
              recipients.push(entityIterator.id);
            });
            payLoad.recipientIds = recipients;
          }
        }

        var urlPart = 'requests/submitter';

        return sendRequest(urlPart, 'POST', payLoad);
      };

      this.getCurrentAccountOpenShifts = function(accountType, options) {
        var urlPart = '';
        if (accountType === 'Employee') {
          urlPart = 'useraccounts/employeepostedopenshifts?startdate=' + options.startDate +
            '&enddate=' + options.endDate;
        }

        return sendRequest(urlPart, 'GET', null);
      };

      this.submitSelectedOpenShifts = function(accountType, accountId, tickInfo, selectedOpenShifts) {
        var type = 'OPEN_SHIFT_REQUEST';
        var dayInMilliseconds = 24 * 3600000;
        var urlPart = 'requests/submitter';
        var payLoad = {
          type: type,
          submitterId: accountId,
          expiration: tickInfo.end + 7 * dayInMilliseconds,
          comment: '',
          openShifts: []
        };

        angular.forEach(selectedOpenShifts, function(entityIterator) {
          var identifier = 'shiftId-' + entityIterator.shiftId;
          payLoad.openShifts.push({shiftId: entityIterator.shiftId, identifier: identifier});
        });

        return sendRequest(urlPart, 'POST', payLoad);
      };

      this.getAbsenceTypes = function(siteId) {
        var urlPart = 'sites/' + siteId + '/absencetypes?filter=isActive=1';

        return sendRequest(urlPart, 'GET', null);
      };

      this.submitPtoRequest = function(accountType, accountId, requestData) {
        var urlPart = 'requests/submitter';
        var dayInMilliseconds = 24 * 3600000;
        var payLoad = {
          type: 'TIME_OFF_REQUEST',
          submitterId: accountId,
          expiration: requestData.timeOffStartDate,
          comment: requestData.note,
          requests: []
        };

        for (var i=0; i<requestData.lengthInDays; i++) {
          var identifier = 'date-' + (requestData.timeOffStartDate + dayInMilliseconds * i);
          payLoad.requests.push({
            identifier: identifier,
            date: requestData.timeOffStartDate + dayInMilliseconds * i,
            absenceTypeId: requestData.timeOffType.id,
            reason: ''
          });
        }

        return sendRequest(urlPart, 'POST', payLoad);
      };


      this.getAccountTeamMemberRequests = function(payLoad) {
        var urlPart = 'requests/peer/ops/queryold';
        return sendRequest(urlPart, 'POST', payLoad);
      };

      this.respondToAccountTeamMemberRequest = function(teamMemberRequest, acceptance) {
        var urlPart = 'requests/peer/' + teamMemberRequest.requestId + '/ops/';

        if (acceptance) {
          urlPart += 'approve';
        } else {
          urlPart += 'decline';
        }

        var payLoad = {
          comment: (acceptance)? "Approved": "Declined"
        };

        if (teamMemberRequest.type === 'SHIFT_SWAP_REQUEST' && acceptance) {
          payLoad.shiftIdList = [];
//          payLoad.shiftId = teamMemberRequest.recipientShift.id;
          payLoad.shiftIdList.push(teamMemberRequest.recipientShift.id);
        }

        return sendRequest(urlPart, 'POST', payLoad);
      };

      this.getStatusValuesOfTeamMemberRequests = function(statusLabel) {
        return statusValuesOfTeamMemberRequests[statusLabel];
      };

      this.getStatusLabelOfTeamMemberRequest = function(status) {
        return statusLabelsOfTeamMemberRequests[status];
      };

      this.getRequestStatuses = function() {

//        PEER_PENDING, ADMIN_PENDING, APPROVED,DECLINED, WITHDRAWN,EXPIRED,DELETED

        return [
          {id:'ADMIN_PENDING',name:'Admin Pending',ticked:true},
          {id:'APPROVED',name:'Approved',ticked:true},
          {id:'DECLINED',name:'Declined',ticked:true},
          {id:'DELETED',name:'Deleted',ticked:true},
          {id:'EXPIRED',name:'Expired',ticked:true},
          {id:'PEER_PENDING',name:'Peer Pending',ticked:true},
          {id:'WITHDRAWN',name:'Withdrawn',ticked:true}
        ];

      };

      this.getRequestTypes = function() {

        return [
          {id:'AVAILABILITY_REQUEST',name:'Availability',ticked: false},
          {id:'OPEN_SHIFT_REQUEST',name:'Open Shift',ticked: false},
          {id:'SHIFT_SWAP_REQUEST',name:'Shift Swap',ticked: true},
          {id:'TIME_OFF_REQUEST', name:'Time Off',ticked: true},
          {id:'WIP_REQUEST',name:'Work in Place',ticked: true}
        ];
      };

      /**
       * Only for team member requests with label change of peer_pending -> pendng
       *
       */
      this.getTeamRequestStatuses = function() {

//        PEER_PENDING, ADMIN_PENDING, APPROVED,DECLINED, WITHDRAWN,EXPIRED,DELETED

        return [
          {id:'PEER_APPROVED',name:'Admin Pending',ticked:true},
          {id:'APPROVED',name:'Approved',ticked:true},
          {id:'DECLINED',name:'Declined',ticked:true},
          {id:'DELETED',name:'Deleted',ticked:true},
          {id:'EXPIRED',name:'Expired',ticked:true},
          {id:'PEER_PENDING',name:'Pending',ticked:true},
          {id:'WITHDRAWN',name:'Withdrawn',ticked:true}
        ];

      };

      this.isPendingRecipientAndNotApprovedRequest = function(recipientStatus, requestStatus) {
        return (recipientStatus != 'PEER_APPROVED' && recipientStatus != 'APPROVED')
            || (requestStatus != 'ADMIN_PENDING' && requestStatus != 'PEER_PENDING' && requestStatus != 'APPROVED');
      };

    }
  ]);
;
angular.module('emlogis.employeeSchedules', ['ui.bootstrap', 'ui.router', 'emlogis.commonservices', 'emlogis.commonDirectives', 'emlogis.commonControllers'])
  .config(['$stateProvider', '$urlRouterProvider',
    function ($stateProvider, $urlRouterProvider) {

      $urlRouterProvider.when('/employee-schedules', '/employee-schedules/week-view');
      $urlRouterProvider.when('/employee-schedules/', '/employee-schedules/week-view');

      $stateProvider.state('authenticated.employeeSchedules', {
        url: '/employee-schedules',
        abstract: true,
        views: {
          'content@authenticated': {
            templateUrl: 'modules/employee-schedules/partials/employee-schedules.html',
            controller: 'EmployeeSchedulesCtrl'
          },
          'breadcrumb@authenticated': {
            templateUrl: 'modules/employee-schedules/partials/employee-schedules-breadcrumb.html',
            controller: 'EmployeeSchedulesBreadcrumbCtrl'
          }
        },
        data: {
          ncyBreadcrumbLabel: '{{"nav.EMPLOYEE_SCHEDULES" | translate}}',
          permissions: function (authService) {
            return authService.isTenantType('Customer') &&
              authService.hasPermissionIn(['Demand_View', 'Demand_Mgmt', 'Shift_Mgmt']);
          }
        }
      })
        .state('authenticated.employeeSchedules.weekView', {
          url: '/week-view',
          views: {
            'employeeSchedulesContent@authenticated.employeeSchedules': {
              templateUrl: 'modules/employee-schedules/partials/employee-schedules-week-view.html',
              controller: 'EmployeeSchedulesWeekViewCtrl'
            },
            'employeeSchedulesBreadcrumb@authenticated.employeeSchedules': {
              templateUrl: 'modules/employee-schedules/partials/employee-schedules-week-view-breadcrumb.html',
              controller: 'EmployeeSchedulesWeekViewBreadcrumbCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"nav.employee_schedules.WEEK_VIEW" | translate}}'
          }
        })
        .state('authenticated.employeeSchedules.weekView.schedule', {
          url: '/:scheduleId',
          views: {
            'employeeSchedulesWeekViewContent@authenticated.employeeSchedules.weekView': {
              templateUrl: 'modules/employee-schedules/partials/employee-schedules-week-view-schedule.html',
              controller: 'EmployeeSchedulesWeekViewScheduleCtrl'
            },
            'employeeSchedulesWeekViewBreadcrumb@authenticated.employeeSchedules.weekView': {
              templateUrl: 'modules/employee-schedules/partials/employee-schedules-week-view-schedule-breadcrumb.html',
              controller: 'EmployeeSchedulesWeekViewScheduleBreadcrumbCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"nav.employee_schedules.SCHEDULE" | translate}}'
          }
        })
        .state('authenticated.employeeSchedules.dayView', {
          url: '/day-view',
          views: {
            'employeeSchedulesContent@authenticated.employeeSchedules': {
              templateUrl: 'modules/employee-schedules/partials/employee-schedules-day-view.html',
              controller: 'EmployeeSchedulesDayViewCtrl'
            },
            'employeeSchedulesBreadcrumb@authenticated.employeeSchedules': {
              templateUrl: 'modules/employee-schedules/partials/employee-schedules-day-view-breadcrumb.html',
              controller: 'EmployeeSchedulesDayViewBreadcrumbCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"nav.employee_schedules.DAY_VIEW" | translate}}'
          }
        })
        .state('authenticated.employeeSchedules.dayView.schedule', {
          url: '/:scheduleId/:dateTimeStamp',
          views: {
            'employeeSchedulesDayViewContent@authenticated.employeeSchedules.dayView': {
              templateUrl: 'modules/employee-schedules/partials/employee-schedules-day-view-schedule.html',
              controller: 'EmployeeSchedulesDayViewScheduleCtrl'
            },
            'employeeSchedulesDayViewBreadcrumb@authenticated.employeeSchedules.dayView': {
              templateUrl: 'modules/employee-schedules/partials/employee-schedules-day-view-schedule-breadcrumb.html',
              controller: 'EmployeeSchedulesDayViewScheduleBreadcrumbCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"nav.employee_schedules.SCHEDULE" | translate}}'
          }
        });
    }
  ])
  .run([function() {

  }]);

;
angular.module('emlogis.employeeSchedules').controller('EmployeeSchedulesBreadcrumbCtrl', ['$scope', '$state', '$translate', 'authService', 'applicationContext',
  function($scope, $state, $translate, authService, applicationContext) {

    var module = applicationContext.getModule();

    $translate('nav.EMPLOYEE_SCHEDULES')
      .then(function (translation) {
        module.name = translation;
      });
    module.href = '/employee-schedules';
    module.disableModuleBreadcrumb = false;
    applicationContext.setModule(module);

    $scope.hasMgmtPermission = function () {
      return authService.hasPermission('Tenant_Mgmt');
    };

    $scope.hasViewPermission = function () {
      return authService.hasPermission('Tenant_View');
    };
  }
]);

;
angular.module('emlogis.employeeSchedules').controller('EmployeeSchedulesDayViewBreadcrumbCtrl', ['$scope', '$state', '$translate', 'authService', 'applicationContext',
  function($scope, $state, $translate, authService, applicationContext) {

  }
]);

;
angular.module('emlogis.employeeSchedules').controller('EmployeeSchedulesDayViewScheduleBreadcrumbCtrl', ['$scope',
  function($scope) {

  }
]);

;
angular.module('emlogis.employeeSchedules')
  .controller('EmployeeSchedulesDayViewScheduleCtrl',
  ['$scope', '$state', '$stateParams',
    function($scope, $state, $stateParams) {
      $scope.getSchedule($stateParams.scheduleId, $stateParams.dateTimeStamp, false);
    }]);
;
angular.module('emlogis.employeeSchedules')
  .controller('EmployeeSchedulesDayViewCtrl',
  ['$scope', '$timeout',
    function($scope, $timeout) {
      $scope.setViewMode('day');
      $timeout(function() {
        if ($scope.selectedSchedule === null && $scope.scheduleInfoLoaded === null) {
          $scope.openSiteSchedulesModal();
        }
      }, 500);
    }]);
;
angular.module('emlogis.employeeSchedules').controller('EmployeeSchedulesWeekViewBreadcrumbCtrl', ['$scope', '$state', '$translate', 'authService', 'applicationContext',
  function($scope, $state, $translate, authService, applicationContext) {

  }
]);

;
angular.module('emlogis.employeeSchedules').controller('EmployeeSchedulesWeekViewScheduleBreadcrumbCtrl', ['$scope',
  function($scope) {

  }
]);

;
angular.module('emlogis.employeeSchedules')
  .controller('EmployeeSchedulesWeekViewScheduleCtrl',
  ['$scope', '$state', '$stateParams',
    function($scope, $state, $stateParams) {
      $scope.getSchedule($stateParams.scheduleId, null, false);
    }]);
;
angular.module('emlogis.employeeSchedules')
  .controller('EmployeeSchedulesWeekViewCtrl',
  ['$scope', '$timeout',
    function($scope, $timeout) {
      $scope.setViewMode('week');
      $timeout(function() {
        if ($scope.selectedSchedule === null && $scope.scheduleInfoLoaded === null) {
          $scope.openSiteSchedulesModal();
        }
      }, 500);
    }]);
;
angular.module('emlogis.employeeSchedules')
  .controller('EmployeeSchedulesCtrl',
  ['$scope', '$state', '$stateParams', '$modal', '$sessionStorage', '$timeout', 'applicationContext', 'authService',
    'appFunc', 'dataService', 'EmployeeSchedulesService', 'sseService', 'wsService',
  function($scope, $state, $stateParams, $modal, $sessionStorage, $timeout, applicationContext, authService,
           appFunc, dataService, EmployeeSchedulesService, sseService, wsService) {

    var siteTimeZone = null;
    $scope.consts = {
      daysOfWeek: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
      calendarTimeLabels: [
        {label: '12A', value: '00'},  {label: '1A', value: '01'},   {label: '2A', value: '02'},
        {label: '3A', value: '03'},   {label: '4A', value: '04'},   {label: '5A', value: '05'},
        {label: '6A', value: '06'},   {label: '7A', value: '07'},   {label: '8A', value: '08'},
        {label: '9A', value: '09'},   {label: '10A', value: '10'},  {label: '11A', value: '11'},
        {label: '12P', value: '12'},  {label: '1P', value: '13'},   {label: '2P', value: '14'},
        {label: '3P', value: '15'},   {label: '4P', value: '16'},   {label: '5P', value: '17'},
        {label: '6P', value: '18'},   {label: '7P', value: '19'},   {label: '8P', value: '20'},
        {label: '9P', value: '21'},   {label: '10P', value: '22'},  {label: '11P', value: '23'}
      ],
        scheduleStatus: {
            POSTED: "Posted",
            SIMULATION: "Simulation",
            PRODUCTION: "Production"
        }
    };

    $scope.sort = {
      field: 'employeeName',
      order: 'asc'
    };
    $scope.filter = {
      homeTeams: [],
      assignedTeams: [],
      primarySkills: [],
      assignedSkills: [],
      selectedHomeTeams: [],
      selectedAssignedTeams: [],
      selectedPrimarySkills: [],
      selectedAssignedSkills: [],
      startTime: '0;1440',
      employeeName: '',
      sliderOptions: {
        from: 0,
        to: 1440,
        step: 30,
        dimension: '',
        scale: ['0', '|', '|', '|', '|', '|', '3', '|', '|', '|', '|', '|', '6',
          '|', '|', '|', '|', '|', '9', '|', '|', '|', '|', '|', '12',
          '|', '|', '|', '|', '|', '15', '|', '|', '|', '|', '|', '18',
          '|', '|', '|', '|', '|', '21', '|', '|', '|', '|', '|', '24'],
        calculate: function(value) {
          var hours = Math.floor( value / 60 );
          var mins = ( value - hours*60 );
          return (hours < 10 ? "0"+hours : hours) + ":" + ( mins === 0 ? "00" : mins );
        },
        css: {
          pointer: { 'background-color': '#0e9ac9' },
          background: { 'background-color': '#899498' },
          range: { 'background-color': '#0e9ac9' }
        }
      },
      displayFloats: false,
      displayScheduledOnly: false
    };
    $scope.checkboxModel = {
      showHourlyRate: false
    };

    $scope.viewMode = {
      mode: null
    };

    $scope.feedWeekForScheduleWeekView = null;
    $scope.selectedSchedule = null;
    $scope.scheduleInfoLoaded = null;
    $scope.summaryCollapsed = false;
    $scope.timeIntervalInMinutes = [{value: 0, width: '25%'}, {value: 15, width: '25%'}, {value: 30, width: '25%'}, {value: 45, width: '25%'}];

    $scope.onFilterChanged = function(needShiftsFilter) {
      $timeout(function() {
        angular.forEach($scope.selectedSchedule.employeesInfo.result, function(employee) {
          if (employee.name.toLowerCase().indexOf($scope.filter.employeeName.toLowerCase()) < 0) {
            employee.visible = false;
            return;
          }
          if (_.findIndex($scope.filter.homeTeams, 'id', employee.homeTeamId) > -1 &&
            _.findIndex($scope.filter.selectedHomeTeams, 'id', employee.homeTeamId) === -1) {
            employee.visible = false;
            return;
          }
          if (_.findIndex($scope.filter.primarySkills, 'id', employee.primarySkillId) > -1 &&
            _.findIndex($scope.filter.selectedPrimarySkills, 'id', employee.primarySkillId) === -1) {
            employee.visible = false;
            return;
          }
          employee.visible = true;
        });

        if (needShiftsFilter) {
          $scope.applyFilterToShifts();
        }
        $scope.calculateSummaryInfoForSelectedWeekOrDay();

        if ($scope.viewMode.mode === 'day') {
          $scope.populateDayHeadCounts();
        }
      }, 0);
    };

    $scope.onFilterHomeTeamsChanged = function() {
      $scope.onFilterChanged(false);
    };

    $scope.onFilterAssignedTeamsChanged = function() {
      $scope.onFilterChanged(true);
    };

    $scope.onFilterPrimarySkillsChanged = function() {
      $scope.onFilterChanged(false);
    };

    $scope.onFilterAssignedSkillsChanged = function() {
      $scope.onFilterChanged(true);
    };

    $scope.onEmployeeNameChanged = function() {
      $scope.onFilterChanged(false);
    };

    $scope.$watch('filter.startTime', function() {
      if (typeof $scope.selectedSchedule !== 'undefined' && $scope.selectedSchedule !== null) {
        $scope.onFilterChanged(true);
      }
    });

    $scope.setViewMode = function(viewMode) {
      $scope.viewMode.mode = viewMode;
    };

    $scope.populateDayHeadCounts = function() {
      var getAppropriateShiftsCountOfEmployeeForMoment = function(employee, comparedDateTimeStamp) {
        if (typeof $scope.selectedSchedule.day.shifts.employeeShifts[employee.id] === 'undefined') {
          return 0;
        }

        var foundIndex = _.findIndex($scope.selectedSchedule.day.shifts.employeeShifts[employee.id], function(shiftIterator) {
          return (!shiftIterator.external && shiftIterator.filterPassed && shiftIterator.start <= comparedDateTimeStamp && shiftIterator.end >= comparedDateTimeStamp);
        });
        if (foundIndex > -1) {
          return 1;
        }
        return 0;
      };

      var getAppropriateShiftsCountForMoment = function(dateTimeStamp) {
        var count = 0;
        angular.forEach($scope.selectedSchedule.employeesInfo.result, function(employee) {
          if (!employee.visible) {
            return;
          }
          var countRes = getAppropriateShiftsCountOfEmployeeForMoment(employee, dateTimeStamp);
          count += countRes;
        });

        return count;
      };

      angular.forEach($scope.consts.calendarTimeLabels, function(timeLabel) {
        $scope.selectedSchedule.day.headCounts[timeLabel.label] = [];
        for (var i=0; i<4; i++) {
          var minutes;
          if (i === 0) {
            minutes = '00';
          } else {
            minutes = (15 * i).toString();
          }
          var momentTimeStr = timeLabel.value + ':' + minutes;
          var fullMomentStr = $scope.selectedSchedule.day.dateText + ' ' + momentTimeStr;
          var dateTimeStamp = moment.tz(fullMomentStr, siteTimeZone).unix() * 1000;
          var count = getAppropriateShiftsCountForMoment(dateTimeStamp);
          $scope.selectedSchedule.day.headCounts[timeLabel.label].push(count);
        }
      });
    };

    $scope.getSchedule = function(scheduleId, dateTimeStamp) {
      $scope.scheduleInfoLoaded = false;
      $scope.selectedSchedule = null;
      if ($scope.viewMode.mode === 'week') {
        EmployeeSchedulesService.getScheduleForWeekView(scheduleId).then(function(response) {
          $scope.initializeSchedule(response.data);
        }, function(err) {
          applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
        }).finally(function() {
          $scope.scheduleInfoLoaded = true;
        });
      } else if ($scope.viewMode.mode === 'day') {
        EmployeeSchedulesService.getScheduleForDayView(scheduleId, dateTimeStamp, false).then(function(response) {
          $scope.initializeSchedule(response.data);
        }, function(err) {
          applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
        }).finally(function() {
          $scope.scheduleInfoLoaded = true;
        });
      }
    };

    $scope.showExceptions = function() {
      $modal.open({
        templateUrl: 'exceptionsModal.html',
        controller: 'ExceptionsModalInstanceCtrl',
        windowClass: 'exceptions-modal',
        resolve: {
          scheduleId: function() {
            return $scope.selectedSchedule.id;
          }
        }
      });
    };

    var reLoadSchedule = function() {
      if ($scope.viewMode.mode === 'week') {
        $scope.getSchedule($scope.selectedSchedule.id, null);
      } else if ($scope.viewMode.mode === 'day') {
        $scope.getSchedule($scope.selectedSchedule.id, $scope.selectedSchedule.day.datetimeStamp);
      }
    };

    $scope.goToWeekViewFromSelectedDay = function() {
      $scope.feedWeekForScheduleWeekView = {
        start: $scope.selectedSchedule.selectedWeek.start,
        end: $scope.selectedSchedule.selectedWeek.end
      };
      $state.go('authenticated.employeeSchedules.weekView.schedule', {scheduleId: $scope.selectedSchedule.id});
    };

    $scope.goToDayViewFromSelectedWeek = function(dayLabel) {
      var dateTimeStamp = moment.tz(dayLabel.date, siteTimeZone).unix() * 1000;
      $state.go('authenticated.employeeSchedules.dayView.schedule', {scheduleId: $scope.selectedSchedule.id, dateTimeStamp: dateTimeStamp});
    };

    $scope.goToPreviousDay = function() {
      var currentDateTimeMoment = moment.tz($scope.selectedSchedule.day.datetimeStamp, siteTimeZone);
      var previousDayMoment = currentDateTimeMoment.clone().subtract(1, 'days');
      $state.go('authenticated.employeeSchedules.dayView.schedule', {scheduleId: $scope.selectedSchedule.id, dateTimeStamp: previousDayMoment.unix() * 1000});
    };

    $scope.goToNextDay = function() {
      var currentDateTimeMoment = moment.tz($scope.selectedSchedule.day.datetimeStamp, siteTimeZone);
      var nextDayMoment = currentDateTimeMoment.clone().add(1, 'days');
      $state.go('authenticated.employeeSchedules.dayView.schedule', {scheduleId: $scope.selectedSchedule.id, dateTimeStamp: nextDayMoment.unix() * 1000});
    };

    $scope.selectWeek = function(week) {
      angular.forEach($scope.selectedSchedule.weeks, function(weekIterator) {
        weekIterator.selected = false;
      });

      week.selected = true;
      $scope.selectedSchedule.selectedWeek = week;
    };

    function employeeComparator(firstElement, secondElement) {
      var firstValue = null;
      var secondValue = null;

      if ($scope.sort.field === 'employeeName') {
        firstValue = firstElement.name;
        secondValue = secondElement.name;
      } else if ($scope.sort.field === 'serviceYears') {
        firstValue = firstElement.seniority;
        secondValue = secondElement.seniority;
      } else if ($scope.sort.field === 'rate') {
        firstValue = firstElement.hourlyRate;
        secondValue = secondElement.hourlyRate;
      } else if ($scope.sort.field === 'total') {
        firstValue = firstElement.total;
        secondValue = secondElement.total;
      } else if ($scope.sort.field === 'due') {
        firstValue = firstElement.due;
        secondValue = secondElement.due;
      } else if ($scope.sort.field === 'homeTeam') {
        firstValue = $scope.getHomeTeamName(firstElement.homeTeamId);
        if (typeof firstValue === 'undefined') {
          firstValue = firstElement.homeTeamId;
        }
        secondValue = $scope.getHomeTeamName(secondElement.homeTeamId);
        if (typeof secondValue === 'undefined') {
          secondValue = secondElement.homeTeamId;
        }
      } else if ($scope.sort.field === 'primarySkill') {
        firstValue = $scope.getPrimarySkillName(firstElement.primarySkillId);
        if (typeof firstValue === 'undefined') {
          firstValue = firstElement.primarySkillId;
        }
        secondValue = $scope.getPrimarySkillName(secondElement.primarySkillId);
        if (typeof secondValue === 'undefined') {
          secondValue = secondElement.primarySkillId;
        }
      }

      if (firstValue < secondValue) {
        if ($scope.sort.order === 'asc') {
          return -1;
        } else {
          return 1;
        }
      } else if (firstValue > secondValue) {
        if ($scope.sort.order === 'asc') {
          return 1;
        } else {
          return -1;
        }
      } else {
        return 0;
      }
    }

    $scope.toggleSort = function(field, order) {
      if (typeof order === 'undefined' || order === null) {
        if ($scope.sort.field === field) {
          if ($scope.sort.order === 'asc') {
            $scope.sort.order = 'dec';
          } else if ($scope.sort.order === 'dec') {
            $scope.sort.order = 'asc';
          } else {
            $scope.sort.order = 'asc';
          }
        } else {
          $scope.sort.field = field;
          $scope.sort.order = 'asc';
        }
      } else {
        $scope.sort.field = field;
        $scope.sort.order = order;
      }

      $scope.selectedSchedule.employeesInfo.result.sort(employeeComparator);
    };

    $scope.getHomeTeamName = function(teamId) {
      var foundTeam = _.find($scope.filter.homeTeams, 'id', teamId);

      if (typeof foundTeam === 'undefined') {
        return '-';
      }

      return foundTeam.name;
    };

    $scope.getAssignedTeamName = function(teamId) {
      var foundTeam = _.find($scope.filter.assignedTeams, 'id', teamId);

      if (typeof foundTeam === 'undefined') {
        return '-';
      }

      return foundTeam.name;
    };

    $scope.getPrimarySkillName = function(skillId) {
      var foundSkill = _.find($scope.filter.primarySkills, 'id', skillId);

      if (typeof foundSkill === 'undefined') {
        return '-';
      }

      return foundSkill.name;
    };

    $scope.getAssignedSkillName = function(skillId) {
      var foundSkill = _.find($scope.filter.assignedSkills, 'id', skillId);

      if (typeof foundSkill === 'undefined') {
        return '-';
      }

      return foundSkill.name;
    };

    $scope.getEmployeeTeamNamesList = function(employee) {
      var listStr = '';
      angular.forEach(employee.teamIds.split(','), function(teamId) {
        if (teamId === employee.homeTeamId) {
          listStr += $scope.getHomeTeamName(teamId) + ', ';
        } else {
          listStr += $scope.getAssignedTeamName(teamId) + ', ';
        }
      });
      listStr = listStr.substr(0, listStr.length - 2);

      return listStr;
    };

    $scope.getEmployeeSkillNamesList = function(employee) {
      var listStr = '';
      var skillIds = employee.skillIds ? employee.skillIds.split(',') : [];
      angular.forEach(skillIds, function(skillId) {
        if (skillId === employee.primarySkillId) {
          listStr += $scope.getPrimarySkillName(skillId) + ', ';
        } else {
          listStr += $scope.getAssignedSkillName(skillId) + ', ';
        }
      });
      listStr = listStr.substr(0, listStr.length - 2);

      return listStr;
    };

    $scope.applyFilterToShift = function(shift) {
      if (shift.external) {
        shift.filterPassed = true;
        return;
      }

      var filterTimeFrom = parseInt($scope.filter.startTime.substring(0, $scope.filter.startTime.indexOf(';')));
      var filterTimeTo = parseInt($scope.filter.startTime.substring($scope.filter.startTime.indexOf(';') + 1));
      var shiftStartDateTime = moment.tz(shift.start, siteTimeZone);
      var shiftStartTimeInMinutes = parseInt(shiftStartDateTime.format('H')) * 60 + parseInt(shiftStartDateTime.format('m'));

      if (_.findIndex($scope.filter.assignedTeams, 'id', shift.teamId) > -1 &&
        _.findIndex($scope.filter.selectedAssignedTeams, 'id', shift.teamId) === -1) {
        shift.filterPassed = false;
        return;
      }
      if (_.findIndex($scope.filter.assignedSkills, 'id', shift.skillId) > -1 &&
        _.findIndex($scope.filter.selectedAssignedSkills, 'id', shift.skillId) === -1) {
        shift.filterPassed = false;
        return;
      }

      if (shiftStartTimeInMinutes < filterTimeFrom || shiftStartTimeInMinutes > filterTimeTo) {
        shift.filterPassed = false;
        return;
      }
      shift.filterPassed = true;
    };

    $scope.applyFilterToShifts = function() {
      var maxShiftsCountPerDay = 0;
      var heightVal = 0;

      angular.forEach($scope.selectedSchedule.employeesInfo.result, function(employee) {
        if ($scope.viewMode.mode === 'week') {
          maxShiftsCountPerDay = 0;
          angular.forEach($scope.selectedSchedule.selectedWeek.shifts.employeeShifts[employee.id], function(dateShifts, calendarDate) {
            angular.forEach(dateShifts, function(shift) {
              if (!shift.external) {
                $scope.applyFilterToShift(shift);
              }
            });
            if (maxShiftsCountPerDay < dateShifts.length) {
              maxShiftsCountPerDay = dateShifts.length;
            }
          });
          heightVal = 54 * Math.max(maxShiftsCountPerDay, 1);
          $scope.selectedSchedule.rowHeightsOfEmployees[employee.id] = heightVal + 'px';
        } else if ($scope.viewMode.mode === 'day') {
          angular.forEach($scope.selectedSchedule.day.shifts.employeeShifts[employee.id], function(shift) {
            if (!shift.external) {
              $scope.applyFilterToShift(shift);
            }
          });
        }
      });

      if ($scope.viewMode.mode === 'week') {
        maxShiftsCountPerDay = 0;
        angular.forEach($scope.selectedSchedule.selectedWeek.shifts.openShifts, function(dateShifts, calendarDate) {
          angular.forEach(dateShifts, function(shift) {
            if (!shift.external) {
              $scope.applyFilterToShift(shift);
            }
          });
          if (maxShiftsCountPerDay < dateShifts.length) {
            maxShiftsCountPerDay = dateShifts.length;
          }
        });
        heightVal = 54 * Math.max(maxShiftsCountPerDay, 1);
        $scope.selectedSchedule.openShiftsRowHeight = heightVal + 'px';
      } else if ($scope.viewMode.mode === 'day') {
        angular.forEach($scope.selectedSchedule.day.shifts.openShifts, function(shift) {
          if (!shift.external) {
            $scope.applyFilterToShift(shift);
          }
        });
        heightVal = 35 * Math.max($scope.selectedSchedule.day.shifts.openShifts.length, 1);
        $scope.selectedSchedule.openShiftsRowHeight = heightVal + 'px';
        $scope.selectedSchedule.openShiftsContainerRowHeight = (heightVal + 29) + 'px';
      }
    };

    function numberStringWithCommas(x) {
      return x.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    }

    $scope.calculateSummaryInfoForSelectedWeekOrDay = function() {
      var totalHours = 0;
      var overtimeHours = 0;
      var totalCost = 0;
      var totalUnfilled = 0;
      var oneHourInMilliseconds = 3600000;

      if ($scope.selectedSchedule === null) {
        return;
      }

      angular.forEach($scope.selectedSchedule.employeesInfo.result, function(employee) {
        if (employee.visible) {
          if ($scope.viewMode.mode === 'week') {
            angular.forEach($scope.selectedSchedule.selectedWeek.shifts.employeeShifts[employee.id], function(dateShifts, calendarDate) {
              angular.forEach(dateShifts, function(shift) {
                if (!shift.external && shift.filterPassed) {
                  addShiftStatistics(shift);
                }
              });
            });
          } else if ($scope.viewMode.mode === 'day') {
            angular.forEach($scope.selectedSchedule.day.shifts.employeeShifts[employee.id], function(shift) {
              if (!shift.external && shift.filterPassed) {
                addShiftStatistics(shift);
              }
            });
          }
        }

        function addShiftStatistics(shift) {
          var shiftDurationInHours = (shift.end - shift.start)/oneHourInMilliseconds;
          totalHours += shiftDurationInHours;
          overtimeHours += shift.overtime;
          totalCost += shift.cost;
        }
      });

      if ($scope.viewMode.mode === 'week') {
        angular.forEach($scope.selectedSchedule.selectedWeek.shifts.openShifts, function(dateShifts) {
          angular.forEach(dateShifts, function(shift) {
            if (!shift.external && shift.filterPassed) {
              var shiftDurationInHours = (shift.end - shift.start)/oneHourInMilliseconds;
              totalUnfilled += shiftDurationInHours;
            }
          });
        });
        updateStatisticsInView($scope.selectedSchedule.selectedWeek);
      } else if ($scope.viewMode.mode === 'day') {
        angular.forEach($scope.selectedSchedule.day.shifts.openShifts, function(shift) {
          if (!shift.external && shift.filterPassed) {
            var shiftDurationInHours = (shift.end - shift.start)/oneHourInMilliseconds;
            totalUnfilled += shiftDurationInHours;
          }
        });
        updateStatisticsInView($scope.selectedSchedule.day);
      }

      function updateStatisticsInView(targetObj) {
        targetObj.hours = numberStringWithCommas(totalHours.toFixed(2));
        targetObj.overtime = numberStringWithCommas(overtimeHours.toFixed(2));
        targetObj.cost = '$' + numberStringWithCommas(totalCost.toFixed(2));
        targetObj.unfilled = numberStringWithCommas(totalUnfilled.toFixed(2));
      }
    };

    $scope.employeeHasShifts = function(employeeId) {
      var result = false;
      if ($scope.viewMode.mode === 'week') {
        var foundObject = _.find($scope.selectedSchedule.selectedWeek.shifts.employeeShifts[employeeId], function(dateShifts, calendarDate) {
          return (dateShifts.length > 0);
        });
        result = (typeof foundObject !== 'undefined');
      } else if ($scope.viewMode.mode === 'day') {
        if (typeof $scope.selectedSchedule.day.shifts.employeeShifts[employeeId] !== 'undefined' &&
          $scope.selectedSchedule.day.shifts.employeeShifts[employeeId].length > 0) {
          result = true;
        }
      }

      return result;
    };

    $scope.openShiftsExisting = function() {
      var result = false;
      if ($scope.viewMode.mode === 'week') {
        var foundObject = _.find($scope.selectedSchedule.selectedWeek.shifts.openShifts, function(dateShifts, calendarDate) {
          return (dateShifts.length > 0);
        });
        result = (typeof foundObject !== 'undefined');
      } else if ($scope.viewMode.mode === 'day') {
        result = ($scope.selectedSchedule.day.shifts.openShifts.length > 0);
      }

      return result;
    };

    $scope.checkIfPastSchedule = function() {
      var currentTime = new Date().getTime();
      var scheduleEndTime = $scope.selectedSchedule.endDate;
      if (scheduleEndTime < currentTime) {
        return true;
      }
      return false;
    };

    $scope.checkIfPastDate = function(date) {
      var nowDateStamp = moment.tz(new Date().getTime(), siteTimeZone).hours(0).minutes(0).seconds(0).milliseconds(0).unix() * 1000;
      var selectedDateStamp = moment.tz(date + ' 00:00', siteTimeZone).unix() * 1000;
      return (nowDateStamp > selectedDateStamp);
    };

    $scope.$watch('selectedSchedule.selectedWeek', function() {
      if ($scope.selectedSchedule === null) {
        return;
      }

      $timeout(function() {
        $scope.applyFilterToShifts();
        $scope.calculateSummaryInfoForSelectedWeekOrDay();
      }, 0);
    });

    $scope.toggleSummary = function() {
      $scope.summaryCollapsed = !$scope.summaryCollapsed;
      if ($scope.summaryCollapsed) {
        angular.element('.schedule-calendar .employee-info.schedule-calendar-cell').css('width', '440px');
      } else {
        angular.element('.schedule-calendar .employee-info.schedule-calendar-cell').css('width', '210px');
      }
    };

    $scope.initializeWeeksLabels = function() {
      angular.forEach($scope.selectedSchedule.weeks, function(week) {
        week.selected = false;
        week.label = moment.tz(week.start, siteTimeZone).format('MMMM DD') +
          ' to ' + moment.tz(week.end, siteTimeZone).format('MMMM DD');
        week.dayLabels = {};
        var startMomentObj = moment.tz(week.start, siteTimeZone);

        for (var i=0; i<7; i++) {
          var momentObj = startMomentObj.clone().add(i, 'days');
          var titleText = momentObj.format('MMM DD');
          var fullStrText = momentObj.format('MMMM DD, YYYY');
          var labelText = $scope.consts.daysOfWeek[momentObj.day()] + ' ' + momentObj.format('MM/DD');
          var dateText = momentObj.format('YYYY-MM-DD');
          week.dayLabels['calendar-day-' + dateText] = {title: titleText, fullStr: fullStrText, label: labelText, date: dateText, selected: false};
        }
      });
    };

    $scope.initializeDayLabels = function() {
      var dateMoment = moment.tz($scope.selectedSchedule.day.datetimeStamp, siteTimeZone);
      var dateMomentWithNoHours = dateMoment.clone().hours(0).minutes(0).seconds(0).milliseconds(0);
      var siteFirstDayOfWeek = $scope.selectedSchedule.siteInfo[3].toLowerCase();
      var iteratorDateMoment = dateMomentWithNoHours.clone();
      var titleText = '', fullStrText = '', labelText = '', dateText = '';
      var disabledFlag = false;

      $scope.selectedSchedule.day.label = dateMoment.format('MMMM DD, YYYY');
      $scope.selectedSchedule.day.dateText = dateMoment.format('YYYY-MM-DD');
      $scope.selectedSchedule.day.headCounts = {};
      $scope.selectedSchedule.selectedWeek = {dayLabels: {}};

      while (iteratorDateMoment.format('dddd').toLowerCase() !== siteFirstDayOfWeek) {
        iteratorDateMoment.subtract(1, 'days');
      }

      var weekStartMoment = iteratorDateMoment.clone();
      var weekEndMoment = weekStartMoment.clone().add(7, 'days').subtract(1, 'seconds');
      $scope.selectedSchedule.selectedWeek.start = weekStartMoment.unix() * 1000;
      $scope.selectedSchedule.selectedWeek.end = weekEndMoment.unix() * 1000;
      for (var i=0; i<7; i++) {
        iteratorDateMoment = weekStartMoment.clone().add(i, 'days');
        titleText = iteratorDateMoment.format('MMM DD');
        fullStrText = iteratorDateMoment.format('MMMM DD, YYYY');
        labelText = $scope.consts.daysOfWeek[iteratorDateMoment.day()] + ' ' + iteratorDateMoment.format('MM/DD');
        dateText = iteratorDateMoment.format('YYYY-MM-DD');
        if (iteratorDateMoment.unix() * 1000 > $scope.selectedSchedule.endDate ||
          iteratorDateMoment.unix() * 1000 < $scope.selectedSchedule.startDate) {
          disabledFlag = true;
        }
        $scope.selectedSchedule.selectedWeek.dayLabels['calendar-day-' + dateText] = {title: titleText, fullStr: fullStrText, label: labelText, date: dateText, selected: false, disabled: disabledFlag};
      }
      $scope.selectedSchedule.selectedWeek.dayLabels['calendar-day-' + $scope.selectedSchedule.day.dateText].selected = true;
    };

    $scope.previousDayOutOfRange = function() {
      var currentDateTimeMoment = moment.tz($scope.selectedSchedule.day.datetimeStamp, siteTimeZone);
      var previousDayMoment = currentDateTimeMoment.clone().subtract(1, 'days');

      return (previousDayMoment.unix() * 1000 < $scope.selectedSchedule.startDate);
    };

    $scope.nextDayOutOfRange = function() {
      var currentDateTimeMoment = moment.tz($scope.selectedSchedule.day.datetimeStamp, siteTimeZone);
      var nextDayMoment = currentDateTimeMoment.clone().add(1, 'days');

      return (nextDayMoment.unix() * 1000 > $scope.selectedSchedule.endDate);
    };

    function shiftComparator(firstElement, secondElement) {
      if (firstElement.start < secondElement.start) {
        return -1;
      } else if (firstElement.start > secondElement.start) {
        return 1;
      } else {
        return 0;
      }
    }

    function parseShift(shift) {
      var dayInMilliseconds = 24 * 3600000;
      var timeStr = '';
      var tempStr = '';
      var startTimeMoment = moment.tz(shift[6], siteTimeZone);
      var endTimeMoment = moment.tz(shift[7], siteTimeZone);
      var selectedDayMomentInDayView = null;
      var startTimeOffSetPercentInDay = null;
      var tooltipPositionStr = null;
      var typeStr = '';
      var lengthPercentInDay = '';

      if (typeof shift[3] !== 'undefined' && shift[3] !== null) {
        typeStr = 'normal';
      } else {
        typeStr = 'open';
      }

      if ($scope.viewMode.mode === 'week') {
        timeStr = appFunc.toShortest12TimeFormat(startTimeMoment) + '-' + appFunc.toShortest12TimeFormat(endTimeMoment);
      } else if ($scope.viewMode.mode === 'day') {
        selectedDayMomentInDayView = moment.tz($scope.selectedSchedule.day.datetimeStamp, siteTimeZone).hours(0).minutes(0).seconds(0).milliseconds(0);

        if (selectedDayMomentInDayView.unix() * 1000 >= shift[6]) {
          timeStr = '(' + appFunc.toShortest12TimeFormat(startTimeMoment) + ')-' + appFunc.toShortest12TimeFormat(endTimeMoment);
          startTimeOffSetPercentInDay = 0;
          lengthPercentInDay = ((shift[7] - selectedDayMomentInDayView.unix() * 1000)/dayInMilliseconds) * 100;
        } else if (shift[7] <= selectedDayMomentInDayView.unix() * 1000 + dayInMilliseconds) {
          timeStr = appFunc.toShortest12TimeFormat(startTimeMoment) + '-' + appFunc.toShortest12TimeFormat(endTimeMoment);
          startTimeOffSetPercentInDay = (((startTimeMoment.hours() * 3600 + startTimeMoment.minutes() * 60 + startTimeMoment.seconds()) * 1000 + startTimeMoment.milliseconds())/dayInMilliseconds) * 100;
          lengthPercentInDay = ((shift[7] - shift[6])/dayInMilliseconds) * 100;
        } else {
          timeStr = appFunc.toShortest12TimeFormat(startTimeMoment) + '-(' + appFunc.toShortest12TimeFormat(endTimeMoment) + ')';
          startTimeOffSetPercentInDay = (((startTimeMoment.hours() * 3600 + startTimeMoment.minutes() * 60 + startTimeMoment.seconds()) * 1000 + startTimeMoment.milliseconds())/dayInMilliseconds) * 100;
          lengthPercentInDay = ((selectedDayMomentInDayView.unix() * 1000 + dayInMilliseconds - shift[6])/dayInMilliseconds) * 100;
        }

        if (startTimeOffSetPercentInDay <= 50) {
          tooltipPositionStr = 'right';
        } else {
          tooltipPositionStr = 'left';
        }
        startTimeOffSetPercentInDay += '%';
        lengthPercentInDay += '%';
      }

      var shiftObj = {
        id: shift[0],
        type: typeStr,
        employeeId: shift[3],
        excessType: (shift[1])? 'extra': 'regular',
        excessTypeStr: (shift[1])? 'Extra': '',
        start: shift[6],
        end: shift[7],
        timeStr: timeStr,
        startTimeOffSetPercentInDay: startTimeOffSetPercentInDay,
        tooltipPositionInDay: tooltipPositionStr,
        lengthPercentInDay: lengthPercentInDay,
        skillId: shift[4],
        skillName: $scope.getAssignedSkillName(shift[4]),
        skillAbbrev: shift[5],
        assignment: 'Assignment',
        teamId: shift[2],
        teamName: (shift[10] ? shift[10] : $scope.getAssignedTeamName(shift[2])),
        posted: '',
        requested: '',
        comment: shift[9],
        external: (shift[11] === 'otherSchedule')? true: false,
        filterPassed: true,
        overtime: shift[12] ? shift[12]/60.0 : 0,
        cost: shift[13] ? shift[13] : 0
      };

      if (shiftObj.end - shiftObj.start >= 7 * 3600 * 1000) {
        shiftObj.canShowAdditionalInfoInDayView = true;
        shiftObj.canShowInfoInDayView = true;
        shiftObj.canShowTimeInDayView = true;
      } else if (shiftObj.end - shiftObj.start >= 3 * 3600 * 1000) {
        shiftObj.canShowAdditionalInfoInDayView = false;
        shiftObj.canShowInfoInDayView = true;
        shiftObj.canShowTimeInDayView = true;
      } else if (shiftObj.end - shiftObj.start >= 2 * 3600 * 1000) {
        shiftObj.canShowAdditionalInfoInDayView = false;
        shiftObj.canShowInfoInDayView = false;
        shiftObj.canShowTimeInDayView = true;
      } else {
        shiftObj.canShowAdditionalInfoInDayView = false;
        shiftObj.canShowInfoInDayView = false;
        shiftObj.canShowTimeInDayView = false;
      }
      if (shiftObj.comment === null) {
        shiftObj.commentClass = '';
      } else {
        shiftObj.commentClass = 'has-comment';
      }

      if (shiftObj.external) {
        shiftObj.externalClass = 'external';
      } else {
        shiftObj.externalClass = '';
      }

      return shiftObj;
    }

    $scope.arrangeWeeksShifts = function() {
      $scope.selectedSchedule.rowHeightsOfEmployees = {};
      $scope.selectedSchedule.openShiftsRowHeight = null;
      angular.forEach($scope.selectedSchedule.weeks, function(week) {
        var arrangedShifts = {
          employeeShifts: {},
          openShifts: {}
        };
        angular.forEach(week.shifts, function(shift) {
          var shiftObj = parseShift(shift);
          var dateStr = moment.tz(shift[6], siteTimeZone).format('YYYY-MM-DD');

          if (shiftObj.type === 'normal') {
            if (typeof arrangedShifts.employeeShifts[shift[3]] === 'undefined') {
              arrangedShifts.employeeShifts[shift[3]] = {};
            }
            if (typeof arrangedShifts.employeeShifts[shift[3]]['calendar-day-' + dateStr] === 'undefined') {
              arrangedShifts.employeeShifts[shift[3]]['calendar-day-' + dateStr] = [];
            }
            arrangedShifts.employeeShifts[shift[3]]['calendar-day-' + dateStr].push(shiftObj);
            arrangedShifts.employeeShifts[shift[3]]['calendar-day-' + dateStr].sort(shiftComparator);
          } else if (shiftObj.type === 'open') {
            if (typeof arrangedShifts.openShifts['calendar-day-' + dateStr] === 'undefined') {
              arrangedShifts.openShifts['calendar-day-' + dateStr] = [];
            }
            var foundShift = _.find(week.postedOpenShifts, function(postedIterator) {
              return (postedIterator[0] === shiftObj.id);
            });
            if (typeof foundShift !== 'undefined') {
              shiftObj.posted = 'Posted ' + moment.tz(foundShift[1], siteTimeZone).format('YYYY-MM-DD');
              shiftObj.requested = (foundShift[2])? '(R)': '';
            }
            arrangedShifts.openShifts['calendar-day-' + dateStr].push(shiftObj);
            arrangedShifts.openShifts['calendar-day-' + dateStr].sort(shiftComparator);
          }
        });
        week.shifts = arrangedShifts;
        angular.forEach(week.dayLabels, function(dateLabel, calendarDate) {
          if (typeof week.shifts.openShifts[calendarDate] !== 'undefined' &&
            week.shifts.openShifts[calendarDate] !==null ) {
            var count = 0;
            angular.forEach(week.shifts.openShifts[calendarDate], function(shiftIterator) {
              if (!shiftIterator.external) {
                count ++;
              }
            });
            dateLabel.openShiftsCount = count;
          } else {
            dateLabel.openShiftsCount = 0;
          }
        });
      });
    };

    $scope.arrangeEmployeeWeeksHours = function() {
      angular.forEach($scope.selectedSchedule.weeks, function(week) {
        var arrangedEmployeeHours = {};
        angular.forEach($scope.selectedSchedule.employeesInfo.result, function(employee) {
          var foundInfo = _.find(week.employees, 'employeeId', employee.id);
          if (typeof foundInfo !== 'undefined') {
            var minimumHours = (foundInfo.minimumMinutes/60);
            var scheduledHours = (foundInfo.scheduledMinutes/60).toFixed(1);
            var alarmed = (minimumHours > scheduledHours);
            arrangedEmployeeHours[employee.id] = {
              minimumHours: minimumHours > 0 ? minimumHours.toFixed(1) : "-",
              scheduledHours: scheduledHours,
              hoursAlarmed: alarmed
            };
          } else {
            arrangedEmployeeHours[employee.id] = {
              minimumHours: '-',
              scheduledHours: '-',
              hoursAlarmed: false
            };
          }
        });
        week.employees = arrangedEmployeeHours;
      });
    };

    $scope.arrangeDayShifts = function() {
      $scope.selectedSchedule.openShiftsRowHeight = null;
      $scope.selectedSchedule.openShiftsContainerRowHeight = null;
      var arrangedShifts = {
        employeeShifts: {},
        openShifts: []
      };
      angular.forEach($scope.selectedSchedule.day.shifts, function(shift) {
        var shiftObj = parseShift(shift);
        if (shiftObj.type === 'normal') {
          if (typeof arrangedShifts.employeeShifts[shift[3]] === 'undefined') {
            arrangedShifts.employeeShifts[shift[3]] = [];
          }
          arrangedShifts.employeeShifts[shift[3]].push(shiftObj);
          arrangedShifts.employeeShifts[shift[3]].sort(shiftComparator);
        } else if (shiftObj.type === 'open') {
          var foundShift = _.find($scope.selectedSchedule.day.postedOpenShifts, 'shiftId', shiftObj.id);
          if (typeof foundShift !== 'undefined') {
            shiftObj.posted = 'Posted ' + moment.tz(foundShift.posted, siteTimeZone).format('YYYY-MM-DD');
            shiftObj.requested = (foundShift.requested)? '(R)': '';
          }
          arrangedShifts.openShifts.push(shiftObj);
          arrangedShifts.openShifts.sort(shiftComparator);
        }
      });
      $scope.selectedSchedule.day.shifts = arrangedShifts;
    };

    $scope.getDisplayedEmployeesCount = function() {
      var number = 0;
      angular.forEach($scope.selectedSchedule.employeesInfo.result, function(employee) {
        if (employee.visible && ($scope.employeeHasShifts(employee.id) || (employee.isFloating && $scope.filter.displayFloats) || (!employee.isFloating && !$scope.filter.displayScheduledOnly))) {
          number++;
        }
      });
      return number;
    };

    $scope.initializeSchedule = function(responseData) {
      $scope.selectedSchedule = responseData;
      siteTimeZone = $scope.selectedSchedule.siteInfo[2];
      $scope.selectedSchedule.startDateStr = moment.tz($scope.selectedSchedule.startDate, siteTimeZone).format('MMMM DD, YYYY');
      $scope.selectedSchedule.lengthInWeeks = $scope.selectedSchedule.scheduleLengthInDays/7;
      $scope.selectedSchedule.isDeletable = function () {
        //Show "Delete" button if schedule is not actual yet.
        if ($scope.selectedSchedule.status == $scope.consts.scheduleStatus.POSTED) {
          var scheduleStartDateTime = appFunc.convertToBrowserTimezone(
              $scope.selectedSchedule.startDate, siteTimeZone);
          return scheduleStartDateTime > new Date();
        }
        return true;
      }();

      fillScheduleStatistics($scope.selectedSchedule.totalMinutes/60,
          $scope.selectedSchedule.overtimeMinutes/60,
          $scope.selectedSchedule.totalCost,
          $scope.selectedSchedule.unfilledShiftsMinutes/60);

      $scope.filter.homeTeams = [];
      $scope.filter.assignedTeams = [];
      $scope.filter.primarySkills = [];
      $scope.filter.assignedSkills = [];
      $scope.filter.selectedHomeTeams = [];
      $scope.filter.selectedAssignedTeams = [];
      $scope.filter.selectedPrimarySkills = [];
      $scope.filter.selectedAssignedSkills = [];

      $scope.filter.homeTeams = prepareTeamsList($scope.selectedSchedule.teamsInfo.result, true);
      $scope.filter.assignedTeams = prepareTeamsList($scope.selectedSchedule.teamsInfo.result, false);

      angular.forEach($scope.selectedSchedule.skillsInfo.result, function(skillInfo) {
        var info = {
          id: skillInfo[0],
          name: skillInfo[1],
          ticked: true
        };
        $scope.filter.primarySkills.push(info);
      });
      $scope.filter.primarySkills.sort(function(firstSkill, secondSkill) {
        if (firstSkill.name < secondSkill.name) {
          return -1;
        } else if (firstSkill.name > secondSkill.name) {
          return 1;
        } else {
          return 0;
        }
      });
      $scope.filter.assignedSkills = angular.copy($scope.filter.primarySkills);

      var parsedEmployees = [];
      angular.forEach($scope.selectedSchedule.employeesInfo.result, function(employeeInfo) {
        var parsedEmployee = {
          id: employeeInfo[0],
          firstName: employeeInfo[1],
          lastName: employeeInfo[2],
          name: employeeInfo[1] + ' ' + employeeInfo[2],
          hourlyRate: employeeInfo[3].toFixed(2),
          teamIds: employeeInfo[4],
          homeTeamId: employeeInfo[5],
          primarySkillId: employeeInfo[6],
          skillIds: employeeInfo[7],
          seniority: employeeInfo[8],
          isFloating: employeeInfo[9],
          visible: true
        };

        if (typeof employeeInfo[8] !== 'number') {
          parsedEmployee.seniority = -1;
          parsedEmployee.seniorityStr = '-';
        } else {
          var abstractEndDate = moment.tz(employeeInfo[8], siteTimeZone);
          var abstractStartDate = moment.tz(0, siteTimeZone);
          var monthsDiff = abstractEndDate.diff(abstractStartDate, 'months');
          var yearsDiff = Math.floor(monthsDiff/12);
          monthsDiff = monthsDiff - 12 * yearsDiff;

          var yearsDiffStr = '', monthsDiffStr = '';
          if (yearsDiff !== 0) {
            yearsDiffStr = yearsDiff + 'y ';
          }
          if (monthsDiff !== 0) {
            monthsDiffStr = monthsDiff + 'm';
          }
          if (yearsDiff === 0 && monthsDiff === 0) {
            parsedEmployee.seniorityStr = '0';
          } else {
            parsedEmployee.seniorityStr = yearsDiffStr + monthsDiffStr;
          }
        }

        if ($scope.viewMode.mode === 'day') {
          var dueHours = parseFloat(employeeInfo[9])/60;
          parsedEmployee.due = dueHours > 0 ? dueHours.toFixed(2) : "-";
          parsedEmployee.total = (parseFloat(employeeInfo[10])/60).toFixed(2);
        }
        parsedEmployees.push(parsedEmployee);
      });
      $scope.selectedSchedule.employeesInfo.result = parsedEmployees;
      $scope.toggleSort('employeeName', 'asc');

      if ($scope.viewMode.mode === 'week') {
        $scope.initializeWeeksLabels();
        $scope.arrangeWeeksShifts();
        $scope.arrangeEmployeeWeeksHours();

        if ($scope.feedWeekForScheduleWeekView !== null) {
          var foundIndex = _.findIndex($scope.selectedSchedule.weeks, function(week) {
            return (week.start === $scope.feedWeekForScheduleWeekView.start);
          });
          if (foundIndex < 0) {
            foundIndex = 0;
          }
          $scope.selectedSchedule.weeks[foundIndex].selected = true;
          $scope.selectedSchedule.selectedWeek = $scope.selectedSchedule.weeks[foundIndex];
          $scope.feedWeekForScheduleWeekView = null;
        } else {
          $scope.selectedSchedule.weeks[0].selected = true;
          $scope.selectedSchedule.selectedWeek = $scope.selectedSchedule.weeks[0];
        }
      } else if ($scope.viewMode.mode === 'day') {
        $scope.initializeDayLabels();
        $scope.arrangeDayShifts();
        $scope.populateDayHeadCounts();
      }
    };

    function fillScheduleStatistics(regularHours, otHours, cost, unfilledHours) {
      $scope.selectedSchedule.totalHours = numberStringWithCommas(regularHours.toFixed(2));
      $scope.selectedSchedule.overtimeHours = numberStringWithCommas(otHours.toFixed(2));
      $scope.selectedSchedule.totalCost = '$' + numberStringWithCommas(cost.toFixed(2));
      $scope.selectedSchedule.unfilledShiftsHours
          = numberStringWithCommas(unfilledHours.toFixed(2));
    }

    function prepareTeamsList(teamsInfo, isHomeTeams) {
      var preparedTeams = [];
      angular.forEach(teamsInfo, function(teamInfo) {
        var isHomeTeam = teamInfo[2];
        if(isHomeTeams || isHomeTeams === false && !isHomeTeam) {
          var info = {
            id: teamInfo[0],
            name: teamInfo[1],
            ticked: true
          };
          preparedTeams.push(info);
        }
      });
      preparedTeams.sort(function(firstTeam, secondTeam) {
        if (firstTeam.name < secondTeam.name) {
          return -1;
        } else if (firstTeam.name > secondTeam.name) {
          return 1;
        } else {
          return 0;
        }
      });
      return preparedTeams;
    }

    $scope.promoteSchedule = function() {
      var modalInstance = $modal.open({
        templateUrl: 'promoteScheduleConfirmationModal.html',
        controller: 'PromoteScheduleConfirmationModalInstanceCtrl',
        size: 'sm',
        windowClass: 'promote-schedule-modal',
        resolve: {
          currentScheduleStatus: function() {
            return $scope.selectedSchedule.status;
          }
        }
      });
      modalInstance.result.then(function(result) {
        if (typeof result !== 'undefined' && result !== null && result.answer) {
          dataService.promoteSchedule($scope.selectedSchedule.id).then(function(response) {
            if ($scope.selectedSchedule.status === 'Production') {
              applicationContext.setNotificationMsgWithValues('employee_schedules.SCHEDULE_POSTED_SUCCESSFULLY', 'success', true);
            } else {
              applicationContext.setNotificationMsgWithValues('employee_schedules.SCHEDULE_PROMOTED_SUCCESSFULLY', 'success', true);
            }
            reLoadSchedule();
          }, function(err) {
            applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
          });
        }
      });
    };

    $scope.deleteSchedule = function() {
      dataService.deleteSchedule($scope.selectedSchedule.id).then(function(response) {
        applicationContext.setNotificationMsgWithValues('employee_schedules.SCHEDULE_DELETED_SUCCESSFULLY', 'success', true);
        $scope.selectedSchedule = null;
        $scope.scheduleInfoLoaded = null;
        if ($scope.viewMode.mode === 'week') {
          $state.go('authenticated.employeeSchedules.weekView', null, {location: true});
        } else if ($scope.viewMode.mode === 'day') {
          $state.go('authenticated.employeeSchedules.dayView', null, {location: true});
        }
      }, function(err) {
        var errorMessage = err.data ? err.data.message : "Schedule delete failed";
        applicationContext.setNotificationMsgWithValues(JSON.stringify(errorMessage), 'danger', true);
      });
    };

    $scope.openSiteSchedulesModal = function() {
      var modalInstance = $modal.open({
        templateUrl: 'scheduleSelectorModal.html',
        controller: 'ScheduleSelectorModalInstanceCtrl',
        size: 'lg',
        windowClass: 'schedules-modal',
        resolve: {
          checkboxModel: function() {
            return {
              simulationGenerated: false,
              production: true,
              posted: true
            };
          },
          customFilter: function() {
            return null;
          }
        }
      });
      modalInstance.result.then(function(selectedSchedule) {
        if ($scope.viewMode.mode === 'week') {
          $state.go('authenticated.employeeSchedules.weekView.schedule', {scheduleId: selectedSchedule.id});
        } else if ($scope.viewMode.mode === 'day') {
          var nowDateStamp = new Date().getTime();
          if (selectedSchedule.start <= nowDateStamp && nowDateStamp <= selectedSchedule.end - 1) {
            $state.go('authenticated.employeeSchedules.dayView.schedule', {scheduleId: selectedSchedule.id, dateTimeStamp: nowDateStamp});
          } else {
            $state.go('authenticated.employeeSchedules.dayView.schedule', {scheduleId: selectedSchedule.id, dateTimeStamp: selectedSchedule.start});
          }
        }
      });
    };

    function pushInfoValuesToShift(info) {
      var shiftInfo = [];

      shiftInfo.push(info.id, info.excess, info.teamId, info.employeeId); // id, excess type, team id, employee id
      shiftInfo.push(info.skillId, info.skillAbbrev, info.startDateTime, info.endDateTime); // skill id, skill abbreviation, start, end
      shiftInfo.push(info.paidTime, info.comment); // paid time, comment

      return shiftInfo;
    }

    function updateEmployeeScheduledHours(operationType, employeeShifts, scheduleViewType) {
      if(!employeeShifts || employeeShifts.length <= 0) {
        return;
      }
      var employeeId = employeeShifts[0].employeeId;
      var shiftsHours = calculateShiftsHours(employeeShifts);

      switch (operationType) {
        case '+': break;
        case '-': shiftsHours *= -1; break;
        default:
          throw "Invalid operationType in updateEmployeeScheduledHours: " + operationType + ". '+' or '-' required!";
      }

      var employeeScheduledHours = 0;
      switch (scheduleViewType) {
        case 'day':
          //TODO: Works incorrect for replace (at least shift swap). Find the problem and uncomment
          //var employeeIndex = _.findIndex($scope.selectedSchedule.employeesInfo.result, 'id', employeeId);
          //if(employeeIndex === -1) {
          //  throw "Cannot find employee with id: " + employeeId;
          //}
          //employeeScheduledHours = $scope.selectedSchedule.employeesInfo.result[employeeIndex].total*1;
          //employeeScheduledHours += shiftsHours;
          //$scope.selectedSchedule.employeesInfo.result[employeeIndex].total = employeeScheduledHours.toFixed(2);
          break;
        case 'week':
          employeeScheduledHours = $scope.selectedSchedule.selectedWeek.employees[employeeId].scheduledHours*1;
          employeeScheduledHours += shiftsHours;
          $scope.selectedSchedule.selectedWeek.employees[employeeId].scheduledHours = employeeScheduledHours.toFixed(2);
          $scope.selectedSchedule.selectedWeek.employees[employeeId].hoursAlarmed =
              $scope.selectedSchedule.selectedWeek.employees[employeeId].minimumHours > employeeScheduledHours;
          break;
        default:
          throw "Invalid scheduleViewType in updateEmployeeScheduledHours: " + scheduleViewType + "." +
                " 'day' or 'week' required!";
      }
    }

    function markFilteredStatisticsAsNotValid() {
      $scope.selectedSchedule.selectedWeek.dirtyStatistics = true;
    }

    function calculateShiftsHours(shifts) {
      var shiftsHours = 0;
      _.forEach(shifts, function(shift) {
        var shiftLengthHours = (shift.end - shift.start) / 1000 / 60 / 60;
        if(shiftLengthHours > 0)
          shiftsHours += shiftLengthHours;
        else
          console.error("Invalid shiftLengthHours calculated: " + shiftLengthHours + " for shift id: " + shift.id);
      });
      return shiftsHours;
    }

    $scope.refreshScheduleStatistics = function() {
      EmployeeSchedulesService.getScheduleStatistics($scope.selectedSchedule.id).then(function(response) {
        var assigned = response.data.assignedShiftsStatistics;
        var unfulledMinutes = response.data.openShiftsTotalTimeMinutes;
        fillScheduleStatistics(assigned.totalTimeMinutes/60,
            assigned.overtimeMinutes/60,
            assigned.totalCost,
            unfulledMinutes/60);

        var assignedShiftsStatistics = assigned.shiftStatistics;

        _.forEach($scope.selectedSchedule.weeks, function(week) {
          _.forEach(week.shifts.employeeShifts, function(employeeDays) {
            _.forEach(employeeDays, function(employeeDayShifts) {
              _.forEach(employeeDayShifts, function(shift) {
                var currentShiftStatistics = assignedShiftsStatistics[shift.id];
                if(currentShiftStatistics) {
                  shift.overtime = currentShiftStatistics.overtimeMinutes/60;
                  shift.cost = currentShiftStatistics.totalCost;
                }
              });
            });
          });
        });
        $scope.calculateSummaryInfoForSelectedWeekOrDay();
        $scope.selectedSchedule.selectedWeek.dirtyStatistics = false;
      }, function(err) {
        console.error(err.data);
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };

    function arrangeShift(arrangeType, shiftObj) {
      var dateStr = moment.tz(shiftObj.start, siteTimeZone).format('YYYY-MM-DD');
      var foundWeekIndex = -1;
      var needExit = false;

      if ($scope.viewMode.mode === 'week') {
        _.forEach($scope.selectedSchedule.weeks, function(week, weekIndex) {
          _.forEach(week.shifts.employeeShifts, function(employeeShifts, employeeId) {
            var foundDateShifts = _.find(employeeShifts, function(dateShifts, calendarDate) {
              var foundIndex = _.findIndex(dateShifts, 'id', shiftObj.id);

              return (foundIndex > -1);
            });
            if (typeof foundDateShifts !== 'undefined') {
              if (arrangeType === 'add') {
                needExit = true;

                return false;
              }

              foundWeekIndex = weekIndex;

              _.remove(foundDateShifts, function(shift) {
                if(shift.id === shiftObj.id) {
                  updateEmployeeScheduledHours('-', [shift], 'week');
                  return true;
                }
                return false;
              });

              return false;
            }
          });

          if (needExit || foundWeekIndex > -1) {
            return false;
          }

          var foundDateShifts = _.find(week.shifts.openShifts, function(dateShifts, calendarDate) {
            var foundIndex = _.findIndex(dateShifts, 'id', shiftObj.id);

            return (foundIndex > -1);
          });
          if (typeof foundDateShifts !== 'undefined') {
            if (arrangeType === 'add') {
              needExit = true;

              return false;
            }

            foundWeekIndex = weekIndex;
            var removedShifts = _.remove(foundDateShifts, 'id', shiftObj.id);
            if (removedShifts.length > 0) {
              $scope.selectedSchedule.weeks[foundWeekIndex].dayLabels['calendar-day-' + dateStr].openShiftsCount--;
            }

            return false;
          }
        });

        if (needExit || (foundWeekIndex === -1 && arrangeType === 'replace' && shiftObj.excessType !== 'extra')) {
          return;
        }
      } else if ($scope.viewMode.mode === 'day') {
        var foundEmployeeShifts = _.find($scope.selectedSchedule.day.shifts.employeeShifts, function(employeeShifts, employeeId) {
          var foundIndex = _.findIndex(employeeShifts, 'id', shiftObj.id);

          return (foundIndex > -1);
        });
        if (typeof foundEmployeeShifts !== 'undefined') {
          if (arrangeType === 'add') {
            return;
          }
          _.remove(foundEmployeeShifts, function(shift) {
            if(shift.id === shiftObj.id) {
              updateEmployeeScheduledHours('-', foundEmployeeShifts, 'day');
              return true;
            }
            return false;
          });
        } else {
          var foundIndex = _.findIndex($scope.selectedSchedule.day.shifts.openShifts, 'id', shiftObj.id);

          if (foundIndex > -1) {
            if (arrangeType === 'add') {
              return;
            }

            _.remove($scope.selectedSchedule.day.shifts.openShifts, 'id', shiftObj.id);
          } else {
            if (arrangeType === 'replace' && shiftObj.excessType !== 'extra') {
              return;
            }
          }
        }
      }

      if (arrangeType === 'remove') {
        return;
      }

      if ($scope.viewMode.mode === 'week' && foundWeekIndex === -1) {
        foundWeekIndex = _.findIndex($scope.selectedSchedule.weeks, function(week) {
          if (week.start <= shiftObj.start && week.end >= shiftObj.end) {
            return true;
          }
          return false;
        });
      }

      if (shiftObj.type === 'normal') {
        if ($scope.viewMode.mode === 'week') {
          if (typeof $scope.selectedSchedule.weeks[foundWeekIndex].shifts.employeeShifts[shiftObj.employeeId] === 'undefined') {
            $scope.selectedSchedule.weeks[foundWeekIndex].shifts.employeeShifts[shiftObj.employeeId] = {};
          }
          if (typeof $scope.selectedSchedule.weeks[foundWeekIndex].shifts.employeeShifts[shiftObj.employeeId]['calendar-day-' + dateStr] === 'undefined') {
            $scope.selectedSchedule.weeks[foundWeekIndex].shifts.employeeShifts[shiftObj.employeeId]['calendar-day-' + dateStr] = [];
          }
          $scope.selectedSchedule.weeks[foundWeekIndex].shifts.employeeShifts[shiftObj.employeeId]['calendar-day-' + dateStr].push(shiftObj);
          updateEmployeeScheduledHours('+', [shiftObj], 'week');
          $scope.selectedSchedule.weeks[foundWeekIndex].shifts.employeeShifts[shiftObj.employeeId]['calendar-day-' + dateStr].sort(shiftComparator);
        } else if ($scope.viewMode.mode === 'day') {
          if (typeof $scope.selectedSchedule.day.shifts.employeeShifts[shiftObj.employeeId] === 'undefined') {
            $scope.selectedSchedule.day.shifts.employeeShifts[shiftObj.employeeId] = [];
          }
          $scope.selectedSchedule.day.shifts.employeeShifts[shiftObj.employeeId].push(shiftObj);
          updateEmployeeScheduledHours('+', [shiftObj], 'day');
          $scope.selectedSchedule.day.shifts.employeeShifts[shiftObj.employeeId].sort(shiftComparator);
        }
      } else if (shiftObj.type === 'open') {
        if ($scope.viewMode.mode === 'week') {
          if (typeof $scope.selectedSchedule.weeks[foundWeekIndex].shifts.openShifts['calendar-day-' + dateStr] === 'undefined') {
            $scope.selectedSchedule.weeks[foundWeekIndex].shifts.openShifts['calendar-day-' + dateStr] = [];
          }
          $scope.selectedSchedule.weeks[foundWeekIndex].shifts.openShifts['calendar-day-' + dateStr].push(shiftObj);
          $scope.selectedSchedule.weeks[foundWeekIndex].shifts.openShifts['calendar-day-' + dateStr].sort(shiftComparator);
          $scope.selectedSchedule.weeks[foundWeekIndex].dayLabels['calendar-day-' + dateStr].openShiftsCount++;
        } else if ($scope.viewMode.mode === 'day') {
          $scope.selectedSchedule.day.shifts.openShifts.push(shiftObj);
          $scope.selectedSchedule.day.shifts.openShifts.sort(shiftComparator);
        }
      }
      markFilteredStatisticsAsNotValid();
    }

    function doActionAfterDroppingShift(response) {
      var shiftInfo = [];
      var shiftObj = {};

      shiftInfo = pushInfoValuesToShift(response);
      shiftObj = parseShift(shiftInfo);

      arrangeShift('replace', shiftObj);

      $scope.onFilterChanged(true);
      applicationContext.setNotificationMsgWithValues('employee_schedules.SHIFT_DROPPED_SUCCESSFULLY', 'success', true);
    }

    function doActionAfterSwappingShifts(response) {
      var shiftInfo = [];
      var shiftObj = {};

      shiftInfo = pushInfoValuesToShift(response.shift1Dto);
      shiftObj = parseShift(shiftInfo);
      arrangeShift('replace', shiftObj);

      shiftInfo = pushInfoValuesToShift(response.shift2Dto);
      shiftObj = parseShift(shiftInfo);
      arrangeShift('replace', shiftObj);

      $scope.onFilterChanged(true);
      applicationContext.setNotificationMsgWithValues('employee_schedules.SHIFTS_SWAPPED_SUCCESSFULLY', 'success', true);
    }

    function doActionAfterUpdatingShift(updateType, response) {
      var shiftInfo = [];
      var shiftObj = {};

      shiftInfo = pushInfoValuesToShift(response.updatedShiftDto);
      shiftObj = parseShift(shiftInfo);
      arrangeShift('replace', shiftObj);

      if (typeof response.createdShiftDto !== 'undefined' && response.createdShiftDto !== null) {
        shiftInfo = pushInfoValuesToShift(response.createdShiftDto);
        shiftObj = parseShift(shiftInfo);
        if (updateType === 'CreateAndPost') {
          shiftObj.posted = 'Posted ' + moment.tz(response.createdShiftDto.postedDate, siteTimeZone).format('YYYY-MM-DD');
          shiftObj.requested = '';
        }
        arrangeShift('add', shiftObj);
      }

      $scope.onFilterChanged(true);
      applicationContext.setNotificationMsgWithValues('employee_schedules.SHIFT_UPDATED_SUCCESSFULLY', 'success', true);
    }

    $scope.openManageShiftModal = function(shift, employee) {
      if (shift.external) {
        return;
      }

      var modalInstance = $modal.open({
        templateUrl: 'manageScheduleShiftPopupModal.html',
        controller: 'ManageScheduleShiftPopupModalInstanceCtrl',
        windowClass: 'manage-shift-modal',
        resolve: {
          selectedSchedule: function() {
            return $scope.selectedSchedule;
          },
          selectedShift: function() {
            return shift;
          },
          selectedEmployee: function() {
            return employee;
          }
        }
      });
      modalInstance.result.then(function(modalResult) {
        if (modalResult.operation === 'drop') {
          dataService.dropShift($scope.selectedSchedule.id, shift.id, modalResult.dropShiftReasonId).then(function(response) {
            doActionAfterDroppingShift(response);
          }, function(err) {
            applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
          });
        } else if (modalResult.operation === 'swap') {
          dataService.submitSelectedEligibleEntities('swap', $scope.selectedSchedule.id, shift, modalResult.newSelectedShift, modalResult.comment).then(function(response) {
            doActionAfterSwappingShifts(response);
          }, function(err) {
            applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
          });
        } else if (modalResult.operation === 'update') {
          var shiftInfo = {
            newStartDateTime: modalResult.startTime,
            newEndDateTime: modalResult.endTime
          };
          var osShiftInfo = null;

          if (typeof modalResult.spaceOperation !== 'undefined') {
            osShiftInfo = {
              action: modalResult.spaceOperation,
              startDateTime: modalResult.newShiftStartTime,
              endDateTime: modalResult.newShiftEndTime
            };

            if (modalResult.spaceOperation === 'CreateAndAssign') {
              osShiftInfo.employeeId = modalResult.newFillEmployee.employeeId;
            }

            if (typeof modalResult.ptoType !== 'undefined') {
              osShiftInfo.unavailabilityInfo = {
                absenceTypeId: modalResult.ptoType
              };
            }
          }

          dataService.manageShift($scope.selectedSchedule.id, shift.id, modalResult.comment, shiftInfo, osShiftInfo).then(function(response) {
            doActionAfterUpdatingShift(modalResult.spaceOperation, response);
          }, function(err) {
            applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
          });
        }
      });
    };

    $scope.openManageOpenShiftsModal = function(date) {
      if ($scope.selectedSchedule.status !== 'Posted') {
        return;
      }

      if (typeof date !== 'undefined' && date !== null) {
        if ($scope.checkIfPastDate(date)) {
          return;
        }
      } else {
        if ($scope.checkIfPastSchedule()) {
          return;
        }
      }

      var modalInstance = $modal.open({
        templateUrl: 'manageOpenShiftsPopupModal.html',
        controller: 'ManageOpenShiftsPopupModalInstanceCtrl',
        size: 'lg',
        backdrop: false,
        windowClass: 'manage-open-shifts-modal',
        resolve: {
          siteId: function() {
            return $scope.selectedSchedule.siteInfo[0];
          },
          scheduleId: function() {
            return $scope.selectedSchedule.id;
          },
          dateRangeStart: function() {
            if (typeof date === 'undefined' || date === null) {
              return $scope.selectedSchedule.selectedWeek.start;
            } else {
              return moment.tz(date + ' 00:00', siteTimeZone).unix() * 1000;
            }
          },
          dateRangeEnd: function() {
            var dateMoment = null;
            if (typeof date === 'undefined' || date === null) {
              return $scope.selectedSchedule.selectedWeek.end;
            } else {
              dateMoment = moment.tz(date + ' 00:00', siteTimeZone);
              dateMoment.add(1, 'days').subtract(1, 'seconds');
              return dateMoment.unix() * 1000;
            }
          },
          timezone: function() {
            return siteTimeZone;
          }
        }
      });

      modalInstance.result.then(function(modalResult) {
        if (modalResult.openShiftsPosted) {
          reLoadSchedule();
        }
      });
    };

    function doActionAfterAddingNewShift(addType, response) {
      var shiftInfo = [];
      var shiftObj = {};

      shiftInfo = pushInfoValuesToShift(response.shiftDto);
      shiftObj = parseShift(shiftInfo);
      if (addType === 'CreateAndPost' && typeof response.postedEmployeeMap !== 'undefined' && response.postedEmployeeMap !== null) {
        shiftObj.posted = 'Posted ' + moment.tz(response.shiftDto.postedDate, siteTimeZone).format('YYYY-MM-DD');
        shiftObj.requested = '';
      }

      arrangeShift('add', shiftObj);

      $scope.onFilterChanged(true);
      applicationContext.setNotificationMsgWithValues('employee_schedules.SHIFT_ADDED_SUCCESSFULLY', 'success', true);
    }

    $scope.openAddNewShiftModal = function() {
      var modalInstance = $modal.open({
        templateUrl: 'addNewShiftPopupModal.html',
        controller: 'AddNewShiftPopupModalInstanceCtrl',
        size: 'lg',
        windowClass: 'add-new-shift-modal',
        resolve: {
          viewMode: function() {
            return $scope.viewMode.mode;
          },
          selectedSchedule: function() {
            return $scope.selectedSchedule;
          }
        }
      });
      modalInstance.result.then(function(modalResult) {
        dataService.createShiftByAction($scope.selectedSchedule.id, modalResult.shiftInfo, modalResult.action, modalResult.employeeId).then(function(response) {
          doActionAfterAddingNewShift(modalResult.action, response);
        }, function(err) {
          applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
        });
      });
    };

    function doActionAfterDeletingShift(shift) {
      arrangeShift('remove', shift);

      $scope.onFilterChanged(true);
      applicationContext.setNotificationMsgWithValues('{{ "app.DELETED_SUCCESSFULLY" | translate }}', 'success', true);
    }

    function doActionAfterFillingShift(fillType, response) {
      var shiftInfo = [];
      var shiftObj = {};

      shiftInfo = pushInfoValuesToShift(response.updatedShiftDto);
      shiftObj = parseShift(shiftInfo);
      if (fillType === 'Post' && typeof response.postedEmployeeMap !== 'undefined' && response.postedEmployeeMap !== null) {
        shiftObj.posted = 'Posted ' + moment.tz(response.updatedShiftDto.postedDate, siteTimeZone).format('YYYY-MM-DD');
        shiftObj.requested = '';
      } else if (fillType === 'Edit') {
        shiftObj.posted = 'Posted ' + moment.tz(response.updatedShiftDto.postedDate, siteTimeZone).format('YYYY-MM-DD');
        shiftObj.requested = (response.updatedShiftDto.requested)? '(R)': '';
      }

      arrangeShift('replace', shiftObj);

      $scope.onFilterChanged(true);
      if (fillType === 'Edit') {
        applicationContext.setNotificationMsgWithValues('employee_schedules.SHIFT_UPDATED_SUCCESSFULLY', 'success', true);
      } else if (fillType === 'Post') {
        applicationContext.setNotificationMsgWithValues('employee_schedules.SHIFT_POSTED_SUCCESSFULLY', 'success', true);
      } else if (fillType === 'Assign') {
        applicationContext.setNotificationMsgWithValues('employee_schedules.SHIFT_FILLED_SUCCESSFULLY', 'success', true);
      }
    }

    $scope.openFillShiftModal = function(shift) {
      if (shift.external) {
        return;
      }

      var modalInstance = $modal.open({
        templateUrl: 'fillShiftPopupModal.html',
        controller: 'FillShiftPopupModalInstanceCtrl',
        windowClass: 'fill-shift-modal',
        resolve: {
          viewMode: function() {
            return $scope.viewMode.mode;
          },
          selectedSchedule: function() {
            return $scope.selectedSchedule;
          },
          selectedOpenShift: function() {
            return shift;
          }
        }
      });
      modalInstance.result.then(function(modalResult) {
        if (modalResult.action === 'Delete') {
          return dataService.deleteOS($scope.selectedSchedule.id, shift.id).then( function(response) {
            doActionAfterDeletingShift(shift);
          }, function(err) {
            applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
          });
        }

        var employeeId = null;
        if (modalResult.action === 'Assign') {
          employeeId = modalResult.employeeId;
        }
        var payLoad = {
          updateOpenShiftInfo: modalResult.shiftInfo,
          action: modalResult.action,
          employeeId: employeeId,
          comment: null,
          force: false,
          overrideOptions: null
        };

        dataService.manageOpenShift($scope.selectedSchedule.id, shift.id, payLoad).then(function(response) {
          doActionAfterFillingShift(modalResult.action, response);
        }, function(err) {
          applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
        });
      });
    };

    function doActionAfterAssigningShift(response) {
      var shiftInfo = [];
      var shiftObj = {};

      shiftInfo = pushInfoValuesToShift(response.shiftDto);
      shiftObj = parseShift(shiftInfo);

      arrangeShift('replace', shiftObj);

      $scope.onFilterChanged(true);
      applicationContext.setNotificationMsgWithValues('employee_schedules.SHIFT_ASSIGNED_SUCCESSFULLY', 'success', true);
    }

    $scope.openAssignShiftsModal = function(selectedEmployee) {
      var modalInstance = $modal.open({
        templateUrl: 'assignShiftsPopupModal.html',
        controller: 'AssignShiftsPopupModalInstanceCtrl',
        size: 'lg',
        windowClass: 'assign-shifts-modal',
        resolve: {
          selectedSchedule: function() {
            return $scope.selectedSchedule;
          },
          selectedEmployee: function() {
            return selectedEmployee;
          }
        }
      });
      modalInstance.result.then(function(modalResult) {
        if (modalResult.selectedOpenShiftId !== null) {
          dataService.assignShiftToEmployee($scope.selectedSchedule.id, modalResult.selectedOpenShiftId, selectedEmployee.id).then(function(response) {
            doActionAfterAssigningShift(response);
          }, function(err) {
            applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
          });
        }
      });
    };

    $scope.openOverrides = function () {
      $modal.open({
        templateUrl: 'modules/common/partials/schedule-settings-overrides.html',
        controller: 'ScheduleBuilderCreateSettingsCtrl',
        windowClass: 'overrides-modal',
        resolve: {
          selectedSchedule: function() {
            return $scope.selectedSchedule;
          }
        }
      });
    };

    $scope.hasMgmtPermission = function() {
      return authService.hasPermission('Tenant_Mgmt');
    };

    $scope.hasViewPermission = function () {
      return authService.hasPermission('Tenant_View');
    };

    wsService.registerConsumer({
      id: 'scheduleShiftActionsEventHandler',
      selector: function (key) {
        if ($scope.selectedSchedule) {
          var keySelector = '<ObjLifecycle><.*><><Shift><.*><.*>';
          return key.match(keySelector);
        }
        return false;
      },
      callback: function(key, serverEvent) {
        var shiftInfo = [];
        var shiftObj = {};

        shiftInfo = pushInfoValuesToShift(serverEvent);
        shiftObj = parseShift(shiftInfo);

        switch (key.eventType) {
          case 'Create':
            if (serverEvent.scheduleId !== $scope.selectedSchedule.id) {
              return;
            }

            if (typeof serverEvent.postedDate !== 'undefined' && serverEvent.postedDate !== null) {
              shiftObj.posted = 'Posted ' + moment.tz(serverEvent.postedDate, siteTimeZone).format('YYYY-MM-DD');
              shiftObj.requested = '';
            }
            arrangeShift('add', shiftObj);
            break;
          case 'Update':
            if (serverEvent.scheduleId !== $scope.selectedSchedule.id) {
              arrangeShift('remove', shiftObj);
              break;
            }

            arrangeShift('replace', shiftObj);
            break;
          case 'Delete':
            arrangeShift('remove', shiftObj);
            break;
          default:
            break;
        }

        $scope.onFilterChanged(true);
        $scope.$apply();
      },
      scope: $scope,
      params: []
    });

    wsService.registerConsumer({
      id: 'schedulePostedOpenShiftsEventHandler',
      selector: function (key) {
        if ($scope.selectedSchedule) {
          var keySelector = '<Schedule><.*>< PostedOSChange ><' + $scope.selectedSchedule.id + '>';
          return key.match(keySelector);
        }
        return false;
      },
      callback: function(key, serverEvent) {
        if (key.eventType === 'PostedOSChange' && serverEvent !== null) {
          EmployeeSchedulesService.getPostedOpenShifts($scope.selectedSchedule.id).then(function(response) {
            angular.forEach(response.result, function(shiftInfo) {
              var arrayInfo = [];

              arrayInfo.push(shiftInfo.shiftId, shiftInfo.excess, shiftInfo.teamId, null); //id, excess, team id, employee id
              arrayInfo.push(shiftInfo.skillId, shiftInfo.skillAbbrev, shiftInfo.startDateTime, shiftInfo.endDateTime); // skill id, skill abbrev, start, end
              arrayInfo.push(0, shiftInfo.comments); // paid time, comment

              var shiftObj = parseShift(arrayInfo);
              arrangeShift('replace', shiftObj);
            });
          });
        }
      },
      scope: $scope,
      params: []
    });
  }
]);

angular.module('emlogis.employeeSchedules').controller('ManageOpenShiftsPopupModalInstanceCtrl', ['$scope', '$modalInstance', '$timeout', '$filter', 'appFunc', 'applicationContext', 'EmployeeSchedulesService', 'siteId', 'scheduleId', 'dateRangeStart', 'dateRangeEnd', 'timezone',
  function ($scope, $modalInstance, $timeout, $filter, appFunc, applicationContext, EmployeeSchedulesService, siteId, scheduleId, dateRangeStart, dateRangeEnd, timezone) {

    $scope.data = {
      originalOpenShifts: [],
      openShifts: [],
      selectedOpenShifts: [],
      employees: [],
      selectedEmployees: [],
      qualificationSummary: {},
      qualificationSummaryDisplayed: false,
      comments: '',
      deadline: moment.tz([new Date().getFullYear(), new Date().getMonth(), new Date().getDate() + 7], timezone).unix() * 1000,
      terms: 'AutoApprove',
      postingRulesShown: false,
      messages: [],
      operationRun: false
    };

    $scope.loadingState = {
      populatingOverrideOptions: true,
      populatingOpenShifts: true,
      loadingEligibilityData: null,
      postingOpenShifts: false
    };

    $scope.options = {
      firstRequestOnly: true,
      overrideOptions: {},
      allOverrideOptions: false
    };

    $scope.checkboxModel = {
      notPostedOnly: false,
      requested: false
    };

    $scope.datePickerModel = {
      postUntil: new Date(new Date().getFullYear(), new Date().getMonth(), new Date().getDate() + 7),
      datePickerOpened: false,
      datePickerOptions: {
        formatYear: 'yyyy',
        startingDay: 1
      },
      openDatePicker: function($event) {
        $event.preventDefault();
        $event.stopPropagation();

        $scope.datePickerModel.datePickerOpened = true;
      }
    };

    $scope.toggleAllOverrideOptions = function() {
      if ($scope.options.allOverrideOptions) {
        $scope.options.overrideOptions.TEAM_FLOAT_ON = true;
        $scope.options.overrideOptions.AVOID_OVERTIME = true;
        $scope.options.overrideOptions.ALL_DAY_UNAVAILABLE_OVERRIDE = true;
        $scope.options.overrideOptions.TIME_WINDOW_UNAVAILABLE_OVERRIDE = true;
        $scope.options.overrideOptions.MAX_DAYS_WEEK_OVERRIDE = true;
        $scope.options.overrideOptions.MAX_CONSECUTIVE_DAYS_OVERRIDE = true;
        $scope.options.overrideOptions.MAX_HOURS_WEEK_OVERRIDE = true;
        $scope.options.overrideOptions.MIN_HOURS_WEEK_OVERRIDE = true;
        $scope.options.overrideOptions.MAX_HOURS_DAY_OVERRIDE = true;
        $scope.options.overrideOptions.MIN_HOURS_DAY_OVERRIDE = true;
      } else {
        $scope.options.overrideOptions.TEAM_FLOAT_ON = false;
        $scope.options.overrideOptions.AVOID_OVERTIME = false;
        $scope.options.overrideOptions.ALL_DAY_UNAVAILABLE_OVERRIDE = false;
        $scope.options.overrideOptions.TIME_WINDOW_UNAVAILABLE_OVERRIDE = false;
        $scope.options.overrideOptions.MAX_DAYS_WEEK_OVERRIDE = false;
        $scope.options.overrideOptions.MAX_CONSECUTIVE_DAYS_OVERRIDE = false;
        $scope.options.overrideOptions.MAX_HOURS_WEEK_OVERRIDE = false;
        $scope.options.overrideOptions.MIN_HOURS_WEEK_OVERRIDE = false;
        $scope.options.overrideOptions.MAX_HOURS_DAY_OVERRIDE = false;
        $scope.options.overrideOptions.MIN_HOURS_DAY_OVERRIDE = false;
      }
    };

    $scope.parseDeadline = function() {
      var yearVal = $scope.datePickerModel.postUntil.getFullYear();
      var monthVal = $scope.datePickerModel.postUntil.getMonth();
      var dateVal = $scope.datePickerModel.postUntil.getDate();
      var dateInArrFormat = [yearVal, monthVal, dateVal];
      $scope.data.deadline = moment.tz(dateInArrFormat, timezone).unix() * 1000;
    };

    $scope.parseTerms = function() {
      if ($scope.options.firstRequestOnly) {
        $scope.data.terms = 'AutoApprove';
      } else {
        $scope.data.terms = 'Manager Review';
      }
    };

    $scope.togglePostingRulesPopup = function(employeeListUpdateNeeded) {
      if (employeeListUpdateNeeded) {
        $scope.getEligibilityDataFromSelectedEntities();
      }
      $scope.data.postingRulesShown = !$scope.data.postingRulesShown;
    };

    $scope.getOverrideOptions = function() {
      $scope.loadingState.populatingOverrideOptions = true;
      EmployeeSchedulesService.getOverrideOptions(siteId).then(function(response) {
        $scope.options.overrideOptions = response.data.overrideOptions;
      }, function(err) {
        $scope.data.messages.push({type: 'danger', msg: $filter('translate')('employee_schedules.OVERRIDE_OPTIONS_GET_ERROR')});
      }).finally(function() {
        $scope.loadingState.populatingOverrideOptions = false;
      });
    };

    $scope.updateOverrideOptions = function() {
      EmployeeSchedulesService.updateOverrideOptions(siteId, $scope.options.overrideOptions).then(function(overrideOptionsResponse) {
        $scope.data.messages.push({type: 'success', msg: $filter('translate')('employee_schedules.OVERRIDE_OPTIONS_UPDATED_SUCCESSFULLY')});
      }, function(overrideOptionsErr) {
        $scope.data.messages.push({type: 'danger', msg: $filter('translate')('employee_schedules.OVERRIDE_OPTIONS_UPDATED_ERROR')});
      });
    };

    $scope.openShiftsGridOptions = {
      data: 'data.openShifts',
      enableRowSelection: true,
      enableSelectAll: true,
      multiSelect: true,
      columnDefs: [
        { field: 'shiftId', visible: false },
        { field: 'shift', width: '200', enableSorting: false },
        { field: 'teamName', width: '100' },
        { field: 'skillName', width: '100' },
        { field: 'posted', width: '90',
          cellClass: function(grid, row, col, rowRenderIndex, colRenderIndex) {
            if (grid.getCellValue(row,col) !== '-') {
              return 'cell-bold';
            }
          }
        },
        { field: 'req', width: '70',
          cellClass: function(grid, row, col, rowRenderIndex, colRenderIndex) {
            if (grid.getCellValue(row,col).charAt(0) !== '-') {
              return 'cell-req-bold cell-bold';
            }
          }
        }
      ]
    };

    $scope.processSelectedRow = function(gridName, row) {
      if (row.isSelected) {
        if (gridName === 'openShifts') {
          $scope.data.selectedOpenShifts.push(row.entity);
          $scope.data.employees = [];
          $scope.data.selectedEmployees = [];
        } else {
          $scope.data.selectedEmployees.push(row.entity);
        }
      } else {
        if (gridName === 'openShifts') {
          $scope.data.selectedOpenShifts = _.filter($scope.data.selectedOpenShifts, function(entity){ return entity.shiftId !== row.entity.shiftId; });
          $scope.data.employees = [];
          $scope.data.selectedEmployees = [];
        } else {
          $scope.data.selectedEmployees = _.filter($scope.data.selectedEmployees, function(entity){ return entity.id !== row.entity.id; });
        }
      }
    };

    $scope.openShiftsGridOptions.onRegisterApi = function(gridApi) {
      gridApi.selection.on.rowSelectionChanged($scope, function (row) {
        $scope.processSelectedRow('openShifts', row);
      });

      gridApi.selection.on.rowSelectionChangedBatch($scope, function (rows) {
        angular.forEach(rows, function (row) {
          $scope.processSelectedRow('openShifts', row);
        });
      });
    };

    function comparator(firstElement, secondElement) {
      var firstValue = firstElement.startDateTime;
      var secondValue = secondElement.startDateTime;

      if (firstValue < secondValue) {
        return -1;
      } else if (firstValue > secondValue) {
        return 1;
      } else {
        return 0;
      }
    }

    $scope.populateOpenShifts = function() {
      $scope.data.openShifts = [];
      $scope.data.selectedOpenShifts = [];
      $scope.data.employees = [];
      $scope.data.selectedEmployees = [];
      EmployeeSchedulesService.getOpenShifts(scheduleId, dateRangeStart, dateRangeEnd).then(function(response) {
        $scope.data.openShifts = response.data.result;
        angular.forEach($scope.data.openShifts, function(openShift) {
          var startMomentObj = moment.tz(openShift.startDateTime, timezone);
          var endMomentObj = moment.tz(openShift.endDateTime, timezone);
          var startTimeStr = '';
          var endTimeStr = '';
          if (startMomentObj.minutes() > 0) {
            startTimeStr = startMomentObj.format('hh:mma');
          } else {
            startTimeStr = startMomentObj.format('hha');
          }
          if (endMomentObj.minutes() > 0) {
            endTimeStr = endMomentObj.format('hh:mma');
          } else {
            endTimeStr = endMomentObj.format('hha');
          }
          var shiftStr = startMomentObj.format('MMMM DD, YYYY, ') + startTimeStr + ' - ' + endTimeStr;

          openShift.shift = shiftStr;
          openShift.posted = (typeof openShift.postId === 'undefined' || openShift.postId === null || openShift.postId === 0)? '-': moment.tz(openShift.postId, timezone).format('MM/DD/YYYY');
          var reqCountStr = (openShift.reqCount === 0)? '-': openShift.reqCount;
          var empCountStr = (openShift.empCount === 0)? '-': openShift.empCount;
          openShift.req = reqCountStr + '/' + empCountStr;
        });
        $scope.loadingState.populatingOpenShifts = false;
        $scope.data.openShifts.sort(comparator);
        $scope.data.originalOpenShifts = angular.copy($scope.data.openShifts);
        $timeout(function () {
          $('.open-shifts-grid').resize();

          // Make font bold for entire row which has req > 0
          angular.forEach($('.cell-req-bold'), function(reqCell) {
            $(reqCell).parent().css('font-weight', 900);
          });
        }, 0);
      }, function(err) {
        $scope.data.messages.push({type: 'danger', msg: $filter('translate')('employee_schedules.POPULATING_OPEN_SHIFTS_ERROR')});
      });
    };

    function formatShiftTime(startDateTime, endDateTime, timezone) {
      var shiftStartDate =  moment.tz(startDateTime, timezone);
      var shiftEndDate =  moment.tz(endDateTime, timezone);
      return appFunc.toShortest12TimeFormat(shiftStartDate) + "-" + appFunc.toShortest12TimeFormat(shiftEndDate);
    }

    $scope.filterDisplayedShifts = function() {
      $scope.data.openShifts = [];
      $scope.data.selectedOpenShifts = [];
      $scope.data.employees = [];
      $scope.data.selectedEmployees = [];

      angular.forEach($scope.data.originalOpenShifts, function(openShift) {
        if ($scope.checkboxModel.notPostedOnly) {
          if (openShift.postId > 0) {
            return;
          }
        }
        if ($scope.checkboxModel.requested) {
          if (openShift.reqCount <=0) {
            return;
          }
        }
        $scope.data.openShifts.push(openShift);
      });
    };

    $scope.getEligibilityDataFromSelectedEntities = function() {
      $scope.data.employees = [];
      $scope.data.selectedEmployees = [];
      $scope.loadingState.loadingEligibilityData = true;
      var payLoad = {
        includeConstraintViolationSummary: true,
        maxSynchronousWaitSeconds: 180,
        maxComputationTime: 180,
        maximumUnimprovedSecondsSpent: 100,
        employeeIds: null,
        shiftIds: _.map($scope.data.selectedOpenShifts, 'shiftId'),
        startDateTime: dateRangeStart,
        endDateTime: dateRangeEnd,
        overrideOptions: $scope.options.overrideOptions
      };
      EmployeeSchedulesService.getEligibilityDataFromSelectedEntities(scheduleId, payLoad).then(function(response) {
        $scope.data.qualificationSummary = response.data.constraintViolationSummary;
        angular.forEach($scope.data.qualificationSummary.constraintViolations, function(violation) {
          violation.shiftTime
              = formatShiftTime(violation.shiftStartDateTime, violation.shiftEndDateTime, timezone);
          violation.shiftDate = moment.tz(violation.shiftStartDateTime, timezone).format('M/D/YY');
        });
        $scope.data.qualificationSummary.constraintViolations.sort(constraintViolationsComparator);
        angular.forEach(response.data.openShifts, function(openShift) {
          var foundIndex = _.findIndex($scope.data.openShifts, 'shiftId', openShift.id);
          $scope.data.openShifts[foundIndex].eligibleEmployees = openShift.employees;

          angular.forEach(openShift.employees, function(employee) {
            if (_.findIndex($scope.data.employees, 'id', employee.id) < 0) {
              $scope.data.employees.push(employee);
            }
          });
        });
        $timeout(function () {
          $('.employees-grid').resize();
        }, 0);
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
      }).finally(function() {
        $scope.loadingState.loadingEligibilityData = false;
      });
    };

    function constraintViolationsComparator(violation1, violation2) {
      if(violation1.shiftStartDateTime < violation2.shiftStartDateTime) {
        return -1;
      } else if(violation1.shiftStartDateTime > violation2.shiftStartDateTime){
        return 1;
      }
      var employee1Name = violation1.employeeFirstName + violation1.employeeLastName;
      var employee2Name = violation2.employeeFirstName + violation2.employeeLastName;
      if(employee1Name < employee2Name) {
        return -1;
      } else if(employee1Name > employee2Name) {
        return 1;
      }
      return 0;
    }

    $scope.toggleQualificationSummary = function() {
      $scope.data.qualificationSummaryDisplayed = !$scope.data.qualificationSummaryDisplayed;
    };

    $scope.employeesGridOptions = {
      data: 'data.employees',
      enableRowSelection: true,
      enableSelectAll: true,
      multiSelect: true,
      columnDefs: [
        { field: 'id', visible: false},
        { field: 'name'},
        { field: 'homeTeamName'}
      ]
    };

    $scope.employeesGridOptions.onRegisterApi = function(gridApi) {
      gridApi.selection.on.rowSelectionChanged($scope, function (row) {
        $scope.processSelectedRow('employees', row);
      });

      gridApi.selection.on.rowSelectionChangedBatch($scope, function (rows) {
        angular.forEach(rows, function (row) {
          $scope.processSelectedRow('employees', row);
        });
      });
    };

    $scope.postOpenShifts = function() {
      $scope.loadingState.postingOpenShifts = true;
      var openShifts = {};
      angular.forEach($scope.data.selectedOpenShifts, function(selectedOpenShift) {
        openShifts[selectedOpenShift.shiftId] = [];
        angular.forEach($scope.data.selectedEmployees, function(selectedEmployee) {
          if (_.findIndex(selectedOpenShift.eligibleEmployees, 'id', selectedEmployee.id) > -1) {
            openShifts[selectedOpenShift.shiftId].push(selectedEmployee.id);
          }
        });
        if (openShifts[selectedOpenShift.shiftId].length === 0) {
          delete openShifts[selectedOpenShift.shiftId];
        }
      });

      var payLoad = {
        comments: $scope.data.comments,
        terms: $scope.data.terms,
        deadline: $scope.data.deadline,
        overrideOptions: $scope.options.overrideOptions,
        openShifts: openShifts
      };

      EmployeeSchedulesService.postOpenShifts(scheduleId, payLoad).then(function(openShiftsResponse) {
        $scope.data.messages.push({type: 'success', msg: openShiftsResponse.data.result.length + ' ' + $filter('translate')('employee_schedules.OPEN_SHIFTS_POSTED_SUCCESSFULLY')});
        $scope.data.operationRun = true;
      }, function(openShiftsErr) {
        $scope.data.messages.push({type: 'danger', msg: $filter('translate')('employee_schedules.OPEN_SHIFTS_POSTED_ERROR')});
      }).finally(function() {
        $scope.loadingState.postingOpenShifts = false;
        $scope.populateOpenShifts();
      });
    };

    $scope.closeMessage = function(index) {
      $scope.data.messages.splice(index, 1);
    };

    $scope.close = function () {
      $modalInstance.close({openShiftsPosted: $scope.data.operationRun});
    };

    $scope.getOverrideOptions();
    $scope.populateOpenShifts();
  }]);

angular.module('emlogis.employeeSchedules').controller('ExceptionsModalInstanceCtrl', ['$scope', '$modalInstance', 'applicationContext', 'dataService', 'scheduleId',
  function ($scope, $modalInstance, applicationContext, dataService, scheduleId) {
    $scope.data = {
      exceptions: null,
      exceptionsLoaded: null
    };

    $scope.close = function () {
      $modalInstance.dismiss('cancel');
    };

    dataService.getScheduleExceptions(scheduleId).then(function(response) {
      $scope.data.exceptions = response.data;
    }, function(err) {
      applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
    }).finally(function() {
      $scope.data.exceptionsLoaded = true;
    });
  }]);

angular.module('emlogis.employeeSchedules').controller('PromoteScheduleConfirmationModalInstanceCtrl', ['$scope', '$modalInstance', '$filter', 'currentScheduleStatus',
  function ($scope, $modalInstance, $filter, currentScheduleStatus) {
    $scope.modalTitle = null;
    $scope.modalText = null;

    if (currentScheduleStatus === 'Production') {
      $scope.modalTitle = $filter('translate')('employee_schedules.POST_SCHEDULE');
      $scope.modalText = $filter('translate')('employee_schedules.POST_CONFIRMATION_MESSAGE');
    } else {
      $scope.modalTitle = $filter('translate')('employee_schedules.PROMOTE_SCHEDULE');
      $scope.modalText = $filter('translate')('employee_schedules.PROMOTE_CONFIRMATION_MESSAGE');
    }

    $scope.confirmToPromote = function() {
      $modalInstance.close({answer: true});
    };

    $scope.close = function () {
      $modalInstance.dismiss('cancel');
    };
  }]);

angular.module('emlogis.employeeSchedules').directive('shiftTimeLine',
  function() {
    return {
      restrict: 'A',
      link: function (scope, elem, attrs) {
        scope.timeLineWidth = attrs.width;
        scope.maxHours = 48;

        scope.$on('event:updateShift', function (event, args) {
          init();
        });

        function init() {
          elem.resizable({handles: 'w,e', containment: 'parent', grid: [scope.data.step, 1], minWidth : 1});
        }

        elem.on('resizestop', function (evt, ui) {
          scope.$apply(function() {
            scope.$eval(attrs.firstpos + '=' + ui.position.left);
            scope.$eval(attrs.endpos + '=' + (ui.size.width + 2));
            scope.data.swapShift = false;
            scope.getWipEligibleEmployees();
          });
        });

        scope.initShiftEditForm();
        init();
      }
    };
  });

angular.module('emlogis.employeeSchedules').controller('ManageScheduleShiftPopupModalInstanceCtrl', ['$scope', '$modalInstance', '$timeout', 'dataService', 'applicationContext', 'selectedSchedule', 'selectedShift', 'selectedEmployee',
  function ($scope, $modalInstance, $timeout, dataService, applicationContext, selectedSchedule, selectedShift, selectedEmployee) {
    var siteId = selectedSchedule.siteInfo[0];
    var timezone = selectedSchedule.siteInfo[2];

    $scope.watchers = {};

    $scope.removeWatchers = function() {
      for (var i in $scope.watchers) {
        $scope.watchers[i]();
      }
    };

    $scope.data = {
      selectedEmployee: selectedEmployee,
      teamName: selectedShift.teamName,
      skillName: selectedShift.skillName,
      swapShift: false,
      eligibleEmployeesLoaded: null,
      eligibleEmployees: [],
      qualificationSummary: {},
      qualificationSummaryDisplayed: false,
      eligibleShiftsLoaded: false,
      eligibleShifts: [],
      eligibleShiftsGridOptions: {
        data: 'data.eligibleShifts',
        enableRowSelection: true,
        enableSelectAll: false,
        multiSelect: false,
        columnDefs: [
          { name: 'shiftId', visible: false },
          { name: 'employeeId', visible: false },
          { name: 'employeeName', width: 140 },
          { name: 'teamName', width: 100 },
          { name: 'skillName', width: 120 },
          { name: 'date', width: 80 },
          { name: 'shift', width: 150, sortable: false }
        ],
        onRegisterApi: function(gridApi) {
          $scope.gridApi = gridApi;
          gridApi.selection.on.rowSelectionChanged($scope, function(row) {
            if (row.isSelected) {
              $scope.data.newSelectedShift = row.entity;
            } else {
              $scope.data.newSelectedShift = null;
            }
          });
        }
      },
      dropShiftReasonsAndAbsenceTypes: [],
      comment: selectedShift.comment
    };
    $scope.data.formattedTime = moment.tz(selectedShift.start, timezone).format('dddd, MM/DD/YYYY h:mma') + '-' +
      moment.tz(selectedShift.end, timezone).format('h:mma');

    $scope.hasNewShift = function() {
      if (typeof $scope.data.endPtoDate === 'undefined' || $scope.data.endPtoDate === null ||
        typeof $scope.data.startPtoDate === 'undefined' || $scope.data.startPtoDate === null) {
        return false;
      }

      if ($scope.data.endPtoDate.unix() > $scope.data.startPtoDate.unix()) {
        return true;
      }

      return false;
    };

    $scope.toggleQualificationSummary = function() {
      $scope.data.qualificationSummaryDisplayed = !$scope.data.qualificationSummaryDisplayed;
    };

    $scope.getWipEligibleEmployees = function() {
      if ($scope.data.action !== 'CreateAndAssign') {
        return;
      }

      $scope.data.eligibleEmployeesLoaded = false;
      $scope.data.eligibleEmployees = [];
      var shiftInfo = {
        teamId: selectedShift.teamId,
        skillId: selectedShift.skillId,
        start: $scope.data.startPtoDate.unix() * 1000,
        end: $scope.data.endPtoDate.unix() * 1000
      };

      dataService.getWipEligibleEmployeesForProposedOpenShift(selectedSchedule.id, shiftInfo).then(function(result) {
        $scope.data.qualificationSummary = result.data.constraintViolationSummary;
        $scope.data.eligibleEmployees = result.data.eligibleEmployees;
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
      }).finally(function() {
        $scope.data.eligibleEmployeesLoaded = true;
      });
    };

    $scope.getSwapEligibleShifts = function() {
      $scope.data.eligibleShiftsLoaded = false;
      $scope.data.eligibleShifts = [];
      dataService.getSwapEligibleShiftsForShift(selectedEmployee.id, selectedShift.id).then(function(result) {
        angular.forEach(result.data.swappableShifts, function(shift) {
          shift.date = moment.tz(shift.startDateTime, timezone).format('MM/DD/YYYY');
          shift.shift = moment.tz(shift.startDateTime, timezone).format('hh:mma') + ' - ' +
            moment.tz(shift.endDateTime, timezone).format('hh:mma');
          $scope.data.eligibleShifts.push(shift);
        });
        $timeout(function() {
          $('.eligible-shifts-grid').resize();
        }, 0);
      }, function(err) {
        var message = err.data.message || JSON.stringify(err.data);
        applicationContext.setNotificationMsgWithValues(message, 'danger', true);
      }).finally(function() {
        $scope.data.eligibleShiftsLoaded = true;
      });
    };

    $scope.initTimeLine = function() {
      var timeLineWidth = $scope.timeLineWidth;
      var startDateLine = moment.tz($scope.data.selectedShift.start, timezone);
      startDateLine.hours(startDateLine.hours() - $scope.hoursBeforeAfter).minutes(0).seconds(0).milliseconds(0);
      startDateLine.hours(startDateLine.hours() + startDateLine.hours()%2).minutes(0).seconds(0).milliseconds(0);
      var endDateLine = moment.tz($scope.data.selectedShift.end, timezone);
      endDateLine.hours(endDateLine.hours() + $scope.hoursBeforeAfter).minutes(0).seconds(0).milliseconds(0);
      var hoursN = (endDateLine.unix() - startDateLine.unix()) / 3600;

      var koef = 1;
      if (hoursN > 12) {
        koef = Math.ceil(hoursN / 12);
        switch (koef) {
          case 5:
            koef = 6;
            break;
          case 7:
            koef = 8;
            break;
          default:
            if (koef > 8 && koef <= 12) {
              koef = 12;
            } else if (koef > 12) {
              koef = 24;
            }
        }
        //koef = Math.pow(2, Math.floor(hoursN / 12));
      }
      $scope.hours = [];
      for (var i = 0; i < hoursN / koef; i++) {
        var temp = moment.tz(startDateLine, timezone);
        temp.hours(temp.hours() + i * koef);
        $scope.hours[i] = temp;
      }

      var minStep = 15;
      //var minStep = 15 * Math.pow(2, Math.floor(Math.sqrt(koef1)) - 1);
      //if (minStep > 60) {
      //    minStep = 60;
      //}
      $scope.data.step = timeLineWidth / (hoursN * (60 / minStep));

      var controlDate = moment.tz($scope.hours[$scope.hours.length - 1], timezone);
      controlDate.hours(controlDate.hours() + koef);
      if (controlDate.unix() > endDateLine.unix()) {
        endDateLine = controlDate;
      }

      var lineDiff = (endDateLine.unix() - startDateLine.unix()) * 1000;
      var startPoint = ($scope.data.startDate.unix() - startDateLine.unix()) * 1000;
      var duration = ($scope.data.endDate.unix() - $scope.data.startDate.unix()) * 1000;

      $scope.data.shiftModel = {
        start: startPoint * timeLineWidth / lineDiff,
        width: duration * timeLineWidth / lineDiff
      };

      $scope.data.newShiftModel.start = ($scope.data.startPtoDate.unix() - startDateLine.unix()) * 1000 * timeLineWidth / lineDiff;
      $scope.data.newShiftModel.width = ($scope.data.endPtoDate.unix() - $scope.data.startPtoDate.unix()) * 1000 * timeLineWidth / lineDiff;

      $scope.data.limits = {
        start: ($scope.data.selectedShift.start - startDateLine.unix() * 1000) * timeLineWidth / lineDiff,
        end: ($scope.data.selectedShift.end - startDateLine.unix() * 1000) * timeLineWidth / lineDiff
      };

      $scope.watchers.shiftModel = $scope.$watch('[data.shiftModel.start, data.shiftModel.width]', function (newValue, oldValue) {
        $scope.data.startDate = moment.tz(roundTime((newValue[0] * lineDiff) / timeLineWidth + startDateLine.unix() * 1000, minStep), timezone);
        $scope.data.endDate = moment.tz(roundTime((newValue[1] * lineDiff) / timeLineWidth + $scope.data.startDate.unix() * 1000, minStep), timezone);
        $scope.data.dropShitAttempt = false;

        var newVal = {
          start: newValue[0],
          width: newValue[1]
        };

        var oldVal = {
          start: oldValue[0],
          width: oldValue[1]
        };

        var shiftModel = {
          start: newVal.start,
          width: newVal.width
        };
        var newShiftModel = angular.copy($scope.data.newShiftModel);

        angular.forEach(newValue, function(value, key) {
          if (newValue[key] < 0) {
            newValue[key] = 0;
          }
        });

        if (!$scope.hasNewShift()) {
          if (newVal.start > oldVal.start) {
            newShiftModel.start = $scope.data.limits.start;
            if ((newVal.start - $scope.data.limits.start) > 0) {
              newShiftModel.width = newVal.start - $scope.data.limits.start;
            } else {
              newShiftModel.width = 0;
            }
            newShiftModel.position = 'before';
          } else if (newVal.width < oldVal.width) {
            newShiftModel.start = newVal.start + newVal.width;
            if (($scope.data.limits.end - newVal.width) > 0) {
              newShiftModel.width = $scope.data.limits.end - (newVal.width + newVal.start);
            } else {
              newShiftModel.width = 0;
            }
            newShiftModel.position = 'after';
          }
        } else if (newShiftModel.position == 'before') {
          if ((newVal.start > oldVal.start)) {
            newShiftModel.width += (newVal.start - oldVal.start);
          } else if (newVal.start >= newShiftModel.start) {
            newShiftModel.width = newShiftModel.width - (oldVal.start - newVal.start);
          } else {
            newShiftModel.start = newVal.start;
            newShiftModel.width = 0;
          }
          //} else if (newShiftModel.position == 'after' && $scope.backUpEndDate.getTime() != $scope.endDate.getTime()) {
        } else if (newShiftModel.position == 'after' && (
          ( Math.abs((newVal.start + newVal.width) - (oldVal.start + oldVal.width)) > 3 ))) {
          var widthDiff = newVal.width - oldVal.width;
          if ((newVal.width < oldVal.width)) {
            newShiftModel.start += widthDiff;
            newShiftModel.width -= widthDiff;

          } else if ((newVal.start + newVal.width) < (newShiftModel.start + newShiftModel.width) &&
            (newVal.start + newVal.width) > newShiftModel.start) {
            newShiftModel.start += widthDiff;
            newShiftModel.width -= widthDiff;
          } else {
            newShiftModel.start = newVal.start;
            newShiftModel.width = 0;
          }
        }

        if ($scope.hasNewShift()) {
          if (newShiftModel.position == 'before' && (newVal.width < oldVal.width) &&
            ((newVal.width + newVal.start) < $scope.data.limits.end)) {
            shiftModel.width = Math.abs($scope.data.limits.end - newVal.start);
          }

          if (newShiftModel.position == 'after' && (newVal.width < oldVal.width) &&
            (shiftModel.start > $scope.data.limits.start)) {
            shiftModel.start = $scope.data.limits.start;
            shiftModel.width = Math.abs(newShiftModel.start - $scope.data.limits.start);
          }

          if (shiftModel.start + shiftModel.width > newShiftModel.start  && newShiftModel.position == 'after'){
            var diff = shiftModel.start + shiftModel.width - newShiftModel.start;
            newShiftModel.width -= diff;
            newShiftModel.start += diff;
          }
        }

        $scope.data.shiftModel = angular.copy(shiftModel);
        $scope.data.newShiftModel = angular.copy(newShiftModel);
        $scope.data.startPtoDate = moment.tz(roundTime(($scope.data.newShiftModel.start * lineDiff) / timeLineWidth + startDateLine.unix() * 1000, minStep), timezone);
        $scope.data.endPtoDate = moment.tz(roundTime(($scope.data.newShiftModel.width * lineDiff) / timeLineWidth + $scope.data.startPtoDate.unix() * 1000, minStep), timezone);
      }, true);

      function roundTime(time, min) {
        return (Math.round(time / 1000 / 60 / min)) * min * 60 * 1000;
      }
    };

    $scope.initShiftEditForm = function() {
      $scope.hoursBeforeAfter = 4;
      if (typeof $scope.gridApi !== 'undefined' && $scope.gridApi !== null) {
        $scope.gridApi.selection.clearSelectedRows();
      }

      $scope.data = _.assign($scope.data, {
        selectedShift: angular.copy(selectedShift),
        newFillEmployee: null,
        newSelectedShift: null,
        startDate: moment.tz(selectedShift.start, timezone),
        endDate: moment.tz(selectedShift.end, timezone),
        startPtoDate: moment.tz(selectedShift.start, timezone),
        endPtoDate: moment.tz(selectedShift.start, timezone),
        newShiftModel: {
          start: 0,
          width: 0,
          position: ''
        },
        action: 'CreateAndDelete',
        changeToPto: false,
        selectedDropShiftReasonAndAbsenceType: null
      });

      $scope.initTimeLine();
    };

    $scope.onSwapShiftChanged = function() {
      console.log("onSwapShiftChanged");

      $scope.data.dropShitAttempt = false;
      $scope.initShiftEditForm();
      if ($scope.data.swapShift) {
        $scope.getSwapEligibleShifts();
      }
    };

    $scope.onDropShiftAttempt = function() {
      $scope.data.dropShitAttempt = true;

      dataService.getDropShiftReasonsAndAbsenceTypes(siteId).then(function(result) {
        $scope.data.dropShiftReasonsAndAbsenceTypes = result.data;
        $scope.data.selectedDropShiftReasonAndAbsenceType = $scope.data.dropShiftReasonsAndAbsenceTypes[0];
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
      });
    };

    $scope.zoomIn = function() {
      if ($scope.hoursBeforeAfter > 1) {
        $scope.hoursBeforeAfter /= 2;

        var tempStartDateLine = moment.tz($scope.data.selectedShift.start, timezone);
        tempStartDateLine.hours(tempStartDateLine.hours() - $scope.hoursBeforeAfter).minutes(0).seconds(0).milliseconds(0);
        var tempEndDateLine = moment.tz($scope.data.selectedShift.end, timezone);
        tempEndDateLine.hours(tempEndDateLine.hours() + $scope.hoursBeforeAfter).minutes(0).seconds(0).milliseconds(0);
        if (tempStartDateLine.unix() <= $scope.data.startDate.unix() &&
          tempEndDateLine.unix() >= $scope.data.endDate.unix()) {
          $scope.updateTimeLine();
          return true;
        } else {
          $scope.hoursBeforeAfter *= 2;
          return false;
        }
      }
    };

    $scope.zoomOut = function() {
      $scope.hoursBeforeAfter *= 2;

      var tempStartDateLine = moment.tz($scope.data.selectedShift.start, timezone);
      tempStartDateLine.hours(tempStartDateLine.hours() - $scope.hoursBeforeAfter).minutes(0).seconds(0).milliseconds(0);
      var tempEndDateLine = moment.tz($scope.data.selectedShift.end, timezone);
      tempEndDateLine.hours(tempEndDateLine.hours() + $scope.hoursBeforeAfter).minutes(0).seconds(0).milliseconds(0);
      if ((tempEndDateLine.unix() - tempStartDateLine.unix()) < ($scope.maxHours * 3600)) {
        $scope.updateTimeLine();
        return true;
      } else {
        $scope.hoursBeforeAfter /= 2;
        return false;
      }
    };

    $scope.zoomBest = function() {
      var i = true;
      while(i) {
        i = $scope.zoomIn();
      }
    };

    $scope.updateTimeLine = function() {
      $scope.removeWatchers();
      $scope.$broadcast('event:updateShift');

      $scope.initTimeLine();
    };

    $scope.dropShift = function() {
      $modalInstance.close({operation: 'drop', dropShiftReasonId: $scope.data.selectedDropShiftReasonAndAbsenceType.name});
    };

    $scope.submit = function() {
      var result = null;
      var startTime = null;
      var endTime = null;
      var newShiftStartTime = null;
      var newShiftEndTime = null;

      if ($scope.data.swapShift) {
        result = {
          operation: 'swap',
          newSelectedShift: $scope.data.newSelectedShift
        };
      } else {
        startTime = $scope.data.startDate.unix() * 1000;
        endTime = $scope.data.endDate.unix() * 1000;
        result = {
          operation: 'update',
          startTime: startTime,
          endTime: endTime
        };
        if ($scope.hasNewShift()) {
          newShiftStartTime = $scope.data.startPtoDate.unix() * 1000;
          newShiftEndTime = $scope.data.endPtoDate.unix() * 1000;
          result.newShiftStartTime = newShiftStartTime;
          result.newShiftEndTime = newShiftEndTime;
          if ($scope.data.changeToPto) {
            result.ptoType = $scope.data.selectedAbsenceType;
          }
          result.spaceOperation = $scope.data.action;
          if ($scope.data.action === 'CreateAndAssign') {
            result.newFillEmployee = $scope.data.newFillEmployee;
          }
        }
      }
      result.comment = $scope.data.comment;
      $modalInstance.close(result);
    };

    $scope.close = function () {
      $modalInstance.dismiss('cancel');
    };
  }]);

angular.module('emlogis.employeeSchedules').controller('AddNewShiftPopupModalInstanceCtrl', ['$scope', '$modalInstance', '$timeout', '$filter', 'applicationContext', 'dataService', 'viewMode', 'selectedSchedule',
  function ($scope, $modalInstance, $timeout, $filter, applicationContext, dataService, viewMode, selectedSchedule) {
    var siteId = selectedSchedule.siteInfo[0];
    var scheduleId = selectedSchedule.id;
    var timezone = selectedSchedule.siteInfo[2];
    var teams = [];

    $scope.data = {
      selectedScheduleStatus: selectedSchedule.status,
      teams: _.filter(selectedSchedule.teamsInfo.result, function(teamInfo) {
        var isHomeTeam = teamInfo[2];
        return !isHomeTeam;
      }),
      skills: [],
      selectedTeam: null,
      selectedSkill: null,
      shiftTime: {
        start: null,
        end: null
      },
      shiftTimeRangeInvalid: true,
      selectedOperationType: 'addAsOpenShift',
      qualificationSummary: {},
      qualificationSummaryDisplayed: false,
      selectedEligibleEmployee: null,
      eligibleEmployees: [],
      eligibleEmployeesLoaded: true,
      showAvailableOnly: true,
      employeeCalendarHeaderCells: [],
      employeeCalendarShifts: {},
      employeeCalendarShiftsRowHeight: '51px',
      employeeCalendarAvailItems: {},
      employeeCalendarAvailItemsRowHeight: '26px',
      employeeCalendarPrefItems: {},
      employeeCalendarPrefItemsRowHeight: '26px',
      sortOption: 'sortByName'
    };

    function nameComparator(firstEntity, secondEntity) {
      if (firstEntity[1] < secondEntity[1]) {
        return -1;
      } else if (firstEntity[1] > secondEntity[1]) {
        return 1;
      } else {
        return 0;
      }
    }

    $scope.data.teams.sort(nameComparator);

    var initializeTeamsSkills = function() {
      dataService.getSitesTeamsTree({}).then(function(response) {
        teams = _.result(_.find(response.data, function(site) {return site.id === siteId;}), 'children');
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
      });
    };

    $scope.onSelectedTeamChanged = function() {
      if ($scope.data.selectedTeam === null) {
        $scope.data.skills = [];
      } else {
        var selectedTeamId = $scope.data.selectedTeam[0];
        var selectedTeam = _.find(teams, function(team) {return team.id === selectedTeamId;});
        $scope.data.skills = _.filter(selectedSchedule.skillsInfo.result, function(skillInfo) {
          return (skillInfo[3] && _.findIndex(selectedTeam.children, function(skill) {
            return (skill.id === skillInfo[0]);
          }) > -1);
        });
        $scope.data.skills.sort(nameComparator);
      }
      $scope.data.selectedSkill = null;
      $scope.data.eligibleEmployees = [];
    };

    $scope.onSelectedSkillChanged = function() {
      if ($scope.data.selectedSkill === null) {
        $scope.data.eligibleEmployees = [];
        return;
      }
      $scope.getWipEligibleEmployees();
      initializeCalendarCells();
    };

    $scope.onFillShiftSelected = function() {
      $scope.getWipEligibleEmployees();
      initializeCalendarCells();
    };

    $scope.canShowFooterContent = function() {
      return ($scope.data.selectedTeam !== null && $scope.data.selectedSkill !== null &&
        $scope.data.shiftTime.start !== null && $scope.data.selectedOperationType === 'fillShift' &&
        $scope.data.selectedEligibleEmployee !== null);
    };

    var calculateEmployeesInfo = function() {
      angular.forEach($scope.data.eligibleEmployees, function(employee) {
        var foundEmployee = _.find(selectedSchedule.employeesInfo.result, function(iteratee) {
          return (iteratee.id === employee.employeeId);
        });
        var hoursOfEmployee = 0;
        angular.forEach(selectedSchedule.selectedWeek.shifts.employeeShifts[employee.employeeId], function(dateShifts, calendarDate) {
          angular.forEach(dateShifts, function(shift) {
            var shiftDurationInHours = (shift.end - shift.start)/3600000;
            hoursOfEmployee += shiftDurationInHours;
          });
        });
        var costOfEmployee = foundEmployee[3] * hoursOfEmployee;
        employee.hours = hoursOfEmployee;
        employee.cost = costOfEmployee;
      });
    };

    var comparator = function(firstElement, secondElement) {
      var firstValue = null;
      var secondValue = null;

      if ($scope.data.sortOption === 'sortByName') {
        firstValue = firstElement.employeeName;
        secondValue = secondElement.employeeName;
      } else if ($scope.data.sortOption === 'leastHoursFirst') {
        firstValue = firstElement.hours;
        secondValue = secondElement.hours;
      } else if ($scope.data.sortOption === 'leastCostFirst') {
        firstValue = firstElement.cost;
        secondValue = secondElement.cost;
      }

      if (firstValue < secondValue) {
        return -1;
      } else if (firstValue > secondValue) {
        return 1;
      } else {
        return 0;
      }
    };

    $scope.setSortOption = function(option) {
      $scope.data.sortOption = option;
      $scope.data.eligibleEmployees.sort(comparator);
    };

    $scope.getWipEligibleEmployees = function() {
      $scope.data.eligibleEmployees = [];
      $scope.data.selectedEligibleEmployee = null;

      if ($scope.data.selectedOperationType !== 'fillShift') {
        return;
      }
      if ($scope.data.selectedTeam === null || $scope.data.selectedSkill === null) {
        return;
      }
      if ($scope.data.shiftTime.start === null || $scope.data.shiftTime.end === null) {
        return;
      }

      $scope.data.eligibleEmployeesLoaded = false;
      var overrideOptions = null;

      if (!$scope.data.showAvailableOnly) {
        overrideOptions = {
          ALL_DAY_UNAVAILABLE_OVERRIDE: true,
          TIME_WINDOW_UNAVAILABLE_OVERRIDE: true
        };
      }

      var shiftInfo = {
        teamId: $scope.data.selectedTeam[0],
        skillId: $scope.data.selectedSkill[0],
        start: $scope.data.shiftTime.start,
        end: $scope.data.shiftTime.end
      };

      dataService.getWipEligibleEmployeesForProposedOpenShift(scheduleId, shiftInfo, overrideOptions).then(function(result) {
        $scope.data.eligibleEmployees = result.data.eligibleEmployees;
        $scope.data.qualificationSummary = result.data.constraintViolationSummary;
        calculateEmployeesInfo();
        $scope.setSortOption('sortByName');
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
      }).finally(function() {
        $scope.data.eligibleEmployeesLoaded = true;
      });
    };

    $scope.toggleQualificationSummary = function() {
      $scope.data.qualificationSummaryDisplayed = !$scope.data.qualificationSummaryDisplayed;
    };

    var composeAvailabilityItem = function(availType, timeFrame) {
      var type = 'avail-item';
      var title = '';
      var className = '';

      if (availType === 'AVAIL') {
        var startDateTime = moment.tz(timeFrame.startDateTime, timezone);
        var endDateTime = moment.tz(timeFrame.endDateTime, timezone);

        title = startDateTime.format('h:mma') + '-' + endDateTime.format('h:mma');
        className = 'partially-available';
      } else if (availType === 'DAY_OFF') {
        if (timeFrame.pto) {
          title = $filter('translate')('availability.PTO_VACATION');
          className = 'holiday-vacation';
        } else {
          title = $filter('translate')('availability.NOT_AVAILABLE');
          className = 'not-available';
        }
      } else {
        title = $filter('translate')('availability.UNKNOWN_AVAILABILITY_TYPE') + ' ' + availType;
      }

      var result = {
        type: type,
        title: title,
        className: className
      };

      return result;
    };

    var composePreferenceItem = function(prefType, timeFrame) {
      var type = 'pref-item';
      var title = '';
      var className = '';
      var startDateTime = null;
      var endDateTime = null;

      if (timeFrame.startDateTime && timeFrame.endDateTime) {
        startDateTime = moment.tz(timeFrame.startDateTime, timezone);
        endDateTime = moment.tz(timeFrame.endDateTime, timezone);
      }

      switch (prefType) {
        case 'AVOID_TIMEFRAME':
          title = $filter('translate')('availability.AVOID') + ' ' +
            startDateTime.format('h:mma') + '-' + endDateTime.format('h:mma');
          className = 'avoid-time-frame';
          break;
        case 'PREFER_TIMEFRAME':
          title = $filter('translate')('availability.PREFER') + ' ' +
            startDateTime.format('h:mma') + '-' + endDateTime.format('h:mma');
          className = 'prefer-time-frame';
          break;
        case 'AVOID_DAY':
          title = $filter('translate')('availability.AVOID_DAY');
          className = 'avoid-day';
          break;
        case 'PREFER_DAY':
          title = $filter('translate')('availability.PREFER_DAY');
          className = 'prefer-day';
          break;
        default:
          title = $filter('translate')('availability.UNKNOWN_PREFERENCE_TYPE') + ' ' + prefType;
      }

      var result = {
        type: type,
        title: title,
        className: className
      };

      return result;
    };

    $scope.onSelectedEligibleEmployeeChanged = function() {
      initializeCalendarCells();
      if ($scope.data.selectedEligibleEmployee === null) {
        return;
      }

      var rowCount = 0;
      var startTime = selectedSchedule.selectedWeek.start;
      var endTime = selectedSchedule.selectedWeek.end;

      var queryParams = {
        params: {
          startdate: startTime,
          enddate: endTime,
          returnedfields: 'id,startDateTime,endDateTime,excess,skillAbbrev,skillName,teamName'
        }
      };
      dataService.getEmployeeCalendarAndAvailabilityView(scheduleId, $scope.data.selectedEligibleEmployee.employeeId, queryParams).then(function(response) {
        // Draw Shifts
        angular.forEach(response.data.shifts.result, function(shift) {
          var shiftStartTimeDayOfWeek = moment.tz(shift[1], timezone).format('ddd');
          var startTimeStr = moment.tz(shift[1], timezone).format('h:mma');
          startTimeStr = startTimeStr.substr(0, startTimeStr.length - 1);
          var endTimeStr = moment.tz(shift[2], timezone).format('h:mma');
          endTimeStr = endTimeStr.substr(0, endTimeStr.length - 1);

          var shiftObj = {
            type: 'normal-shift',
            start: shift[1],
            end: shift[2],
            timeStr: startTimeStr + '-' + endTimeStr,
            team: shift[6],
            skill: shift[5],
            skillAbbrev: shift[4],
            className: ''
          };
          $scope.data.employeeCalendarShifts[shiftStartTimeDayOfWeek].push(shiftObj);
        });
        rowCount = _.max($scope.data.employeeCalendarShifts, function(dayShifts, day) {
          return dayShifts.length;
        }).length;
        angular.forEach($scope.data.employeeCalendarShifts, function(dayShifts, day) {
          if (dayShifts.length === rowCount) {
            dayShifts[dayShifts.length - 1].className = 'no-border';
          }
        });
        $scope.data.employeeCalendarShiftsRowHeight = Math.max(51, (51 * rowCount)) + 'px';

        // Draw Availability
        angular.forEach(response.data.availcalViewDto.availCDTimeFrames, function(availCDTimeFrame) {
          var availStartTimeDayOfWeek = moment.tz(availCDTimeFrame.startDateTime, timezone).format('ddd');
          var availItemObj = composeAvailabilityItem(availCDTimeFrame.availType, availCDTimeFrame);
          $scope.data.employeeCalendarAvailItems[availStartTimeDayOfWeek].push(availItemObj);
        });
        angular.forEach(response.data.availcalViewDto.availCITimeFrames, function(availCITimeFrame) {
          var availStartTimeDayOfWeek = availCITimeFrame.dayOfTheWeek.substr(0, 3);
          availStartTimeDayOfWeek = availStartTimeDayOfWeek.charAt(0).toUpperCase() + availStartTimeDayOfWeek.slice(1).toLowerCase();
          var availItemObj = composeAvailabilityItem(availCITimeFrame.availType, availCITimeFrame.timeFrameInstances[0]);
          $scope.data.employeeCalendarAvailItems[availStartTimeDayOfWeek].push(availItemObj);
        });
        rowCount = _.max($scope.data.employeeCalendarAvailItems, function(dayItems, day) {
          return dayItems.length;
        }).length;
        $scope.data.employeeCalendarAvailItemsRowHeight = Math.max(26, (26 * rowCount)) + 'px';
        $scope.data.employeeCalendarAvailPrefItemsRowHeight = Math.max(26, (26 * rowCount));

        // Draw Preference
        angular.forEach(response.data.availcalViewDto.prefCDTimeFrames, function(prefCDTimeFrame) {
          var prefStartTimeDayOfWeek = moment.tz(prefCDTimeFrame.startDateTime, timezone).format('ddd');
          var prefItemObj = composePreferenceItem(prefCDTimeFrame.prefType, prefCDTimeFrame);
          $scope.data.employeeCalendarPrefItems[prefStartTimeDayOfWeek].push(prefItemObj);
        });
        angular.forEach(response.data.availcalViewDto.prefCITimeFrames, function(prefCITimeFrame) {
          var prefStartTimeDayOfWeek = prefCITimeFrame.dayOfTheWeek.substr(0, 3);
          prefStartTimeDayOfWeek = prefStartTimeDayOfWeek.charAt(0).toUpperCase() + prefStartTimeDayOfWeek.slice(1).toLowerCase();
          var prefItemObj = composePreferenceItem(prefCITimeFrame.prefType, prefCITimeFrame.timeFrameInstances[0]);
          $scope.data.employeeCalendarPrefItems[prefStartTimeDayOfWeek].push(prefItemObj);
        });
        rowCount = _.max($scope.data.employeeCalendarPrefItems, function(dayItems, day) {
          return dayItems.length;
        }).length;
        $scope.data.employeeCalendarPrefItemsRowHeight = Math.max(26, (26 * rowCount)) + 'px';
        $scope.data.employeeCalendarAvailPrefItemsRowHeight += Math.max(26, (26 * rowCount));
        $scope.data.employeeCalendarAvailPrefItemsRowHeight += 'px';
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
      });

      dataService.getEmployeeDetails($scope.data.selectedEligibleEmployee.employeeId).then(function(response) {
        $scope.data.selectedEligibleEmployee.name = response.data.firstName + response.data.lastName;
        $scope.data.selectedEligibleEmployee.homePhone = (response.data.homePhone)? response.data.homePhone: 'N/A';
        $scope.data.selectedEligibleEmployee.cellPhone = (response.data.mobilePhone)? response.data.mobilePhone: 'N/A';
        $scope.data.selectedEligibleEmployee.email = (response.data.workEmail)? response.data.workEmail: 'N/A';
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
      });
    };

    var initializeCalendarHeaderCells = function() {
      var startDayOfWeek = moment.tz(selectedSchedule.selectedWeek.start, timezone).hours(0).minutes(0).seconds(0).milliseconds(0);
      for (var i=0; i<7; i++) {
        var day = startDayOfWeek.clone().add(i, 'days');
        $scope.data.employeeCalendarHeaderCells.push({dayOfWeek: day.format('ddd'), date: day.format('M/D'), timestamp: day.unix() * 1000});
      }
    };

    var initializeCalendarCells = function() {
      if ($scope.data.selectedOperationType !== 'fillShift') {
        return;
      }
      if ($scope.data.selectedTeam === null || $scope.data.selectedSkill === null) {
        return;
      }
      if ($scope.data.shiftTime.start === null || $scope.data.shiftTime.end === null) {
        return;
      }

      $scope.data.employeeCalendarShifts = { Sun: [], Mon: [], Tue: [], Wed: [], Thu: [], Fri: [], Sat: [] };
      $scope.data.employeeCalendarAvailItems = { Sun: [], Mon: [], Tue: [], Wed: [], Thu: [], Fri: [], Sat: [] };
      $scope.data.employeeCalendarPrefItems = { Sun: [], Mon: [], Tue: [], Wed: [], Thu: [], Fri: [], Sat: [] };

      var shiftStartTimeDayOfWeek = moment.tz($scope.data.shiftTime.start, timezone).format('ddd');
      var startTimeStr = moment.tz($scope.data.shiftTime.start, timezone).format('h:mma');
      startTimeStr = startTimeStr.substr(0, startTimeStr.length - 1);
      var endTimeStr = moment.tz($scope.data.shiftTime.end, timezone).format('h:mma');
      endTimeStr = endTimeStr.substr(0, endTimeStr.length - 1);

      var shiftObj = {
        type: 'new-shift',
        start: $scope.data.shiftTime.start,
        end: $scope.data.shiftTime.end,
        timeStr: startTimeStr + '-' + endTimeStr,
        team: $scope.data.selectedTeam[1],
        skill: $scope.data.selectedSkill[1],
        skillAbbrev: $scope.data.selectedSkill[2],
        className: ''
      };
      $scope.data.employeeCalendarShifts[shiftStartTimeDayOfWeek] = [shiftObj];
    };

    $scope.submit = function() {
      var actionStr = '';
      var employeeId = null;
      var shiftInfo = {
        teamId: $scope.data.selectedTeam[0],
        skillId: $scope.data.selectedSkill[0],
        startDateTime: $scope.data.shiftTime.start,
        endDateTime: $scope.data.shiftTime.end
      };

      if ($scope.data.selectedOperationType === 'addAsOpenShift') {
        actionStr = 'CreateAsOpenShift';
      } else if ($scope.data.selectedOperationType === 'postShift') {
        actionStr = 'CreateAndPost';
      } else if ($scope.data.selectedOperationType === 'fillShift') {
        actionStr = 'CreateAndAssign';
        employeeId = $scope.data.selectedEligibleEmployee.employeeId;
      }

      var result = {
        shiftInfo: shiftInfo,
        action: actionStr,
        employeeId: employeeId
      };
      $modalInstance.close(result);
    };

    $scope.close = function() {
      $modalInstance.dismiss('cancel');
    };

    $timeout(function() {
      var startMoment = null;
      var endMoment = null;
      if (viewMode === 'week') {
        startMoment = moment.tz(selectedSchedule.selectedWeek.start, timezone);
        endMoment = moment.tz(selectedSchedule.selectedWeek.end, timezone);
      } else {
        startMoment = moment.tz(selectedSchedule.day.datetimeStamp, timezone).hours(0).minutes(0).seconds(0);
        endMoment = moment.tz(selectedSchedule.day.datetimeStamp, timezone).hours(23).minutes(59).seconds(59);
      }
      $('#start-datetime-picker').datetimepicker();
      $('#end-datetime-picker').datetimepicker();
      $('#start-datetime-picker').data('DateTimePicker').minDate(moment(startMoment.format('YYYY-MM-DD HH:mm:ss')));
      $('#start-datetime-picker').data('DateTimePicker').maxDate(moment(endMoment.format('YYYY-MM-DD HH:mm:ss')));
      $('#start-datetime-picker').data('DateTimePicker').date(moment(startMoment.clone().hours(8).format('YYYY-MM-DD HH:mm:ss')));
      $('#end-datetime-picker').data('DateTimePicker').date(moment(startMoment.clone().hours(8).format('YYYY-MM-DD HH:mm:ss')));
      $('#end-datetime-picker').data('DateTimePicker').minDate(moment(startMoment.clone().hours(8).format('YYYY-MM-DD HH:mm:ss')));

      var startDateTimeStr = $('#start-datetime-picker').data('DateTimePicker').date().format('YYYY-MM-DD HH:mm:ss');
      var endDateTimeStr = $('#end-datetime-picker').data('DateTimePicker').date().format('YYYY-MM-DD HH:mm:ss');
      $scope.data.shiftTime.start = moment.tz(startDateTimeStr, timezone).unix() * 1000;
      $scope.data.shiftTime.end = moment.tz(endDateTimeStr, timezone).unix() * 1000;

      $('#start-datetime-picker').on('dp.change', function (e) {
        $('#end-datetime-picker').data('DateTimePicker').minDate(false);
        if ($('#end-datetime-picker').data('DateTimePicker').date().unix() < e.date.unix()) {
          $('#end-datetime-picker').data('DateTimePicker').date(e.date.clone());
        }
        $('#end-datetime-picker').data('DateTimePicker').minDate(e.date.clone());
        if ($('#end-datetime-picker').data('DateTimePicker').date().unix() - e.date.unix() > 16 * 3600 ||
          $('#end-datetime-picker').data('DateTimePicker').date().unix() - e.date.unix() === 0) {
          $scope.data.shiftTimeRangeInvalid = true;
          return;
        } else {
          $scope.data.shiftTimeRangeInvalid = false;
        }

        var startDateTimeStr = e.date.format('YYYY-MM-DD HH:mm:ss');
        var endDateTimeStr = $('#end-datetime-picker').data('DateTimePicker').date().format('YYYY-MM-DD HH:mm:ss');
        $scope.data.shiftTime.start = moment.tz(startDateTimeStr, timezone).unix() * 1000;
        $scope.data.shiftTime.end = moment.tz(endDateTimeStr, timezone).unix() * 1000;
        $scope.getWipEligibleEmployees();
        initializeCalendarCells();
        $scope.$apply();
      });
      $('#end-datetime-picker').on('dp.change', function (e) {
        if ($('#start-datetime-picker').data('DateTimePicker').date() === null) {
          $('#start-datetime-picker').data('DateTimePicker').date(e.date.clone());
        }
        if (e.date.unix() - $('#start-datetime-picker').data('DateTimePicker').date().unix() > 16 * 3600 ||
          e.date.unix() - $('#start-datetime-picker').data('DateTimePicker').date().unix() === 0) {
          $scope.data.shiftTimeRangeInvalid = true;
          return;
        } else {
          $scope.data.shiftTimeRangeInvalid = false;
        }

        var startDateTimeStr = $('#start-datetime-picker').data('DateTimePicker').date().format('YYYY-MM-DD HH:mm:ss');
        var endDateTimeStr = e.date.format('YYYY-MM-DD HH:mm:ss');
        $scope.data.shiftTime.start = moment.tz(startDateTimeStr, timezone).unix() * 1000;
        $scope.data.shiftTime.end = moment.tz(endDateTimeStr, timezone).unix() * 1000;
        $scope.getWipEligibleEmployees();
        initializeCalendarCells();
        $scope.$apply();
      });
    }, 0);
    initializeTeamsSkills();
    initializeCalendarHeaderCells();
  }]);

angular.module('emlogis.employeeSchedules').controller('AssignShiftsPopupModalInstanceCtrl', ['$scope', '$modalInstance', '$timeout', '$filter', 'appFunc', 'applicationContext', 'dataService', 'EmployeeSchedulesService', 'selectedSchedule', 'selectedEmployee',
  function ($scope, $modalInstance, $timeout, $filter, appFunc, applicationContext, dataService, EmployeeSchedulesService, selectedSchedule, selectedEmployee) {
    var siteId = selectedSchedule.siteInfo[0];
    var scheduleId = selectedSchedule.id;
    var timezone = selectedSchedule.siteInfo[2];

    $scope.data = {
      parsedEmployeeInfo: {
        id: selectedEmployee.id,
        name: selectedEmployee.name
      },
      employeeCalendarHeaderCells: [],
      employeeCalendarShifts: {},
      employeeCalendarShiftsRowHeight: '51px',
      employeeCalendarAvailItems: {},
      employeeCalendarAvailItemsRowHeight: '26px',
      employeeCalendarPrefItems: {},
      employeeCalendarPrefItemsRowHeight: '26px',
      employeeCalendarAvailPrefItemsRowHeight: '52px',
      employeeCalendarOpenShifts: {},
      employeeCalendarOpenShiftsRowHeight: '51px',
      selectedOpenShiftId: null,
      openShiftsLoaded: false,
      qualificationSummary: {},
      qualificationSummaryDisplayed: false
    };

    var initializeEmployeeDetails = function() {
      dataService.getEmployeeDetails(selectedEmployee.id).then(function(response) {
        $scope.data.parsedEmployeeInfo.homePhone = (response.data.homePhone)? response.data.homePhone: 'N/A';
        $scope.data.parsedEmployeeInfo.cellPhone = (response.data.mobilePhone)? response.data.mobilePhone: 'N/A';
        $scope.data.parsedEmployeeInfo.email = (response.data.workEmail)? response.data.workEmail: 'N/A';
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
      });
    };

    var initializeCalendarCells = function() {
      var startDayOfWeek = moment.tz(selectedSchedule.selectedWeek.start, timezone).hours(0).minutes(0).seconds(0).milliseconds(0);
      for (var i=0; i<7; i++) {
        var day = startDayOfWeek.clone().add(i, 'days');
        $scope.data.employeeCalendarHeaderCells.push({dayOfWeek: day.format('ddd'), date: day.format('M/D'), timestamp: day.unix() * 1000});
      }
      $scope.data.employeeCalendarShifts = { Sun: [], Mon: [], Tue: [], Wed: [], Thu: [], Fri: [], Sat: [] };
      $scope.data.employeeCalendarAvailItems = { Sun: [], Mon: [], Tue: [], Wed: [], Thu: [], Fri: [], Sat: [] };
      $scope.data.employeeCalendarPrefItems = { Sun: [], Mon: [], Tue: [], Wed: [], Thu: [], Fri: [], Sat: [] };
    };

    var composeAvailabilityItem = function(availType, timeFrame) {
      var type = 'avail-item';
      var title = '';
      var className = '';

      if (availType === 'AVAIL') {
        var startDateTime = moment.tz(timeFrame.startDateTime, timezone);
        var endDateTime = moment.tz(timeFrame.endDateTime, timezone);
        var startDateTimeStr = '', endDateTimeStr = '';
        if (startDateTime.minutes() > 0) {
          startDateTimeStr = startDateTime.format('h:mma');
        } else {
          startDateTimeStr = startDateTime.format('ha');
        }
        startDateTimeStr = startDateTimeStr.substr(0, startDateTimeStr.length - 1);
        if (endDateTime.minutes() > 0) {
          endDateTimeStr = endDateTime.format('h:mma');
        } else {
          endDateTimeStr = endDateTime.format('ha');
        }
        endDateTimeStr = endDateTimeStr.substr(0, endDateTimeStr.length - 1);
        title = startDateTimeStr + '-' + endDateTimeStr;
        className = 'partially-available';
      } else if (availType === 'DAY_OFF') {
        if (timeFrame.pto) {
          title = $filter('translate')('availability.PTO_VACATION');
          className = 'holiday-vacation';
        } else {
          title = $filter('translate')('availability.NOT_AVAILABLE');
          className = 'not-available';
        }
      } else {
        title = $filter('translate')('availability.UNKNOWN_AVAILABILITY_TYPE') + ' ' + availType;
      }

      var result = {
        type: type,
        title: title,
        className: className,
        availType: availType,
        start: (availType === 'AVAIL')? timeFrame.startDateTime: null,
        end: (availType === 'AVAIL')? timeFrame.endDateTime: null
      };

      return result;
    };

    var composePreferenceItem = function(prefType, timeFrame) {
      var type = 'pref-item';
      var title = '';
      var className = '';
      var startDateTime = null;
      var endDateTime = null;
      var startDateTimeStr = '', endDateTimeStr = '';

      if (timeFrame.startDateTime && timeFrame.endDateTime) {
        startDateTime = moment.tz(timeFrame.startDateTime, timezone);
        endDateTime = moment.tz(timeFrame.endDateTime, timezone);
      }

      switch (prefType) {
        case 'AVOID_TIMEFRAME':
          if (startDateTime.minutes() > 0) {
            startDateTimeStr = startDateTime.format('h:mma');
          } else {
            startDateTimeStr = startDateTime.format('ha');
          }
          startDateTimeStr = startDateTimeStr.substr(0, startDateTimeStr.length - 1);
          if (endDateTime.minutes() > 0) {
            endDateTimeStr = endDateTime.format('h:mma');
          } else {
            endDateTimeStr = endDateTime.format('ha');
          }
          endDateTimeStr = endDateTimeStr.substr(0, endDateTimeStr.length - 1);
          title = $filter('translate')('availability.AVOID') + ' ' +
            startDateTimeStr + '-' + endDateTimeStr;
          className = 'avoid-time-frame';
          break;
        case 'PREFER_TIMEFRAME':
          if (startDateTime.minutes() > 0) {
            startDateTimeStr = startDateTime.format('h:mma');
          } else {
            startDateTimeStr = startDateTime.format('ha');
          }
          startDateTimeStr = startDateTimeStr.substr(0, startDateTimeStr.length - 1);
          if (endDateTime.minutes() > 0) {
            endDateTimeStr = endDateTime.format('h:mma');
          } else {
            endDateTimeStr = endDateTime.format('ha');
          }
          endDateTimeStr = endDateTimeStr.substr(0, endDateTimeStr.length - 1);
          title = $filter('translate')('availability.PREFER') + ' ' +
            startDateTimeStr + '-' + endDateTimeStr;
          className = 'prefer-time-frame';
          break;
        case 'AVOID_DAY':
          title = $filter('translate')('availability.AVOID_DAY');
          className = 'avoid-day';
          break;
        case 'PREFER_DAY':
          title = $filter('translate')('availability.PREFER_DAY');
          className = 'prefer-day';
          break;
        default:
          title = $filter('translate')('availability.UNKNOWN_PREFERENCE_TYPE') + ' ' + prefType;
      }

      var result = {
        type: type,
        title: title,
        className: className
      };

      return result;
    };

    var drawCalendarContent = function() {
      var rowCount = 0;
      var startTime = selectedSchedule.selectedWeek.start;
      var endTime = selectedSchedule.selectedWeek.end;

      var queryParams = {
        params: {
          startdate: startTime,
          enddate: endTime,
          returnedfields: 'id,startDateTime,endDateTime,excess,skillAbbrev,skillName,teamName,teamAbbrev'
        }
      };
      dataService.getEmployeeCalendarAndAvailabilityView(scheduleId, $scope.data.parsedEmployeeInfo.id, queryParams).then(function(response) {
        // Draw Shifts
        angular.forEach(response.data.shifts.result, function(shift) {
          var shiftStartTimeDayOfWeek = moment.tz(shift[1], timezone).format('ddd');

          var startTimeStr;
          var startTimeMoment = moment.tz(shift[1], timezone);
          if (startTimeMoment.minutes() > 0) {
            startTimeStr = startTimeMoment.format('h:mma');
          } else {
            startTimeStr = startTimeMoment.format('ha');
          }
          startTimeStr = startTimeStr.substr(0, startTimeStr.length - 1);

          var endTimeStr;
          var endTimeMoment = moment.tz(shift[2], timezone);
          if (endTimeMoment.minutes() > 0) {
            endTimeStr = endTimeMoment.format('h:mma');
          } else {
            endTimeStr = endTimeMoment.format('ha');
          }
          endTimeStr = endTimeStr.substr(0, endTimeStr.length - 1);

          var shiftObj = {
            type: 'normal-shift',
            start: shift[1],
            end: shift[2],
            timeStr: startTimeStr + '-' + endTimeStr,
            team: shift[6],
            teamAbbrev: shift[7],
            skill: shift[5],
            skillAbbrev: shift[4],
            className: ''
          };
          $scope.data.employeeCalendarShifts[shiftStartTimeDayOfWeek].push(shiftObj);
        });
        rowCount = _.max($scope.data.employeeCalendarShifts, function(dayShifts, day) {
          return dayShifts.length;
        }).length;
        if (rowCount > 0) {
          angular.forEach($scope.data.employeeCalendarShifts, function(dayShifts, day) {
            if (dayShifts.length === rowCount) {
              dayShifts[dayShifts.length - 1].className = 'no-border';
            }
          });
        }
        $scope.data.employeeCalendarShiftsRowHeight = Math.max(51, (51 * rowCount)) + 'px';

        // Draw Availability
        angular.forEach(response.data.availcalViewDto.availCDTimeFrames, function(availCDTimeFrame) {
          var availStartTimeDayOfWeek = moment.tz(availCDTimeFrame.startDateTime, timezone).format('ddd');
          var availItemObj = composeAvailabilityItem(availCDTimeFrame.availType, availCDTimeFrame);
          $scope.data.employeeCalendarAvailItems[availStartTimeDayOfWeek].push(availItemObj);
        });
        angular.forEach(response.data.availcalViewDto.availCITimeFrames, function(availCITimeFrame) {
          var availStartTimeDayOfWeek = availCITimeFrame.dayOfTheWeek.substr(0, 3);
          availStartTimeDayOfWeek = availStartTimeDayOfWeek.charAt(0).toUpperCase() + availStartTimeDayOfWeek.slice(1).toLowerCase();
          var availItemObj = composeAvailabilityItem(availCITimeFrame.availType, availCITimeFrame.timeFrameInstances[0]);
          $scope.data.employeeCalendarAvailItems[availStartTimeDayOfWeek].push(availItemObj);
        });
        rowCount = _.max($scope.data.employeeCalendarAvailItems, function(dayItems, day) {
          return dayItems.length;
        }).length;
        $scope.data.employeeCalendarAvailItemsRowHeight = Math.max(26, (26 * rowCount)) + 'px';
        $scope.data.employeeCalendarAvailPrefItemsRowHeight = Math.max(26, (26 * rowCount));

        // Draw Preference
        angular.forEach(response.data.availcalViewDto.prefCDTimeFrames, function(prefCDTimeFrame) {
          var prefStartTimeDayOfWeek = moment.tz(prefCDTimeFrame.startDateTime, timezone).format('ddd');
          var prefItemObj = composePreferenceItem(prefCDTimeFrame.prefType, prefCDTimeFrame);
          $scope.data.employeeCalendarPrefItems[prefStartTimeDayOfWeek].push(prefItemObj);
        });
        angular.forEach(response.data.availcalViewDto.prefCITimeFrames, function(prefCITimeFrame) {
          var prefStartTimeDayOfWeek = prefCITimeFrame.dayOfTheWeek.substr(0, 3);
          prefStartTimeDayOfWeek = prefStartTimeDayOfWeek.charAt(0).toUpperCase() + prefStartTimeDayOfWeek.slice(1).toLowerCase();
          var prefItemObj = composePreferenceItem(prefCITimeFrame.prefType, prefCITimeFrame.timeFrameInstances[0]);
          $scope.data.employeeCalendarPrefItems[prefStartTimeDayOfWeek].push(prefItemObj);
        });
        rowCount = _.max($scope.data.employeeCalendarPrefItems, function(dayItems, day) {
          return dayItems.length;
        }).length;
        $scope.data.employeeCalendarPrefItemsRowHeight = Math.max(26, (26 * rowCount)) + 'px';
        $scope.data.employeeCalendarAvailPrefItemsRowHeight += Math.max(26, (26 * rowCount));
        $scope.data.employeeCalendarAvailPrefItemsRowHeight += 'px';
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
      });

      // Draw Open Shifts
      var payLoad = {
        includeConstraintViolationSummary: true,
        maxSynchronousWaitSeconds: 180,
        maxComputationTime: 180,
        maximumUnimprovedSecondsSpent: 100,
        employeeIds: [selectedEmployee.id],
        shiftIds: null,
        startDateTime: startTime,
        endDateTime: endTime
      };
      EmployeeSchedulesService.getEligibilityDataFromSelectedEntities(scheduleId, payLoad).then(function(result) {
        $scope.data.qualificationSummary = result.data.constraintViolationSummary;
        angular.forEach($scope.data.qualificationSummary.constraintViolations, function(violation) {
          violation.shiftStr = moment.tz(violation.shiftStartDateTime, timezone).format('MM/DD/YYYY h:mma') + '-' +
            moment.tz(violation.shiftEndDateTime, timezone).format('h:mma');
        });
        angular.forEach(result.data.openShifts, function(openShift) {
          var startTimeDayOfWeek = moment.tz(openShift.startDateTime, timezone).format('ddd');
          if (typeof $scope.data.employeeCalendarOpenShifts[startTimeDayOfWeek] === 'undefined') {
            $scope.data.employeeCalendarOpenShifts[startTimeDayOfWeek] = [];
          }

          $scope.data.employeeCalendarOpenShifts[startTimeDayOfWeek].push(parseOpenShift(openShift));
        });

        $scope.data.openShiftsLoaded = true;
        rowCount = _.max($scope.data.employeeCalendarOpenShifts, function(dayShifts, day) {
          return dayShifts.length;
        }).length;
        $scope.data.employeeCalendarOpenShiftsRowHeight = Math.max(51, (51 * rowCount)) + 'px';
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
      });
    };

    function parseOpenShift(openShift) {
      var dayInMilliseconds = 24 * 3600000;
      var startTimeMoment = moment.tz(openShift.startDateTime, timezone);
      var endTimeMoment = moment.tz(openShift.endDateTime, timezone);

      var timeStr = appFunc.toShortest12TimeFormat(startTimeMoment) + '-' + appFunc.toShortest12TimeFormat(endTimeMoment);

      var startTimeOffSetPercentInDay =
          (((startTimeMoment.hours() * 3600 + startTimeMoment.minutes() * 60 + startTimeMoment.seconds()) * 1000
          + startTimeMoment.milliseconds())/dayInMilliseconds) * 100;
      var tooltipPositionStr = startTimeOffSetPercentInDay <= 50 ? 'right' : 'left';
      startTimeOffSetPercentInDay += '%';

      var lengthPercentInDay = ((openShift.endDateTime - openShift.startDateTime)/dayInMilliseconds) * 100 + "%";

      var shiftObj = {
        id: openShift.id,
        type: 'open',
        employeeId: null,
        excessType: openShift.excess ? 'extra' : 'regular',
        excessTypeStr: openShift.excess ? 'Extra' : '',
        start: openShift.startDateTime,
        end: openShift.endDateTime,
        timeStr: timeStr,
        startTimeOffSetPercentInDay: startTimeOffSetPercentInDay,
        tooltipPositionInDay: tooltipPositionStr,
        lengthPercentInDay: lengthPercentInDay,
        skillId: openShift.skillId,
        skillName: openShift.skillName,
        skillAbbrev: openShift.skillAbbrev,
        assignment: 'Assignment',
        teamId: openShift.teamId,
        teamName: openShift.teamName,
        teamAbbrev: openShift.teamAbbrev,
        posted: '',
        requested: '',
        comment: null,
        commentClass: '',
        external: false,
        filterPassed: true,
        overtime: 0,
        cost: 0
      };
      return shiftObj;
    }

    $scope.toggleQualificationSummary = function() {
      $scope.data.qualificationSummaryDisplayed = !$scope.data.qualificationSummaryDisplayed;
    };

    var validateOpenShiftTick = function(openShift, dayOfWeek) {
      var foundIndex = _.findIndex($scope.data.employeeCalendarShifts[dayOfWeek], function(shiftIterator) {
        return (shiftIterator.type !== 'new-shift' && (shiftIterator.end > openShift.start && shiftIterator.start < openShift.end));
      });

      if (foundIndex < 0) {
        foundIndex = _.findIndex($scope.data.employeeCalendarAvailItems[dayOfWeek], function(itemIterator) {
          return (itemIterator.availType === 'DAY_OFF' || (itemIterator.end > openShift.start && itemIterator.start < openShift.end));
        });
      }

      return (foundIndex < 0);
    };

    var updateEmployeeCalendarShifts = function(openShift, dayOfWeek) {
      if (openShift.ticked) {
        angular.forEach($scope.data.employeeCalendarShifts, function(dayShifts, day) {
          _.remove(dayShifts, function(shiftIterator) {
            return (shiftIterator.type === 'new-shift');
          });
        });
        var addedOpenShift = angular.copy(openShift);
        addedOpenShift.type = 'new-shift';
        $scope.data.employeeCalendarShifts[dayOfWeek].push(addedOpenShift);
      } else {
        _.remove($scope.data.employeeCalendarShifts[dayOfWeek], function(shiftIterator) {
          return (shiftIterator.id === openShift.id);
        });
      }
      var rowCount = _.max($scope.data.employeeCalendarShifts, function(dayShifts, day) {
        return dayShifts.length;
      }).length;
      if (rowCount > 0) {
        angular.forEach($scope.data.employeeCalendarShifts, function(dayShifts, day) {
          angular.forEach(dayShifts, function(dayShift) {
            dayShift.className = '';
          });
          if (dayShifts.length === rowCount) {
            dayShifts[dayShifts.length - 1].className = 'no-border';
          }
        });
      }
      $scope.data.employeeCalendarShiftsRowHeight = Math.max(51, (51 * rowCount)) + 'px';
    };

    $scope.tickOpenShift = function(openShift, dayOfWeek) {
      if ((!openShift.ticked /*&& validateOpenShiftTick(openShift, dayOfWeek)*/) || openShift.ticked) {
        angular.forEach($scope.data.employeeCalendarOpenShifts, function(dayOpenShifts, day) {
          angular.forEach(dayOpenShifts, function(dayOpenShift) {
            if (dayOpenShift.id !== openShift.id) {
              dayOpenShift.ticked = false;
            }
          });
        });
        openShift.ticked = !openShift.ticked;
        updateEmployeeCalendarShifts(openShift, dayOfWeek);
        $scope.data.selectedOpenShiftId = (openShift.ticked)? openShift.id: null;
      }
    };

    $scope.submit = function() {
      var result = {
        selectedOpenShiftId: $scope.data.selectedOpenShiftId
      };
      $modalInstance.close(result);
    };

    $scope.close = function() {
      $modalInstance.dismiss('cancel');
    };

    initializeEmployeeDetails();
    initializeCalendarCells();
    drawCalendarContent();
  }]);

angular.module('emlogis.employeeSchedules').controller('FillShiftPopupModalInstanceCtrl', ['$scope', '$modalInstance', '$timeout', '$filter', 'applicationContext', 'dataService', 'EmployeeSchedulesService', 'viewMode', 'selectedSchedule', 'selectedOpenShift',
  function ($scope, $modalInstance, $timeout, $filter, applicationContext, dataService, EmployeeSchedulesService, viewMode, selectedSchedule, selectedOpenShift) {
    var siteId = selectedSchedule.siteInfo[0];
    var scheduleId = selectedSchedule.id;
    var timezone = selectedSchedule.siteInfo[2];
    var teams = [];

    $scope.data = {
      selectedScheduleStatus: selectedSchedule.status,
      teams: _.filter(selectedSchedule.teamsInfo.result, function(teamInfo) {
        var isHomeTeam = teamInfo[2];
        return !isHomeTeam;
      }),
      skills: [],
      selectedTeam: null,
      selectedSkill: null,
      shiftTime: {
        start: null,
        end: null
      },
      shiftTimeRangeInvalid: false,
      selectedOpenShift: angular.copy(selectedOpenShift),
      selectedOperationType: 'saveShift',
      qualificationSummary: {},
      qualificationSummaryDisplayed: false,
      selectedEligibleEmployee: null,
      eligibleEmployees: [],
      eligibleEmployeesLoaded: true,
      showAvailableOnly: true,
      employeeCalendarHeaderCells: [],
      employeeCalendarShifts: {},
      employeeCalendarShiftsRowHeight: '51px',
      employeeCalendarAvailItems: {},
      employeeCalendarAvailItemsRowHeight: '26px',
      employeeCalendarPrefItems: {},
      employeeCalendarPrefItemsRowHeight: '26px',
      sortOption: 'sortByName'
    };

    function nameComparator(firstEntity, secondEntity) {
      if (firstEntity[1] < secondEntity[1]) {
        return -1;
      } else if (firstEntity[1] > secondEntity[1]) {
        return 1;
      } else {
        return 0;
      }
    }

    $scope.data.teams.sort(nameComparator);

    var initializeTeamsSkills = function() {
      dataService.getSitesTeamsTree({}).then(function(response) {
        var currentTeamIndexOfSelectedShift = _.findIndex($scope.data.teams, function(team) {
          return (team[1] === $scope.data.selectedOpenShift.teamName);
        });
        $scope.data.selectedTeam = $scope.data.teams[currentTeamIndexOfSelectedShift];

        teams = _.result(_.find(response.data, function(site) {return site.id === siteId;}), 'children');

        var currentTeamOfSelectedShift = _.find(teams, 'name', $scope.data.selectedOpenShift.teamName);
        $scope.data.skills = _.filter(selectedSchedule.skillsInfo.result, function(skillInfo) {
          return (skillInfo[3] && _.findIndex(currentTeamOfSelectedShift.children, function(skill) {
            return (skill.id === skillInfo[0]);
          }) > -1);
        });
        $scope.data.skills.sort(nameComparator);

        var currentSkillIndexOfSelectedShift = _.findIndex($scope.data.skills, function(skill) {
          return (skill[1] === $scope.data.selectedOpenShift.skillName);
        });
        $scope.data.selectedSkill = $scope.data.skills[currentSkillIndexOfSelectedShift];
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
      });
    };

    $scope.onSelectedTeamChanged = function() {
      if ($scope.data.selectedTeam === null) {
        $scope.data.skills = [];
      } else {
        var selectedTeamId = $scope.data.selectedTeam[0];
        var selectedTeam = _.find(teams, function(team) {return team.id === selectedTeamId;});
        $scope.data.skills = _.filter(selectedSchedule.skillsInfo.result, function(skillInfo) {
          return (skillInfo[3] && _.findIndex(selectedTeam.children, function(skill) {
            return (skill.id === skillInfo[0]);
          }) > -1);
        });
        $scope.data.skills.sort(nameComparator);
      }
      $scope.data.selectedSkill = null;
      $scope.data.eligibleEmployees = [];
    };

    $scope.onSelectedSkillChanged = function() {
      if ($scope.data.selectedSkill === null) {
        $scope.data.eligibleEmployees = [];
        return;
      }
      $scope.getWipEligibleEmployees();
      initializeCalendarCells();
    };

    $scope.onFillShiftSelected = function() {
      $scope.getWipEligibleEmployees();
      initializeCalendarCells();
    };

    $scope.canShowFooterContent = function() {
      return ($scope.data.selectedTeam !== null && $scope.data.selectedSkill !== null &&
        $scope.data.shiftTime.start !== null && $scope.data.selectedOperationType === 'fillShift' &&
        $scope.data.selectedEligibleEmployee !== null);
    };

    $scope.checkIfPastShift = function(shift) {
      var nowDateTimeStamp = moment.tz(new Date().getTime(), timezone).unix() * 1000;
      return (nowDateTimeStamp > shift.start);
    };

    var calculateEmployeesInfo = function() {
      angular.forEach($scope.data.eligibleEmployees, function(employee) {
        var foundEmployee = _.find(selectedSchedule.employeesInfo.result, function(iteratee) {
          return (iteratee.id === employee.employeeId);
        });
        var hoursOfEmployee = 0;
        angular.forEach(selectedSchedule.selectedWeek.shifts.employeeShifts[employee.employeeId], function(dateShifts, calendarDate) {
          angular.forEach(dateShifts, function(shift) {
            var shiftDurationInHours = (shift.end - shift.start)/3600000;
            hoursOfEmployee += shiftDurationInHours;
          });
        });
        var costOfEmployee = foundEmployee[3] * hoursOfEmployee;
        employee.hours = hoursOfEmployee;
        employee.cost = costOfEmployee;
      });
    };

    var comparator = function(firstElement, secondElement) {
      var firstValue = null;
      var secondValue = null;

      if ($scope.data.sortOption === 'sortByName') {
        firstValue = firstElement.employeeName;
        secondValue = secondElement.employeeName;
      } else if ($scope.data.sortOption === 'leastHoursFirst') {
        firstValue = firstElement.hours;
        secondValue = secondElement.hours;
      } else if ($scope.data.sortOption === 'leastCostFirst') {
        firstValue = firstElement.cost;
        secondValue = secondElement.cost;
      }

      if (firstValue < secondValue) {
        return -1;
      } else if (firstValue > secondValue) {
        return 1;
      } else {
        return 0;
      }
    };

    $scope.setSortOption = function(option) {
      $scope.data.sortOption = option;
      $scope.data.eligibleEmployees.sort(comparator);
    };

    $scope.getWipEligibleEmployees = function() {
      $scope.data.eligibleEmployees = [];
      $scope.data.selectedEligibleEmployee = null;

      if ($scope.data.selectedOperationType !== 'fillShift') {
        return;
      }
      if ($scope.data.selectedTeam === null || $scope.data.selectedSkill === null) {
        return;
      }
      if ($scope.data.shiftTime.start === null || $scope.data.shiftTime.end === null) {
        return;
      }

      $scope.data.eligibleEmployeesLoaded = false;
      var overrideOptions = null;

      if (!$scope.data.showAvailableOnly) {
        overrideOptions = {
          ALL_DAY_UNAVAILABLE_OVERRIDE: true,
          TIME_WINDOW_UNAVAILABLE_OVERRIDE: true
        };
      }

      var shiftInfo = {
        teamId: $scope.data.selectedTeam[0],
        skillId: $scope.data.selectedSkill[0],
        start: $scope.data.shiftTime.start,
        end: $scope.data.shiftTime.end
      };

      dataService.getWipEligibleEmployeesForProposedOpenShift(scheduleId, shiftInfo, overrideOptions).then(function(result) {
        $scope.data.eligibleEmployees = result.data.eligibleEmployees;
        $scope.data.qualificationSummary = result.data.constraintViolationSummary;
        calculateEmployeesInfo();
        $scope.setSortOption('sortByName');
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
      }).finally(function() {
        $scope.data.eligibleEmployeesLoaded = true;
      });
    };

    $scope.toggleQualificationSummary = function() {
      $scope.data.qualificationSummaryDisplayed = !$scope.data.qualificationSummaryDisplayed;
    };

    var composeAvailabilityItem = function(availType, timeFrame) {
      var type = 'avail-item';
      var title = '';
      var className = '';

      if (availType === 'AVAIL') {
        var startDateTime = moment.tz(timeFrame.startDateTime, timezone);
        var endDateTime = moment.tz(timeFrame.endDateTime, timezone);

        title = startDateTime.format('h:mma') + '-' + endDateTime.format('h:mma');
        className = 'partially-available';
      } else if (availType === 'DAY_OFF') {
        if (timeFrame.pto) {
          title = $filter('translate')('availability.PTO_VACATION');
          className = 'holiday-vacation';
        } else {
          title = $filter('translate')('availability.NOT_AVAILABLE');
          className = 'not-available';
        }
      } else {
        title = $filter('translate')('availability.UNKNOWN_AVAILABILITY_TYPE') + ' ' + availType;
      }

      var result = {
        type: type,
        title: title,
        className: className
      };

      return result;
    };

    var composePreferenceItem = function(prefType, timeFrame) {
      var type = 'pref-item';
      var title = '';
      var className = '';
      var startDateTime = null;
      var endDateTime = null;

      if (timeFrame.startDateTime && timeFrame.endDateTime) {
        startDateTime = moment.tz(timeFrame.startDateTime, timezone);
        endDateTime = moment.tz(timeFrame.endDateTime, timezone);
      }

      switch (prefType) {
        case 'AVOID_TIMEFRAME':
          title = $filter('translate')('availability.AVOID') + ' ' +
            startDateTime.format('h:mma') + '-' + endDateTime.format('h:mma');
          className = 'avoid-time-frame';
          break;
        case 'PREFER_TIMEFRAME':
          title = $filter('translate')('availability.PREFER') + ' ' +
            startDateTime.format('h:mma') + '-' + endDateTime.format('h:mma');
          className = 'prefer-time-frame';
          break;
        case 'AVOID_DAY':
          title = $filter('translate')('availability.AVOID_DAY');
          className = 'avoid-day';
          break;
        case 'PREFER_DAY':
          title = $filter('translate')('availability.PREFER_DAY');
          className = 'prefer-day';
          break;
        default:
          title = $filter('translate')('availability.UNKNOWN_PREFERENCE_TYPE') + ' ' + prefType;
      }

      var result = {
        type: type,
        title: title,
        className: className
      };

      return result;
    };

    $scope.deleteOS = function() {
      var result = {
        shiftId: selectedOpenShift.id,
        action: 'Delete'
      };
      $modalInstance.close(result);
    };

    $scope.onSelectedEligibleEmployeeChanged = function() {
      initializeCalendarCells();
      if ($scope.data.selectedEligibleEmployee === null) {
        return;
      }

      var rowCount = 0;
      var startTime = selectedSchedule.selectedWeek.start;
      var endTime = selectedSchedule.selectedWeek.end;

      var queryParams = {
        params: {
          startdate: startTime,
          enddate: endTime,
          returnedfields: 'id,startDateTime,endDateTime,excess,skillAbbrev,skillName,teamName'
        }
      };
      dataService.getEmployeeCalendarAndAvailabilityView(scheduleId, $scope.data.selectedEligibleEmployee.employeeId, queryParams).then(function(response) {
        // Draw Shifts
        angular.forEach(response.data.shifts.result, function(shift) {
          var shiftStartTimeDayOfWeek = moment.tz(shift[1], timezone).format('ddd');
          var startTimeStr = moment.tz(shift[1], timezone).format('h:mma');
          startTimeStr = startTimeStr.substr(0, startTimeStr.length - 1);
          var endTimeStr = moment.tz(shift[2], timezone).format('h:mma');
          endTimeStr = endTimeStr.substr(0, endTimeStr.length - 1);

          var shiftObj = {
            type: 'normal-shift',
            start: shift[1],
            end: shift[2],
            timeStr: startTimeStr + '-' + endTimeStr,
            team: shift[6],
            skill: shift[5],
            skillAbbrev: shift[4],
            className: ''
          };
          $scope.data.employeeCalendarShifts[shiftStartTimeDayOfWeek].push(shiftObj);
        });
        rowCount = _.max($scope.data.employeeCalendarShifts, function(dayShifts, day) {
          return dayShifts.length;
        }).length;
        angular.forEach($scope.data.employeeCalendarShifts, function(dayShifts, day) {
          if (dayShifts.length === rowCount) {
            dayShifts[dayShifts.length - 1].className = 'no-border';
          }
        });
        $scope.data.employeeCalendarShiftsRowHeight = Math.max(51, (51 * rowCount)) + 'px';

        // Draw Availability
        angular.forEach(response.data.availcalViewDto.availCDTimeFrames, function(availCDTimeFrame) {
          var availStartTimeDayOfWeek = moment.tz(availCDTimeFrame.startDateTime, timezone).format('ddd');
          var availItemObj = composeAvailabilityItem(availCDTimeFrame.availType, availCDTimeFrame);
          $scope.data.employeeCalendarAvailItems[availStartTimeDayOfWeek].push(availItemObj);
        });
        angular.forEach(response.data.availcalViewDto.availCITimeFrames, function(availCITimeFrame) {
          var availStartTimeDayOfWeek = availCITimeFrame.dayOfTheWeek.substr(0, 3);
          availStartTimeDayOfWeek = availStartTimeDayOfWeek.charAt(0).toUpperCase() + availStartTimeDayOfWeek.slice(1).toLowerCase();
          var availItemObj = composeAvailabilityItem(availCITimeFrame.availType, availCITimeFrame.timeFrameInstances[0]);
          $scope.data.employeeCalendarAvailItems[availStartTimeDayOfWeek].push(availItemObj);
        });
        rowCount = _.max($scope.data.employeeCalendarAvailItems, function(dayItems, day) {
          return dayItems.length;
        }).length;
        $scope.data.employeeCalendarAvailItemsRowHeight = Math.max(26, (26 * rowCount)) + 'px';
        $scope.data.employeeCalendarAvailPrefItemsRowHeight = Math.max(26, (26 * rowCount));

        // Draw Preference
        angular.forEach(response.data.availcalViewDto.prefCDTimeFrames, function(prefCDTimeFrame) {
          var prefStartTimeDayOfWeek = moment.tz(prefCDTimeFrame.startDateTime, timezone).format('ddd');
          var prefItemObj = composePreferenceItem(prefCDTimeFrame.prefType, prefCDTimeFrame);
          $scope.data.employeeCalendarPrefItems[prefStartTimeDayOfWeek].push(prefItemObj);
        });
        angular.forEach(response.data.availcalViewDto.prefCITimeFrames, function(prefCITimeFrame) {
          var prefStartTimeDayOfWeek = prefCITimeFrame.dayOfTheWeek.substr(0, 3);
          prefStartTimeDayOfWeek = prefStartTimeDayOfWeek.charAt(0).toUpperCase() + prefStartTimeDayOfWeek.slice(1).toLowerCase();
          var prefItemObj = composePreferenceItem(prefCITimeFrame.prefType, prefCITimeFrame.timeFrameInstances[0]);
          $scope.data.employeeCalendarPrefItems[prefStartTimeDayOfWeek].push(prefItemObj);
        });
        rowCount = _.max($scope.data.employeeCalendarPrefItems, function(dayItems, day) {
          return dayItems.length;
        }).length;
        $scope.data.employeeCalendarPrefItemsRowHeight = Math.max(26, (26 * rowCount)) + 'px';
        $scope.data.employeeCalendarAvailPrefItemsRowHeight += Math.max(26, (26 * rowCount));
        $scope.data.employeeCalendarAvailPrefItemsRowHeight += 'px';
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
      });

      dataService.getEmployeeDetails($scope.data.selectedEligibleEmployee.employeeId).then(function(response) {
        $scope.data.selectedEligibleEmployee.name = response.data.firstName + response.data.lastName;
        $scope.data.selectedEligibleEmployee.homePhone = (response.data.homePhone)? response.data.homePhone: 'N/A';
        $scope.data.selectedEligibleEmployee.cellPhone = (response.data.mobilePhone)? response.data.mobilePhone: 'N/A';
        $scope.data.selectedEligibleEmployee.email = (response.data.workEmail)? response.data.workEmail: 'N/A';
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
      });
    };

    var initializeCalendarHeaderCells = function() {
      var startDayOfWeek = moment.tz(selectedSchedule.selectedWeek.start, timezone).hours(0).minutes(0).seconds(0).milliseconds(0);
      for (var i=0; i<7; i++) {
        var day = startDayOfWeek.clone().add(i, 'days');
        $scope.data.employeeCalendarHeaderCells.push({dayOfWeek: day.format('ddd'), date: day.format('M/D'), timestamp: day.unix() * 1000});
      }
    };

    var initializeCalendarCells = function() {
      if ($scope.data.selectedOperationType !== 'fillShift') {
        return;
      }
      if ($scope.data.selectedTeam === null || $scope.data.selectedSkill === null) {
        return;
      }
      if ($scope.data.shiftTime.start === null || $scope.data.shiftTime.end === null) {
        return;
      }

      $scope.data.employeeCalendarShifts = { Sun: [], Mon: [], Tue: [], Wed: [], Thu: [], Fri: [], Sat: [] };
      $scope.data.employeeCalendarAvailItems = { Sun: [], Mon: [], Tue: [], Wed: [], Thu: [], Fri: [], Sat: [] };
      $scope.data.employeeCalendarPrefItems = { Sun: [], Mon: [], Tue: [], Wed: [], Thu: [], Fri: [], Sat: [] };

      var shiftStartTimeDayOfWeek = moment.tz(selectedOpenShift.start, timezone).format('ddd');
      var startTimeStr = moment.tz(selectedOpenShift.start, timezone).format('h:mma');
      startTimeStr = startTimeStr.substr(0, startTimeStr.length - 1);
      var endTimeStr = moment.tz(selectedOpenShift.end, timezone).format('h:mma');
      endTimeStr = endTimeStr.substr(0, endTimeStr.length - 1);

      var shiftObj = {
        type: 'new-shift',
        start: selectedOpenShift.start,
        end: selectedOpenShift.end,
        timeStr: startTimeStr + '-' + endTimeStr,
        team: selectedOpenShift.teamName,
        skill: selectedOpenShift.skillName,
        skillAbbrev: selectedOpenShift.skillAbbrev,
        className: ''
      };
      $scope.data.employeeCalendarShifts[shiftStartTimeDayOfWeek] = [shiftObj];
    };

    $scope.submit = function() {
      var actionStr = '';
      var employeeId = null;
      var shiftInfo = {
        teamId: $scope.data.selectedTeam[0],
        skillId: $scope.data.selectedSkill[0],
        newStartDateTime: $scope.data.shiftTime.start,
        newEndDateTime: $scope.data.shiftTime.end
      };

      if ($scope.data.selectedOperationType === 'saveShift') {
        actionStr = 'Edit';
      } else if ($scope.data.selectedOperationType === 'postShift') {
        actionStr = 'Post';
      } else if ($scope.data.selectedOperationType === 'fillShift') {
        actionStr = 'Assign';
        employeeId = $scope.data.selectedEligibleEmployee.employeeId;
      }

      var result = {
        shiftInfo: shiftInfo,
        action: actionStr,
        employeeId: employeeId
      };
      $modalInstance.close(result);
    };

    $scope.close = function() {
      $modalInstance.dismiss('cancel');
    };

    $timeout(function() {
      var startMoment = null;
      var endMoment = null;
      if (viewMode === 'week') {
        startMoment = moment.tz(selectedSchedule.selectedWeek.start, timezone);
        endMoment = moment.tz(selectedSchedule.selectedWeek.end, timezone);
      } else {
        startMoment = moment.tz(selectedSchedule.day.datetimeStamp, timezone).hours(0).minutes(0).seconds(0);
        endMoment = moment.tz(selectedSchedule.day.datetimeStamp, timezone).hours(23).minutes(59).seconds(59);
      }
      var selectedOpenShiftStartMoment = moment.tz(selectedOpenShift.start, timezone);
      var selectedOpenShiftEndMoment = moment.tz(selectedOpenShift.end, timezone);
      var startTimeStr = '', endTimeStr = '';
      startTimeStr = selectedOpenShiftStartMoment.format('MM/DD/YYYY h:mma');
      endTimeStr = selectedOpenShiftEndMoment.format('h:mma');
      $scope.data.selectedOpenShift.timeStr = startTimeStr + '-' + endTimeStr;

      $('#start-picker').datetimepicker();
      $('#end-picker').datetimepicker();
      $('#start-picker').data('DateTimePicker').minDate(moment(startMoment.format('YYYY-MM-DD HH:mm:ss')));
      $('#start-picker').data('DateTimePicker').maxDate(moment(endMoment.format('YYYY-MM-DD HH:mm:ss')));
      $('#start-picker').data('DateTimePicker').date(moment(selectedOpenShiftStartMoment.format('YYYY-MM-DD HH:mm:ss')));
      $('#end-picker').data('DateTimePicker').date(moment(selectedOpenShiftEndMoment.format('YYYY-MM-DD HH:mm:ss')));
      $('#end-picker').data('DateTimePicker').minDate(moment(selectedOpenShiftStartMoment.format('YYYY-MM-DD HH:mm:ss')));

      var startDateTimeStr = $('#start-picker').data('DateTimePicker').date().format('YYYY-MM-DD HH:mm:ss');
      var endDateTimeStr = $('#end-picker').data('DateTimePicker').date().format('YYYY-MM-DD HH:mm:ss');
      $scope.data.shiftTime.start = moment.tz(startDateTimeStr, timezone).unix() * 1000;
      $scope.data.shiftTime.end = moment.tz(endDateTimeStr, timezone).unix() * 1000;

      $('#start-picker').on('dp.change', function (e) {
        $('#end-picker').data('DateTimePicker').minDate(false);
        if ($('#end-picker').data('DateTimePicker').date().unix() < e.date.unix()) {
          $('#end-picker').data('DateTimePicker').date(e.date.clone());
        }
        $('#end-picker').data('DateTimePicker').minDate(e.date.clone());
        if ($('#end-picker').data('DateTimePicker').date().unix() - e.date.unix() > 16 * 3600 ||
          $('#end-picker').data('DateTimePicker').date().unix() - e.date.unix() === 0) {
          $scope.data.shiftTimeRangeInvalid = true;
          return;
        } else {
          $scope.data.shiftTimeRangeInvalid = false;
        }

        var startDateTimeStr = e.date.format('YYYY-MM-DD HH:mm:ss');
        var endDateTimeStr = $('#end-picker').data('DateTimePicker').date().format('YYYY-MM-DD HH:mm:ss');
        $scope.data.shiftTime.start = moment.tz(startDateTimeStr, timezone).unix() * 1000;
        $scope.data.shiftTime.end = moment.tz(endDateTimeStr, timezone).unix() * 1000;
        $scope.getWipEligibleEmployees();
        initializeCalendarCells();
        $scope.$apply();
      });
      $('#end-picker').on('dp.change', function (e) {
        if ($('#start-picker').data('DateTimePicker').date() === null) {
          $('#start-picker').data('DateTimePicker').date(e.date.clone());
        }
        if (e.date.unix() - $('#start-picker').data('DateTimePicker').date().unix() > 16 * 3600 ||
          e.date.unix() - $('#start-picker').data('DateTimePicker').date().unix() === 0) {
          $scope.data.shiftTimeRangeInvalid = true;
          return;
        } else {
          $scope.data.shiftTimeRangeInvalid = false;
        }

        var startDateTimeStr = $('#start-picker').data('DateTimePicker').date().format('YYYY-MM-DD HH:mm:ss');
        var endDateTimeStr = e.date.format('YYYY-MM-DD HH:mm:ss');
        $scope.data.shiftTime.start = moment.tz(startDateTimeStr, timezone).unix() * 1000;
        $scope.data.shiftTime.end = moment.tz(endDateTimeStr, timezone).unix() * 1000;
        $scope.getWipEligibleEmployees();
        initializeCalendarCells();
        $scope.$apply();
      });
    }, 0);

    initializeTeamsSkills();
    initializeCalendarHeaderCells();
  }]);

;
angular.module('emlogis.employeeSchedules')
  .service('EmployeeSchedulesService', ['$http', 'applicationContext', 'UtilsService',
    function($http, applicationContext, UtilsService) {
      var baseUrl = applicationContext.getBaseRestUrl();

      function sendRequest(urlPart, method, requestPayload) {
        var apiUrl = baseUrl + urlPart;
        var req = {
          method: method,
          url: apiUrl
        };
        if (method === 'POST' || method === 'PUT') {
          req.data = requestPayload;
        }

        return $http(req);
      }

      this.getSiteSchedules = function(selectedSite) {
        var urlPart = 'sites/' + selectedSite.id + '/schedules?limit=200';

        return sendRequest(urlPart, 'GET', null);
      };

      this.getScheduleForWeekView = function(scheduleId) {
        var urlPart = 'schedules/' + scheduleId + '/scheduleview';

        return sendRequest(urlPart, 'GET', null);
      };

      this.getScheduleForDayView = function(scheduleId, datetimeStamp, shiftsOnly) {
        var urlPart = 'schedules/' + scheduleId + '/scheduledayview?date=' + datetimeStamp + '&shiftsonly=' + shiftsOnly;

        return sendRequest(urlPart, 'GET', null);
      };

      this.getScheduleStatistics = function(scheduleId) {
        var urlPart = 'schedules/' + scheduleId + '/statistics';

        return sendRequest(urlPart, 'GET', null);
      };

      this.getOpenShifts = function(scheduleId, startDate, endDate) {
        var urlPart = 'schedules/' + scheduleId + '/openshifts?startdate=' + startDate + '&enddate=' + endDate;

        return sendRequest(urlPart, 'GET', null);
      };

      this.getEligibilityDataFromSelectedEntities = function(scheduleId, payLoad) {
        var urlPart = 'schedules/' + scheduleId + '/ops/getopenshifteligibilitysimple?asstring=false';

        return sendRequest(urlPart, 'POST', payLoad);
      };

      this.getOverrideOptions = function(siteId) {
        var urlPart = 'sites/' + siteId + '/postoverrides/default';

        return sendRequest(urlPart, 'GET', null);
      };

      this.updateOverrideOptions = function(siteId, overrideOptions) {
        var urlPart = 'sites/' + siteId + '/postoverrides/default';
        var payLoad = {
          clName: 'PostOverrides',
          name: 'default',
          overrideOptions: overrideOptions
        };

        return sendRequest(urlPart, 'PUT', payLoad);
      };

      this.postOpenShifts = function(scheduleId, payLoad) {
        var urlPart = 'schedules/' + scheduleId + '/postedopenshifts';

        return sendRequest(urlPart, 'POST', payLoad);
      };

      this.getPostedOpenShifts = function(scheduleId) {
        var urlPart = 'schedules/' + scheduleId + '/postedopenshifts';

        return sendRequest(urlPart, 'GET', null);
      };
    }
  ]);
;
angular.module('emlogis.employees', ['ui.bootstrap', 'ui.calendar', 'ui.router', 'http-auth-interceptor',
  'ui.grid.resizeColumns', 'ui.grid.pagination', 'ui.grid.pinning' ])
  .config(
  [
    '$stateProvider', '$urlRouterProvider',
    function ($stateProvider, $urlRouterProvider) {

      $urlRouterProvider.when('/employees/:id/detail', '/employees/:id/detail/calendar');
      $urlRouterProvider.when('/employees', '/employees/list');
      $urlRouterProvider.when('/employees/', '/employees/list');

      $stateProvider.state('authenticated.employees', {
        url: '/employees',
        abstract: true,
        views: {
          "content@authenticated": {
            templateUrl: "modules/employees/partials/employees.html",
            controller: 'EmployeesCtrl'
          },
          "breadcrumb@authenticated": {
            templateUrl: "modules/employees/partials/employee_breadcrumb.html",
            controller: 'EmployeesBreadcrumbCtrl'
          }
        },
        data: {
          permissions: function (authService) {
            return authService.isTenantType('Customer') && authService.hasPermissionIn(
                ['Demand_View','Demand_Mgmt','Availability_RequestMgmt','Shift_RequestMgmt','Shift_Mgmt',
                  'SystemConfiguration_Mgmt','Employee_Mgmt']);
          }
        }
      })
        .state('authenticated.employees.list', {
          url: '/list',
          views: {
            "employeeContent@authenticated.employees": {
              templateUrl: "modules/employees/partials/employees_list.html",
              controller: 'EmployeesListCtrl'
            },
            "employeeBreadcrumb@authenticated.employees": {
              templateUrl: "modules/employees/partials/employee_breadcrumb.html",
              controller: "EmployeesBreadcrumbCtrl"
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"app.LIST"|translate}}'
          }
        })
        .state('authenticated.employees.detail', {
          url: '/:id/detail',
          views: {
            "employeeContent@authenticated.employees": {
              templateUrl: "modules/employees/partials/employee-details/employees_detail.html",
              controller: 'EmployeesDetailCtrl'
            },
            "employeeBreadcrumb@authenticated.employees": {
              templateUrl: "modules/employees/partials/employee_breadcrumb.html",
              controller: "EmployeesBreadcrumbCtrl"
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"app.DETAIL"|translate}}'
          }
        })
        .state('authenticated.employees.detail.currentCalendar', {
          url: '/calendar',
          views: {
            "detailsTabContent@authenticated.employees.detail": {
              templateUrl: "modules/employees/partials/employee-details/tabs/current_calendar.html",
              controller: 'EmployeeDetailsCalendarCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"employees.tabs.CURRENT_CALENDAR"|translate}}'
          }
        })
        .state('authenticated.employees.detail.availability', {
          url: '/availability',
          views: {
            "detailsTabContent@authenticated.employees.detail": {
              templateUrl: "modules/employees/partials/employee-details/tabs/availability.html",
              controller: 'EmployeeDetailsAvailabilityCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"employees.tabs.AVAILABILITY"|translate}}'
          }
        })
        .state('authenticated.employees.detail.settings', {
          url: '/settings',
          views: {
            "detailsTabContent@authenticated.employees.detail": {
              templateUrl: "modules/employees/partials/employee-details/tabs/settings.html",
              controller: 'EmployeeDetailsSettingsCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"employees.tabs.SETTINGS"|translate}}'
          }
        });


    }
  ]
)
.filter('wage', function () {
  return function (number) {
    if (number > 0) {
      number = number/100;
      return '$' + number;
    } else {
      return '';
    }
  };
})
.filter('gender', function () {
  return function (str) {
    switch (str) {
      case '1':
        return 'employees.MALE';
      case '2':
        return 'employees.FEMALE';
      case '0':
        return 'employees.NA';
      default:
        return str;
    }
  };
})
.filter('employeeType', function () {
  return function (str) {
    return 'employees.' + str;
  };
})
.filter('minutesToDays', function () {
  return function (minutes) {
    var days = minutes / 24 / 60;
    var hours = minutes / 60 % 24;
    var minutesLeft = minutes % 60;
    return days > 0 ? days +  'd '  : '' +
           hours > 0 ? hours + 'h ' : '' +
           minutesLeft > 0 ? minutesLeft + 'm' : '';
  };
});

;
(function () {
  "use strict";

  var employees = angular.module('emlogis.employees');

  employees.controller('EmployeesDetailsEmergencyModalCtrl',
    ['$scope', '$rootScope', '$modalInstance', 'employeesDetailsService', 'employee',
      function ($scope, $rootScope, $modalInstance, employeesDetailsService, employee) {

        //--------------------------------------------------------------------
        // Defaults for Emergency Contact Modal
        //--------------------------------------------------------------------

        var ec = this;

        ec.employee = employee;
        ec.isEditing = false;
        ec.relationships = ['Brother', 'Daughter', 'Father', 'Friend', 'Husband', 'Mother', 'Peer', 'Sister', 'Son', 'Spouse', 'Wife'];



        //
        // If user navigates away from the page,
        // dismiss the modal

        $rootScope.$on('$stateChangeStart',
          function(){
            $modalInstance.dismiss('cancel');
          }
        );


        //--------------------------------------------------------------------
        // CRUD
        //--------------------------------------------------------------------

        ec.startEditing = function () {
          ec.employeeForEdit = angular.copy(ec.employee);
          ec.isEditing = true;
        };


        ec.cancelEditing = function () {
          ec.isEditing = false;
        };


        ec.saveEmergencyContact = function(){
          var newEc = {
            emergencyContact: ec.employeeForEdit.emergencyContact,
            ecRelationship: ec.employeeForEdit.ecRelationship,
            ecPhoneNumber: ec.employeeForEdit.ecPhoneNumber
          };

          return employeesDetailsService.updateEmployee(ec.employee, newEc).then(function(employee){
            ec.employee = employee;
            ec.isEditing = false;
          });
        };


        //--------------------------------------------------------------------
        // Modal methods
        //--------------------------------------------------------------------


        ec.closeEcModal = function () {
          $modalInstance.close(ec.employee);
        };


        ec.cancelEcModal = function () {
          $modalInstance.dismiss('cancel');
        };

      }
    ]);
})();
;
(function () {
  "use strict";

  var employees = angular.module('emlogis.employees');

  employees.controller('EmployeesDetailsPTOsModalCtrl',
    ['$scope', '$timeout', '$modalInstance', 'uiGridConstants', 'employeesDetailsService', 'employee',
      function ($scope, $timeout, $modalInstance, uiGridConstants, employeesDetailsService, employee) {

        //--------------------------------------------------------------------
        // Defaults for Employee Skills Modal
        //--------------------------------------------------------------------

        var pto = this,
            numOfRows = 15;

        pto.employee = employee;
        pto.allPTOs = null;
        pto.allPTOsInit = null;


        employeesDetailsService.getEmployeePTO(pto.employee).then(function(data) {
          pto.allPTOs = data;

          $timeout(function() {
            preparePTOsGrid(pto.allPTOs);
          });
        },
        function (err) {
          applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
        });



        //--------------------------------------------------------------------
        // Grid settings
        //--------------------------------------------------------------------

        var preparePTOsGrid = function(allPTOs){

          pto.gridOptions = {
            data: allPTOs,
            totalItems: allPTOs.length,
            minRowsToShow: allPTOs.length < numOfRows ? allPTOs.length : numOfRows,
            needPagination: true,
            enableHorizontalScrollbar: 0,
            enableVerticalScrollbar: 1,
            enableColumnMenus: false,
            enableFiltering: false,
            enableSorting: true,
            columnDefs: [
              {
                field: 'startDateTime',
                displayName: 'Date',
                cellFilter: 'date', // :\'MM/dd/yyyy\'
                type: 'date',
                sort: {
                  direction: uiGridConstants.DESC
                }
              },
              {
                field: 'absenceTypeDto.name',
                displayName: 'Absence Type'
              },
              {
                field: 'reason',
                enableSorting: false
              },
              { field: 'id', visible: false }
            ],
            onRegisterApi: function(gridApi) {
              pto.gridApi = gridApi;

            }
          };
        };


        //--------------------------------------------------------------------
        // Modal methods
        //--------------------------------------------------------------------


        pto.closeModal = function () {
          $modalInstance.close(pto.employee);
        };


        //
        // If user navigates away from the page,
        // dismiss the modal

        $scope.$on('$stateChangeStart', function(){
            $modalInstance.dismiss('cancel');
          }
        );

      }
    ]);
})();
;
(function () {
  "use strict";

  var employees = angular.module('emlogis.employees');

  employees.controller('EmployeesDetailsSkillsModalCtrl',
    ['$scope', '$rootScope', '$timeout', '$modalInstance', 'uiGridConstants', 'dataService', 'employeesDetailsService', 'applicationContext', 'employee',
      function ($scope, $rootScope, $timeout, $modalInstance, uiGridConstants, dataService, employeesDetailsService, applicationContext, employee) {

        //--------------------------------------------------------------------
        // Defaults for Employee Skills Modal
        //--------------------------------------------------------------------

        var es = this,
            numOfRows = 15;

        es.employee = employee;
        es.isEditing = false;
        es.allSkills = null;
        es.allSkillsInit = null;



        employeesDetailsService.getSkills().then(function(data) {
          es.allSkillsInit = data;

          angular.forEach(es.allSkillsInit, function(skill) {
            var employeeSkillInfo = _.find(es.employee.skillInfo, { 'skillId': skill.id });
            skill.isEmployeeHasSkill = employeeSkillInfo ? true : false;
            skill.isSelected = employeeSkillInfo ? true : false;

            if ( employeeSkillInfo ) {
              skill.isPrimarySkill = employeeSkillInfo.isPrimarySkill;
              skill.skillScore = employeeSkillInfo.skillScore;
            }
          });

          es.allSkills = angular.copy(es.allSkillsInit);

          $timeout(function() {
            prepareSkillsGrid(es.allSkills);
          });
        },
        function (err) {
          applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
        });



        //--------------------------------------------------------------------
        // Grid settings
        //--------------------------------------------------------------------

        var prepareSkillsGrid = function(allSkills){
          function rowTemplate() {
            return '<div>' +
              '<div ng-repeat="(colRenderIndex, col) in colContainer.renderedColumns track by col.colDef.name" ' +
              'class="ui-grid-cell" ' +
              'ng-class="{ \'ui-grid-row-header-cell\': col.isRowHeader,          '  +
              '            \'row-to-add\': grid.appScope.es.skillToAdd(row),         '  +
              '            \'row-to-remove\': grid.appScope.es.skillToRemove(row)}"  '  +
              ' ui-grid-cell>' +
              '</div>' +
              '</div>';
          }

          es.scores = [ 1, 2, 3, 4, 5 ];
          es.skillsToRemove = [];
          es.skillsToAdd = [];

          es.skillToAdd = function(row) {
            return row.entity.isEmployeeHasSkill === false && row.isSelected === true;
          };

          es.skillToRemove = function(row) {
            return row.entity.isEmployeeHasSkill === true && row.isSelected === false;
          };

          es.gridOptions = {
            data: allSkills,
            totalItems: allSkills.length,
            minRowsToShow: allSkills.length < numOfRows ? allSkills.length : numOfRows,
            needPagination: false,
            enableHorizontalScrollbar: 0,
            enableVerticalScrollbar: 1,
            enableColumnMenus: false,
            enableFiltering: false,
            enableSorting: true,
            enableSelectAll: true,
            enableRowSelection: true,

            columnDefs: [
              { field: 'name', width: '55%'},
              {
                field: 'skillScore',
                cellTemplate: '<div class="text-center">' +
                                '<span ng-show="row.isSelected">' +
                                  '<select class="form-control eml-grid-select" ' +
                                          'ng-model="row.entity.skillScore" ' +
                                          'ng-options="score as score for score in grid.appScope.es.scores" ' +
                                          'ng-click="$event.stopPropagation()" ' +
                                          'ng-change="grid.appScope.es.updateEditing()">' +
                                  '</select>' +
                                '</span>' +
                              '</div>'
              },
              {
                field: 'isPrimarySkill',
                cellTemplate: '<div class="text-center">' +
                                '<span ng-show="row.isSelected">' +
                                  '<label class="eml-switch">' +
                                    '<input type="checkbox" ' +
                                            'class="eml-switch-input" ' +
                                            'ng-model="row.entity.isPrimarySkill" ' +
                                            'ng-checked="row.entity.isPrimarySkill"' +
                                            'ng-change="grid.appScope.es.updatePrimarySkill(row.entity.id)">' +
                                    '<span class="eml-switch-label" ' +
                                          'data-on="{{ ::\'app.YES\' | translate }}" ' +
                                          'data-off="{{ ::\'app.NO\' | translate }}"></span>' +
                                    '<span class="eml-switch-handle"></span>' +
                                '</span>' +
                              '</div>'
              },
              { field: 'id', visible: false }
            ],
            rowTemplate: rowTemplate(),
            onRegisterApi: function(gridApi) {
              es.gridApi = gridApi;

              $timeout(function() {
                _.each(allSkills, function(skill) {
                  if (skill.isEmployeeHasSkill) {
                    es.gridApi.selection.selectRow(skill);
                  }
                });
              });

              gridApi.selection.on.rowSelectionChanged($scope, function (row) {
                row.entity.isSelected = row.isSelected;
                es.updateEditing();

                // Update skillsToRemove list
                var isInRemoveList = _.indexOf(es.skillsToRemove, row.entity.id) > -1;
                if (row.isSelected && isInRemoveList) _.pull(es.skillsToRemove, row.entity.id);
                if (!row.isSelected && !isInRemoveList) es.skillsToRemove.push(row.entity.id);

                // Update skillsToAdd list
                var prepareSkill = function(skillObj){
                  return {
                    skillId:      skillObj.id,
                    primarySkill: skillObj.isPrimarySkill,
                    skillScore:   skillObj.skillScore
                  };
                };
                var isInAddList = _.find(es.skillsToAdd, {'skillId': row.entity.id});
                if (row.isSelected && !isInAddList) es.skillsToAdd.push( prepareSkill(row.entity) );
                if (!row.isSelected && isInAddList) {
                  _.remove(es.skillsToAdd, function(skill) {
                    return skill.skillId === row.entity.id;
                  });
                }
              });
            }
          };
        };


        //--------------------------------------------------------------------
        // CRUD
        //--------------------------------------------------------------------

        es.updateEditing = function(){
          es.isEditing = !angular.equals(es.allSkillsInit, es.allSkills);
        };


        es.updatePrimarySkill = function(skillId){
          angular.forEach(es.allSkills, function(skill){
            if ( skill.id !== skillId) skill.isPrimarySkill = false;
          });
          es.updateEditing();
        };


        es.saveSkills = function(){

          // 1. check what skillsToRemove Employee initially had
          var removeCollection = [];
          angular.forEach(es.skillsToRemove, function(skillId){
            var skillExisted = _.find(es.employee.skillInfo, {'skillId': skillId});
            if ( skillExisted ) removeCollection.push(skillId);
          });

          // 2. check what skillsToAdd Employee initially didn't have
          var addCollection = [],
              updateCollection = [];

          angular.forEach(es.skillsToAdd, function(skill){
            // 2.1. get current skill settings
            var skillModel = _.find(es.allSkills, {'id': skill.skillId });
            skill.skillScore = skillModel.skillScore;
            skill.primarySkill = skillModel.isPrimarySkill;

            // 2.2. check if skill was attached to employee on modal load
            var skillExisted = _.find(es.employee.skillInfo, {'skillId': skill.skillId});

            // 2.3. push to the corresponding array
            if ( skillExisted ) {
              updateCollection.push(skill);
            } else {
              addCollection.push(skill);
            }
          });

          // 3. create a dto for API
          var dto = {
            removeCollection: removeCollection,
            addCollection: addCollection,
            updateCollection: updateCollection
          };

          return employeesDetailsService.updateEmployeeSkills(es.employee, dto).then(function(employee){
            es.employee = employee;
            es.isEditing = false;
            es.closeModal();
          });
        };


        //--------------------------------------------------------------------
        // Modal methods
        //--------------------------------------------------------------------


        es.closeModal = function () {
          $modalInstance.close(es.employee);
        };


        //
        // If user navigates away from the page,
        // dismiss the modal

        $rootScope.$on('$stateChangeStart', function(){
            $modalInstance.dismiss('cancel');
          }
        );

      }
    ]);
})();
;
(function () {
  "use strict";

  var employees = angular.module('emlogis.employees');

  employees.controller('EmployeesDetailsTeamsModalCtrl',
    ['$scope', '$rootScope', '$timeout', '$modalInstance', 'dataService', 'employeesDetailsService', 'applicationContext', 'employee',
      function ($scope, $rootScope, $timeout, $modalInstance, dataService, employeesDetailsService, applicationContext, employee) {

        //--------------------------------------------------------------------
        // Defaults for Employee Teams Modal
        //--------------------------------------------------------------------

        var et = this,
            numOfRows = 15;

        et.employee = employee;
        et.isEditing = false;
        et.allTeams = null;
        et.allTeamsInit = null;



        employeesDetailsService.getSiteTeams().then(function(data) {
          et.allTeamsInit = data;
          //console.log('et.allTeamsInit', data);

          angular.forEach(et.allTeamsInit, function(team) {
            var employeeTeamInfo = _.find(et.employee.teamInfo, { 'teamId': team.id });
            team.isEmployeeAttachedToTeam = employeeTeamInfo ? true : false;
            team.isSelected = employeeTeamInfo ? true : false;

            if ( employeeTeamInfo ) {
              team.isFloating = employeeTeamInfo.isFloating;
              team.isSchedulable = employeeTeamInfo.isSchedulable;
              team.isHomeTeam = employeeTeamInfo.isHomeTeam;
            }
          });

          et.allTeams = angular.copy(et.allTeamsInit);

          $timeout(function() {
            prepareTeamsGrid(et.allTeams);
          });
        },
        function (err) {
          applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
        });

        //--------------------------------------------------------------------
        // Grid settings
        //--------------------------------------------------------------------

        var prepareTeamsGrid = function(allTeams){
          function rowTemplate() {
            return '<div>' +
              '<div ng-repeat="(colRenderIndex, col) in colContainer.renderedColumns track by col.colDef.name" ' +
              'class="ui-grid-cell" ' +
              'ng-class="{ \'ui-grid-row-header-cell\': col.isRowHeader,          '  +
              '            \'row-to-add\': grid.appScope.et.teamToAdd(row),         '  +
              '            \'row-to-remove\': grid.appScope.et.teamToRemove(row),  '  +
              '            \'row-home-team\': grid.appScope.et.isHomeTeam(row) }" ' +
              ' ui-grid-cell>' +
              '</div>' +
              '</div>';
          }

          et.teamsToRemove = [];
          et.teamsToAdd = [];

          et.teamToAdd = function(row) {
            return row.entity.isEmployeeAttachedToTeam === false && row.isSelected === true;
          };

          et.teamToRemove = function(row) {
            return row.entity.isEmployeeAttachedToTeam === true && row.isSelected === false;
          };

          et.isHomeTeam = function(row) {
            return row.entity.isHomeTeam;
          };


          et.gridOptions = {
            data: allTeams,
            totalItems: allTeams.length,
            minRowsToShow: allTeams.length < numOfRows ? allTeams.length : numOfRows,
            needPagination: false,
            enableHorizontalScrollbar: 0,
            enableVerticalScrollbar: 1,
            enableColumnMenus: false,
            enableFiltering: false,
            enableSorting: true,
            enableSelectAll: true,
            enableRowSelection: true,

            columnDefs: [
              { field: 'name', width: '55%'},
              {
                field: 'isFloating',
                cellTemplate: '<div>' +
                                  '<span ng-show="row.isSelected">' +
                                    '<label class="eml-switch">' +
                                      '<input type="checkbox" ' +
                                              'class="eml-switch-input" ' +
                                              'ng-model="row.entity.isFloating" ' +
                                              'ng-checked="row.entity.isFloating"' +
                                              'ng-change="grid.appScope.et.updateEditing()">' +
                                      '<span class="eml-switch-label" ' +
                                              'data-on="{{ ::\'app.YES\' | translate }}" ' +
                                              'data-off="{{ ::\'app.NO\' | translate }}"></span>' +
                                    '<span class="eml-switch-handle"></span>' +
                                  '</span>' +
                              '</div>'
              },
              { field: 'teamId',          visible: false },
              { field: 'isHomeTeam',      visible: false }
            ],
            rowTemplate: rowTemplate(),
            onRegisterApi: function(gridApi) {
              et.gridApi = gridApi;

              $timeout(function() {
                _.each(allTeams, function(team) {
                  if (team.isEmployeeAttachedToTeam) {
                    et.gridApi.selection.selectRow(team);
                  }
                });
              });

              gridApi.selection.on.rowSelectionChanged($scope, function (row) {

                // prevent Home Team to be deselected
                if ( !row.isSelected && row.entity.isHomeTeam ) {
                  et.gridApi.selection.selectRow(row.entity);
                  return;
                }

                row.entity.isSelected = row.isSelected;
                et.updateEditing();

                // Update teamsToRemove list
                var isInRemoveList = _.indexOf(et.teamsToRemove, row.entity.id) > -1;
                if (row.isSelected && isInRemoveList) _.pull(et.teamsToRemove, row.entity.id);
                if (!row.isSelected && !isInRemoveList) et.teamsToRemove.push(row.entity.id);

                // Update teamsToAdd list
                var prepareTeam = function(teamsObj){
                  return {
                    teamId:         teamsObj.id,
                    isFloating:     teamsObj.isFloating,
                    isSchedulable:  teamsObj.isSchedulable
                  };
                };
                var isInAddList = _.find(et.teamsToAdd, {'teamId': row.entity.id});
                if (row.isSelected && !isInAddList) et.teamsToAdd.push( prepareTeam(row.entity) );
                if (!row.isSelected && isInAddList) {
                  _.remove(et.teamsToAdd, function(team) {
                    return team.teamId === row.entity.id;
                  });
                }
              });

            }
          };
        };


        //--------------------------------------------------------------------
        // CRUD
        //--------------------------------------------------------------------


        et.updateEditing = function(){
          et.isEditing = !angular.equals(et.allTeamsInit, et.allTeams);
          //console.log('+++ et.isEditing', et.isEditing);
        };


        et.saveTeams = function(){

          // 1. check what teamsToRemove Employee initially had
          var removeCollection = [];
          angular.forEach(et.teamsToRemove, function(teamId){
            var teamExisted = _.find(et.employee.teamInfo, {'teamId': teamId});
            if ( teamExisted ) removeCollection.push(teamId);
          });

          // 2. check what teamsToAdd Employee initially didn't have
          var addCollection = [],
            updateCollection = [];

          angular.forEach(et.teamsToAdd, function(team){
            // 2.1. get current team settings
            var teamModel = _.find(et.allTeams, {'id': team.teamId });
            team.isFloating = teamModel.isFloating ? teamModel.isFloating : false;
            team.isSchedulable = teamModel.isSchedulable ? teamModel.isSchedulable : false;

            // 2.2. check if team was attached to employee on modal load
            var teamExisted = _.find(et.employee.teamInfo, {'teamId': team.teamId});

            // 2.3. push to the corresponding array
            if ( teamExisted ) {
              if ( !angular.equals(teamExisted, team) ) {
                updateCollection.push(team);
              }
            } else {
              addCollection.push(team);
            }
          });

          // 3. create a dto for API
          var dto = {
            removeCollection: removeCollection,
            addCollection: addCollection,
            updateCollection: updateCollection
          };

          return employeesDetailsService.updateEmployeeTeams(et.employee, dto).then(function(employee){
            et.employee = employee;
            et.isEditing = false;
            et.closeModal();
          });

        };


        //--------------------------------------------------------------------
        // Modal methods
        //--------------------------------------------------------------------


        et.closeModal = function () {
          $modalInstance.close(et.employee);
        };


        //
        // If user navigates away from the page,
        // dismiss the modal

        $rootScope.$on('$stateChangeStart', function(){
            $modalInstance.dismiss('cancel');
          }
        );

      }
    ]);
})();
;
(function () {
  "use strict";

  var employees = angular.module('emlogis.employees');

  employees.controller('EmployeeDetailsProfileCtrl',
    ['$scope', '$state', '$filter', '$timeout', '$modal', 'applicationContext', 'authService', 'employeesDetailsService', 'appFunc', 'dataService',
    function ($scope, $state, $filter, $timeout, $modal, applicationContext, authService, employeesDetailsService, appFunc, dataService) {

      //--------------------------------------------------------------------
      // On Ctrl load
      //--------------------------------------------------------------------

      var profile = this;
      profile.employee = null;
      profile.allSiteTeams = [];

      profile.isEditing = false;
      profile.updatesCounter = 0;
      profile.isWageClosed = true;

      profile.genderOptions = ['0', '1', '2'];
      profile.employeeTypes = [ 'FullTime', 'PartTime' ];
      profile.activityTypes = [ 'Active', 'Inactive', 'Pooled' ];

      profile.picture = null;
      profile.pictureToLoad = null;
      profile.isPictureDisplayed = false;

      profile.hireDate = {
        isOpened: false,
        openDatepicker: function($event) {

          if(profile.hireDate.isOpened) {
            // Prevent datepicker from closing this calendar popup
            $event.preventDefault();
            $event.stopPropagation();

          } else {
            // Delay opening until next tick,
            // otherwise calendar popup will be immediately closed
            $timeout(function() {
              profile.hireDate.isOpened = true;
            });
          }
        }
      };
      profile.startDate = {
        isOpened: false,
        openDatepicker: function($event) {

          if(profile.startDate.isOpened) {
            // Prevent datepicker from closing this calendar popup
            $event.preventDefault();
            $event.stopPropagation();

          } else {
            // Delay opening until next tick,
            // otherwise calendar popup will be immediately closed
            $timeout(function() {
              profile.startDate.isOpened = true;
            });
          }
        }
      };
      profile.endDate = {
        isOpened: false,
        openDatepicker: function($event) {

          if(profile.endDate.isOpened) {
            // Prevent datepicker from closing this calendar popup
            $event.preventDefault();
            $event.stopPropagation();

          } else {
            // Delay opening until next tick,
            // otherwise calendar popup will be immediately closed
            $timeout(function() {
              profile.endDate.isOpened = true;
            });
          }
        }
      };



      employeesDetailsService.getEmployeeDetails($state.params.id).then(function(employee){
        updateProfileModel(employee);

        employeesDetailsService.getEmployeePicture(employee).then(function(picture){
          updateProfilePicture(picture);
        });
      });



      var updateProfileModel = function(employee){
        profile.employee = employee;
        //console.log('+++ profile.employee updated', profile.employee);
        //console.log('1 employeeObj.hireDate', moment(employee.hireDate).format() );
        //console.log('1 utc employeeObj.hireDate', moment.tz(employee.hireDate, 'UTC').format() );
      };

      var updateProfilePicture = function(picture){
        profile.picture = picture;
        profile.isPictureDisplayed = picture.size > 0;
      };


      //
      // check if user has permission to edit wages

      profile.hasWagePermission = function () {
        return authService.hasPermission('EmployeeWages_Mgmt');
      };

      profile.displayWage = function(){
        profile.isWageClosed = false;
      };



      //--------------------------------------------------------------------
      // CRUD
      //--------------------------------------------------------------------


      profile.deleteEmployee = function(){
        employeesDetailsService.deleteEmployee(profile.employee).
          then(function(employee){
            updateProfileModel(employee);
            $state.go("authenticated.employees.list");
          });
      };



      //
      // on Save button click in Profile section
      // update Employee Details, Employee Login and Employee HomeTeam

      profile.saveEmployeeProfile = function(employeeForEdit){
        profile.updatesCounter = 0;

        // 1. Check if login was changed

        var newLogin;
        if ( profile.employee.userAccountDto ) {
          var isLoginChanged = !angular.equals(profile.employee.userAccountDto.login, employeeForEdit.userAccountDto.login);
          if ( isLoginChanged ) {
            profile.updatesCounter++;
            newLogin = { login: employeeForEdit.userAccountDto.login };
            employeesDetailsService.updateEmployeeAccount(employeeForEdit, newLogin).then( function(data){
              profile.updatesCounter--;
            });
          }
        } else if ( employeeForEdit.userAccountDto ) {
          newLogin = { login: employeeForEdit.userAccountDto.login };
          profile.updatesCounter++;
          employeesDetailsService.updateEmployeeAccount(employeeForEdit, newLogin).then( function(data){
            profile.updatesCounter--;
          });
        }


        // 2. Check if home team was changed

        if ( !angular.equals(profile.employee.homeTeam.teamId, employeeForEdit.homeTeam.teamId) ) {
          profile.updatesCounter++;

          // check if new home team is already assigned to an employee
          var teamIsAssosiated = (_.find(employeeForEdit.teamInfo, { 'teamId': employeeForEdit.homeTeam.teamId })) ? true : false;
          if (teamIsAssosiated) {
            var putDto = { isHomeTeam: true };
            employeesDetailsService.updateEmployeeHomeTeam(employeeForEdit, employeeForEdit.homeTeam.teamId, putDto)
              .then(function(res){
                profile.updatesCounter--;
              })
            ;

          } else {
            var assosiateDto = {
              isHomeTeam: true,
              teamId: employeeForEdit.homeTeam.teamId,
              isSchedulable: true,
              isFloating: false
            };
            employeesDetailsService.addHomeTeamToEmployee(employeeForEdit, employeeForEdit.homeTeam.teamId, assosiateDto)
              .then(function(res){
                profile.updatesCounter--;
              })
            ;
          }
        }


        // 3. Check if details were changed

        var prepareEmployeeDetailsDto = function(employeeObj){
          //console.log('2 employeeObj.hireDate', employeeObj.hireDate);
          return {
            firstName:          employeeObj.firstName,
            middleName:         employeeObj.middleName,
            lastName:           employeeObj.lastName,
            employeeIdentifier: employeeObj.employeeIdentifier,
            professionalLabel:  employeeObj.professionalLabel,
            gender:             employeeObj.gender,
            homePhone:          employeeObj.homePhone || null,
            mobilePhone:        employeeObj.mobilePhone || null,
            homeEmail:          employeeObj.homeEmail || null,
            workEmail:          employeeObj.workEmail || null,
            hireDate:           employeeObj.hireDate,
            startDate:          employeeObj.startDate,
            endDate:            employeeObj.endDate,
            hourlyRate:         employeeObj.hourlyRate,
            employeeType:       employeeObj.employeeType,
            activityType:       employeeObj.activityType
          };
        };

        var oldEmployee = prepareEmployeeDetailsDto(profile.employee);
        var newEmployee = prepareEmployeeDetailsDto(employeeForEdit);

        if ( !angular.equals(oldEmployee, newEmployee) ) {
          profile.updatesCounter++;
          console.log('newEmployee', newEmployee);
          employeesDetailsService.updateEmployee(employeeForEdit, newEmployee).then(function(res){
            profile.updatesCounter--;
            console.log(res);
          });
        }

        // 4. Wait for all API calls to be resolved,
        // then update page options and get updated employee

        var removeThisWatcher = $scope.$watch("profile.updatesCounter", function(newVal, oldVal) {
          if (newVal === 0 && oldVal === 1) {
            employeesDetailsService.getEmployeeDetails(employeeForEdit.id).then(function(employee){
              applicationContext.setNotificationMsgWithValues('app.SAVED_SUCCESSFULLY', 'success', true);
              updateProfileModel(employee);
              profile.isEditing = false;
            }, function(err) {
              applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
            });
            removeThisWatcher();                                           // remove this $watch
          }
        });
      };



      //
      // Upload Employee picture

      profile.uploadPicture = function($event){
        var evt = $event,
            img = profile.pictureToLoad,
            reader = new FileReader();

        // If we use onloadend, we need to check the readyState.
        reader.onloadend = function(evt) {
          if (evt.target.readyState == FileReader.DONE) { // DONE == 2
            var imageBytes, commaIndex, image, dto;

            imageBytes = evt.target.result;
            commaIndex = imageBytes.indexOf(',') + 1;
            image = imageBytes.slice(commaIndex);
            img.dto = { image: image };

            employeesDetailsService.uploadEmployeePicture(profile.employee, img).then(function(picture){
              updateProfilePicture(picture);
            });
          }
        };
        reader.readAsDataURL(img);
      };


      //
      // when new picture is selected
      // upload Employee picture

      $scope.$watch('profile.pictureToLoad', function(newVal){
        if (newVal) {
          profile.uploadPicture();
        }
      });


      //
      // delete Employee picture

      profile.deletePicture = function(){
        var img = profile.picture;
        img.dto = { image: null };
        employeesDetailsService.uploadEmployeePicture(profile.employee, img).then(function(picture){
          updateProfilePicture(picture);
        });
      };


      //--------------------------------------------------------------------
      // Editing process
      //--------------------------------------------------------------------


      profile.startEditing = function () {
        employeesDetailsService.getSiteTeams().then( function(data) {
          profile.allSiteTeams = data;
        });
        profile.employeeForEdit = angular.copy(profile.employee);
        profile.isEditing = true;
      };


      profile.cancelEditing = function () {
        profile.isEditing = false;
      };


      profile.isModified = function() {
        return !angular.equals(profile.employeeForEdit, profile.employee);
      };



      //--------------------------------------------------------------------
      // Emergency modal
      //--------------------------------------------------------------------

      profile.openEmergencyContactModal = function (size) {

        var modalInstance = $modal.open({
          templateUrl:  'modules/employees/partials/employee-details/empl-details-emergency-modal.html',
          controller:   'EmployeesDetailsEmergencyModalCtrl as ec',
          backdrop:     'static',
          size: size,
          resolve: {
            employee: function () {
              return profile.employee;
            }
          }
        });


        modalInstance.result.then(function (employee) {
          updateProfileModel(employee);
        }, function () {
          //console.log('Modal dismissed at: ' + new Date());
        });
      };
    }
  ]);

  employees.directive('fileModel', ['$parse', function ($parse) {
    return {
      restrict: 'A',
      link: function(scope, element, attrs) {
        var model = $parse(attrs.fileModel);
        var modelSetter = model.assign;

        element.bind('change', function(){
          scope.$apply(function(){
            modelSetter(scope, element[0].files[0]);
          });
        });
      }
    };
  }]);

})();
;
(function () {
  "use strict";

  var employees = angular.module('emlogis.employees');

  employees.controller('EmployeeDetailsSidebarCtrl', ['$scope', '$state', '$modal', 'employeesDetailsService',
    function ($scope, $state, $modal, employeesDetailsService) {

      //--------------------------------------------------------------------
      // On Ctrl load
      //--------------------------------------------------------------------

      var employeeInit,
          sidebar = this;

      sidebar.employee = null;
      sidebar.isEditingApprovals = false;


      employeesDetailsService.getEmployeeDetails($state.params.id).then(function(employee){
        updateSidebarModel(employee);
      });

      var updateSidebarModel = function(employee){
        sidebar.employee = employee;
        employeeInit = employeesDetailsService.getEmployeeInit();
        //console.log('+++ sidebar.employee updated', sidebar.employee);
      };


      //
      // watch for Employee Home Team is edited in profile section
      // and update Employee obj

      $scope.$watch(function () {
        if ( sidebar.employee ) {
          return employeesDetailsService.getEmployeeTeam();
        }
      }, function (newTeam, oldTeam) {
        if ( !newTeam || oldTeam === undefined || angular.equals(newTeam, oldTeam) ) {
          return;
        }
        employeesDetailsService.getEmployeeDetails(sidebar.employee.id).then(function(employee){
          updateSidebarModel(employee);
        });
      });


      //
      // watch for Employee Home Team is edited in profile section
      // and update Employee obj

      $scope.$watch(function () {
        if ( sidebar.employee ) {
          return employeesDetailsService.getEmployeeActivityType();
        }
      }, function (newActivity, oldActivity) {
        if ( !newActivity || oldActivity === undefined || angular.equals(newActivity, oldActivity) ) {
          return;
        }
        employeesDetailsService.getEmployeeDetails(sidebar.employee.id).then(function(employee){
          updateSidebarModel(employee);
        });
      });



      //--------------------------------------------------------------------
      // USER panel
      //--------------------------------------------------------------------

      sidebar.resetPassword = function() {
        employeesDetailsService.requestUserPasswordReset();
      };

      sidebar.toggleNotifications = function(enable) {
        employeesDetailsService.toggleUserNotifications(enable);
      };


      //--------------------------------------------------------------------
      // EMLOGIS panel
      //--------------------------------------------------------------------

      //
      // Update Approvals settings

      sidebar.updateEditingApprovals = function(){
        sidebar.isEditingApprovals = !angular.equals(sidebar.employee.autoApprovalsSettingDto, employeeInit.autoApprovalsSettingDto);
      };


      //
      // Update Approvals settings

      sidebar.saveApprovals = function(){
        var newApprovals = {
          availAutoApprove: sidebar.employee.autoApprovalsSettingDto.availAutoApprove,
          wipAutoApprove: sidebar.employee.autoApprovalsSettingDto.wipAutoApprove,
          swapAutoApprove: sidebar.employee.autoApprovalsSettingDto.swapAutoApprove
        };

        employeesDetailsService.updateEmployeeAutoapprovals(sidebar.employee, newApprovals)
          .then(function(employee){
            updateSidebarModel(employee);
            sidebar.isEditingApprovals = false;
          }, function(err) {
            // TODO: add modal type of errors
          })
        ;
      };


      //--------------------------------------------------------------------
      // PTO panel
      //--------------------------------------------------------------------


      //
      // get a list of PTOs for an Employee

      sidebar.getEmployeePTO = function(){
        employeesDetailsService.getEmployeePTO(sidebar.employee).then(function(res){

        });
      };

      sidebar.openPTOModal = function (size) {

        var modalInstance = $modal.open({
          templateUrl: 'modules/employees/partials/employee-details/empl-details-ptos-modal.html',
          controller: 'EmployeesDetailsPTOsModalCtrl as pto',
          size: size,
          backdrop: 'static',
          resolve: {
            employee: function () {
              return sidebar.employee;
            }
          }
        });

        modalInstance.result.then(function (employee) {
          updateSidebarModel(employee);
        }, function () {
          //console.log('Modal dismissed at: ' + new Date());
        });
      };


      //--------------------------------------------------------------------
      // SKILLS panel
      //--------------------------------------------------------------------


      //
      // Skills modal

      sidebar.openSkillsModal = function (size) {

        var modalInstance = $modal.open({
          templateUrl: 'modules/employees/partials/employee-details/empl-details-skills-modal.html',
          controller: 'EmployeesDetailsSkillsModalCtrl as es',
          size: size,
          backdrop: 'static',
          resolve: {
            employee: function () {
              return sidebar.employee;
            }
          }
        });

        modalInstance.result.then(function (employee) {
          updateSidebarModel(employee);
        }, function () {
          //console.log('Modal dismissed at: ' + new Date());
        });
      };



      //--------------------------------------------------------------------
      // TEAMS panel
      //--------------------------------------------------------------------


      //
      // Teams modal

      sidebar.openTeamsModal = function (size) {

        var modalInstance = $modal.open({
          templateUrl: 'modules/employees/partials/employee-details/empl-details-teams-modal.html',
          controller: 'EmployeesDetailsTeamsModalCtrl as et',
          size: size,
          backdrop: 'static',
          resolve: {
            employee: function () {
              return sidebar.employee;
            }
          }
        });

        modalInstance.result.then(function (employee) {
          updateSidebarModel(employee);
        }, function () {
          //console.log('Modal dismissed at: ' + new Date());
        });
      };


    }]);
})();
;
var employees = angular.module('emlogis.employees');

employees.controller('EmployeesDetailCtrl', ['$scope', '$state',
  function ($scope, $state) {
    //console.log('employees detail controller id: "' + $state.params.id);
    $scope.employeeId = $state.params.id;
  }
]);

;
(function () {
  "use strict";

  angular.module('emlogis.employees').controller('EmployeeDetailsAvailabilityCtrl', ['$scope', 'dataService', 'employeesDetailsService',
    function ($scope, dataService, employeesDetailsService) {

      $scope.getEmployeeDetails = employeesDetailsService.getEmployeeInit;

      $scope.$watch("getEmployeeDetails()", function(details) {
        if (!details) return;

        $scope.employeeId = details.id;
        $scope.siteTimeZone = details.siteInfo.timeZone;
        $scope.firstDayOfWeek = details.siteInfo.firstDayOfWeek;
        dataService.getAbsenceTypes(details.siteInfo.siteId).then(function(res) {
          $scope.absenceTypes = res.data;
        });
      });

    }]);
})();
;
(function () {
  "use strict";

  angular.module('emlogis.employees').controller('EmployeeDetailsCalendarCtrl',
    ['$scope', '$state', '$q', 'dataService', 'employeesDetailsService',
    function ($scope, $state, $q, dataService, employeesDetailsService) {

      $scope.accountInfoDeferred = $q.defer();
      $scope.getEmployeeDetails = employeesDetailsService.getEmployeeInit;

      $scope.$watch("getEmployeeDetails()", function(details) {
        if (!details) return;

        $scope.accountInfoDeferred.resolve({
          timezone: details.siteInfo.timeZone,
          siteFirstDayOfweek: details.siteInfo.firstDayOfWeek,
          teams: details.teamInfo
        });
      });

      $scope.getAccountInfo = function() {
        return $scope.accountInfoDeferred.promise;
      };

      $scope.getEmployeeCalendarView = function(startDate, endDate) {
        var employeeId = $state.params.id,
            queryParams = {
              params: {
                startdate: startDate,
                enddate: endDate,
                scheduleStatus: 'Posted',
                returnedfields: "id, startDateTime, endDateTime, excess, skillAbbrev, skillName, teamName"
              }
            };
        return dataService.getEmployeeCalendarView(employeeId, queryParams);
      };
    }]);
})();
;
(function () {
  "use strict";

  angular.module('emlogis.employees').controller('EmployeeDetailsTabsCtrl', ['$scope',
    function ($scope) {
      $scope.tabs = [
        {heading: "employees.tabs.CURRENT_CALENDAR", route: 'authenticated.employees.detail.currentCalendar'},
        {heading: "employees.tabs.AVAILABILITY", route: 'authenticated.employees.detail.availability'},
        {heading: "employees.tabs.SETTINGS", route: 'authenticated.employees.detail.settings'}
      ];
    }]);
})();
;
(function () {
  "use strict";

  angular.module('emlogis.employees').controller('EmployeeDetailsSettingsCtrl',
    ['$scope', '$state', '$filter', '$timeout', 'dataService', 'applicationContext', 'employeesDetailsService',
      function ($scope, $state, $filter, $timeout, dataService, applicationContext, employeesDetailsService) {

        $scope.employeeId = $state.params.id;

        $scope.translations = {
          min:                    $filter('translate')("employees.tabs.hours.MIN"),
          max:                    $filter('translate')("employees.tabs.hours.MAX"),
          hoursPerDay:            $filter('translate')("employees.tabs.hours.HOURS_PER_DAY"),
          hoursPerWeek:           $filter('translate')("employees.tabs.hours.HOURS_PER_WEEK"),
          maxDaysPerWeek:         $filter('translate')("employees.tabs.hours.MAX_DAYS_PER_WEEK"),
          maxConsecutiveDays:     $filter('translate')("employees.tabs.hours.MAX_CONSECUTIVE_DAYS"),
          primarySkillHours:      $filter('translate')("employees.tabs.hours.PRIMARY_SKILL_HOURS"),
          overtime:               $filter('translate')("employees.tabs.hours.OVERTIME"),
          dailyOvertimeStarts:    $filter('translate')("employees.tabs.hours.DAILY_OVERTIME_STARTS"),
          weeklyOvertimeStarts:   $filter('translate')("employees.tabs.hours.WEEKLY_OVERTIME_STARTS"),
          beweeklyOvertimeStarts: $filter('translate')("employees.tabs.hours.BIWEEKLY_OVERTIME_STARTS"),
          beweeklyMinHours:       $filter('translate')("employees.tabs.hours.BIWEEKLY_MIN_HOURS"),
          na:                     $filter('translate')("employees.tabs.hours.NA")
        };

        $scope.settings = {
          daysPerWeek: 0,
          consecutiveDays: 0,
          minHoursPerDay: 0,
          maxHoursPerDay: 0,
          minHoursPerWeek: 0,
          maxHoursPerWeek: 0,
          primarySkillHours: 0,
          overtimeDto: {
            dailyOvertimeMins: 0,
            weeklyOvertimeMins: 0,
            biweeklyOvertimeMins: 0
          }
        };

        $scope.options = {
          minHoursPerDay:   generateArrayOfNumbers(1, 12),
          maxHoursPerDay:   generateArrayOfNumbers(1, 24),
          minHoursPerWeek:  generateArrayOfNumbers(1, 168), // 7 days in hours
          maxHoursPerWeek:  generateArrayOfNumbers(1, 168),
          hoursPer2Weeks:   generateArrayOfNumbers(1, 336), // 14 days in hours
          daysPerWeek:      generateArrayOfNumbers(1, 7),
          consecutiveDays:  generateArrayOfNumbers(2, 28),
          overtimeType:     null,
          overtimeTypes: [
            { id: "daily",            name: $filter('translate')("employees.tabs.hours.DAILY") },
            { id: "weekly",           name: $filter('translate')("employees.tabs.hours.WEEKLY") },
            { id: "biweekly",         name: $filter('translate')("employees.tabs.hours.BIWEEKLY") },
            { id: "dailyAndWeekly",   name: $filter('translate')("employees.tabs.hours.DAILY_AND_WEEKLY") },
            { id: "dailyAndBiweekly", name: $filter('translate')("employees.tabs.hours.DAILY_AND_BIWEEKLY") },
            { id: "na",               name: $scope.translations.na }
          ],
          dailyOvertime:   generateArrayOfNumbers(1, 24, 0.5),
          weeklyOvertime:  generateArrayOfNumbers(1, 168, 0.5),
          biweeklyOvertime:  generateArrayOfNumbers(1, 336, 0.5)
        };

        $scope.hasPrimarySkill = false;
        $scope.getEmployeeDetails = employeesDetailsService.getEmployeeInit;

        $scope.$watch("getEmployeeDetails()", function(details) {
          if (!details) return;
          $scope.hasPrimarySkill = _.some(details.skillInfo, { 'isPrimarySkill': true });
        });

        var ot = $scope.options.overtimeTypes;

        function defineOvertimeType() {
          var sets = $scope.settings.overtimeDto,
              na = $scope.translations.na;
          if (sets.dailyOvertimeMins != na && sets.weeklyOvertimeMins != na)   return _.find(ot, 'id', "dailyAndWeekly");
          if (sets.dailyOvertimeMins != na && sets.biweeklyOvertimeMins != na) return _.find(ot, 'id', "dailyAndBiweekly");
          if (sets.dailyOvertimeMins != na)    return _.find(ot, 'id', "daily");
          if (sets.weeklyOvertimeMins != na)   return _.find(ot, 'id', "weekly");
          if (sets.biweeklyOvertimeMins != na) return _.find(ot, 'id', "biweekly");
          return _.find(ot, 'id', "na");
        }

        $scope.disableOvertimeInput = {
          daily: function() {
            var disabled = $scope.options.overtimeType && !_.includes(["daily", "dailyAndWeekly", "dailyAndBiweekly"], $scope.options.overtimeType.id);
            if (disabled) {
              $scope.settings.overtimeDto.dailyOvertimeMins = $scope.translations.na;
            }
            return disabled;
          },
          weekly: function() {
            var disabled = $scope.options.overtimeType && !_.includes(["weekly", "dailyAndWeekly"], $scope.options.overtimeType.id);
            if (disabled) {
              $scope.settings.overtimeDto.weeklyOvertimeMins = $scope.translations.na;
            }
            return disabled;
          },
          biweekly: function() {
            var disabled = $scope.options.overtimeType && !_.includes(["biweekly", "dailyAndBiweekly"], $scope.options.overtimeType.id);
            if (disabled) {
              $scope.settings.overtimeDto.biweeklyOvertimeMins = $scope.translations.na;
            }
            return disabled;
          }
        };

        $scope.onMaxHoursChange = function(minHoursProp, maxHoursProp) {
          $timeout(function() {
            if ($scope.settings[maxHoursProp] === $scope.translations.na) return;
            if ($scope.settings[minHoursProp] > $scope.settings[maxHoursProp]) {
              $scope.settings[minHoursProp] = $scope.settings[maxHoursProp];
            }
          });
        };

        $scope.onMinHoursChange = function(minHoursProp, maxHoursProp) {
          $timeout(function() {
            if ($scope.settings[minHoursProp] === $scope.translations.na) return;
            if ($scope.settings[minHoursProp] > $scope.settings[maxHoursProp]) {
              $scope.settings[maxHoursProp] = $scope.settings[minHoursProp];
            }
          });
        };

        function generateArrayOfNumbers(min, max, step, noNA) {
          var arr = noNA ? [] : [$scope.translations.na];
          step = step || 1;
          for (var i = min; i <= max; i=i+step) {
            arr.push(i);
          }
          return arr;
        }

        function fromMinutesToHours(minutes) {
          return minutes <= 0 ? $scope.translations.na : (minutes%60 === 0 ? minutes/60 : (minutes/60).toFixed(1));
        }

        function fromHoursToMinutes(hours) {
          return hours == $scope.translations.na ? -1 : hours*60;
        }

        function convertTime(convertFn, settingsObj) {
          return {
            daysPerWeek:       settingsObj.daysPerWeek,
            consecutiveDays:   settingsObj.consecutiveDays,
            minHoursPerDay:    convertFn(settingsObj.minHoursPerDay),
            maxHoursPerDay:    convertFn(settingsObj.maxHoursPerDay),
            minHoursPerWeek:   convertFn(settingsObj.minHoursPerWeek),
            maxHoursPerWeek:   convertFn(settingsObj.maxHoursPerWeek),
            primarySkillHours: convertFn(settingsObj.primarySkillHours),
            overtimeDto: {
              dailyOvertimeMins:    convertFn(settingsObj.overtimeDto.dailyOvertimeMins),
              weeklyOvertimeMins:   convertFn(settingsObj.overtimeDto.weeklyOvertimeMins),
              biweeklyOvertimeMins: convertFn(settingsObj.overtimeDto.biweeklyOvertimeMins)
            }
          };
        }

        function validOvertime(overtimeTypeId, overtimeDto) {
          return overtimeTypeId === "daily" && overtimeDto.dailyOvertimeMins > 0 ||
                 overtimeTypeId === "weekly" && overtimeDto.weeklyOvertimeMins > 0 ||
                 overtimeTypeId === "biweekly" && overtimeDto.biweeklyOvertimeMins > 0 ||
                 overtimeTypeId === "dailyAndWeekly" && overtimeDto.dailyOvertimeMins > 0 && overtimeDto.weeklyOvertimeMins > 0 ||
                 overtimeTypeId === "dailyAndBiweekly" && overtimeDto.dailyOvertimeMins > 0 && overtimeDto.biweeklyOvertimeMins > 0 ||
                 overtimeTypeId === "na";
        }

        $scope.updateSettings = function() {
          var settings = convertTime(fromHoursToMinutes, $scope.settings);

          if (!validOvertime($scope.options.overtimeType.id, settings.overtimeDto)) {
            applicationContext.setNotificationMsgWithValues("Please specify overtime values for selected overtime type", 'danger', true);
            return;
          }

          settings.daysPerWeek = $scope.settings.daysPerWeek === $scope.translations.na ? -1 : $scope.settings.daysPerWeek;
          settings.consecutiveDays = $scope.settings.consecutiveDays === $scope.translations.na ? -1 : $scope.settings.consecutiveDays;

          dataService.updateEmployeeHoursAndOvertime($scope.employeeId, settings).
            then(function(res) {
              applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', 'success', true);
              $scope.options.overtimeType = defineOvertimeType();
            }, function(err) {
              applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
            });
        };

        dataService.getEmployeeHoursAndOvertime($scope.employeeId).
            then(function(res) {
              $scope.settings = convertTime(fromMinutesToHours, res.data);

              $scope.settings.daysPerWeek = $scope.settings.daysPerWeek > 0 ? $scope.settings.daysPerWeek : $scope.translations.na;
              $scope.settings.consecutiveDays = $scope.settings.consecutiveDays > 0 ? $scope.settings.consecutiveDays : $scope.translations.na;

              $scope.options.overtimeType = defineOvertimeType();
            }, function(err) {
                applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
          });

    }]);
})();
;
var employees = angular.module('emlogis.employees');

employees.controller('EmployeesBreadcrumbCtrl', ['$scope', '$filter', '$state', '$modal', 'dataService', 'applicationContext',
    function($scope, $filter, $state, $modal, dataService, applicationContext) {

      $scope.homeTeamId = null;

      // Update Module Information
      var module = applicationContext.getModule();

      module.name = $filter('translate')('nav.EMPLOYEES');
      module.icoClass = '';
      module.href = '/employees';
      module.disableModuleBreadcrumb = false;
      applicationContext.setModule(module);



      $scope.selectEmployee = function(employee) {
        $state.go('authenticated.employees.detail', {id: employee.id});
      };

      $scope.searchEmployees = function(searchText) {
        var params = {
          search: searchText,
          searchfields: 'firstName,lastName',
          returnedfields: 'firstName,lastName,id',
          limit: 15
        };

        return dataService.searchEmployees(params)
            .then(function(res) {
              return _.map(res.data, function(e) {
                return {
                  fullName: e[0] + " " + e[1],
                  id: e[2]
                };
              });
            });
      };



      $scope.startCreatingEmployee = function(){
        var modalInstance = $modal.open({
          templateUrl:  'modules/employees/partials/new-employee-modal.html',
          controller:   'NewEmployeeModalCtrl as newbie',
          backdrop:     'static',
          size: 'sm',
          resolve: {
            homeTeamId: function () {
              return $scope.homeTeamId;
            }
          }
        });

        modalInstance.result.then(function (employee) {
          $scope.homeTeamId = employee.homeTeamId;
          $state.go('authenticated.employees.detail', {id: employee.id});
        }, function () {
          //console.log('Modal dismissed at: ' + new Date());
        });

      };

    }
]);

;
angular.module('emlogis.employees').controller('EmployeesListCtrl',
    [
      '$scope', '$state', '$filter', '$cacheFactory', '$timeout', 'dataService', 'crudDataService',
      function($scope, $state, $filter, $cacheFactory, $timeout, dataService, crudDataService) {

        var numOfRows = 25,
            cache = $cacheFactory.get('EmployeesListCache') || $cacheFactory('EmployeesListCache'),
            cachedPaginationCurrentPage = cache.get("paginationCurrentPage"),
            cachedQueryParams = cache.get("queryParams"),
            cachedSelectedTeamIds = cache.get("selectedTeamIds");

        $scope.sites = [];
        $scope.teams = [];
        $scope.activityTypes = cache.get("selectedActivityTypes") || [
          { id: 1, name: $filter('translate')("employees.ACTIVE"), ticked: true},
          { id: 0, name: $filter('translate')("employees.INACTIVE"), ticked: false},
          { id: 2, name: $filter('translate')("employees.POOLED"), ticked: true}
        ];
        $scope.nameFilter = cachedQueryParams ? cachedQueryParams.employeenamefilter : null;

        $scope.selectedSites = [];
        $scope.selectedTeams = [];
        $scope.selectedActivityTypes = [];

        $scope.gridOptions = {
          data: [],
          totalItems: 0,
          minRowsToShow: 0,

          enableHorizontalScrollbar: 0,
          enableVerticalScrollbar: 0,
          enableColumnMenus: false,
          enableGridMenu: true,

          enableFiltering: true,
          useExternalFiltering: true,

          enableSorting: true,
          useExternalSorting: true,

          needPagination: true,
          useExternalPagination: true,
          enablePaginationControls: false,
          paginationPageSize: numOfRows,
          paginationCurrentPage: 1,

          rowTemplate: rowTemplate(),
          columnDefs: [
            { name: $filter('translate')("app.LAST_NAME"),              field: 'lastName',         enableFiltering: false },
            { name: $filter('translate')("app.FIRST_NAME"),             field: 'firstName',        enableFiltering: false },
            { name: $filter('translate')("employees.PRIMARY_JOB_ROLE"), field: 'primaryJobRole',   enableFiltering: false },
            { name: $filter('translate')("employees.HOME_SITE"),        field: 'homeSite',         enableFiltering: false },
            { name: $filter('translate')("employees.HOME_TEAM"),        field: 'homeTeam',         enableFiltering: false },
            { name: $filter('translate')("employees.START_DATE"),       field: 'startDate',        enableFiltering: false, cellFilter: 'date' },
            { name: $filter('translate')("employees.WORK_EMAIL"),       field: 'workEmail',        enableFiltering: false },
            { name: $filter('translate')("employees.MOBILE_PHONE"),     field: 'mobilePhone',      enableFiltering: false },
            { name: $filter('translate')("app.STATUS"),                 field: 'activityType',     enableFiltering: false }
          ],
          onRegisterApi: function(gridApi) {
            $scope.gridApi = gridApi;
            $scope.gridOptions.queryParams = cachedQueryParams || {
              orderby:'lastName',
              orderdir:'ASC'
            };

            var _this = this,
                fieldToSort = _.find(_this.columnDefs, function(c) {
                  return c.field == $scope.gridOptions.queryParams.orderby;
                });

            // Show sorting arrow in grid header
            fieldToSort.sort = {
              direction: $scope.gridOptions.queryParams.orderdir.toLowerCase()
            };

            // Back-end sorting
            $scope.gridApi.core.on.sortChanged($scope, function(grid, sortColumns) {
              if (sortColumns.length === 0) {
                $scope.gridOptions.queryParams.orderdir = 'ASC';
                $scope.gridOptions.queryParams.orderby = 'lastName';
              } else {
                $scope.gridOptions.queryParams.orderdir = sortColumns[0].sort.direction;
                $scope.gridOptions.queryParams.orderby =  sortColumns[0].field;
              }
              getPage();
            });

            // Back-end pagination
            $scope.gridApi.pagination.on.paginationChanged($scope, function (newPage) {
              $scope.gridOptions.paginationCurrentPage = newPage;
              getPage();
            });
          }
        };

        function rowTemplate() {
          return '<div ng-class="{\'row-hovered\' : hover}" ' +
                 '     ng-mouseenter="hover = true" ' +
                 '     ng-mouseleave="hover = false" ' +
                 '     ng-click="grid.appScope.selectEmployee(row.entity.id)">' +
                 '  <div ng-repeat="(colRenderIndex, col) in colContainer.renderedColumns track by col.colDef.name" ' +
                 '       class="ui-grid-cell" ' +
                 '       ng-class="{ \'ui-grid-row-header-cell\': col.isRowHeader }"  ' +
                 '       ui-grid-cell>' +
                 '  </div>' +
                 '</div>';
        }

        $scope.selectEmployee = function(employeeId) {
          $state.go('authenticated.employees.detail', {id: employeeId});
        };

        $scope.haveEmployees = function() {
          return ($scope.gridOptions.data && $scope.gridOptions.totalItems > 0);
        };

        function getPage() {

          var teamIds = -1,
              activityTypeIds = -1;

          if (!_.isEmpty($scope.selectedSites)) {
            cache.put("selectedSiteId", _.pluck($scope.selectedSites, 'id'));
          }

          if (!_.isEmpty($scope.selectedTeams)) {
            teamIds = _.pluck($scope.selectedTeams, 'id');
            cache.put("selectedTeamIds", teamIds);
            teamIds = teamIds.join();
          }

          if (!_.isEmpty($scope.selectedActivityTypes)) {
            activityTypeIds = _.pluck($scope.selectedActivityTypes, 'id').join();
            cache.put("selectedActivityTypes", $scope.activityTypes);
          }

          $scope.gridOptions.queryParams.teamids = teamIds;
          $scope.gridOptions.queryParams.belonging = "Both";
          $scope.gridOptions.queryParams.activitytypefilter = activityTypeIds;
          $scope.gridOptions.queryParams.employeenamefilter = $scope.nameFilter || null;

          return dataService.getEmployees($scope.gridOptions.queryParams, $scope.gridOptions.paginationCurrentPage, numOfRows)
            .then(function(res) {
              $scope.gridOptions.data = res.data;
              $scope.gridOptions.totalItems = res.total;
              $scope.gridOptions.minRowsToShow = res.total < numOfRows ? res.total : numOfRows;

              cache.put("queryParams", $scope.gridOptions.queryParams);
              cache.put("paginationCurrentPage", $scope.gridOptions.paginationCurrentPage);
              setTimeout(function() {
                $(window).resize();
              });
            });
        }

        // Load teams into dropdown list based on the siteId
        $scope.loadTeamsForSite = function(siteId) {

          // for reset button
          if (!siteId) {
            siteId = _.find($scope.sites, 'ticked', true).id;
          }

          return crudDataService.getElements('sites/' + siteId + '/teams')
            .then(function(res) {
              $scope.teams = res.data;

              // if returned 'back to listing'
              if (cachedSelectedTeamIds) {
                _.each($scope.teams, function(t) {
                  t.ticked = _.includes(cachedSelectedTeamIds, t.id);
                });
                $scope.selectedTeams = _.filter($scope.teams, 'ticked', true);
                cachedSelectedTeamIds = null;
              } else {
                // if it's regular site selection from selectbox
                _.each($scope.teams, function(t) {
                  t.ticked = true;
                });
              }
           });
        };

        function init() {
          // Load sites into dropdown list
          crudDataService.getElements("sites", {}, 1, -1)
            .then(function(res) {
              $scope.sites = res.data;

              if (_.isEmpty($scope.sites)) return;

              var selectedSiteId = cache.get("selectedSiteId") || $scope.sites[0].id,
                  selectedSite = _.find($scope.sites, function(s) {
                    return s.id == selectedSiteId;
                  });

              selectedSite.ticked = true;
              return $scope.loadTeamsForSite(selectedSite.id);
            })
            .then(function() {
              if (cachedPaginationCurrentPage) {
                $scope.gridOptions.paginationCurrentPage = cachedPaginationCurrentPage;
              }
              return getPage();
            })
            .then(function() {
              $scope.$watch('selectedTeams', function(oldVal, newVal) {
                if (!_.isEqual(oldVal, newVal)) {
                  getPage();
                }
              });

              $scope.$watch('selectedActivityTypes', function(oldVal, newVal) {
                if (!_.isEqual(oldVal, newVal)) {
                  getPage();
                }
              });

              $scope.$watch("nameFilter", function(oldVal, newVal) {
                if (!_.isEqual(oldVal, newVal)) {
                  getPage();
                }
              });
            });
        }

        init();

      }
    ]
);

;
angular.module('emlogis.employees').controller('EmployeesCtrl',
  [
    '$scope', 'employeesDetailsService', function ($scope, employeesDetailsService) {

    // on module change
    // clear SiteTeams and Skills cache

    $scope.$on("$destroy", function () {
      employeesDetailsService.cleanExternalCache();
    });

  }
  ]
);

;
(function () {
  "use strict";

  var employees = angular.module('emlogis.employees');

  employees.controller('NewEmployeeModalCtrl',
    ['$scope', '$rootScope', '$filter', '$modalInstance', 'employeesDetailsService', 'homeTeamId',
      function ($scope, $rootScope, $filter, $modalInstance, employeesDetailsService, homeTeamId) {

        //--------------------------------------------------------------------
        // Defaults for Emergency Contact Modal
        //--------------------------------------------------------------------

        var siteTeamsTreeInit,
            newbie = this;

        newbie.submitted = false;
        newbie.sitesTeamsTree = [];
        newbie.loginEqualsId = true;

        newbie.dto = {
          firstName: null,
          lastName: null,
          employeeIdentifier: null,
          userAccountDto: {
            login: '',
            email: null,
            inactivityPeriod: 0,
            language: 'en',
            status: 'Active'
          },
          employeeTeamCreateDto: {
            isHomeTeam: true,
            teamId: ''
          }
        };


        //
        // Get SitesTeamsTree

        employeesDetailsService.getSitesTeamsTree().then( function(data){
          siteTeamsTreeInit = data;
          angular.forEach(siteTeamsTreeInit, function(site){
            angular.forEach(site.children, function(team){
              team.site = site;
              newbie.sitesTeamsTree.push(team);
            });
          });
          newbie.sitesTeamsTree = $filter('orderBy')(newbie.sitesTeamsTree, 'name');
        });


        //
        // If user navigates away from the page,
        // dismiss the modal

        $rootScope.$on('$stateChangeStart',
          function(){
            $modalInstance.dismiss('cancel');
          }
        );


        //--------------------------------------------------------------------
        // CRUD
        //--------------------------------------------------------------------


        //
        // Create a new Employee

        newbie.createEmployee = function(){

          if ( $scope.newbieForm.$valid ) {
            newbie.dto.userAccountDto.login = newbie.loginEqualsId ? newbie.dto.employeeIdentifier : newbie.dto.userAccountDto.login;

            return employeesDetailsService.createEmployee(newbie.dto).then( function(employee){
              $modalInstance.close(employee);
            });
          } else {
            newbie.submitted = true;
          }
        };


        //--------------------------------------------------------------------
        // Modal methods
        //--------------------------------------------------------------------


        newbie.closeModal = function(){
          $modalInstance.close();
        };


        newbie.cancelModal = function(){
          $modalInstance.dismiss('cancel');
        };

      }
    ]);
})();
;
(function() {
  "use strict";

  // Service
  // Create service function

  var employeesDetailsService = function($filter, $cacheFactory, $q, dialogs, applicationContext, appFunc, dataService){

    var eds = this,
        employee,
        employeeInit,
        employeeSiteTimeZone,
        employeeCache = $cacheFactory('employeeCache'),
        pictureCache = $cacheFactory('pictureCache'),
        allOrgSkillsCache = $cacheFactory('allOrgSkillsCache'),
        allSiteTeamsCache = $cacheFactory('allSiteTeamsCache'),
        sitesTeamsTreeCache = $cacheFactory('sitesTeamsTreeCache'),
        abcOrder = { orderby: 'name', orderdir: 'ASC' };


    //--------------------------------------------------------------------
    // Cached Employee Details
    //--------------------------------------------------------------------


    //
    // get Employee details for managers view

    eds.getEmployeeDetails = function(employeeId){
      return dataService.getEmployeeDetails(employeeId, { cache: employeeCache })
        .then(function(res){
          employeeInit = res.data;
          employeeInit.cacheId = res.config.url;
          console.log('got hireDate', employeeInit.hireDate);
          console.log('got hireDate UTC ms', moment.tz(employeeInit.hireDate, 'UTC').valueOf());

          employeeInit.primarySkill = findPrimarySkill(employeeInit.skillInfo);
          employeeInit.homeTeam = findHomeTeam(employeeInit.teamInfo);

          employeeInit.skillInfo = $filter('orderBy')(employeeInit.skillInfo, 'name');
          employeeInit.teamInfo = $filter('orderBy')(employeeInit.teamInfo, 'name');

          employeeSiteTimeZone = employeeInit.siteInfo.timeZone;

          // Convert dates to Site time zone
          employeeInit.hireDate = appFunc.convertToBrowserTimezone(employeeInit.hireDate, employeeSiteTimeZone);
          employeeInit.startDate = appFunc.convertToBrowserTimezone(employeeInit.startDate, employeeSiteTimeZone);
          employeeInit.endDate = appFunc.convertToBrowserTimezone(employeeInit.endDate, employeeSiteTimeZone);

          employee = angular.copy(employeeInit);
          return employee;
        })
      ;
    };


    //
    // provide Initial Employee obj

    eds.getEmployeeInit = function(){
      return employeeInit;
    };


    //
    // provide Employee HomeTeam

    eds.getEmployeeTeam = function(){
      return employee.homeTeam;
    };


    //
    // provide Employee status

    eds.getEmployeeActivityType = function(){
      return employee.activityType;
    };


    //
    // clean cache that can be modified in other modules

    eds.cleanExternalCache = function(){
      allOrgSkillsCache.removeAll();
      allSiteTeamsCache.removeAll();
    };



    //--------------------------------------------------------------------
    // Employee Profile section
    //--------------------------------------------------------------------

    //
    // update an Employee

    eds.updateEmployee = function(employee, dto){
      // prepare dates for back-end format
      dto.hireDate = prepareDate(dto.hireDate);
      dto.startDate = prepareDate(dto.startDate);
      dto.endDate = prepareDate(dto.endDate);

      return dataService.updateEmployee(employee.id, dto).then(function(res){
        employeeCache.remove(employee.cacheId);                               // clear cache for this employee
        return eds.getEmployeeDetails(employee.id);

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };


    //
    // delete an Employee

    eds.deleteEmployee = function(employee){
      var deferred = $q.defer();

      // Confirm deletion
      var question = $filter('translate')("rules.site_teams.DELETE_EMPLOYEE") + employee.firstName + ' ' + employee.lastName + '?';
      var dlg = dialogs.confirm('app.PLEASE_CONFIRM', question);

      dlg.result.then(function () {
        return dataService.deleteEmployee(employee.id).then(function(){
          applicationContext.setNotificationMsgWithValues('app.DELETED_SUCCESSFULLY', 'success', true);
          employeeCache.remove(employee.cacheId);                               // clear cache for this employee
          eds.getEmployeeDetails(employee.id).then(function(res){
            deferred.resolve(res);
          });

        }, function(err) {
          applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
        });
      });

      return deferred.promise;
    };



    // --------- Employee Account ---------


    //
    // get account info for an Employee
    // TEMP TODO is it needed?

    eds.getEmployeeAccount = function(employeeId){
      return dataService.getEmployeeAccount(employeeId).then(function(res){
        //console.log('+++ getEmployeeAccount', res);
      });
    };


    //
    // update Employee's account

    eds.updateEmployeeAccount = function(employee, dto){
      //console.log('+++ login to upd', dto);
      return dataService.updateEmployeeAccount(employee.id, dto).then(function(res){
        employeeCache.remove(employee.cacheId);                               // clear cache for this employee

        //eds.getEmployeeAccount(employee.id); // TODO: returns 200 but login is not being updated

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };



    // --------- Employee picture ---------


    //
    // get Employee picture

    eds.getEmployeePicture = function(employee){ // TODO: add caching for Employee picture
      var userId = employee.userAccountDto.id;
      return dataService.getUserPicture(userId).then(function(res){
        var imageData = res.data;
        if ( res.data.size > 0 ) {
          imageData.pictureCacheId = res.config.url;
          imageData.image = 'data:image/JPEG;base64,' + imageData.image;
        }
        return imageData;
      });
    };


    //
    // upload new Employee image

    eds.uploadEmployeePicture = function(employee, img){
      var userId = employee.userAccountDto.id;
      return dataService.uploadUserPicture(userId, img.dto).then(function(res){
        applicationContext.setNotificationMsgWithValues('app.SAVED_SUCCESSFULLY', 'success', true);
        //console.log('+++ uploadEmployeePicture', res);
        //pictureCache.remove(img.pictureCacheId); TODO add when picture is caching
        return eds.getEmployeePicture(employee).then(function(picture){
          return picture;
        });
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };



    // --------- Employee Home Team ---------

    //
    // change Home Team for an Employee,
    // if this Teams is already associated to Employee

    eds.updateEmployeeHomeTeam = function(employee, teamId, dto){
      return dataService.updateEmployeeHomeTeam(employee.id, teamId, dto).then(function(res){
        if (employee.cacheId) employeeCache.remove(employee.cacheId);

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };


    //
    // change Home Team for an Employee,
    // if this Teams is not currently associated to Employee

    eds.addHomeTeamToEmployee = function(employee, teamId, dto){
      return dataService.addTeamToEmployee(employee.id, teamId, dto).then(function(res){
        employeeCache.remove(employee.cacheId);

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };



    //--------------------------------------------------------------------
    // Employee Sidebar section
    //--------------------------------------------------------------------

    // --------- User --------

    //
    // Request a Password reset for a user

    eds.requestUserPasswordReset = function() {
      var deferred = $q.defer();

      // Confirm deletion
      var question = $filter('translate')("employees.RESET_PASSWORD") + employee.firstName + ' ' + employee.lastName + '?';
      var dlg = dialogs.confirm('app.PLEASE_CONFIRM', question);

      dlg.result.then(function () {
        return dataService.requestUserPasswordReset(employee.userAccountDto.id).then( function(res){
          var notification = $filter('translate')('employees.RESET_REQUESTED') + res.data.emailAddress;
          applicationContext.setNotificationMsgWithValues(notification, 'success', true);
          deferred.resolve(res);

        }, function(err) {
          applicationContext.setNotificationMsgWithValues(err.data.info, 'danger', true);
        });
      });

      return deferred.promise;
    };

    //
    // Toggle notifications for a user

    eds.toggleUserNotifications = function(enable) {
      var question = (enable ? $filter('translate')("employees.ENABLE_NOTIFICATIONS_QUESTION") :
                               $filter('translate')("employees.DISABLE_NOTIFICATIONS_QUESTION")) +
                               employee.firstName + ' ' + employee.lastName + '?',
          dlg = dialogs.confirm('app.PLEASE_CONFIRM', question);

      dlg.result.then(
        // if 'Yes' pressed
        function () {
          return dataService.toggleUserNotifications(employee.userAccountDto.id, enable).then(function(res) {
            applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', 'success', true);
          }, function(err) {
            applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
          });
        // if 'No' pressed
        }, function() {
          employee.notificationSettings.isNotificationEnabledByManager = !employee.notificationSettings.isNotificationEnabledByManager;
        });
    };




    // --------- Autoapprovals panel ---------

    //
    // update Autoapprovals settings for  an Employee

    eds.updateEmployeeAutoapprovals = function(employee, dto){
      return dataService.updateEmployeeAutoapprovals(employee.id, dto).then(function(res){
        applicationContext.setNotificationMsgWithValues('app.SAVED_SUCCESSFULLY', 'success', true);
        employeeCache.remove(employee.cacheId);                               // clear cache for this employee
        return eds.getEmployeeDetails(employee.id);

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };



    // --------- PTO panel ---------

    //
    // get all PTOs for an Employee

    eds.getEmployeePTO = function(employee){
      return dataService.getEmployeeCDAvailabilities(employee.id, {filter: 'isPTO=1', orderby:'startDateTime', orderdir:'DESC'}, 1, -1)
        .then(function(res){
          angular.forEach(res.data, function(pto){
            pto.startDateTime = appFunc.convertToBrowserTimezone(pto.startDateTime, employeeSiteTimeZone);
          });
          //console.log('getEmployeeCDAvailabilities', res);
          return res.data;
        })
      ;
    };


    // --------- Skills panel ---------

    //
    // get all Skills for current Org

    eds.getSkills = function(){
      return dataService.getSkills(abcOrder, 1, -1, allOrgSkillsCache).then(function(res){
        //console.log('+++ getSkills', res);
        return res.data;
      });
    };


    //
    // update multiple skills for an Employee

    eds.updateEmployeeSkills = function(employee, dto){
      return dataService.updateEmployeeSkills(employee.id, dto).then(function(res){
        applicationContext.setNotificationMsgWithValues('app.SAVED_SUCCESSFULLY', 'success', true);
        employeeCache.remove(employee.cacheId);                               // clear cache for this employee
        return eds.getEmployeeDetails(employee.id);

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };



    // --------- Teams panel ---------

    //
    // get all Teams for a Site Employee belongs to TODO: check caching and dataService conflict

    eds.getSiteTeams = function(){
      return dataService.getSiteTeams(employee.siteInfo.siteId, abcOrder, 1, -1, allSiteTeamsCache).then(function(res){
        //console.log('getSiteTeams', res);
        return res.data;
      });
    };


    //
    // update Employee teams

    eds.updateEmployeeTeams = function(employee, dto){
      return dataService.updateEmployeeTeams(employee.id, dto).then(function(res){
        applicationContext.setNotificationMsgWithValues('app.SAVED_SUCCESSFULLY', 'success', true);
        employeeCache.remove(employee.cacheId);                               // clear cache for this employee
        return eds.getEmployeeDetails(employee.id);

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };



    //--------------------------------------------------------------------
    // Employee creation
    //--------------------------------------------------------------------


    //
    // create an Employee

    eds.createEmployee = function(dto){
      return dataService.createEmployee(dto).then(function(res){
        return res;

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };


    //
    // get SitesTeamsTree

    eds.getSitesTeamsTree = function() {
      return dataService.getSitesTeamsTree().then(function(res) {
        return res.data;

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };


    //--------------------------------------------------------------------
    // Help methods
    //--------------------------------------------------------------------


    var findPrimarySkill = function(allEmployeeSkills){
      var primarySkill = null;
      angular.forEach(allEmployeeSkills, function(skill) {
        if (skill.isPrimarySkill){
          primarySkill = angular.copy(skill);
        }
      });
      return primarySkill;
    };


    var findHomeTeam = function(allEmployeeTeams){
      var homeTeam = null;
      angular.forEach(allEmployeeTeams, function(team) {
        if (team.isHomeTeam) {
          homeTeam = angular.copy(team);
        }
      });
      return homeTeam;
    };

    var prepareDate = function(dateFromModel){
      if (dateFromModel) {
        var newDate = new Date(dateFromModel);
        var date = appFunc.getDateWithTimezone(
            newDate.getFullYear(),
            newDate.getMonth(),
            newDate.getDate(),
            employeeSiteTimeZone
        ).getTime();
        return date;
      }
      return dateFromModel;
    };

  };


  // Inject dependencies and
  // add service to the Rules module

  employeesDetailsService.$inject = ['$filter', '$cacheFactory', '$q', 'dialogs', 'applicationContext', 'appFunc', 'dataService'];
  angular.module('emlogis.employees').service('employeesDetailsService', employeesDetailsService);

})();
;
angular.module('emlogis.home', ['ui.bootstrap', 'ui.router', 'http-auth-interceptor'])
  .config( function ($stateProvider, $urlRouterProvider, $locationProvider, $httpProvider) {
    $stateProvider.state('authenticated.home', {
      url: '/home',
      views: {
        "content@authenticated": {
          templateUrl: "modules/home/partials/home.html",
          controller: "HomeCtrl as home"
        },
        "breadcrumb@authenticated": {
          template: '',
          controller: 'HomeBreadcrumbCtrl'
        }
      }
    });
  })

  .controller('HomeBreadcrumbCtrl', ['$scope', '$filter', 'applicationContext',
    function($scope, $filter, applicationContext) {

      // Update Module Information
      var module = applicationContext.getModule();

      module.name = $filter('translate')('nav.HOME');
      module.icoClass = '';
      module.href = '/home';
      module.disableModuleBreadcrumb = true;
      applicationContext.setModule(module);

    }
  ])
;



;
var home = angular.module('emlogis.home');

home.controller('HomeCtrl', ['$scope', '$state', '$filter', 'authService', 'dataService', '$q',
  function ($scope, $state, $filter, authService, dataService, $q) {

    console.log('inside home controller');
    var home = this;

    // Set Username
    //
    //if (applicationContext.getUsername() === ""){
    //    applicationContext.setUsername($sessionStorage.username);
    //}
    //
    //$scope.username = applicationContext.getUsername();
    //
    //// Set Variables for accordion
    //$scope.sideBar = {
    //    isManager_ApprovalsOpen : true,
    //    isTeam_Member_RequestsOpen : true
    //};

    var session = authService.getSessionInfo();

    /*if (authService.hasPermission('Demand_Mgmt')) {          // if user is Schedule Creator
     $state.go('authenticated.schedule_builder.create_schedules');
     }
     else if (authService.hasPermissionIn(['Tenant_View', 'Tenant_Mgmt'])) {   // if user is a ServiceAdministrator
     $state.go('authenticated.admin.customers');
     }
     else if (authService.hasPermission('SystemConfiguration_Mgmt') &&       // if user is a customer Admin
     authService.hasPermission('Employee_Mgmt') && session.tenantType === 'Customer') {
     $state.go('authenticated.rules.site_teams');
     }
     else if (authService.hasPermission('SystemConfiguration_Mgmt') &&       // if user is a EmlogisService Admin
     session.tenantType === 'SvcProvider') {
     $state.go('authenticated.monitoring.database');
     }
     else if (authService.hasPermissionIn(['Availability_RequestMgmt', 'Shift_RequestMgmt', 'Shift_Mgmt'])) {   // if user is a ShiftManager
     $state.go('authenticated.dashboard.manager_approvals');
     }
     else if (session.employeeId !== null) {    // if user is a Employee
     $state.go('authenticated.dashboard.calendar');
     }
     else if (authService.hasPermission('Support')   // if user is a Support Employee
     && authService.hasPermission('Employee_View')) {
     $state.go('authenticated.employees.list');
     }*/


    var initCounters = function (dto) {

      home.statItems = {

        // Customers

        customers: {
          title: $filter('translate')('home.CUSTOMERS'),
          num: dto.customerCount,
          visible: session.tenantType === 'SvcProvider',
          url: 'authenticated.admin.customers.list'
        },

        // Settings

        sites: {
          title: $filter('translate')('nav.SITES'),
          num: dto.siteCount,
          visible: true,
          url: 'authenticated.rules.site_teams'
        },
        teams: {
          title: $filter('translate')('nav.TEAMS'),
          num: dto.teamCount,
          visible: true,
          url: 'authenticated.rules.site_teams'
        },
        skills: {
          title: $filter('translate')('monitoring.SKILLS'),
          num: dto.skillCount,
          visible: true,
          url: 'authenticated.rules.skills'
        },


        // Schedules

        posted: {
          title: $filter('translate')('employee_schedules.POSTED'),
          num: dto.postedScheduleCount,
          visible: true,
          url: 'authenticated.schedule_builder.create_schedules'
        },
        production: {
          title: $filter('translate')('employee_schedules.PRODUCTION'),
          num: dto.productionScheduleCount,
          visible: true,
          url: 'authenticated.schedule_builder.create_schedules'
        },
        simulation: {
          title: $filter('translate')('employee_schedules.SIMULATION'),
          num: dto.simulationScheduleCount,
          visible: true,
          url: 'authenticated.schedule_builder.create_schedules'
        },

        // Employees & Users

        employees: {
          title: $filter('translate')('nav.EMPLOYEES'),
          num: dto.employeeCount,
          visible: true,
          url: 'authenticated.employees.list'
        },

        users: {
          title: $filter('translate')('app.USERS'),
          num: dto.userCount,
          visible: true,
          url: 'authenticated.settings.accounts.users'
        },
        groups: {
          title: $filter('translate')('nav.GROUPS'),
          num: dto.groupCount,
          visible: true,
          url: 'authenticated.settings.accounts.groups'
        },

        // Support

        servers: {
          title: $filter('translate')('home.SERVERS'),
          num: dto.appServerCount,
          visible: session.tenantType === 'SvcProvider' ||
          (authService.hasPermission('Support') && authService.hasPermission('Employee_View')),
          url: 'authenticated.monitoring.subsystems.appservers'
        },
        engines: {
          title: $filter('translate')('home.ENGINES'),
          num: dto.engineCount,
          visible: session.tenantType === 'SvcProvider' ||
          (authService.hasPermission('Support') && authService.hasPermission('Employee_View')),
          url: 'authenticated.monitoring.subsystems.engines'
        }

      };
    };

    // If user is a Employee
    if (!!session.employeeId) {
      $state.go('authenticated.dashboard.calendar');

      // For everybody else
    } else {
      if (session.tenantType === 'Customer') {
        dataService.getOrgCounters()
          .then(function (res) {
            initCounters(res);
            if (authService.hasPermission('Support') && authService.hasPermission('Employee_View')){
              dataService.getServiceProviderCounters()
                .then(function (res2) {
                  home.statItems.servers.num = res2.appServerCount;
                  home.statItems.engines.num = res2.engineCount;
                });
            }
          });
      } else if (session.tenantType === 'SvcProvider') {
        dataService.getServiceProviderCounters()
          .then(function (res) {
            initCounters(res);
          });
      }

      home.hasPermissions = function (permission) {
        return authService.hasPermission(permission);
      };

    }

  }]);
;
// Declare Impersonation Module
angular.module('emlogis.impersonation', ['ui.bootstrap' , 'ui.grid.resizeColumns' ] );

;
var app = angular.module('emlogis.impersonation');

/* parameter users is defined in angular-init.js file when app opens the diaglog
 * It is defined as 'Resolve'
 */
app.controller('ImpersonationManageCtrl', ['$scope', '$modalInstance', '$http', '$modal',
    '$sessionStorage', 'authService',  'applicationContext', 'crudDataService', 'uiGridConstants',
  function($scope, $modalInstance, $http, $modal,
           $sessionStorage, authService, applicationContext, crudDataService, uiGridConstants) {

    $scope.browser = {
      filterTxt : "",
      orderBy : "id",
      orderDir : "asc",
      pageSize : 20,
      currentPage : 1
    };

    $scope.isModalOpen = true;

    /*
     *This header cell template is almost same as default cell template except
     * it has translate directive inside so grid header will support i18n as well
     */
    var headerCellTemplate = function(){
      return "<div ng-class=\"{ 'sortable': sortable }\">" +
        "<div class=\"ui-grid-cell-contents\" col-index=\"renderIndex\" ><span translate>{{ col.name CUSTOM_FILTERS }} </span>" +
        "<span ui-grid-visible=\"col.sort.direction\" ng-class=\"{ 'ui-grid-icon-up-dir': col.sort.direction == asc, 'ui-grid-icon-down-dir': col.sort.direction == desc, 'ui-grid-icon-blank': !col.sort.direction }\">&nbsp;</span>" +
        "</div>" +
        "<div class=\"ui-grid-column-menu-button\" ng-if=\"grid.options.enableColumnMenus && !col.isRowHeader  && col.colDef.enableColumnMenu !== false\" class=\"ui-grid-column-menu-button\" ng-click=\"toggleMenu($event)\">" +
        "<i class=\"ui-grid-icon-angle-down\">&nbsp;</i>" +
        "</div>" +
        "<div ng-if=\"filterable\" class=\"ui-grid-filter-container\" ng-repeat=\"colFilter in col.filters\">" +
        "<input type=\"text\" class=\"ui-grid-filter-input\" ng-model=\"colFilter.term\" ng-click=\"$event.stopPropagation()\" ng-attr-placeholder=\"{{colFilter.placeholder || ''}}\">" +
        "<div class=\"ui-grid-filter-button\" ng-click=\"colFilter.term = null\">" +
        "<i class=\"ui-grid-icon-cancel right\" ng-show=\"!!colFilter.term\">&nbsp;</i> <!-- use !! because angular interprets 'f' as false -->" +
        "</div>" +
        "</div>" +
        "</div>";
    };

    // ColumnDef Info
    $scope.columnDef = [
      {
        name: 'impersonation.LOGIN_ID',
        field: 'id',
        headerCellTemplate: headerCellTemplate()
      },
      {
        name:'app.NAME',
        field: 'name',
        headerCellTemplate: headerCellTemplate()
      },
      {
        name:'app.LOGIN',
        field: 'login',
        headerCellTemplate: headerCellTemplate()
      },
      {
        name: 'app.ACTION',
        enableSorting: false,
        disableColumnMenu: true,
        disableHiding: true,
        headerCellTemplate: headerCellTemplate(),
        cellClass: 'action-cell',
        cellTemplate:actionCellTemplate()
      }
    ];

    // Row Template
    function rowTemplate() {
      return '<div title="This is row tooltip"  ng-repeat="col in colContainer.renderedColumns track by col.colDef.name" class="ui-grid-cell" ui-grid-cell></div>';
    }


    // Action Cell Template

    function actionCellTemplate() {
      var action="";

      // Check 2 permissions related to impersonation
      if (authService.hasPermission('Impersonate_ViewOnly')){
        action = '<a ng-click="grid.appScope.impersonateView(row.entity)" translate>impersonation.IMPERSONATE_VIEW</a>';
      }

      if (authService.hasPermission('Impersonate')){
        action += ' | <a ng-click="grid.appScope.impersonate(row.entity)" translate>impersonation.IMPERSONATE</a>';
      }

      return action;
    }

    $scope.gridOptions = {
      useExternalSorting: true,  // It will call backend api
      enableColumnResizing: true,
      enableGridMenu: true,
      columnDefs: angular.copy($scope.columnDef),
      rowTemplate: rowTemplate(), //Row Template
      enablePaginationControls: false,
      onRegisterApi: function( gridApi ) {
        $scope.gridApi = gridApi;
        $scope.gridApi.core.on.sortChanged( $scope, function( grid, sortColumns ) {
          if( sortColumns.length === 0 ){
            console.log('Impersonation column length : 0');
          }
          else {

            if (sortColumns[0].field == "id"){
              $scope.browser.orderBy = "primaryKey.id";

            }
            else{
              $scope.browser.orderBy = sortColumns[0].field;
            }


            if (sortColumns[0].sort.direction == uiGridConstants.DESC) {
              $scope.browser.orderDir = "DESC";
            }
            else {
              $scope.browser.orderDir = "ASC";
            }

            // search again
            $scope.listUsers();

          }
        });
      }
    };


    $scope.impersonate = function(user) {

      console.log('--> ImpersonatingTo(' + user.name + ')...');

      $http.post('../emlogis/rest/sessions/ops/impersonate', user.login)
        .success(function(data) {

          // reset login info  and just restart as if we were in a new session

          $scope.$close();
          applicationContext.setUsername(data.userName);
          $sessionStorage.impersonated = true;

          authService.loginConfirmed( data);
        })
        .error(function() {
          // TODO show login error
          console.log('--> Impersonation FAILED()');

          // not much we can do, our initial session  is probably closed,
          // Move to login page

          // TODO should we clear data ?
          authService.loginCancelled();
        });
    };

    $scope.impersonateView = function(user) {

      $http.post('../emlogis/rest/sessions/ops/impersonateviewonly', user.login)
        .success(function(data) {

          // reset login info  and just restart as if we were in a new session

          $scope.$close();
          applicationContext.setUsername(data.userName);
          $sessionStorage.impersonated = true;

          authService.loginConfirmed( data);
        })
        .error(function() {
          // TODO show login error
          console.log('--> ImpersonationViewOnly FAILED()');

          // not much we can do, our initial session  is probably closed,
          // Move to login page

          // TODO should we clear data ?
          authService.loginCancelled();
        });
    };

    // When we go to login page we have to dismiss the modal.
    $scope.$on('event:auth-loginRequired', function () {

      if ($scope.isModalOpen === true){
        $modalInstance.dismiss('cancel');
        $scope.isModalOpen = false;
      }

    });


    // Prepare Page Offset and Limit
    $scope.preparePageParam = function(){

      $scope.browser.offset = ($scope.browser.currentPage-1) * $scope.browser.pageSize;
      $scope.browser.limit = $scope.browser.pageSize;
    };

    // Retrieve users from backend

    $scope.listUsers = function(){

      var factory = _.clone(crudDataService);

      var filter = "name like '%" + $scope.browser.filterTxt + "%'";
      var userAccountsListUrl = '../emlogis/rest/useraccounts?filter=' + encodeURIComponent(filter);

      userAccountsListUrl += "&orderby="+$scope.browser.orderBy + "&orderdir="+$scope.browser.orderDir;

      $scope.preparePageParam();

      userAccountsListUrl += "&offset="+$scope.browser.offset + "&limit="+$scope.browser.limit;

      console.log(userAccountsListUrl);

      return $http.get(userAccountsListUrl).then(function (response) {

        var resultSet = factory.toResultSet(response);

        $scope.gridOptions.data = resultSet.data;
        $scope.browser.totalRecords = resultSet.total;

        console.log("users : Impersonation ");
        return resultSet;

      });
    };

    // Keydown event on page user filter input box
    $scope.userFilterKeyDown = function($event) {

      //detect Enter Key
      if ($event.keyCode == 13){
        $scope.listUsers();

      }
    };

    // change page and refresh view
    $scope.pageChanged = function () {
      $scope.listUsers();
    };


    // Refresh Data
    $scope.refresh = function(){
      $scope.listUsers();
    };

    // Close Modal
    $scope.close = function(){
      //$modalInstance.dismiss('cancel');
      $modalInstance.dismiss('cancel');
    };


    // Auto Complete List
    $scope.getName = function(val) {

      var factory = _.clone(crudDataService);
      var filter = "name like '%" + val + "%'";
      var userAccountsListUrl = '../emlogis/rest/useraccounts?filter=' + encodeURIComponent(filter);

      return $http.get(userAccountsListUrl).then(function (response) {

        var resultSet = factory.toResultSet(response);

        return resultSet.data.map(function(item){
            return item.name;
        });

      });

    };

    // Call Search function when dialog box loads
    $scope.listUsers();

  }
]);


;
angular.module('emlogis.monitoring', ['ui.bootstrap', 'ui.router', 'http-auth-interceptor', 'ui.grid.pagination', 'ui.grid.selection', 'ui.grid.resizeColumns', 'emlogis.commonservices', 'emlogis.commonDirectives', 'frapontillo.bootstrap-switch'])
  .config(['$stateProvider', '$urlRouterProvider', '$locationProvider', '$httpProvider', '$breadcrumbProvider',
    function ($stateProvider, $urlRouterProvider, $locationProvider, $httpProvider, $breadcrumbProvider) {

      $urlRouterProvider.when('/monitoring', '/monitoring/database');
      $urlRouterProvider.when('/monitoring/', '/monitoring/database');

      $stateProvider.state('authenticated.monitoring', {
        url: '/monitoring',
        abstract: true,
        views: {
          "content@authenticated": {
            templateUrl: "modules/monitoring/partials/monitoring.html",
            controller: 'MonitoringCtrl'
          },
          "breadcrumb@authenticated": {
            templateUrl: "modules/monitoring/partials/monitoring_breadcrumb.html",
            controller: 'MonitoringBreadcrumbCtrl'
          }
        },
        data: {
          ncyBreadcrumbLabel: '{{"nav.MONITORING" | translate}}',
          permissions: function (authService) {
            return authService.isTenantType('SvcProvider') && authService.hasPermission('SystemConfiguration_Mgmt');
          }
        }
      })
        .state('authenticated.monitoring.database', {
          url: '/database',
          views: {
            "monitoringContent@authenticated.monitoring": {
              templateUrl: "modules/monitoring/partials/database/monitoring_database.html",
              controller: 'MonitoringDatabaseCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"monitoring.DATABASE" | translate}}'
          }
        })
        .state('authenticated.monitoring.database.summary', {
          url: '/summary',
          views: {
            "monitoringDatabaseContent@authenticated.monitoring.database": {
              templateUrl: "modules/monitoring/partials/database/monitoring_database_summary.html",
              controller: 'MonitoringDatabaseSummaryCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"monitoring.DATABASE_SUMMARY" | translate}}'
          }
        })
        .state('authenticated.monitoring.database.percustomer', {
          url: '/percustomer',
          views: {
            "monitoringDatabaseContent@authenticated.monitoring.database": {
              templateUrl: "modules/monitoring/partials/database/monitoring_database_percustomer.html",
              controller: 'MonitoringDatabasePerCustomerCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"monitoring.DATABASE_PER_CUSTOMER" | translate}}'
          }
        })
        .state('authenticated.monitoring.subsystems', {
          url: '/subsystems',
          views: {
            "monitoringContent@authenticated.monitoring": {
              templateUrl: "modules/monitoring/partials/subsystems/monitoring_subsystems.html",
              controller: 'MonitoringSubsystemsCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"monitoring.SUBSYSTEMS" | translate}}'
          }
        })
        .state('authenticated.monitoring.subsystems.hazelcast', {
          url: '/hazelcast',
          views: {
            "monitoringSubsystemsContent@authenticated.monitoring.subsystems": {
              templateUrl: "modules/monitoring/partials/subsystems/monitoring_subsystems_hazelcast.html",
              controller: 'MonitoringSubsystemsHazelcastCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"monitoring.SUBSYSTEMS_HAZELCAST" | translate}}'
          }
        })
        .state('authenticated.monitoring.subsystems.notifications', {
          url: '/notifications',
          views: {
            "monitoringSubsystemsContent@authenticated.monitoring.subsystems": {
              templateUrl: "modules/monitoring/partials/subsystems/monitoring_subsystems_notifications.html",
              controller: 'MonitoringSubsystemsNotificationsCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"monitoring.SUBSYSTEMS_NOTIFICATIONS" | translate}}'
          }
        })
        .state('authenticated.monitoring.subsystems.activesessions', {
          url: '/activesessions',
          views: {
            "monitoringSubsystemsContent@authenticated.monitoring.subsystems": {
              templateUrl: "modules/monitoring/partials/subsystems/monitoring_subsystems_active_sessions.html",
              controller: 'MonitoringSubsystemsActiveSessionsCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"monitoring.SUBSYSTEMS_ACTIVE_SESSIONS" | translate}}'
          }
        })
        .state('authenticated.monitoring.subsystems.activesessions.details', {
          url: '/:id',
          views: {
            "monitoringContent@authenticated.monitoring": {
              templateUrl: "modules/monitoring/partials/subsystems/monitoring_subsystems_active_sessions_details.html",
              controller: 'MonitoringSubsystemsActiveSessionsDetailsCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"app.DETAILS" | translate}}'
          }
        })
        .state('authenticated.monitoring.subsystems.appservers', {
          url: '/appservers',
          views: {
            "monitoringSubsystemsContent@authenticated.monitoring.subsystems": {
              templateUrl: "modules/monitoring/partials/subsystems/monitoring_subsystems_appservers.html",
              controller: 'MonitoringSubsystemsAppServersCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"monitoring.SUBSYSTEMS_APPSERVERS" | translate}}'
          }
        })
        .state('authenticated.monitoring.subsystems.appservers.details', {
          url: '/:id',
          views: {
            "monitoringContent@authenticated.monitoring": {
              templateUrl: "modules/monitoring/partials/subsystems/monitoring_subsystems_appservers_details.html",
              controller: 'MonitoringSubsystemsAppServersDetailsCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"app.DETAILS" | translate}}'
          }
        })
        .state('authenticated.monitoring.subsystems.engines', {
          url: '/engines',
          views: {
            "monitoringSubsystemsContent@authenticated.monitoring.subsystems": {
              templateUrl: "modules/monitoring/partials/subsystems/monitoring_subsystems_engines.html",
              controller: 'MonitoringSubsystemsEnginesCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"monitoring.SUBSYSTEMS_ENGINES" | translate}}'
          }
        })
        .state('authenticated.monitoring.subsystems.engines.details', {
          url: '/:id',
          views: {
            "monitoringContent@authenticated.monitoring": {
              templateUrl: "modules/monitoring/partials/subsystems/monitoring_subsystems_engines_details.html",
              controller: 'MonitoringSubsystemsEnginesDetailsCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"app.DETAILS" | translate}}'
          }
        })
      ;
    }]);



;
angular.module('emlogis.monitoring').controller('MonitoringDatabasePerCustomerCtrl',
  ['$scope', '$q', 'MonitoringService', '$state', 'applicationContext',
    function ($scope, $q, MonitoringService, $state, applicationContext) {

      $scope.entityType = 'dbpercustomer';
      $scope.entityDetailsField = '';

      MonitoringEntityListCtlr($scope, $q, MonitoringService, $state, applicationContext);
      $scope.gridOptions.enableRowHeaderSelection = false;
      $scope.gridOptions.multiSelect = false;
      $scope.gridOptions.columnDefs = [
        {
          field: 'name',
          minWidth: 150
        },
        {
          field: 'dbInfo.Site',
          headerCellTemplate: headerCellTemplate(),
          name: 'monitoring.SITES'
        },
        {
          field: 'dbInfo.Team',
          headerCellTemplate: headerCellTemplate(),
          name: 'monitoring.TEAMS'
        },
        {
          field: 'dbInfo.Employee',
          headerCellTemplate: headerCellTemplate(),
          name: 'monitoring.EMPLOYEES'
        },
        {
          field: 'dbInfo.UserAccount',
          headerCellTemplate: headerCellTemplate(),
          name: 'monitoring.ACCOUNTS'
        },
        {
          field: 'dbInfo.GroupAccount',
          headerCellTemplate: headerCellTemplate(),
          name: 'monitoring.GROUPS'
        },
        {
          field: 'dbInfo.Role',
          headerCellTemplate: headerCellTemplate(),
          name: 'monitoring.ROLES'
        },
        {
          field: 'dbInfo.ACE',
          headerCellTemplate: headerCellTemplate(),
          name: 'monitoring.ACE'
        },
        {
          field: 'dbInfo.Skill',
          headerCellTemplate: headerCellTemplate(),
          name: 'monitoring.SKILLS'
        },
        {
          field: 'dbInfo.AvailabilityTimeFrame.total',
          headerCellTemplate: headerCellTemplate(),
          name: 'monitoring.AVAILABILITY_RECORDS'
        },
        {
          field: 'dbInfo.Contract.total',
          headerCellTemplate: headerCellTemplate(),
          name: 'monitoring.CONTRACTS'
        },
        {
          field: 'dbInfo.ContractLine.total',
          headerCellTemplate: headerCellTemplate(),
          name: 'monitoring.CONTRACT_LINES'
        },
        {
          field: 'dbInfo.ShiftLength',
          headerCellTemplate: headerCellTemplate(),
          name: 'monitoring.SHIFT_LENGTHS'
        },
        {
          field: 'dbInfo.ShiftType',
          headerCellTemplate: headerCellTemplate(),
          name: 'monitoring.SHIFT_TYPES'
        },
        {
          field: 'dbInfo.Schedule.total',
          headerCellTemplate: headerCellTemplate(),
          name: 'monitoring.SCHEDULES'
        },
        {
          field: 'dbInfo.ScheduleChange.total',
          headerCellTemplate: headerCellTemplate(),
          name: 'monitoring.SCHEDULE_CHANGES'
        },
        {
          field: 'dbInfo.ShiftPattern',
          headerCellTemplate: headerCellTemplate(),
          name: 'monitoring.SHIFT_PATTERNS'
        },
        {
          field: 'dbInfo.ShiftReq',
          headerCellTemplate: headerCellTemplate(),
          name: 'monitoring.SHIFT_REQS'
        },
        {
          field: 'dbInfo.Shift',
          headerCellTemplate: headerCellTemplate(),
          name: 'monitoring.SHIFTS'
        },
        {
          field: 'dbInfo.PatternElt',
          headerCellTemplate: headerCellTemplate(),
          name: 'monitoring.SHIFT_REQS_ELTS'
        },
        {
          field: 'dbInfo.PostedOpenShift.total',
          headerCellTemplate: headerCellTemplate(),
          name: 'monitoring.POSTED_OPEN_SHIFTS'
        },
        {
          field: 'dbInfo.SendNotification',
          headerCellTemplate: headerCellTemplate(),
          name: 'monitoring.SEND_NOTIFICATION'
        },
        {
          field: 'dbInfo.ReceiveNotification',
          headerCellTemplate: headerCellTemplate(),
          name: 'monitoring.RECEIVE_NOTIFICATION'
        }
      ];

      function headerCellTemplate() {
        return "<div ng-class=\"{ 'sortable': sortable }\">" +
          "<div class=\"ui-grid-vertical-bar\">&nbsp;</div>" +
          "<div class=\"ui-grid-cell-contents\" col-index=\"renderIndex\" title='{{col.name CUSTOM_FILTERS | translate}}' ><span translate>{{col.name CUSTOM_FILTERS }} </span>" +
          "<span ui-grid-visible=\"col.sort.direction\" class='ui-grid-icon-my' ng-class=\"{ 'ui-grid-icon-up-dir': col.sort.direction == asc, 'ui-grid-icon-down-dir': col.sort.direction == desc, 'ui-grid-icon-blank': !col.sort.direction }\">&nbsp;</span></span>" +
          "</div>" +
          "<div ng-if=\"filterable\" class=\"ui-grid-filter-container\" ng-repeat=\"colFilter in col.filters\">" +
          "<input type=\"text\" class=\"ui-grid-filter-input\" ng-model=\"colFilter.term\" ng-click=\"$event.stopPropagation()\" ng-attr-placeholder=\"{{colFilter.placeholder || ''}}\">" +
          "<div class=\"ui-grid-filter-button\" ng-click=\"colFilter.term = null\">" +
          "<i class=\"ui-grid-icon-cancel right\" ng-show=\"!!colFilter.term\">&nbsp;</i> <!-- use !! because angular interprets 'f' as false -->" +
          "</div>" +
          "</div>" +
          "</div>";
      }

    }
  ]);

;
angular.module('emlogis.monitoring').controller('MonitoringDatabaseSummaryCtrl',
  ['$scope', '$q', 'MonitoringService', '$state', 'applicationContext',
    function ($scope, $q, MonitoringService, $state, applicationContext) {

      $scope.getDbSummary = function () {
        var deferred = $q.defer();
        MonitoringService.getDbSummary().then(function (response) {
          if (response.data) {
            deferred.resolve(response.data);
          } else {
            deferred.reject('Error Occurred while trying to get Object');
          }
        }, function (error) {
          applicationContext.setNotificationMsgWithValues(error.data.message, 'danger', true, error.statusText);
          deferred.reject('Error Occurred while trying to get Object');
        });
        return deferred.promise;
      };

      $scope.dbInfo = [
        {
          field: 'Organization',
          name: 'monitoring.CUSTOMERS'
        }, {
          field: 'Site',
          name: 'monitoring.SITES'
        }, {
          field: 'Team',
          name: 'monitoring.TEAMS'
        }, {
          field: 'Employee',
          name: 'monitoring.EMPLOYEES'
        }, {
          field: 'UserAccount',
          name: 'monitoring.ACCOUNTS'
        }, {
          field: 'GroupAccount',
          name: 'monitoring.GROUPS'
        }, {
          field: 'Role',
          name: 'monitoring.ROLES'
        }, {
          field: 'ACE',
          name: 'monitoring.ACE'
        }, {
          field: 'Skill',
          name: 'monitoring.SKILLS'
        }, {
          field: 'AvailabilityTimeFrame',
          name: 'monitoring.AVAILABILITY_RECORDS',
          subTypes: [
            {
              field: 'CIAvailabilityTimeFrame',
              name: 'monitoring.CI_AVAILABILITY'
            }, {
              field: 'CDAvailabilityTimeFrame',
              name: 'monitoring.CD_AVAILABILITY'
            }
          ]
        }, {
          field: 'Contract',
          name: 'monitoring.CONTRACTS',
          subTypes: [
            {
              field: 'SiteContract',
              name: 'monitoring.SITE_CONTRACT'
            }, {
              field: 'TeamContract',
              name: 'monitoring.TEAM_CONTRACT'
            }, {
              field: 'EmployeeContract',
              name: 'monitoring.EMPLOYEE_CONTRACT'
            }
          ]
        }, {
          field: 'ContractLine',
          name: 'monitoring.CONTRACT_LINES',
          subTypes: [
            {
              field: 'BooleanCL',
              name: 'monitoring.BOOLEAN_CL'
            }, {
              field: 'IntMinMaxCL',
              name: 'monitoring.INT_MIN_MAX_CL'
            }, {
              field: 'WeekdayRotationPatternCL',
              name: 'monitoring.WEEKDAY_ROTATION_PATTERN_CL'
            }, {
              field: 'WeekendWorkPatternCL',
              name: 'monitoring.WEEKEND_WORK_PATTERN_CL'
            }
          ]
        }, {
          field: 'ShiftLength',
          name: 'monitoring.SHIFT_LENGTHS'
        }, {
          field: 'ShiftType',
          name: 'monitoring.SHIFT_TYPES'
        }, {
          field: 'Schedule',
          name: 'monitoring.SCHEDULES',
          subTypes: [
            {
              field: 'posted',
              name: 'monitoring.SCHEDULES_POSTED'
            }, {
              field: 'production',
              name: 'monitoring.SCHEDULES_PRODUCTION'
            }, {
              field: 'simulation',
              name: 'monitoring.SCHEDULES_SIMULATION'
            }
          ]
        }, {
          field: 'ScheduleChange',
          name: 'monitoring.SCHEDULE_CHANGES'
        }, {
          field: 'ShiftPattern',
          name: 'monitoring.SHIFT_PATTERNS'
        }, {
          field: 'ShiftReq',
          name: 'monitoring.SHIFT_REQS'
        }, {
          field: 'Shift',
          name: 'monitoring.SHIFTS'
        }, {
          field: 'PatternElt',
          name: 'monitoring.SHIFT_REQS_ELTS'
        }, {
          field: 'PostedOpenShift',
          name: 'monitoring.POSTED_OPEN_SHIFTS',
          subTypes: [
            {
              field: 'current',
              name: 'monitoring.POSTED_OPEN_SHIFTS_CURRENT'
            }, {
              field: 'passed',
              name: 'monitoring.POSTED_OPEN_SHIFTS_PASSED'
            }
          ]
        }
      ];

      $scope.loadData = function () {
        $scope.getDbSummary()
          .then(function (dbInfo) {
            angular.forEach($scope.dbInfo, function (elt, index) {
              if (angular.isDefined(dbInfo[elt.field].total)) {
                elt.value = dbInfo[elt.field].total;
                angular.forEach(elt.subTypes, function (elt1, index1) {
                  elt1.value = dbInfo[elt.field][elt1.field];
                });
              } else {
                elt.value = dbInfo[elt.field];
              }
            });
          });
      };

      $scope.refreshInterval = 5;

      $scope.loadData();
      MonitoringService.refresh(function () {
        $scope.loadData();
      }, $scope.refreshInterval);
    }
  ]);
;
angular.module('emlogis.monitoring').controller('MonitoringDatabaseCtrl', [
  '$scope', '$state',
  function ($scope, $state) {

    $scope.tabs = [
      { heading: "monitoring.DATABASE_SUMMARY", route: 'authenticated.monitoring.database.summary' },
      { heading: "monitoring.DATABASE_PER_CUSTOMER", route: 'authenticated.monitoring.database.percustomer' }
    ];

    $scope.goState = function (tab) {
      $state.go(tab.route);
    };

    $scope.active = function (route) {
      return $state.is(route);
    };

    $scope.$on("$stateChangeSuccess", function () {
      $scope.tabs.forEach(function (tab) {
        tab.active = $scope.active(tab.route);
      });
    });
  }
]);

;
var employees = angular.module('emlogis.monitoring');

employees.controller('MonitoringBreadcrumbCtrl', ['$scope', '$translate',  'applicationContext',
    function($scope, $translate,  applicationContext) {


        // Update Module Information
        var module = applicationContext.getModule();

        // Call translate directive function. Put translated text;
        $translate('nav.MONITORING')
            .then(function (translation) {
                module.name =  translation;
            });


        module.href = '/monitoring';
        module.icoClass = '';
        module.disableModuleBreadcrumb = false;
        applicationContext.setModule(module);

    }
]);

;
angular.module('emlogis.monitoring').controller('MonitoringCtrl', ['$scope', 'MonitoringService',
  function($scope, MonitoringService) {
    $scope.$on("$stateChangeStart", function () {
      MonitoringService.stopRefresh();
    });
  }
]);

angular.module('emlogis.monitoring').directive('optionButtons', function($compile) {
  return {
    restrict: "E",
    replace: true,
    scope : {
      buttons: '='
    },

    link:  function (scope, element, attrs) {
      element.html('<button data-ng-repeat="btn in buttons" class="btn btn-default pull-right" ng-disabled="btn.disabled" data-ng-click="btn.onClick()">' +
      '      <span ng-bind-html="btn.title"></span>' +
      '</button>');
      $compile(element.contents())(scope);
    }
  };
});
;
var MonitoringEntityDetailsCtlr = function ($scope, $q, MonitoringService, $state, $stateParams, applicationContext, $filter) {

  $scope.parentState = '';
  $scope.refreshInterval = 5;

  $scope.getEntityDetails = function () {
    var deferred = $q.defer();
    MonitoringService.getEntityDetails($scope.entityType, $stateParams.id)
      .then(function (response) {
        if (response.data) {
          deferred.resolve(response.data);
        } else {
          deferred.reject('Error Occurred while trying to get Object');
        }
      }, function (error) {
        applicationContext.setNotificationMsgWithValues(error.data.message, 'danger', true, error.statusText);
        deferred.reject('Error Occurred while trying to get Object');
      });
    return deferred.promise;
  };

  $scope.loadPromise = null;

  $scope.loadData = function () {
    $scope.loadPromise = $scope.getEntityDetails()
      .then(function (data) {
        $scope.entity = data;
      });
  };

  if (!$scope.vetoLoad) {
    $scope.loadData();
    MonitoringService.refresh(function () {
      $scope.loadData();
    }, $scope.refreshInterval);
  }

  $scope.close = function () {
    if ($scope.parentState)
      $state.go($scope.parentState);
  };

  $scope.keys = function (obj) {
    return obj ? _.without(Object.keys(obj), '$$hashKey') : [];
  };

  $scope.customFilter = function(value, filter, params) {
    return $filter(filter)(value, params);
  };

};


var MonitoringEntityListCtlr = function ($scope, $q, MonitoringService, $state, applicationContext) {

  $scope.refreshInterval = 5;
  $scope.getEntityList = function () {
    var deferred = $q.defer();
    MonitoringService.getEntityList($scope.entityType).then(function (response) {
      if (response.data) {
        deferred.resolve(response.data);
      } else {
        deferred.reject('Error Occurred while trying to get Object');
      }
    }, function (error) {
      applicationContext.setNotificationMsgWithValues(error.data.message, 'danger', true, error.statusText);
      deferred.reject('Error Occurred while trying to get Object');
    });
    return deferred.promise;
  };

  $scope.gridData = [];
  $scope.selectedEntities = [];
  $scope.gridOptions = {
    enableColumnResizing: true,
    enableScrollbars: false,
    paginationPageSize: 10,
    data: 'gridData | filter: filter.filterTxt',
    rowTemplate: defaultRowTemplate(),
    columnDefs: $scope.columnDefs,
    enableRowSelection: true,
    enableSelectAll: true,
    multiSelect: true
  };

  $scope.gridOptions.onRegisterApi = function(gridApi){
    gridApi.selection.on.rowSelectionChanged($scope, function (row) {
      $scope.processSelectedRow(row);
    });

    gridApi.selection.on.rowSelectionChangedBatch($scope, function (rows) {
      angular.forEach(rows, function (row) {
        $scope.processSelectedRow(row);
      });
    });
  };

  $scope.processSelectedRow = function (row) {
    if (row.isSelected) {
      $scope.selectedEntities.push(row.entity);
    } else {
      $scope.selectedEntities = _.filter($scope.selectedEntities, function(entity){ return entity[$scope.entityDetailsField] !== row.entity[$scope.entityDetailsField]; });
    }
  };

  function defaultRowTemplate() {
    if($scope.entityDetailsField){
      return '<div ng-dblclick="grid.appScope.viewEntity(row.entity.'+ $scope.entityDetailsField +')" ' +
        'ng-repeat="col in colContainer.renderedColumns track by col.colDef.name" class="ui-grid-cell" ui-grid-cell></div>';
    } else {
      return '<div ' +
        'ng-repeat="col in colContainer.renderedColumns track by col.colDef.name" class="ui-grid-cell" ui-grid-cell></div>';
    }
  }

  $scope.headerCellTemplate = function() {
    return "<div ng-class=\"{ 'sortable': sortable }\">" +
      "<div class=\"ui-grid-vertical-bar\">&nbsp;</div>" +
      "<div class=\"ui-grid-cell-contents\" col-index=\"renderIndex\" title='{{col.name CUSTOM_FILTERS | translate}}' ><span translate>{{col.name CUSTOM_FILTERS }} </span>" +
      "<span ui-grid-visible=\"col.sort.direction\" class='ui-grid-icon-my' ng-class=\"{ 'ui-grid-icon-up-dir': col.sort.direction == asc, 'ui-grid-icon-down-dir': col.sort.direction == desc, 'ui-grid-icon-blank': !col.sort.direction }\">&nbsp;</span></span>" +
      "</div>" +
      "<div ng-if=\"filterable\" class=\"ui-grid-filter-container\" ng-repeat=\"colFilter in col.filters\">" +
      "<input type=\"text\" class=\"ui-grid-filter-input\" ng-model=\"colFilter.term\" ng-click=\"$event.stopPropagation()\" ng-attr-placeholder=\"{{colFilter.placeholder || ''}}\">" +
      "<div class=\"ui-grid-filter-button\" ng-click=\"colFilter.term = null\">" +
      "<i class=\"ui-grid-icon-cancel right\" ng-show=\"!!colFilter.term\">&nbsp;</i> <!-- use !! because angular interprets 'f' as false -->" +
      "</div>" +
      "</div>" +
      "</div>";
  };

  $scope.dateCellTemplate = function() {
    return '<div class="ui-grid-cell-contents"> {{COL_FIELD | date: "yyyy/MM/dd HH:mm:ss"}} </div>';
  };

  function createGridData(data) {
    var gridData = [];
    angular.forEach(data, function (elem, index) {
      gridData.push(elem);
    });
    $scope.gridData = gridData;
  }
  $scope.loadPromise = null;
  $scope.loadData = function () {
    $scope.loadPromise = $scope.getEntityList()
      .then(function (data) {
        createGridData(data);
        if($scope.saveResult){
          $scope.entityList = data;
        }
      });
  };

  $scope.loadData();
  MonitoringService.refresh(function () {
    $scope.loadData();
  }, $scope.refreshInterval);

  $scope.viewEntity = function (id) {
    $state.go($state.current.name + '.details', {id: id});
  };
};

;
angular.module('emlogis.monitoring').controller('MonitoringSubsystemsActiveSessionsDetailsCtrl',
  ['$scope', '$q', 'MonitoringService', '$state', '$stateParams', 'applicationContext', '$filter',
    function ($scope, $q, MonitoringService, $state, $stateParams, applicationContext, $filter) {

      $scope.vetoLoad = true;

      MonitoringEntityDetailsCtlr($scope, $q, MonitoringService, $state, $stateParams, applicationContext, $filter);

      $scope.terminate = function () {
        console.log("terminate");
      };

      $scope.buttons = [
        {
          title: 'Terminate Session (N/A)',
          onClick: $scope.terminate
        }
      ];

      $scope.entity = MonitoringService.getSessionByToken($stateParams.id);
      $scope.title = $scope.entity.token + ' / ' + $scope.entity.tenantId + ' - ' + $scope.entity.userId;
      $scope.names = [
        {
          tenantId: 'monitoring.sessions.TENANT'
        }, {
          userName: 'monitoring.sessions.USER',
          impersonatingUserName: 'monitoring.sessions.IMPERSONATING'
        }, {
          clientIPAddress: 'monitoring.sessions.IP',
          clientHostname: 'monitoring.sessions.HOSTNAME'
        }, {
          started: 'monitoring.sessions.SESSIONS_STARTED'
        }, {
          clientUserAgent: 'monitoring.sessions.USER_AGENT'
        }, {
          token: 'monitoring.sessions.TOKEN'
        }
      ];

      $scope.options = {
        started: {
          filter: 'date',
          params: 'yyyy/MM/dd HH:mm:ss'
        }
      };
      $scope.parentState = 'authenticated.monitoring.subsystems.activesessions';


    }
  ]);
;
angular.module('emlogis.monitoring').controller('MonitoringSubsystemsActiveSessionsCtrl',
  ['$scope', '$q', 'MonitoringService', '$state', 'applicationContext',
    function ($scope, $q, MonitoringService, $state, applicationContext) {

      $scope.entityType = 'session';
      $scope.entityDetailsField = 'token';
      $scope.saveResult = true;

      MonitoringEntityListCtlr($scope, $q, MonitoringService, $state, applicationContext);

      $scope.terminate = function () {
        console.log("terminate");
      };

      $scope.buttons = [
        {
          title: 'Terminate Sessions (N/A)',
          onClick: $scope.terminate
        }
      ];

      $scope.gridOptions.columnDefs = [
        {
          field: 'tenantId',
          name: 'monitoring.sessions.TENANT',
          headerCellTemplate: $scope.headerCellTemplate(),
          minWidth: 150
        },
        {
          field: 'userName',
          headerCellTemplate: $scope.headerCellTemplate(),
          name: 'monitoring.sessions.USER'
        },
        {
          field: 'impersonatingUserName',
          headerCellTemplate: $scope.headerCellTemplate(),
          name: 'monitoring.sessions.IMPERSONATING'
        },
        {
          field: 'clientIPAddress',
          headerCellTemplate: $scope.headerCellTemplate(),
          name: 'monitoring.sessions.IP'
        },
        {
          field: 'clientHostname',
          headerCellTemplate: $scope.headerCellTemplate(),
          name: 'monitoring.sessions.HOSTNAME'
        },
        {
          field: 'started',
          headerCellTemplate: $scope.headerCellTemplate(),
          cellTemplate: $scope.dateCellTemplate(),
          name: 'monitoring.sessions.STARTED'
        },
        {
          field: 'clientUserAgent',
          headerCellTemplate: $scope.headerCellTemplate(),
          name: 'monitoring.sessions.USER_AGENT'
        }

      ];

      $q.when($scope.loadPromise).then(function (res) {
        MonitoringService.setSessions($scope.entityList);
      });

    }
  ]);
;
angular.module('emlogis.monitoring').controller('MonitoringSubsystemsAppServersDetailsCtrl',
  ['$scope', '$q', 'MonitoringService', '$state', '$stateParams', 'applicationContext', '$filter',
    function ($scope, $q, MonitoringService, $state, $stateParams, applicationContext, $filter) {

      $scope.entityType = 'appserver';
      MonitoringEntityDetailsCtlr($scope, $q, MonitoringService, $state, $stateParams, applicationContext, $filter);

      $scope.terminate = function () {
        console.log("terminate");
      };
      $scope.buttons = [
        {
          title: '<span class="glyphicon glyphicon-refresh" />',
          onClick: $scope.loadData
        },
        {
          title: 'Terminate (N/A)',
          onClick: $scope.terminate
        }
      ];


      $q.when($scope.loadPromise).then(function (res) {
        $scope.title = $scope.entity.name;
      });

      $scope.names = [
        {
          name: 'app.NAME'
        }, {
          updated: 'monitoring.UPDATED'
        }, {
          ip: 'monitoring.sessions.IP'
        }
      ];

      $scope.options = {
        updated: {
          filter: 'date',
          params: 'yyyy/MM/dd HH:mm:ss'
        }
      };

      $scope.parentState = 'authenticated.monitoring.subsystems.appservers';


    }
  ]);
;
angular.module('emlogis.monitoring').controller('MonitoringSubsystemsAppServersCtrl',
  ['$scope', '$q', 'MonitoringService', '$state', 'applicationContext',
    function ($scope, $q, MonitoringService, $state, applicationContext) {

      $scope.entityType = 'appserver';
      $scope.entityDetailsField = 'name';

      MonitoringEntityListCtlr($scope, $q, MonitoringService, $state, applicationContext);

      $scope.gridOptions.columnDefs = [
        {
          field: 'ip',
          name: 'monitoring.sessions.IP',
          headerCellTemplate: $scope.headerCellTemplate()
        }, {
          field: 'name',
          name: 'app.NAME',
          headerCellTemplate: $scope.headerCellTemplate()
        }, {
          field: 'updated',
          name: 'monitoring.UPDATED',
          cellTemplate: $scope.dateCellTemplate(),
          headerCellTemplate: $scope.headerCellTemplate()
        }
      ];

    }
  ]);
;
angular.module('emlogis.monitoring').controller('MonitoringSubsystemsEnginesDetailsCtrl',
  ['$scope', '$q', 'MonitoringService', '$state', '$stateParams', 'applicationContext', '$filter',
    function ($scope, $q, MonitoringService, $state, $stateParams, applicationContext, $filter) {

      $scope.entityType = 'engine';
      MonitoringEntityDetailsCtlr($scope, $q, MonitoringService, $state, $stateParams, applicationContext, $filter);

      $scope.shutdown = function () {
        MonitoringService.shutdownEngine($stateParams.id)
          .then(function (response) {
            MonitoringService.stopRefresh();
            $scope.buttons[1].disabled = true;
            applicationContext.setNotificationMsgWithValues('Engine has been shut down', 'success', true);
          }, function (error) {
            applicationContext.setNotificationMsgWithValues(error.data.message, 'danger', true);
          });
      };

      $scope.buttons = [
        {
          title: '<span class="glyphicon glyphicon-refresh" />',
          onClick: $scope.loadData
        },
        {
          title: 'Shutdown Engine (N/A)',
          onClick: $scope.shutdown,
          disabled: false
        }
      ];

      $q.when($scope.loadPromise).then(function (res) {
        $scope.title = $scope.entity.name;
      });

      $scope.names = [
        {
          name: 'app.NAME'
        }, {
          updated: 'monitoring.UPDATED'
        }, {
          ip: 'monitoring.sessions.IP'
        }
      ];

      $scope.options = {
        updated: {
          filter: 'date',
          params: 'yyyy/MM/dd HH:mm:ss'
        }
      };

      $scope.parentState = 'authenticated.monitoring.subsystems.engines';


    }
  ]);
;
angular.module('emlogis.monitoring').controller('MonitoringSubsystemsEnginesCtrl',
  ['$scope', '$q', 'MonitoringService', '$state', 'applicationContext',
    function ($scope, $q, MonitoringService, $state, applicationContext) {

      $scope.entityType = 'engine';
      $scope.entityDetailsField = 'name';

      MonitoringEntityListCtlr($scope, $q, MonitoringService, $state, applicationContext);
      $scope.shutdownPromise = function () {
        var promises = [];
        angular.forEach($scope.selectedEntities, function (entity) {
          promises.push(MonitoringService.shutdownEngine(entity.name));
        });
        return $q.all(promises);
      };

      $scope.shutdown = function () {
        $scope.shutdownPromise()
          .then(function () {
            $scope.loadData();
          });
      };

      $scope.buttons = [
        {
          title: 'Shutdown',
          onClick: $scope.shutdown
        }
      ];
      $scope.gridOptions.columnDefs = [
        {
          field: 'ip',
          name: 'monitoring.sessions.IP',
          headerCellTemplate: $scope.headerCellTemplate()
        }, {
          field: 'name',
          name: 'app.NAME',
          headerCellTemplate: $scope.headerCellTemplate()
        }, {
          field: 'updated',
          name: 'monitoring.UPDATED',
          cellTemplate: $scope.dateCellTemplate(),
          headerCellTemplate: $scope.headerCellTemplate()
        }
      ];
    }
  ]);
;
angular.module('emlogis.monitoring').controller('MonitoringSubsystemsHazelcastCtrl',
  ['$scope', '$q', 'MonitoringService', '$state', 'applicationContext', '$filter',
    function ($scope, $q, MonitoringService, $state, $stateParams, applicationContext, $filter) {

      $scope.entityType = 'hazelcast';
      MonitoringEntityDetailsCtlr($scope, $q, MonitoringService, $state, $stateParams, applicationContext, $filter);

      $scope.names = [
        {
          globalAssignmentReqQueueSize: 'monitoring.hazelcast.GLOBAL_ASSIGNMENT_REQ_QUEUE_SIZE',
          globalQualificationReqQueueSize: 'monitoring.hazelcast.GLOBAL_QUALIFICATION_REQ_QUEUE_SIZE',
          globalResponseQueueSize: 'monitoring.hazelcast.GLOBAL_RESPONSE_QUEUE_SIZE'
        }, {
          requestDataMapSize: 'monitoring.hazelcast.REQUEST_DATAMAP_SIZE',
          responseDataMapSize: 'monitoring.hazelcast.RESPONSE_DATAMAP_SIZE',
          qualificationTrackerMapSize: 'monitoring.hazelcast.QUALIFICATION_TRACKER_MAP_SIZE'
        }, {
          abortMapSize: 'monitoring.hazelcast.ABORT_MAP_SIZE',
          shutdownMapSize: 'monitoring.hazelcast.SHUTDOWN_MAP_SIZE'
        }, {
          appServers: 'monitoring.hazelcast.APPSERVERS',
          engines: 'monitoring.hazelcast.ENGINES'
        }
      ];

    }
  ]);
;
angular.module('emlogis.monitoring').controller('MonitoringSubsystemsNotificationsCtrl',
  ['$scope', '$q', 'MonitoringService', '$state', 'applicationContext', '$filter',
    function ($scope, $q, MonitoringService, $state, $stateParams, applicationContext, $filter) {

      $scope.entityType = 'notifications';
      MonitoringEntityDetailsCtlr($scope, $q, MonitoringService, $state, $stateParams, applicationContext, $filter);

      $scope.names = [
        {
          send: 'monitoring.notifications.SEND'
        },{
          receive: 'monitoring.notifications.RECEIVE'
        },{
          archivedReceiveQueue: 'monitoring.notifications.ARCHIVE_SEND'
        },{
          archivedSendQueue: 'monitoring.notifications.ARCHIVE_RECEIVED'
        }
      ];
    }
  ]);
;
angular.module('emlogis.monitoring').controller('MonitoringSubsystemsCtrl', [
  '$scope', '$state', 'MonitoringService',
  function ($scope, $state, MonitoringService) {

    $scope.tabs = [
      {heading: "monitoring.SUBSYSTEMS_HAZELCAST", route: 'authenticated.monitoring.subsystems.hazelcast'},
      {heading: "monitoring.SUBSYSTEMS_NOTIFICATIONS", route: 'authenticated.monitoring.subsystems.notifications'},
      {heading: "monitoring.SUBSYSTEMS_ACTIVE_SESSIONS", route: 'authenticated.monitoring.subsystems.activesessions'},
      {heading: "monitoring.SUBSYSTEMS_APPSERVERS", route: 'authenticated.monitoring.subsystems.appservers'},
      {heading: "monitoring.SUBSYSTEMS_ENGINES", route: 'authenticated.monitoring.subsystems.engines'}
    ];

    $scope.goState = function (tab) {
      $state.go(tab.route);
    };

    $scope.active = function (route) {
      return $state.includes(route);
    };

    $scope.$on("$stateChangeSuccess", function () {
      $scope.tabs.forEach(function (tab) {
        tab.active = $scope.active(tab.route);
      });
    });
  }
]);

;
angular.module('emlogis.monitoring')
  .service('MonitoringService', ['$http', '$rootScope', '$q', 'applicationContext', '$interval',
    function ($http, $rootScope, $q, applicationContext, $interval) {
      var baseUrl = applicationContext.getBaseRestUrl();

      function sendRequest(urlPart, method, requestPayload) {
        var apiUrl = baseUrl + urlPart;
        var req = {
          method: method,
          url: apiUrl
        };
        if (method === 'POST' || method === 'PUT') {
          req.data = requestPayload;
        }
        return $http(req);
      }

      this.getEntityDetails = function (entityType, entityId) {
        var urlPart;
        switch (entityType) {
          case 'engine':
            urlPart = 'engines/' + entityId;
            break;
          case 'appserver':
            urlPart = 'appservers/' + entityId;
            break;
          case 'hazelcast':
            urlPart = 'systeminfo/hzinfo';
            break;
          case 'notifications':
            urlPart = 'systeminfo/notificationinfo';
            break;
        }
        return sendRequest(urlPart, 'GET', null);
      };

      this.getEntityList = function (entityType) {
        var urlPart;
        switch (entityType) {
          case 'engine':
            urlPart = 'engines';
            break;
          case 'appserver':
            urlPart = 'appservers';
            break;
          case 'session':
            urlPart = 'sessions';
            break;
          case 'dbpercustomer':
            urlPart = 'systeminfo/dbpercustomer';
            break;
        }
        return sendRequest(urlPart, 'GET', null);
      };

      this.getDbSummary = function () {
        return sendRequest('systeminfo/dbsummary', 'GET', null);
      };

      this.shutdownEngine = function (id) {
        return sendRequest('engines/' + id, 'POST', null);
      };

      var shared = {sessions: []};

      this.getShared = function () {
        return shared;
      };

      this.setShared = function (value) {
        shared = value;
      };

      this.setSessions = function (data) {
        shared.sessions = data;
      };

      this.getSessionByToken = function (token) {
        return _.find(shared.sessions, function (elem) {
          return elem.token === token;
        });
      };

      var stop;
      this.refresh = function (func, refreshInterval) {
        if (angular.isDefined(stop)) return;
        stop = $interval(func, refreshInterval * 1000);
      };

      this.stopRefresh = function () {
        if (angular.isDefined(stop)) {
          $interval.cancel(stop);
          stop = undefined;
        }
      };
    }]);
;
angular.module('emlogis.profile',
  [
    'ui.bootstrap',
    'ui.router',
    'http-auth-interceptor'
  ])
  .config(
  [
    '$stateProvider',
    '$urlRouterProvider',
    '$locationProvider',
    '$httpProvider',
    '$breadcrumbProvider',
    '$modalProvider',
    function ($stateProvider, $urlRouterProvider, $locationProvider,
              $httpProvider, $breadcrumbProvider, $modalProvider) {

      // Schedule Builder Module Url
      $modalProvider.options.animation = false;
      $stateProvider.state('authenticated.profile', {
        url: '/profile',
        abstract: true,
        views: {
          "content@authenticated": {
            templateUrl: "modules/profile/partials/profile.html",
            controller: 'ProfileCtrl'
          },
          "breadcrumb@authenticated": {
            templateUrl: "modules/profile/partials/profile_breadcrumb.html",
            controller: 'ProfileBreadcrumbCtrl'
          }
        }
      })
        .state('authenticated.profile.detail', {
          url: '/detail',
          views: {
            "profileContent@authenticated.profile": {
              templateUrl: "modules/profile/partials/profile_detail.html",
              controller: 'ProfileDetailCtrl as profile'
            },
            "profileBreadcrumb@authenticated.profile": {
              templateUrl: "modules/profile/partials/profile_detail_breadcrumb.html",
              controller: "ProfileDetailBreadcrumbCtrl"
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"app.DETAIL" | translate}}',
            permissions: function (authService) {
              return authService.isUserAnEmployee() && authService.hasPermission('AccountProfile_Update');
            }
          }
        })
        .state('authenticated.profile.preferences', {
          url: '/preferences',
          views: {
            "profileContent@authenticated.profile": {
              templateUrl: "modules/profile/partials/profile_preferences.html",
              controller: 'ProfilePreferencesCtrl'
            },
            "profileBreadcrumb@authenticated.profile": {
              templateUrl: "modules/profile/partials/profile_preferences_breadcrumb.html",
              controller: "ProfilePreferencesBreadcrumbCtrl"
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"profile.PREFERENCES" | translate}}',
            permissions: function (authService) {
              return authService.hasPermission('AccountProfile_Update');
            }
          }
        })
        .state('authenticated.profile.password', {
          url: '/password',
          views: {
            "profileContent@authenticated.profile": {
              templateUrl: "modules/profile/partials/profile_password.html",
              controller: 'ProfilePasswordCtrl'
            },
            "profileBreadcrumb@authenticated.profile": {
              templateUrl: "modules/profile/partials/profile_password_breadcrumb.html",
              controller: "ProfilePasswordBreadcrumbCtrl"
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"profile.CHANGE_PASSWORD" | translate}}',
            permissions: function (authService) {
              return true;
            }
          }
        });

    }
  ]
);



;
var profile = angular.module('emlogis.profile');

profile.controller('ProfileBreadcrumbCtrl', function($scope, $translate, $sessionStorage, applicationContext ) {

  console.log('inside profile breadcrumb controller');

  // Update Module Information

  var module = applicationContext.getModule();

  // Call translate directive function. Put translated text;
  $translate('nav.EMPLOYEE_PROFILE')
    .then(function (translation) {
      module.name =  translation;
    });


  module.href = '/profile';
  module.icoClass = '';
  module.disableModuleBreadcrumb = false;
  applicationContext.setModule(module);

});

;
var profile = angular.module('emlogis.profile');

profile.controller('ProfileDetailBreadcrumbCtrl',
  [
    '$rootScope',
    '$scope',
    '$modal',
    'applicationContext',
    'scheduleService',
    'crudDataService',
    'appFunc',
    '$q',
  function($rootScope, $scope, $modal, applicationContext, scheduleService, crudDataService, appFunc, $q) {

    console.log('Profile Detail breadcrumb controller');
  }
]);

;
(function () {
  "use strict";

  var employees = angular.module('emlogis.profile');

  employees.controller('ProfileDetailEmergencyModalCtrl',
    ['$scope', '$rootScope', '$modalInstance', 'profileDetailService', 'employee',
      function ($scope, $rootScope, $modalInstance, profileDetailService, employee) {

        //--------------------------------------------------------------------
        // Defaults for Emergency Contact Modal
        //--------------------------------------------------------------------

        var ec = this;

        ec.employee = employee;
        ec.isEditing = false;
        ec.relationships = ['Brother', 'Daughter', 'Father', 'Friend', 'Husband', 'Mother', 'Peer', 'Sister', 'Son', 'Spouse', 'Wife'];



        //
        // If user navigates away from the page,
        // dismiss the modal

        $rootScope.$on('$stateChangeStart',
          function(){
            $modalInstance.dismiss('cancel');
          }
        );


        //--------------------------------------------------------------------
        // CRUD
        //--------------------------------------------------------------------

        ec.startEditing = function () {
          ec.employeeForEdit = angular.copy(ec.employee);
          ec.isEditing = true;
        };


        ec.cancelEditing = function () {
          ec.isEditing = false;
        };


        ec.saveEmergencyContact = function(){
          var newEc = {
            emergencyContact: ec.employeeForEdit.emergencyContact,
            ecRelationship: ec.employeeForEdit.ecRelationship,
            ecPhoneNumber: ec.employeeForEdit.ecPhoneNumber
          };

          return profileDetailService.updateEmployee(ec.employee, newEc).then(function(employee){
            ec.employee = employee;
            ec.isEditing = false;
          });
        };


        //--------------------------------------------------------------------
        // Modal methods
        //--------------------------------------------------------------------


        ec.closeEcModal = function () {
          $modalInstance.close(ec.employee);
        };


        ec.cancelEcModal = function () {
          $modalInstance.dismiss('cancel');
        };

      }
    ]);
})();
;
var profileModule = angular.module('emlogis.profile');

profileModule.controller('ProfileDetailCtrl',
  [
    '$scope',
    '$state',
    '$q',
    '$sessionStorage',
    '$filter',
    '$modal',
    'applicationContext',
    'crudDataService',
    'uiGridConstants',
    'authService',
    'profileDetailService',
    'dataService',
    function($scope, $state, $q, $sessionStorage, $filter, $modal, applicationContext, crudDataService,uiGridConstants,
             authService,profileDetailService,dataService) {

      console.log('Profile Detail controller');

      $scope.tabs[0].active = true;

      var baseUrl = applicationContext.getBaseRestUrl();
      var factory = _.clone(crudDataService);
      var profile = this;

      profile.genderOptions = ['0', '1', '2'];
      profile.employeeTypes = [ 'FullTime', 'PartTime' ];
      profile.activityTypes = [ 'Active', 'Inactive', 'Pooled' ];

      /**
       * init function
       */
      $scope.init = function() {

        profileDetailService.getDetail()
          .then(function(employee){
            updateProfileModel(employee);

            profileDetailService.getProfilePicture(employee).then(function(picture){
              updateProfilePicture(picture);
          });
        });

        dataService.getEmployeeHoursAndOvertime(profile.currentAccountInfo.employeeId).
          then(function(res) {
            $scope.settings = convertTime(fromMinutesToHours, res.data);
            $scope.options.overtimeType = defineOvertimeType();
          }, function(err) {
            applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
          });

      };

      //--------------------------------------------------------------------
      // EMLOGIS panel
      //--------------------------------------------------------------------

      //
      // Update Approvals settings

      $scope.updateEditingApprovals = function(){
        profile.isEditingApprovals = !angular.equals(profile.employee.autoApprovalsSettingDto, employeeInit.autoApprovalsSettingDto);
      };

      $scope.$watch(function () {
        if ( profile.employee ) {
          return profileDetailService.getProfileTeam();
        }
      }, function (newTeam, oldTeam) {
        if ( !newTeam || oldTeam === undefined || angular.equals(newTeam, oldTeam) ) {
          return;
        }
        profileDetailService.getDetail().then(function(employee){
          updateProfileModel(employee);
        });
      });



//      $scope.$watch("getEmployeeDetails()", function(details) {
//        if (!details) return;
//        $scope.hasPrimarySkill = _.some(details.skillInfo, { 'isPrimarySkill': true });
//      });



      function defineOvertimeType() {
        var sets = $scope.settings.overtimeDto,
          na = $scope.translations.na;
        if (sets.dailyOvertimeMins != na && sets.weeklyOvertimeMins != na)   return _.find(ot, 'id', "dailyAndWeekly");
        if (sets.dailyOvertimeMins != na && sets.biweeklyOvertimeMins != na) return _.find(ot, 'id', "dailyAndBiweekly");
        if (sets.dailyOvertimeMins != na)    return _.find(ot, 'id', "daily");
        if (sets.weeklyOvertimeMins != na)   return _.find(ot, 'id', "weekly");
        if (sets.biweeklyOvertimeMins != na) return _.find(ot, 'id', "biweekly");
        return _.find(ot, 'id', "na");
      }

      $scope.disableOvertimeInput = {
        daily: function() {
          return $scope.options.overtimeType && !_.includes(["daily", "dailyAndWeekly", "dailyAndBiweekly"], $scope.options.overtimeType.id);
        },
        weekly: function() {
          return $scope.options.overtimeType && !_.includes(["weekly", "dailyAndWeekly"], $scope.options.overtimeType.id);
        },
        biweekly: function() {
          return $scope.options.overtimeType && !_.includes(["biweekly", "dailyAndBiweekly"], $scope.options.overtimeType.id);
        }
      };

      $scope.onMaxHoursChange = function(minHoursProp, maxHoursProp) {
        $timeout(function() {
          if ($scope.settings[maxHoursProp] === $scope.translations.na) return;
          if ($scope.settings[minHoursProp] > $scope.settings[maxHoursProp]) {
            $scope.settings[minHoursProp] = $scope.settings[maxHoursProp];
          }
        });
      };

      $scope.onMinHoursChange = function(minHoursProp, maxHoursProp) {
        $timeout(function() {
          if ($scope.settings[minHoursProp] === $scope.translations.na) return;
          if ($scope.settings[minHoursProp] > $scope.settings[maxHoursProp]) {
            $scope.settings[maxHoursProp] = $scope.settings[minHoursProp];
          }
        });
      };

      function generateArrayOfNumbers(min, max, noNA) {
        var arr = noNA ? [] : [$scope.translations.na];
        for (var i = min; i <= max; i++) {
          arr.push(i);
        }
        return arr;
      }

      function fromMinutesToHours(minutes) {
        return minutes <= 0 ? $scope.translations.na : (minutes%60 === 0 ? minutes/60 : (minutes/60).toFixed(1));
      }

      function fromHoursToMinutes(hours) {
        return hours == $scope.translations.na ? -1 : hours*60;
      }

      function convertTime(convertFn, settingsObj) {
        return {
          daysPerWeek: settingsObj.daysPerWeek,
          consecutiveDays:   settingsObj.consecutiveDays || $scope.translations.na,
          minHoursPerDay:    convertFn(settingsObj.minHoursPerDay),
          maxHoursPerDay:    convertFn(settingsObj.maxHoursPerDay),
          minHoursPerWeek:   convertFn(settingsObj.minHoursPerWeek),
          maxHoursPerWeek:   convertFn(settingsObj.maxHoursPerWeek),
          primarySkillHours: convertFn(settingsObj.primarySkillHours),
          overtimeDto: {
            dailyOvertimeMins:    convertFn(settingsObj.overtimeDto.dailyOvertimeMins),
            weeklyOvertimeMins:   convertFn(settingsObj.overtimeDto.weeklyOvertimeMins),
            biweeklyOvertimeMins: convertFn(settingsObj.overtimeDto.biweeklyOvertimeMins)
          }
        };
      }

      $scope.updateSettings = function() {
        var settings = convertTime(fromHoursToMinutes, $scope.settings);
        dataService.updateEmployeeHoursAndOvertime($scope.currentAccountInfo.employeeId, settings).
          then(function(res) {
            applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', 'success', true);
            $scope.options.overtimeType = defineOvertimeType();
          }, function(err) {
            applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
          });
      };


      var updateProfileModel = function(employee){
        profile.employee = employee;
        //console.log('+++ profile.employee updated', profile.employee);
      };

      var updateProfilePicture = function(picture){
        profile.picture = picture;
        profile.isPictureDisplayed = picture.size > 0;
      };

      //
      // delete Employee picture

      profile.deletePicture = function(){
        var img = profile.picture;
        img.dto = { image: null };
        profileDetailService.uploadEmployeePicture(profile.employee, img).then(function(picture){
          updateProfilePicture(picture);
        });
      };


      //--------------------------------------------------------------------
      // Editing process
      //--------------------------------------------------------------------


      profile.startEditing = function () {
    	//employee cannot edit his own home team -comment out get team list
//        profileDetailService.getSiteTeams().then( function(data) {
//          profile.allSiteTeams = data;
//        });
        profile.employeeForEdit = angular.copy(profile.employee);
        profile.isEditing = true;
      };

      // Profile Detail
      profile.cancelEditing = function () {
        profile.isEditing = false;
      };

      //--------------------------------------------------------------------
      // Emergency modal
      //--------------------------------------------------------------------

      profile.openEmergencyContactModal = function (size) {

        var modalInstance = $modal.open({
          templateUrl:  'modules/employees/partials/employee-details/empl-details-emergency-modal.html',
          controller:   'ProfileDetailEmergencyModalCtrl as ec',
          backdrop:     'static',
          size: size,
          resolve: {
            employee: function () {
              return profile.employee;
            }
          }
        });


        modalInstance.result.then(function (employee) {
          updateProfileModel(employee);
        }, function () {
          //console.log('Modal dismissed at: ' + new Date());
        });
      };


      /**
       * Variable initialization
       */


      profile.currentAccountInfo = JSON.parse($sessionStorage.info);
      profile.isEditingApprovals = false;

      /**
       * Settings: Hours
       */

      $scope.translations = {
        min:                    $filter('translate')("employees.tabs.hours.MIN"),
        max:                    $filter('translate')("employees.tabs.hours.MAX"),
        hoursPerDay:            $filter('translate')("employees.tabs.hours.HOURS_PER_DAY"),
        hoursPerWeek:           $filter('translate')("employees.tabs.hours.HOURS_PER_WEEK"),
        daysPerWeek:            $filter('translate')("employees.tabs.hours.DAYS_PER_WEEK"),
        consecutiveDays:        $filter('translate')("employees.tabs.hours.CONSECUTIVE_DAYS"),
        primarySkillHours:      $filter('translate')("employees.tabs.hours.PRIMARY_SKILL_HOURS"),
        overtime:               $filter('translate')("employees.tabs.hours.OVERTIME"),
        dailyOvertimeStarts:    $filter('translate')("employees.tabs.hours.DAILY_OVERTIME_STARTS"),
        weeklyOvertimeStarts:   $filter('translate')("employees.tabs.hours.WEEKLY_OVERTIME_STARTS"),
        beweeklyOvertimeStarts: $filter('translate')("employees.tabs.hours.BIWEEKLY_OVERTIME_STARTS"),
        beweeklyMinHours:       $filter('translate')("employees.tabs.hours.BIWEEKLY_MIN_HOURS"),
        na:                     $filter('translate')("employees.tabs.hours.NA")
      };

      $scope.settings = {
        daysPerWeek: 0,
        consecutiveDays: 0,
        minHoursPerDay: 0,
        maxHoursPerDay: 0,
        minHoursPerWeek: 0,
        maxHoursPerWeek: 0,
        primarySkillHours: 0,
        overtimeDto: {
          dailyOvertimeMins: 0,
          weeklyOvertimeMins: 0,
          biweeklyOvertimeMins: 0
        }
      };

      $scope.options = {
        minHoursPerDay:   generateArrayOfNumbers(1, 12),
        maxHoursPerDay:   generateArrayOfNumbers(1, 24),
        minHoursPerWeek:  generateArrayOfNumbers(1, 168), // 7 days in hours
        maxHoursPerWeek:  generateArrayOfNumbers(1, 168),
        hoursPer2Weeks:   generateArrayOfNumbers(1, 336), // 14 days in hours
        daysPerWeek:      generateArrayOfNumbers(1, 7, true),
        overtimeType:     null,
        overtimeTypes: [
          { id: "daily",            name: $filter('translate')("employees.tabs.hours.DAILY") },
          { id: "weekly",           name: $filter('translate')("employees.tabs.hours.WEEKLY") },
          { id: "biweekly",         name: $filter('translate')("employees.tabs.hours.BIWEEKLY") },
          { id: "dailyAndWeekly",   name: $filter('translate')("employees.tabs.hours.DAILY_AND_WEEKLY") },
          { id: "dailyAndBiweekly", name: $filter('translate')("employees.tabs.hours.DAILY_AND_BIWEEKLY") },
          { id: "na",               name: $scope.translations.na }
        ]
      };

      $scope.hasPrimarySkill = false;
      $scope.hoursEditDisabled = true;
//      $scope.getProfile = profileDetailService.getEmployeeInit;

      var ot = $scope.options.overtimeTypes;

      // on Save button click in User Profile section
      // update Employee Details, Employee Login and Employee HomeTeam

      profile.saveEmployeeProfile = function(employeeForEdit){
        profile.updatesCounter = 0;

        // 1. Check if login was changed

        var newLogin;
        if ( profile.employee.userAccountDto ) {
          var isLoginChanged = !angular.equals(profile.employee.userAccountDto.login, employeeForEdit.userAccountDto.login);
          if ( isLoginChanged ) {
            profile.updatesCounter++;
            newLogin = { login: employeeForEdit.userAccountDto.login };
            profileDetailService.updateEmployeeAccount(employeeForEdit, newLogin).then( function(data){
              profile.updatesCounter--;
            });
          }
        } else if ( employeeForEdit.userAccountDto ) {
          newLogin = { login: employeeForEdit.userAccountDto.login };
          profile.updatesCounter++;
          profileDetailService.updateEmployeeAccount(employeeForEdit, newLogin).then( function(data){
            profile.updatesCounter--;
          });
        }


        // 2. Check if home team was changed

        if ( !angular.equals(profile.employee.homeTeam.teamId, employeeForEdit.homeTeam.teamId) ) {
          profile.updatesCounter++;

          // check if new home team is already assigned to an employee
          var teamIsAssosiated = (_.find(employeeForEdit.teamInfo, { 'teamId': employeeForEdit.homeTeam.teamId })) ? true : false;
          if (teamIsAssosiated) {
            var putDto = { isHomeTeam: true };
            profileDetailService.updateEmployeeHomeTeam(employeeForEdit, employeeForEdit.homeTeam.teamId, putDto)
              .then(function(res){
                profile.updatesCounter--;
              })
            ;

          } else {
            var assosiateDto = {
              isHomeTeam: true,
              teamId: employeeForEdit.homeTeam.teamId,
              isSchedulable: true,
              isFloating: false
            };
            profileDetailService.addHomeTeamToEmployee(employeeForEdit, employeeForEdit.homeTeam.teamId, assosiateDto)
              .then(function(res){
                profile.updatesCounter--;
              })
            ;
          }
        }


        // 3. Check if details were changed

        var prepareEmployeeDetailsDto = function(employeeObj){
          return {
            firstName: employeeObj.firstName,
            middleName: employeeObj.middleName,
            lastName: employeeObj.lastName,
            employeeIdentifier: employeeObj.employeeIdentifier,
            professionalLabel: employeeObj.professionalLabel,
            gender: employeeObj.gender,
            homePhone: employeeObj.homePhone || null,
            mobilePhone: employeeObj.mobilePhone || null,
            homeEmail: employeeObj.homeEmail || null,
            workEmail: employeeObj.workEmail || null,
            hireDate: employeeObj.hireDate,
            startDate: employeeObj.startDate,
            endDate: employeeObj.endDate,
            hourlyRate: employeeObj.hourlyRate,
            employeeType: employeeObj.employeeType,
            activityType: employeeObj.activityType
          };
        };

        var oldEmployee = prepareEmployeeDetailsDto(profile.employee);
        var newEmployee = prepareEmployeeDetailsDto(employeeForEdit);

        if ( !angular.equals(oldEmployee, newEmployee) ) {
          profile.updatesCounter++;
          profileDetailService.updateEmployee(employeeForEdit, newEmployee).then(function(res){
            profile.updatesCounter--;
            //console.log(res);
          });
        }

        // 4. Wait for all API calls to be resolved,
        // then update page options and get updated employee

        //var removeThisWatcher = $scope.$watch("profile.updatesCounter", function(newVal, oldVal) {
        //  if (newVal === 0 && oldVal === 1) {
        //    profileDetailService.getEmployeeDetails(employeeForEdit.id).then(function(employee){
        //      applicationContext.setNotificationMsgWithValues('app.SAVED_SUCCESSFULLY', 'success', true);
        //      updateProfileModel(employee);
        //      profile.isEditing = false;
        //    }, function(err) {
        //      applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
        //    });
        //    removeThisWatcher();                                           // remove this $watch
        //  }
        //});
      };

      //
      // Upload Employee picture

      profile.uploadPicture = function($event){
        var evt = $event,
          img = profile.pictureToLoad,
          reader = new FileReader();

        // If we use onloadend, we need to check the readyState.
        reader.onloadend = function(evt) {
          if (evt.target.readyState == FileReader.DONE) { // DONE == 2
            var imageBytes, commaIndex, image, dto;

            imageBytes = evt.target.result;
            commaIndex = imageBytes.indexOf(',') + 1;
            image = imageBytes.slice(commaIndex);
            img.dto = { image: image };

            profileDetailService.uploadEmployeePicture(profile.employee, img).then(function(picture){
              updateProfilePicture(picture);
            });
          }
        };
        reader.readAsDataURL(img);
      };

      //
      // when new picture is selected
      // upload Employee picture

      $scope.$watch('profile.pictureToLoad', function(newVal){
        if (newVal) {
          profile.uploadPicture();
        }
      });


    }
  ]
);
;
var profile = angular.module('emlogis.profile');

profile.controller('ProfilePasswordBreadcrumbCtrl',
  [
    '$rootScope',
    '$scope',
    '$modal',
    'applicationContext',
    'scheduleService',
    'crudDataService',
    'appFunc',
    '$q',
  function($rootScope, $scope, $modal, applicationContext, scheduleService, crudDataService, appFunc, $q) {

    console.log('Profile Password breadcrumb controller');
  }
]);

;
angular.module('emlogis.profile').controller('ProfilePasswordCtrl', ['$scope', 'authService', 'applicationContext', 'dataService',
    function($scope, authService, applicationContext, dataService) {

      $scope.tabs[2].active = true;

      $scope.passwords = {
        currentPassword: "",
        newPassword: "",
        repeatPassword: ""
      };

      $scope.passwordsMatch = function() {
        return $scope.passwords.newPassword && $scope.passwords.newPassword === $scope.passwords.repeatPassword;
      };

      $scope.changePassword = function() {
        var hashedPassword = CryptoJS.SHA256($scope.passwords.currentPassword + "." + authService.getSessionInfo().tenantId).toString();

        dataService.changePassword(hashedPassword, $scope.passwords.newPassword).
          then(function() {
            applicationContext.setNotificationMsgWithValues("Password changed", 'success', true);
          }, function(err) {
            applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
          });
      };

    }
  ]
);

;
var profile = angular.module('emlogis.profile');

profile.controller('ProfilePreferencesBreadcrumbCtrl',
  [
    '$rootScope',
    '$scope',
    '$modal',
    'applicationContext',
    'scheduleService',
    'crudDataService',
    'appFunc',
    '$q',
  function($rootScope, $scope, $modal, applicationContext, scheduleService, crudDataService, appFunc, $q) {

    console.log('Profile Preferences breadcrumb controller');
  }
]);

;
angular.module('emlogis.profile').controller('ProfilePreferencesCtrl',
  ['$scope', '$filter', 'authService', 'dataService', 'applicationContext',
    function ($scope, $filter, authService, dataService, applicationContext) {

      var userId = authService.getSessionInfo().userId;
      $scope.employeePreferences = null;
      $scope.allSystemNotifications = false;
      $scope.notificationFormats = {
        HTML: "HTML",
        PLAIN_TEXT: "PLAIN_TEXT"
      };
      $scope.emailShouldBeSpecified = $filter('translate')("nav.employeePreferences.EMAIL_SHOULD_BE_SPECIFIED");
      $scope.phoneShouldBeSpecified = $filter('translate')("nav.employeePreferences.PHONE_SHOULD_BE_SPECIFIED");
      $scope.enableNotificationsLabel = $filter('translate')("nav.employeePreferences.ENABLE_NOTIFICATIONS");

      $scope.tabs[1].active = true;

      $scope.notificationConfig = function(method) {
        if (!$scope.employeePreferences) return {};
        return _.find($scope.employeePreferences.notificationConfigs, function(p) {
          return p.method === method;
        });
      };

      $scope.hasHTMLFormat = function(method) {
        return $scope.notificationConfig(method).format === $scope.notificationFormats.HTML;
      };

      $scope.changeNotificationFormat = function(method, format) {
        $scope.notificationConfig(method).format = format;
      };

      $scope.selectAllNotifications = function() {
        if (!$scope.employeePreferences) return;
        _.forOwn($scope.employeePreferences.notificationTypes, function(value, key) {
          $scope.employeePreferences.notificationTypes[key] = $scope.allSystemNotifications;
        });
      };

      $scope.$watch("employeePreferences.notificationTypes", function(types) {
        var disabledOption = _.findKey(types, function(value) {
          return value === false;
        });
        $scope.allSystemNotifications = disabledOption === undefined;
      }, true);

      $scope.updateEmployeePreferences = function() {
        dataService.updateEmployeePreferences(userId, $scope.employeePreferences).
          then(function() {
            applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', 'success', true);
          }, function(err) {
            applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
          });
      };

      var updateScope = function() {
        if(!$scope.employeePreferences.isNotificationEnabledByManager) {
          $scope.employeePreferences.isNotificationEnabled = false;
          $scope.enableNotificationsLabel = $filter('translate')("nav.employeePreferences.NOTIFICATIONS_DISABLED_BY_MANAGER");
        }
      };

      dataService.getEmployeePreferences(userId).
        then(function(res) {
          $scope.employeePreferences = res.data;
          updateScope();
        }, function(err) {
          applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
        });
    }
  ]);



;
var profile = angular.module('emlogis.profile');

profile.controller('ProfileCtrl',
  [
    '$scope',
    '$rootScope',
    '$state',
    '$q',
    '$modal',
    'applicationContext',
    'appFunc',
    'crudDataService',
    'profileDetailService',
    'authService',
    function ($scope, $rootScope, $state, $q, $modal, applicationContext, appFunc,
              crudDataService, profileDetailService, authService) {

      console.log('Profile Controller');

      $scope.tabs = [
        {
          heading: "profile.EMPLOYEE_PROFILE",
          route: 'authenticated.profile.detail',
          active: false
        },
        {
          heading: "profile.PREFERENCES",
          route: 'authenticated.profile.preferences',
          active: false
        },
        {
          heading: "profile.CHANGE_PASSWORD",
          route: 'authenticated.profile.password',
          active: false
        }
      ];

      /**
       * Custom variable to be prevent showing save_work dialog twice
       * @type {boolean}
       */
      $scope.tabChecked = false;

      /**
       * Tabset Tab Click LInk
       * @param tab
       */
      $scope.goState = function (tab) {

        /**
         * It is tab library issue which shows confirmation dialog box twice, because active state is changed
         */
        if ($scope.tabChecked === true) {
          $scope.tabChecked = false;
          return;
        }

        /**
         * if create schedules are clicked, open with id
         */
        var param = null;
//        if (tab.route ==='authenticated.profile.detail' || tab.route ==='authenticated.schedule_builder.generation_report') {
//          var tmp = scheduleService.getShared();
//
//          if (tmp.schedule && tmp.schedule.id) {
//            param = {'id': tmp.schedule.id};
//          }
//        }

        /**
         * Profile: Tab Switch
         */
        appFunc.getSaveWorkDlg().then(function (reason) {
            var working = applicationContext.getWorking();

            if (reason === DISCARD || reason === SKIP) {
              if (working.option !== null)
                working.option.editing = false;
              $state.go(tab.route, param);
            }
            else if (reason === SAVE) {
              working.saveFunc()
                .then(function (result) {
                  $state.go(tab.route, param);
                }, function (error) {
                  console.log('Saving is failed because of error');
                  cancelTabSwitch();
                }
              );
            }
            else {
              /**
               * the last condition is discard which we don't need to care, because state will be changed
               */
              if (working.option !== null)
                working.option.editing = false;
              $state.go(tab.route, param);
            }

          },
          function (reject) {
            /**
             * Cancel Pressed, roll back the tab states
             */
            console.log('Cancel pressed');
            cancelTabSwitch();

          }
        );
      };

      /**
       * Cancel Tab Switch
       */
      function cancelTabSwitch() {
        if ($state.$current.name.indexOf('create_schedules') > -1) {
          $scope.tabs[0].active = true;
          $scope.tabs[1].active = false;
        }
        else {
          $scope.tabs[0].active = false;
          $scope.tabs[1].active = true;
        }
        $scope.tabChecked = true;
        console.log('Rollback Tab Switch');
      }

      $scope.active = function (route) {
        return $state.is(route);
      };

      $scope.$on("$stateChangeSuccess", function () {
        $scope.tabs.forEach(function (tab) {
          tab.active = $scope.active(tab.route);
        });
      });

    }
  ]
);

;
(function() {
  "use strict";

  // Service
  // Create service function

  var profileDetailService = function($http, $filter, $q, dialogs, applicationContext, appFunc, dataService){

    var eds = this,
      profile,
      profileInit,
      profileSiteTimeZone,
      abcOrder = { orderby: 'name', orderdir: 'ASC' };

    var baseUrl = applicationContext.getBaseRestUrl();

    //--------------------------------------------------------------------
    // Cached Employee Details
    //--------------------------------------------------------------------


    //
    // get User Profile Detail for current logged in user

    eds.getDetail = function(){

      return $http.get(baseUrl + 'employees/profileview', {})
        .then(function(res){
          profile = res.data;

          profile.primarySkill = findPrimarySkill(profile.skillInfo);
          profile.homeTeam = findHomeTeam(profile.teamInfo);

          profile.skillInfo = $filter('orderBy')(profile.skillInfo, 'name');
          profile.teamInfo = $filter('orderBy')(profile.teamInfo, 'name');

          profileSiteTimeZone = profile.siteInfo ? profile.siteInfo.timeZone : null;
          profile.hireDate = appFunc.convertToBrowserTimezone(profile.hireDate, profileSiteTimeZone);
          profile.startDate = appFunc.convertToBrowserTimezone(profile.startDate, profileSiteTimeZone);
          profile.endDate = appFunc.convertToBrowserTimezone(profile.endDate, profileSiteTimeZone);


          return profile;
        })
      ;
    };

    //
    // provide Employee HomeTeam

    eds.getProfileTeam = function(){
      return profile.homeTeam;
    };

    //--------------------------------------------------------------------
    // Employee Profile section
    //--------------------------------------------------------------------

    //
    // update an Employee

    eds.updateEmployee = function(employee, dto){
      // prepare dates for back-end format
      dto.hireDate = prepareDate(dto.hireDate);
      dto.startDate = prepareDate(dto.startDate);
      dto.endDate = prepareDate(dto.endDate);

      return dataService.updateEmployee(employee.id, dto).then(function(res){
        applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', '', true);
        return eds.getDetail();

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };


    //
    // delete an Employee

    eds.deleteEmployee = function(employee){
      var deferred = $q.defer();

      // Confirm deletion
      var question = $filter('translate')("rules.site_teams.DELETE_TEAM") + employee.firstName + ' ' + employee.lastName + '?';
      var dlg = dialogs.confirm('app.PLEASE_CONFIRM', question);

      dlg.result.then(function () {
        return dataService.deleteEmployee(employee.id).then(function(){
          applicationContext.setNotificationMsgWithValues('app.DELETED_SUCCESSFULLY', 'success', true);
          employeeCache.remove(employee.cacheId);                               // clear cache for this employee
          eds.getDetail().then(function(res){
            deferred.resolve(res);
          });

        }, function(err) {
          applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
        });
      });

      return deferred.promise;
    };



    // --------- Employee Account ---------


    //
    // get account info for an Employee
    // TEMP TODO is it needed?

    eds.getEmployeeAccount = function(employeeId){
      return dataService.getEmployeeAccount(employeeId).then(function(res){
        //console.log('+++ getEmployeeAccount', res);
      });
    };


    //
    // update Employee's account

    eds.updateEmployeeAccount = function(employee, dto){
      //console.log('+++ login to upd', dto);
      return dataService.updateEmployeeAccount(employee.id, dto).then(function(res){
        employeeCache.remove(employee.cacheId);                               // clear cache for this employee

        //eds.getEmployeeAccount(employee.id); // TODO: returns 200 but login is not being updated

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };



    // --------- Profile Management: Employee picture ---------


    //
    // get Profile picture

    eds.getProfilePicture = function(employee){
      return dataService.getEmployeePicture(employee.id).then(function(res){ //, { cache: pictureCache } TODO: add caching for Employee picture
        var imageData = res.data;
        if ( res.data.size > 0 ) {
          imageData.pictureCacheId = res.config.url;
          imageData.image = 'data:image/JPEG;base64,' + imageData.image;
        }
        return imageData;
      });
    };


    //
    // upload new Employee image

    eds.uploadEmployeePicture = function(employee, img){
      return dataService.uploadEmployeePicture(employee.id, img.dto).then(function(res){
        applicationContext.setNotificationMsgWithValues('app.SAVED_SUCCESSFULLY', 'success', true);
        //console.log('+++ uploadEmployeePicture', res);
        //pictureCache.remove(img.pictureCacheId); TODO add when picture is caching
        return eds.getProfilePicture(employee).then(function(picture){
          return picture;
        });
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };



    // --------- Employee Home Team ---------

    //
    // change Home Team for an Employee,
    // if this Teams is already associated to Employee

    eds.updateEmployeeHomeTeam = function(employee, teamId, dto){
      return dataService.updateEmployeeHomeTeam(employee.id, teamId, dto).then(function(res){
        if (employee.cacheId) employeeCache.remove(employee.cacheId);

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };


    //
    // change Home Team for an Employee,
    // if this Teams is not currently associated to Employee

    eds.addHomeTeamToEmployee = function(employee, teamId, dto){
      return dataService.addTeamToEmployee(employee.id, teamId, dto).then(function(res){
        employeeCache.remove(employee.cacheId);

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };



    //--------------------------------------------------------------------
    // Employee Sidebar section
    //--------------------------------------------------------------------


    // --------- Autoapprovals panel ---------

    //
    // update Autoapprovals settings for  an Employee

    eds.updateEmployeeAutoapprovals = function(employee, dto){
      return dataService.updateEmployeeAutoapprovals(employee.id, dto).then(function(res){
        applicationContext.setNotificationMsgWithValues('app.SAVED_SUCCESSFULLY', 'success', true);

        return eds.getDetail();

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };



    // --------- PTO panel ---------

    //
    // get all PTOs for an Employee

    eds.getEmployeePTO = function(employee){
      return dataService.getEmployeeCDAvailabilities(employee.id, {filter: 'isPTO=1', orderby:'startDateTime', orderdir:'DESC'}, 1, -1)
        .then(function(res){
          angular.forEach(res.data, function(pto){
            pto.startDateTime = appFunc.convertToBrowserTimezone(pto.startDateTime, profileSiteTimeZone);
          });
          //console.log('getEmployeeCDAvailabilities', res);
          return res.data;
        })
      ;
    };


    // --------- Skills panel ---------

    //
    // get all Skills for current Org

    eds.getSkills = function(){
      return dataService.getSkills(abcOrder, 1, -1, allOrgSkillsCache).then(function(res){
        //console.log('+++ getSkills', res);
        return res.data;
      });
    };


    //
    // update multiple skills for an Employee

    eds.updateEmployeeSkills = function(employee, dto){
      return dataService.updateEmployeeSkills(employee.id, dto).then(function(res){
        applicationContext.setNotificationMsgWithValues('app.SAVED_SUCCESSFULLY', 'success', true);

        return eds.getDetail();

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };



    // --------- Teams panel ---------

    //
    // get all Teams for a Site Employee belongs to TODO: check caching and dataService conflict

    eds.getSiteTeams = function(){
      return dataService.getSiteTeams(profile.siteInfo.siteId, abcOrder, 1, -1).then(function(res){
        //console.log('getSiteTeams', res);
        return res.data;
      });
    };


    //
    // update Employee teams

    eds.updateEmployeeTeams = function(employee, dto){
      return dataService.updateEmployeeTeams(employee.id, dto).then(function(res){
        applicationContext.setNotificationMsgWithValues('app.SAVED_SUCCESSFULLY', 'success', true);
        return eds.getDetail();

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };



    //--------------------------------------------------------------------
    // Employee creation
    //--------------------------------------------------------------------


    //
    // create an Employee

    eds.createEmployee = function(dto){
      return dataService.createEmployee(dto).then(function(res){
        return res;

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };


    //
    // get SitesTeamsTree

    eds.getSitesTeamsTree = function(){
      return dataService.getSitesTeamsTree({ cache: sitesTeamsTreeCache }).then(function(res) {
        return res.data;

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };

    //--------------------------------------------------------------------
    // Help methods
    //--------------------------------------------------------------------


    var findPrimarySkill = function(allEmployeeSkills){
      var primarySkill = null;
      angular.forEach(allEmployeeSkills, function(skill) {
        if (skill.isPrimarySkill){
          primarySkill = angular.copy(skill);
        }
      });
      return primarySkill;
    };


    var findHomeTeam = function(allEmployeeTeams){
      var homeTeam = null;
      angular.forEach(allEmployeeTeams, function(team) {
        if (team.isHomeTeam) {
          homeTeam = angular.copy(team);
        }
      });
      return homeTeam;
    };

    var prepareDate = function(dateFromModel){
      if (dateFromModel) {
        var newDate = new Date(dateFromModel);
        var date = appFunc.getDateWithTimezone(
            newDate.getFullYear(),
            newDate.getMonth(),
            newDate.getDate(),
            profileSiteTimeZone
        ).getTime();
        return date;
      }
      return dateFromModel;
    };

  };


  // Inject dependencies and
  // add service to the Profile module

  profileDetailService.$inject = ['$http', '$filter', '$q', 'dialogs', 'applicationContext', 'appFunc', 'dataService'];
  angular.module('emlogis.profile').service('profileDetailService', profileDetailService);

})();
;
angular.module('emlogis.reports',
  [
    'ui.bootstrap',
    'ui.router',
    'http-auth-interceptor',
    'angularLoad',
    'emlogis.commonservices',
    'emlogis.commonDirectives'])
  .config(['$stateProvider', '$urlRouterProvider', '$locationProvider', '$httpProvider', '$breadcrumbProvider',
    function ($stateProvider, $urlRouterProvider, $locationProvider, $httpProvider, $breadcrumbProvider) {

      $urlRouterProvider.when('/reports', '/reports/staffing');
      $urlRouterProvider.when('/reports/', '/reports/staffing');

      $stateProvider.state('authenticated.reports', {
        url: '/reports',
        abstract: true,
        views: {
          "content@authenticated": {
            templateUrl: "modules/reports/partials/reports.html",
            controller: 'ReportsCtrl'
          },
          "breadcrumb@authenticated": {
            templateUrl: "modules/reports/partials/reports_breadcrumb.html",
            controller: 'ReportsBreadcrumbCtrl'
          }
        },
        data: {
          permissions: function (authService) {
            return authService.isTenantType('Customer') &&
              authService.hasPermissionIn(['Demand_View','Demand_Mgmt','Shift_Mgmt','SystemConfiguration_View','SystemConfiguration_Mgmt']);
          }
        }
      })
        .state('authenticated.reports.group', {
          url: '/:groupId',
          views: {
            "reportContent@authenticated.reports": {
              templateUrl: "modules/reports/partials/reports-group.partial.html",
              controller: 'ReportsGroupCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{group}}'
          }
        })
        .state('authenticated.reports.group.details', {
          url: '/:id',
          views: {
            "birtReportContent@authenticated.reports.group": {
              templateUrl: "modules/reports/partials/reports-details.partial.html",
              controller: 'ReportsDetailsCtrl'
            }
          },
          data: {
            ncyBreadcrumbSkip: true // Never display this state in breadcrumb.
          }
        })

      ;
    }
  ]);



;
var employees = angular.module('emlogis.reports');

employees.controller('ReportsBreadcrumbCtrl', ['$scope', '$translate', 'applicationContext',
    function($scope, $translate, applicationContext) {

        // Update Module Information
        var module = applicationContext.getModule();

        // Call translate directive function. Put translated text;
        $translate('nav.REPORTS')
            .then(function (translation) {
                module.name =  translation;
            });


        module.href = '/reports';
        module.icoClass = '';
        module.disableModuleBreadcrumb = false;
        applicationContext.setModule(module);

    }
]);

;
var home = angular.module('emlogis.reports');

home.controller('ReportsDetailsCtrl',
  [
    '$scope',
    'ReportsService',
    'ReportsiHubService',
    'applicationContext',
    'authService',
    '$stateParams',
    '$filter',
    '$q',
    '$sce',
    function ($scope,
              ReportsService,
              ReportsiHubService,
              applicationContext,
              authService,
              $stateParams,
              $filter,
              $q,
              $sce) {

      var reportName = "";
      var reportNamePrefix = "/Reports/";
      var visualId = null;
      var accountInfo = {};
      $scope.reportInfo = null;
      var param = null;

      $q.when(ReportsService.reportsConfigPromise && ReportsService.loadJsapiPromise).then(function () {
        $scope.reportInfo = ReportsService.getReportInfo($stateParams.groupId, $stateParams.id);
        initReport();
      });

      function initReport() {
        reportName = $stateParams.id + ".rptdesign";
        if (!accountInfo.tenantId) {
          ReportsService.getAccountInfo().then(function (res) {
            accountInfo = res.data;
          }, function (error) {
            applicationContext.setNotificationMsgWithValues(error.data.message, 'danger', true, error.statusText);
          });
        }
        if (!$scope.reportInfo || $scope.reportInfo.ui === 0) {
          init();
        } else if ($scope.reportInfo.ui === 1) {
          initWithBirt();
        }
        ReportsService.StoredReportParameters.clear();
      }

      function init() {

        try {
          actuate.load("viewer");
          actuate.load("parameter");
          var reqOpts = new actuate.RequestOptions();
          reqOpts.setCustomParameters({
            "code": authService.getToken()
          });
          if (!actuate.isInitialized()) {
            actuate.initialize(
              ReportsiHubService.getIhubUrl(),
              reqOpts,
              null,
              null,
              getParamsInfo,
              function (err) {
                console.log(err);
              });
          } else {
            getParamsInfo();
          }
        } catch (error) {
          applicationContext.setNotificationMsgWithValues(error.message, 'danger', true, error.statusText);
        }

      }

      $scope.parameters = [];

      function removeExtention(filename) {
        return filename.replace(/\.[^/.]+$/, "");
      }

      function getParamsInfo() {
        $scope.parameterIsLoading = true;
        ReportsiHubService.items().then(function (res) {
          var items = res.data.ItemList.File;
          var report = _.find(items, function (item) {
            return removeExtention(item.Name) == removeExtention(reportName);
          });
          if (report) {
            visualId = report.Id;
            ReportsiHubService.parameters(visualId).then(function (res) {
              var params = res.data;
              renderParamsForUI(params.ParameterList.ParameterDefinition);
            }, function (error) {
              applicationContext.setNotificationMsgWithValues(error.data.error.message + ' - ' + error.data.error.description, 'danger', true);
              $scope.parameterIsLoading = false;
            });
          } else {
            applicationContext.setNotificationMsgWithValues('Report does not exist', 'danger', true);
            $scope.parameterIsLoading = false;
          }
        });
      }

      function renderParamsForUI(paramdefs) {

        $scope.parameters = paramdefs.filter(function (el) {
          return el.Name !== "restApiUrl";
        });

        angular.forEach($scope.parameters, function (val, key) {
          if (val.DataType == 'DateOnly') {
            val._type = 'Date';
          }
          if ((val.DataType == 'String' || val.DataType == 'Time') && !val.IsAdHoc) {
            val._type = 'Select';
          }
          if (val.DataType == 'String' && val.IsAdHoc) {
            val._type = 'MultiSelect';
          }
          if (val.DataType == 'Boolean') {
            val._type = 'Boolean';
          }
        });

        angular.forEach($scope.parameters, function (val, key) {

          if (val._type == 'Date') {
            val.value = new Date();
            val.dateOpened = false;
          }
          if (val.SelectNameValueList === undefined ||
            (val.SelectNameValueList !== undefined && val.SelectNameValueList.NameValuePair === undefined)) {
            val.SelectNameValueList = {NameValuePair: []};
          }

          var value = null;
          if (val.Name === 'Security') {
            value = accountInfo.tenantId + "," + accountInfo.accountId;
          }

          if (val._type === 'Date') {
            value = $filter('date')(val.value, "MM/dd/yyyy");
          }
          if (val._type === 'Boolean') {
            value = (val.DefaultValue.toLowerCase() === 'true');
          }
          val._Value = value;
        });

        $scope.fetchNext(0);

      }

      function getAllParamValues() {
        var paramValues = [];
        angular.forEach($scope.parameters, function (val, key) {
          if (val._Value !== null && val.Name !== 'ShowSkill' && val.Name !== 'ShowTeamName') {
            paramValues.push({
              Name: val.Name,
              Value: val._Value
            });
          }
        });
        return paramValues;
      }

      function getCurentParamValues(index) {
        if ($scope.parameters.length > index) {
          var paramValues = [];
          for (var i = 0; i < index; i++) {
            var item = $scope.parameters[i];
            if (item._Value !== null && item.Group && item.Group === $scope.parameters[index].Group) {
              var tmp = item._Value;
              //todo
              if (item.Name === 'siteInfo' || item.Name === 'SelectedSiteInfo') {
                tmp = {};
              }
              paramValues.push({
                Name: item.Name,
                Value: tmp
              });
            }
          }
          return paramValues;
        }
      }

      //on change event
      $scope.fetchNextFromUI = function (index) {
        var param = $scope.parameters[index];

        changeValue(param);
        if (angular.isDefined(param.Group)) {
          $scope.fetchNext(index);
        }
      };

      function changeValue(param) {
        if (param._type == 'Date') {
          param._Value = $filter('date')(param.value, "MM/dd/yyyy");
        }
        if (param._type == 'Select' && param.Name !== 'Security') {
          param._Value = param.value.Value;
        }
        if (param._type == 'MultiSelect') {
          var values = "";
          angular.forEach(param.SelectNameValueList.NameValuePair, function (val1, key1) {
            if (val1.ticked) {
              if (values !== "") {
                values += ',';
              }
              values += '\'' + val1.Value + '\'';
            }
          });
          param._Value = values;
        }
      }

      //index - index of param in $scope.parameters
      $scope.fetchNext = function (index) {

        $scope.parameterIsLoading = true;

        var param = $scope.parameters[index];

        changeValue(param);

        var next = index + 1;
        var paramNext;
        do {
          paramNext = $scope.parameters[next];
          next++;
        } while (paramNext && paramNext.IsHidden);
        next--;

        if (paramNext) {
          if ((paramNext.IsDynamicSelectionList && paramNext.Group) || paramNext._Value === null) {
            ReportsiHubService.picklist(visualId, paramNext.Name, paramNext.Group, getCurentParamValues(next))
              .then(function (res) {
                paramNext.SelectNameValueList = res.data.ParameterPickList || {};

                if (paramNext.SelectNameValueList.NameValuePair === undefined) {
                  paramNext.SelectNameValueList.NameValuePair = [];
                }
                if (paramNext._type == 'Select') {
                  if (!paramNext.DefaultValueIsNull) {
                    paramNext.value = _.find(paramNext.SelectNameValueList.NameValuePair, function (item) {
                      return item.Value == paramNext.DefaultValue;
                    });
                  } else {
                    paramNext.value = paramNext.SelectNameValueList.NameValuePair[0];
                  }
                }
                if (paramNext._type == 'MultiSelect') {
                  paramNext.selectedValues = [];

                  angular.forEach(paramNext.SelectNameValueList.NameValuePair, function (val, key) {
                    val.ticked = true;
                  });
                }
                if (paramNext.SelectNameValueList.NameValuePair.length > 0) {
                  $scope.fetchNext(next);
                } else {
                  $scope.clearNext(next);
                }
              }, function (error) {
                applicationContext.setNotificationMsgWithValues(error.data.error.message + ' - ' +
                error.data.error.description, 'danger', true);
              });
          } else {
            //todo change  paramNext._type === 'Date'
            if (paramNext.SelectNameValueList.NameValuePair.length > 0 || paramNext._type === 'Date') {
              $scope.fetchNext(next);
            } else {
              $scope.clearNext(next);
            }
          }
        } else {
          $scope.parameterIsLoading = false;
        }

      };

      $scope.clearNext = function (index) {
        var param = $scope.parameters[index];
        if (param.IsDynamicSelectionList) {
          param.SelectNameValueList.NameValuePair = [];
          param._Value = null;
        }

        if ($scope.parameters[index + 1]) {
          $scope.clearNext(index + 1);
        } else {
          $scope.parameterIsLoading = false;
        }
      };

      $scope.submitted = false;

      $scope.runReport = function ($event, valid) {
        $event.preventDefault();
        $event.stopPropagation();
        $scope.submitted = true;

        if (valid) {
          $scope.parameterIsLoading = true;
          ReportsiHubService.execute(visualId, getAllParamValues()).then(function (res) {
            $scope.parameterIsLoading = false;
            console.log(res.data);
            var viewer = new actuate.Viewer("viewer");
            //viewer.setReportName(reportName);
            //viewer.setParameterValues({"ParameterValue": paramValues});
            viewer.setReportDocument("/$$$Transient/" + res.data.ObjectId + "." + res.data.OutputFileType, res.data.connectionHandle);
            viewer.setSize(window.innerWidth - 45, 900);
            viewer.submit();
            $('#actuateViewerContainerviewer').bind('DOMMouseScroll', function (e) {
              e.stopPropagation();
            });
            $('#actuateViewerContainerviewer').bind('mousewheel', function (e) {
              e.stopPropagation();
            });
          }, function (error) {
            $scope.parameterIsLoading = false;
            applicationContext.setNotificationMsgWithValues(error.data.error.message + ' - ' +
            error.data.error.description, 'danger', true);
          });
        }

      };

      // open calendar control
      $scope.openCalendar = function ($event, sObj, propName) {
        $event.preventDefault();
        $event.stopPropagation();
        sObj[propName] = true;
      };


      //====================== display parameters UI from BIRT

      function initWithBirt() {
        actuate.load("viewer");
        actuate.load("dialog");
        actuate.load("parameter");
        var reqOpts = new actuate.RequestOptions();
        reqOpts.setCustomParameters({
          'code': authService.getToken()
        });
        if (!actuate.isInitialized()) {
          actuate.initialize(
            ReportsiHubService.getIhubUrl(),
            reqOpts,
            null,
            null,
            displayParams);
        } else {
          displayParams();
        }
      }

      function displayParams() {
        //$scope.loading = 'visible-opt';
        //document.getElementById("progress_animation_null").style.display = 'block';
        document.getElementById("run").style.display = 'none';
        param = new actuate.Parameter("parameters");
        param.setReportName(reportNamePrefix + reportName);
        param.submit(
          function () {
            document.getElementById("progress_animation_null").style.display = 'block';
            param.downloadParameters(function (paramdefs) {
              for (var i = 0; i < paramdefs.length; i++) {
                if (paramdefs[i].getName() == 'Security') {
                  paramdefs[i].setDefaultValue(accountInfo.tenantId + "," + accountInfo.accountId);
                }
                if (paramdefs[i].getName() == 'siteId' || paramdefs[i].getName() == 'teamId') {
                  paramdefs[i].setSelectNameValueList([]);
                }
              }
              updateParams(paramdefs);
            });
          }, function (error) {
            console.log(error);
          }
        );
      }

      function updateParams(paramdefs) {
        param.renderContent(paramdefs, function () {
          //document.getElementsByClassName("param-opt").style.visibility = 'visible';
          //$scope.visible = 'visible-opt';
          document.getElementById("progress_animation_null").style.display = 'none';
          //document.getElementById("parameters-container").style.display = 'block';
          document.getElementById("run").style.display = 'inline-block';
        });
      }

      $scope.processParameters = function () {
        param.downloadParameterValues(runReportWithBirt);
      };

      function runReportWithBirt(paramvalues) {
        var viewer = new actuate.Viewer("viewer");
        viewer.setReportName(reportNamePrefix + reportName);
        viewer.setParameterValues(paramvalues);
        viewer.setSize(window.innerWidth - 45, window.innerHeight - 200);
        viewer.submit();
      }


    }
  ]);

;
var home = angular.module('emlogis.reports');

home.controller('ReportsGroupCtrl', [

  '$scope',
  'ReportsService',
  'applicationContext',
  '$state',
  '$stateParams',
  '$q',
  function ($scope,
            ReportsService,
            applicationContext,
            $state,
            $stateParams,
            $q) {

    $q.when(ReportsService.reportsConfigPromise).then(function (res) {
      var tmp = ReportsService.getReportsConfig($stateParams.groupId);
      $scope.reports = tmp ? tmp.reports : null;
    });

    $scope.group = $stateParams.groupId;

    $scope.reportsModel = {current: undefined};

    $scope.changeReport = function (id) {
      $state.go('authenticated.reports.group.details', {id: id});
    };
  }
]);

;
var home = angular.module('emlogis.reports');

home.controller('ReportsCtrl', [
  '$scope',
  '$state',
  'ReportsiHubService',
  'ReportsService',
  'applicationContext',
  'angularLoad',
  function ($scope,
            $state,
            ReportsiHubService,
            ReportsService,
            applicationContext,
            angularLoad) {

    $scope.tabs = [];

    $scope.goState = function (tab) {
      $state.go.apply(this, tab.route);
    };

    $scope.active = function (route) {
      return $state.includes.apply(this, route);
    };

    $scope.$on("$stateChangeSuccess", function () {
      $scope.tabs.forEach(function (tab) {
        tab.active = $scope.active(tab.route);
      });
    });

    $scope.loadingReportsList = true;

    ReportsService.getIhubProperties().then(function (res) {
      ReportsiHubService.setIhubUrl(res.data.proxyHost, res.data.proxyIportalPort);
      ReportsService.loadJsapiPromise = angularLoad.loadScript(ReportsiHubService.getIhubUrl() + '/jsapi').then(function () {
        console.log("jsapi loaded ok");
        ReportsService.loginIntoIhub();
      }).catch(function () {
        applicationContext.setNotificationMsgWithValues('Cannot connect to IHub', 'danger', true);
        console.log("! jsapi load failed ");
        $scope.loadingReportsList = false;
      });
    }, function (err) {
      applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true, err.statusText);
    });

    loadReportsList();

    function loadReportsList() {
      ReportsService.reportsConfigPromise = ReportsService.loadReportsConfig().then(function (res) {
        ReportsService.setReportsConfig(res.data);
        $scope.loadingReportsList = false;
        var groups = res.data.groups;
        angular.forEach(groups, function (val, key) {
          var tab = {
            heading: val.heading,
            route: ['authenticated.reports.group', {groupId: val.id}]
          };
          $scope.tabs.push(tab);

        });
      });
    }


  }
]);

/*
* Directive to validadate timeframe parameters
* */
home.directive('timeframe', ['ReportsService', function (ReportsService) {
  var startTimeParamName = "StartTime";
  var endTimeParamName = "EndTime";
  var requiredTimeFormat = "h:mm:ss A";

  function storeParam(name, value, ngModel) {
    ReportsService.StoredReportParameters.put(
        name,
        {
          val: value,
          model: ngModel
        }
    );
    return ReportsService.StoredReportParameters.all();
  }

  /**
   * parse time string like to millis
   */
  function parseTime(timeStr, format) {
    var defaultTimeFormat = "hh:mm:ss";
    var momentDateTime = moment(timeStr, format || defaultTimeFormat, true);
    if (!momentDateTime.isValid()) {
      return NaN;
    }
    var dt = momentDateTime.toDate();
    return dt.getHours() * 60 * 60 * 1000 + dt.getMinutes() * 60 * 1000 + dt.getSeconds() * 1000;
  }

  function isValidTime(time) {
    return !isNaN(time);
  }

  function isValidTimeInterval(startTime, entTime) {
    return startTime && entTime && startTime <= entTime;
  }

  function validateParams(values) {
    var startTimeParam = values[startTimeParamName];
    var endTimeParam = values[endTimeParamName];

    if(!startTimeParam || !endTimeParam) {
      return;
    }

    var isValid = isValidTimeInterval(startTimeParam.val, endTimeParam.val);
    startTimeParam.model.$setValidity('timeframe', isValid);
    endTimeParam.model.$setValidity('timeframe', isValid);
  }

  return {
    require: 'ngModel',
    link: function (scope, elem, attr, ngModel) {
      var name = attr.name;
      if (name === startTimeParamName || name === endTimeParamName) {
        ngModel.$formatters.unshift(onValueChanged);
      }

      function onValueChanged(value) {
        var time = parseTime(value ? value.Value : "", requiredTimeFormat);
        if(!isValidTime(time)) {
          return;
        }
        var storedParams = storeParam(name, time, ngModel);
        validateParams(storedParams);
        return value;
      }
    }
  };
}]);

home.directive('dateInterval', ['ReportsService', function (ReportsService) {
  var startDateParamName = "StartDate";
  var endDateParamName = "EndDate";

  function storeParam(name, value, ngModel) {
    ReportsService.StoredReportParameters.put(
        name,
        {
          val: value,
          model: ngModel
        }
    );
    return ReportsService.StoredReportParameters.all();
  }

  function validateParams(values) {
    var startDate = values[startDateParamName];
    var endDate = values[endDateParamName];
    if(!startDate || !endDate) {
      return;
    }
    var isValidInterval = isValidDatesInterval(startDate.val, endDate.val);
    startDate.model.$setValidity('dateInterval', isValidInterval);
    endDate.model.$setValidity('dateInterval', isValidInterval);
  }

  function isValidDate(date) {
    return date && (date !== "Invalid Date") && (date instanceof Date);
  }

  function isValidDatesInterval(startDate, endDate) {
    return startDate <= endDate;
  }

  return {
    require: 'ngModel',
    link: function (scope, elem, attr, ngModel) {
      var name = attr.name;
      var datePattern = attr.datepickerPopup;

      if (name === startDateParamName || name === endDateParamName) {
        ngModel.$parsers.unshift(onValueChanged);
        ngModel.$formatters.unshift(onValueChanged);
      }

      function onValueChanged(value) {
        datePattern = datePattern ? datePattern : "";
        var date = moment(value, datePattern.toUpperCase()).toDate();
        if(!isValidDate(date)) {
          return value;
        }
        var storedDateParams = storeParam(name, date.getTime(), ngModel);
        validateParams(storedDateParams);
        return value;
      }
    }
  };
}]);


;
angular.module('emlogis.reports')
  .service('ReportsiHubService', ['$http', 'authService',
    'applicationContext',
    function ($http, authService, applicationContext) {

      var ihubUrl = "";

      this.setIhubUrl = function (host, port) {
        ihubUrl = "http://" + host + ":" + port + "/iportal";
      };

      this.getIhubUrl = function () {
        return ihubUrl;
      };

      var defaultFolderId;

      var baseUrl = applicationContext.getBaseRestUrl();

      function sendiHubRequest(urlPart, method, requestPayload) {

        var apiUrl = baseUrl + "ihub/" + method.toLowerCase();
        var req = {
          method: method,
          url: apiUrl,
          params: {
            authid: authService.getihubAuthId(),
            urlpart: urlPart
          }
        };
        if (method === 'GET') {
          req.params.params = requestPayload;
        } else {
          req.data = requestPayload;
        }
        return $http(req);
      }

      this.getAuthId = function () {
        return authService.getihubAuthId();
      };

      this.getFolderId = function () {
        sendiHubRequest('folders/', 'GET').then(function (res) {
          if (angular.isDefined(res.data.ItemList)) {
            var list = res.data.ItemList;
            if (angular.isDefined(list.File)) {
              angular.forEach(list.File, function (item) {
                if (item.Name === 'Reports' && item.FileType === 'Directory') {
                  defaultFolderId = item.Id;
                }
              });
            }
          }

        });
      };


      this.items = function () {
        return sendiHubRequest('folders/' + defaultFolderId + '/items', 'GET');
      };

      this.parameters = function (visualId) {
        return sendiHubRequest('visuals/' + visualId + '/parameters', 'GET');
      };

      this.picklist = function (visualId, paramName, cascadingGroupName, precedingParamValues) {
        var url = 'visuals/' + visualId + '/parameters/picklist';
        var payload = {
          paramName: paramName
        };
        if (cascadingGroupName) {
          payload.cascadingGroupName = cascadingGroupName;
        }
        if (precedingParamValues) {
          payload.precedingParamValues = JSON.stringify({ParameterValue: precedingParamValues});
        }
        return sendiHubRequest(url, 'GET', payload);
      };

      this.execute = function (visualId, paramValues) {
        return sendiHubRequest('visuals/' + visualId + '/execute', 'POST',
          $.param({
            paramValues: JSON.stringify({"ParameterValue": paramValues})
          }));
      };

    }
  ]);

;
angular.module('emlogis.reports')
  .service('ReportsService', ['$http', '$rootScope', '$q', 'applicationContext', 'authService', 'ReportsiHubService',
    function ($http, $rootScope, $q, applicationContext, authService, ReportsiHubService) {

      var reportsConfig = {};
      this.reportsConfigPromise = null;
      this.loadJsapiPromise = null;

      //For date, time intervals validation in report params
      this.StoredReportParameters = (function() {
        var storedParams = {};

        return {
          put: function(name, value) {
            storedParams[name] = value;
          },
          get: function(name) {
            return storedParams[name];
          },
          all: function() {
            return storedParams;
          },
          clear: function() {
            storedParams = {};
          }
        };
      }());

      var baseUrl = applicationContext.getBaseRestUrl();

      function sendRequest(urlPart, method, requestPayload) {
        var apiUrl = baseUrl + urlPart;
        var req = {
          method: method,
          url: apiUrl
        };
        if (method === 'POST' || method === 'PUT') {
          req.data = requestPayload;
        }
        return $http(req);
      }

      this.getAccountInfo = function () {
        return sendRequest('sessions/accountid', 'GET', null);
      };

      this.getReportsConfig = function () {

        return reportsConfig;
      };

      this.setReportsConfig = function (config) {
        reportsConfig = config;
      };

      this.getReportsConfig = function (groupId) {
        return _.find(reportsConfig.groups, function (group) {
          return group.id == groupId;
        });
      };

      this.getReportInfo = function (groupId, reportId) {
        var group = _.find(reportsConfig.groups, function (group) {
          return group.id == groupId;
        });
        if(!group) {
          return null;
        }
        var report = _.find(group.reports, function (report) {
          return report.id == reportId;
        });
        if (!report.ui && group.ui) {
          report.ui = group.ui;
        }
        if (!report.ui && !group.ui) {
          report.ui = reportsConfig.ui;
        }
        return report;
      };

      this.loadReportsConfig = function () {
        return $http.get('modules/reports/reports-config.json');
      };

      this.loginIntoIhub = function () {
        sendRequest('ihub/login', 'GET', {}).then(function (res) {
          authService.setihubSessionInfo(res.data);
          ReportsiHubService.getFolderId();
        }, function (err) {
          applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true, err.statusText);
        });
      };

      this.getIhubProperties = function () {
        return sendRequest('ihub/ihubproperties', 'GET', null);
      };
    }
  ]);
;
angular.module('emlogis.schedule_builder',
  [
    'ui.bootstrap',
    'ui.router',
    'http-auth-interceptor',
    'ui.grid.resizeColumns',
    'emlogis.commonservices',
    'emlogis.commonDirectives',
    'emlogis.commonControllers'
  ])

  .config(
  [
    '$stateProvider',
    '$urlRouterProvider',
    '$locationProvider',
    '$httpProvider',
    '$breadcrumbProvider',
    '$modalProvider',
    function ($stateProvider, $urlRouterProvider, $locationProvider,
              $httpProvider, $breadcrumbProvider, $modalProvider) {

      $urlRouterProvider.when('/schedule_builder', '/schedule_builder/create_schedules/');
      $urlRouterProvider.when('/schedule_builder/', '/schedule_builder/create_schedules/');
      // Schedule Builder Module Url
      $modalProvider.options.animation = false;
      $stateProvider.state('authenticated.schedule_builder', {
        url: '/schedule_builder',
        abstract: true,
        views: {
          "content@authenticated": {
            templateUrl: "modules/schedule_builder/partials/schedule_builder.html",
            controller: 'ScheduleBuilderCtrl'
          },
          "breadcrumb@authenticated": {
            templateUrl: "modules/schedule_builder/partials/schedule_builder_breadcrumb.html",
            controller: 'ScheduleBuilderBreadcrumbCtrl'
          }
        },
        data: {
          permissions: function (authService) {
            return authService.isTenantType('Customer') && authService.hasPermissionIn(['Demand_View', 'Demand_Mgmt']);
          }
        }
      })
        .state('authenticated.schedule_builder.create_schedules', {
          url: '/create_schedules/:id',
          views: {
            "scheduleBuilderContent@authenticated.schedule_builder": {
              templateUrl: "modules/schedule_builder/partials/schedule_builder_create_schedules.html",
              controller: 'ScheduleBuilderCreateSchedulesCtrl'
            },
            "scheduleBuilderBreadcrumb@authenticated.schedule_builder": {
              templateUrl: "modules/schedule_builder/partials/schedule_builder_create_schedules_breadcrumb.html",
              controller: "ScheduleBuilderCreateSchedulesBreadcrumbCtrl"
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"schedule_builder.CREATE_SCHEDULES" | translate}}'
          }
        })
        .state('authenticated.schedule_builder.shift_patterns', {
          url: '/shift_patterns',
          views: {
            "scheduleBuilderContent@authenticated.schedule_builder": {
              templateUrl: "modules/schedule_builder/partials/schedule_builder_shift_patterns.html",
              controller: 'ScheduleBuilderShiftPatternsCtrl'
            },
            "scheduleBuilderBreadcrumb@authenticated.schedule_builder": {
              templateUrl: "modules/schedule_builder/partials/schedule_builder_shift_patterns_breadcrumb.html",
              controller: "ScheduleBuilderShiftPatternsBreadcrumbCtrl"
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"schedule_builder.SHIFT_PATTERNS" | translate}}'
          }
        })
        .state('authenticated.schedule_builder.shift_bidding', {
          url: '/shift_bidding',
          views: {
            "scheduleBuilderContent@authenticated.schedule_builder": {
              templateUrl: "modules/schedule_builder/partials/schedule_builder_shift_bidding.html",
              controller: 'ScheduleBuilderShiftBiddingCtrl'
            },
            "scheduleBuilderBreadcrumb@authenticated.schedule_builder": {
              templateUrl: "modules/schedule_builder/partials/schedule_builder_shift_bidding_breadcrumb.html",
              controller: "ScheduleBuilderShiftBiddingBreadcrumbCtrl"
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"schedule_builder.SHIFT_BIDDING" | translate}}'
          }
        })
        .state('authenticated.schedule_builder.generation_report', {
          url: '/generation_report/:id',
          views: {
            "scheduleBuilderContent@authenticated.schedule_builder": {
              templateUrl: "modules/schedule_builder/partials/reports/schedule_builder_generation_report.html",
              controller: 'ScheduleBuilderGenerationReportCtrl'
            },
            "scheduleBuilderBreadcrumb@authenticated.schedule_builder": {
              templateUrl: "modules/schedule_builder/partials/reports/schedule_builder_generation_report_breadcrumb.html"
//                        controller: "ScheduleBuilderGenerationReportBreadcrumbCtrl"
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"reports.SCHEDULE_GENERATION_REPORTS" | translate}}'
          }
        });

    }
  ]
);



;
var scheduleBuilder = angular.module('emlogis.schedule_builder');

scheduleBuilder.controller('ScheduleBuilderBreadcrumbCtrl', ['$scope', '$translate', 'applicationContext',
    function($scope, $translate, applicationContext) {

        // Update Module Information

        var module = applicationContext.getModule();

        // Call translate directive function. Put translated text;
        $translate('nav.SCHEDULE_BUILDER')
            .then(function (translation) {
                module.name =  translation;
            });

        module.icoClass = 'glyphicon glyphicon-wrench';
        module.href = '/schedule_builder';
        module.disableModuleBreadcrumb = false;
        applicationContext.setModule(module);

    }
]);

;
var scheduleBuilder = angular.module('emlogis.schedule_builder');

scheduleBuilder.controller('ScheduleBuilderCreateSchedulesBreadcrumbCtrl',

  [
    '$rootScope',
    '$scope',
    '$modal',
    'applicationContext',
    'scheduleService',
    'crudDataService',
    'appFunc',
    '$q',
  function($rootScope, $scope, $modal, applicationContext, scheduleService, crudDataService, appFunc, $q) {

    console.log('Schedule Builder Create breadcrumb controller');

    /**
     * this variable will be used in
     */
    $scope.shared = scheduleService.getShared();
    var factory = _.clone(crudDataService);

       /**
     * New Schedule
     */
    $scope.newScheduleAction = function() {

      var schedule = {};

      appFunc.getSaveWorkDlg()
        .then(function (reason) {
          var working = applicationContext.getWorking();

          if (reason === DISCARD || reason === SKIP) {
            if (working.option !==null)
              working.option.editing = false;
            return working.restoreFunc();
          }
          else if (reason === SAVE) {
            return working.saveFunc();
          }
        },
        function (reject) {
          console.log('Cancel pressed');
          return $q.reject(reject);
        })
        .then( function (result) {

          var dlg = $modal.open({
            templateUrl: 'modules/schedule_builder/partials/schedule_builder_create_schedules_new_modal.html',
            windowClass: 'schedule-builder-breadcrumb',
            controller: function($scope, $modalInstance, schedule, applicationContext) {

              $scope.schedule = schedule;
              $scope.days = [7, 14, 21, 28];

              function firstDayOfWeekNumber(stringvalue) {
                var firstDayIntOfWeek = 0;

                if (stringvalue === 'MONDAY') {
                  firstDayIntOfWeek = 1;
                }
                else if (stringvalue === 'TUESDAY') {
                  firstDayIntOfWeek = 2;
                }
                else if (stringvalue === 'WEDNESDAY') {
                  firstDayIntOfWeek = 3;
                }
                else if (stringvalue === 'THURSDAY') {
                  firstDayIntOfWeek = 4;
                }
                else if (stringvalue === 'FRIDAY') {
                  firstDayIntOfWeek = 5;
                }
                else if (stringvalue === 'SATURDAY') {
                  firstDayIntOfWeek = 6;
                }

                return firstDayIntOfWeek;
              }

              $scope.$watch("selectedSites", function(sites) {
                if (sites) {
                  $scope.startingDay = firstDayOfWeekNumber(sites[0].firstDayOfWeek);
                }
              });

              $scope.site = null;

              // When we go to login page we have to dismiss the modal.
              $scope.$on('event:auth-loginRequired', function () {
                $modalInstance.dismiss('cancel');
              });

              // Shows start date dialog box
              $scope.showDate = function($event) {
                $event.preventDefault();
                $event.stopPropagation();

                $scope.startDateOpened = true;
              };

              /**
               * Enable only first day of the week based on site settings
               * @param date
               * @param mode
               */
              $scope.calendarDisabled = function(date, mode) {
//                return ( mode === 'day' && ( date.getDay() !== $scope.dateOptions.startingDay ));
                return false;
              };

              // CreateAction
              $scope.create = function() {

                /**
                 * Perform Validation
                 */
                if (!$scope.schedule.startDate) {
                  applicationContext.setNotificationMsgWithValues('schedule_builder.PLEASE_SPECIFY_START_DATE', '', true);
                  return;
                }

                if (!$scope.schedule.length) {
                  applicationContext.setNotificationMsgWithValues('schedule_builder.PLEASE_SPECIFY_SCHEDULE_LENGTH', '', true);
                  return;
                }
                if (!$scope.schedule.name) {
                  applicationContext.setNotificationMsgWithValues('schedule_builder.PLEASE_SPECIFY_SCHEDULE_NAME', '', true);
                  return;
                }

                /**
                 * Check the teams selection
                 * teams under different sites should not be selected
                 */

                var teams = [];

                for (var i in $scope.teams) {

                  var ele = $scope.teams[i];
                  if (ele.ticked === true) {
                    teams.push(ele);
                  }

                }

                if (teams.length <= 0) {
                  applicationContext.setNotificationMsgWithValues('schedule_builder.PLEASE_SPECIFY_SCHEDULE_TEAMS', '', true);
                  return;
                }

                /**
                 * Move startdate of schedule to site's firstdayof the week
                 */

                var firstDayIntOfWeek = firstDayOfWeekNumber($scope.site.firstDayOfWeek);

                if (firstDayIntOfWeek !== $scope.schedule.startDate.getDay()) {
                  var dateDiff = ($scope.schedule.startDate.getDay() + 7 - firstDayIntOfWeek) % 7;
                  $scope.schedule.startDate = new Date($scope.schedule.startDate.getTime() - dateDiff * 24 * 60 * 60 * 1000);
                }

                $scope.schedule.teams = teams;
                $scope.schedule.site = $scope.site;

                $modalInstance.close($scope.schedule);
              };

              // Close Modal
              $scope.close = function(){
                $modalInstance.dismiss('cancel');
              };

              /**
               * Load all sites
               */
              function loadSites() {

                return factory.getElements('sites?limit=0&orderby=name&orderdir=ASC',{})
                  .then(function(entities){

                    /**
                     * resolves sites
                     */
                    return entities.data;
                  });
              }

              /**
               * Load all teams for the site
               */
              function loadTeams(site) {
                return factory.getElements('sites/' + site.id + '/teams?limit=0&orderby=name&orderdir=ASC', {})
                  .then(function(entities) {

                    $scope.site = site;
                    /**
                     * return teams;
                     */
                    return entities.data;
                  });
              }

              $scope.loadTeamsAction = function(site) {
                loadTeams(site)
                  .then(function(teams){

                    $scope.teams = [];
                    var ticked = true;

                    /**
                     * build $scope.sites
                     */
                    for(var i in teams){
                      if (i > 0) {
                        ticked = false;
                      }
                      $scope.teams.push(
                        {id: teams[i].id, name: teams[i].name, ticked: ticked}
                      );
                    }
                  });
              };


              /**
               * Initial Loading
               */

              loadSites()
                .then(function(sites) {

                  $scope.sites = [];
                  var ticked = true;
                  /**
                   * build $scope.sites
                   */
                  for(var i in sites){
                    if (i > 0){
                      ticked = false;
                    }
                    $scope.sites.push(
                      {
                        id: sites[i].id,
                        name: sites[i].name,
                        ticked: ticked,
                        firstDayOfWeek: sites[i].firstDayOfWeek,
                        timeZone: sites[i].timeZone
                      }
                    );
                  }

                  var site = null;
                  if (sites.length >0 ) {
                    site = sites[0];
                    return loadTeams(site);
                  }

                  return null;

                })
                .then(function(teams) {

                  $scope.teams = [];
                  var ticked = true;

                  /**
                   * build $scope.sites
                   */
                  for(var i in teams){
                    if (i > 0) {
                      ticked = false;
                    }
                    $scope.teams.push(
                      {id: teams[i].id, name: teams[i].name, ticked: ticked}
                    );
                  }

                });

            },
            resolve: {
              schedule: function() {
                return schedule;
              }
            }

          });

          /**
           * Initialize Variables
           */

          dlg.result.then(function(schedule){
            /**
             * Broadcast create New Schedule Event
             */

            $rootScope.$broadcast('event:schedule-builder-new-schedule', {schedule: schedule });

          }, function(reason) {
            console.log('dismissed');
          });
        });


    };

  }
]);

;
var scheduleBuilder = angular.module('emlogis.schedule_builder');

scheduleBuilder.controller('ScheduleBuilderCreateSettingsCtrl',
  [
    '$scope',
    '$modalInstance',
    '$state',
    'applicationContext',
    'dataService',
    '$modal',
    'scheduleService',
    'authService',
    'selectedSchedule',
    'dialogs',
    function ($scope, $modalInstance, $state, applicationContext, dataService, $modal, scheduleService, authService, selectedSchedule, dialogs) {

      console.log('Schedule Builder Create Settings controller');

      $scope.schedule = angular.copy(selectedSchedule);

      $scope.selectTab = function (tabName) {
        $scope.selectedTab = tabName;
      };

      $scope.isValid = function () {
        return ($scope.schedule.state === 'Complete') && ($scope.schedule.executionStartDate > 0) && ($scope.schedule.executionEndDate > 0)
          && ($scope.schedule.executionStartDate < $scope.schedule.executionEndDate);
      };

      $scope.maxComputationTimes = [
        //{label: 'Infinite', id: 0, val: -1},
        {label: '1  min', id: 1, val: 60},
        {label: '5  mins', id: 2, val: 300},
        {label: '10 mins', id: 3, val: 600},
        {label: '15 mins', id: 4, val: 900},
        {label: '30 mins', id: 5, val: 1800}
      ];

      $scope.maximumUnimprovedSecondsSpents = [
        {label: 'Unspecified', id: 0, val: 0},
        {label: '10 secs', id: 1, val: 10},
        {label: '30 secs', id: 2, val: 30},
        {label: '1 min', id: 3, val: 60},
        {label: '1 min 30 secs', id: 4, val: 90},
        {label: '1 min 40 secs', id: 5, val: 100},
        {label: '2 mins', id: 6, val: 120},
        {label: '3 mins', id: 7, val: 180},
        {label: '5 mins 30 secs', id: 8, val: 330}
      ];

      $scope.standardOptimizationsGoals = [
        'AVOID_DAILY_OVERTIME_RULE',
        'AVOID_TWO_WEEK_OVERTIME_RULE',
        'AVOID_WEEKLY_OVERTIME_RULE'
      ];

      $scope.optimizationsType = 'standard';

      $scope.overrideOptions = ["None", "COP", "CPO", "OCP", "OPC", "PCO", "POC"];

      $scope.overrideCop = function () {
        if (!$scope.settings.overrideOptimizationPreference) {
          $scope.previousOptimizationPreferenceSetting = $scope.settings.optimizationPreferenceSetting;
          $scope.settings.optimizationPreferenceSetting = $scope.settings.siteOptimizationPreferenceSetting;
        } else {
          $scope.settings.optimizationPreferenceSetting = $scope.previousOptimizationPreferenceSetting;
        }
      };

      //filter for standard goals
      $scope.containsGoal = function (goal) {
        return _.contains($scope.standardOptimizationsGoals, goal);
      };

      $scope.isScheduleEmpty = function () {
        return _.isEmpty($scope.schedule);
      };

      var executionDuration = $scope.schedule.executionEndDate - $scope.schedule.executionStartDate;
      $scope.executionDuration = new Date(executionDuration);

      $scope.overridesData = [];

      $scope.overridesGridOptions = {
        enableColumnResizing: true,
        enableScrollbars: true,
        paginationPageSize: 25,
        paginationCurrentPage: 1,
        data: 'overridesData | filter: employeeSearchText',
        rowTemplate: defaultRowTemplate(),
        enableGridMenu: false,
        enablePaginationControls: false,
        columnDefs: [
          {
            field: 'employeeName',
            displayName: 'Employee',
            minWidth: 150,
            pinnedLeft: true,
            enableColumnMenu: false
          }, {
            field: 'MIN_HOURS_WEEK_OVERRIDE'
          }, {
            field: 'AVOID_OVERTIME'
          }, {
            field: 'TEAM_FLOAT_ON'
          }, {
            field: 'EMPLOYEE_UNAVAILABLE'
          }, {
            field: 'TIME_WINDOW_UNAVAILABLE_OVERRIDE'
          }, {
            field: 'PTO_OVERRIDE'
          }, {
            field: 'ALL_DAY_UNAVAILABLE_OVERRIDE'
          }, {
            field: 'WEEKDAY_ROTATION_OVERRIDE'
          }, {
            field: 'COUPLED_WEEKEND_OVERRIDE'
          }, {
            field: 'DAYS_OFF_AFTER_OVERRIDE'
          }, {
            field: 'DAYS_OFF_BEFORE_OVERRIDE'
          }, {
            field: 'MIN_HOURS_BETWEEN_DAYS_OVERRIDE',
            minWidth: 80
          }, {
            field: 'MIN_HOURS_DAY_OVERRIDE'
          }, {
            field: 'MAX_HOURS_DAY_OVERRIDE'
          }, {
            field: 'MAX_HOURS_WEEK_OVERRIDE'
          }, {
            field: 'MAX_DAYS_WEEK_OVERRIDE'
          }, {
            field: 'MAX_CONSECUTIVE_DAYS_OVERRIDE'
          }
        ]
      };

      angular.forEach($scope.overridesGridOptions.columnDefs, function (col, i) {
        if (col.field !== 'employeeName') {
          col.enableSorting = false;
          col.selected = true;
          if (!angular.isDefined(col.minWidth)) col.minWidth = 70;
          col.cellTemplate = cellTpl();
          col.headerCellTemplate = headerCellTemplate();
          col.enableHiding = false;
        }
      });
      $scope.overridesGridOptions.onRegisterApi = function (gridApi) {
        $scope.gridApi = gridApi;
      };

      function cellTpl() {
        return '<div> <input type="checkbox" data-ng-model="row.entity[col.field]" data-ng-change="grid.appScope.extScope.change(row.entity, col.field)"></div>';
      }

      function headerCellTemplate() {
        return "<div ng-class=\"{ 'sortable': sortable }\">" +
          "<div class=\"ui-grid-cell-contents\" col-index=\"renderIndex\" title='{{grid.appScope.extScope.getTranslateName(col.field) CUSTOM_FILTERS | translate}}' >" +
          "<span translate>{{ grid.appScope.extScope.getTranslateName(col.field) CUSTOM_FILTERS }} </span> <br> <input type=\"checkbox\" data-ng-model=\"grid.appScope.headers[col.field]\" ng-change=\"grid.appScope.extScope.changeAll(col.field)\" >" +
          "<span ng-if=\"col.enableSorting\" ui-grid-visible=\"col.sort.direction\" ng-class=\"{ 'ui-grid-icon-up-dir': col.sort.direction == asc, 'ui-grid-icon-down-dir': col.sort.direction == desc, 'ui-grid-icon-blank': !col.sort.direction }\">&nbsp;</span>" +
          "</div>" +
            //"<div class=\"ui-grid-column-menu-button\" ng-if=\"grid.options.enableColumnMenus && !col.isRowHeader  && col.colDef.enableColumnMenu !== false\" class=\"ui-grid-column-menu-button\" ng-click=\"toggleMenu($event)\">" +
            //"<i class=\"ui-grid-icon-angle-down\">&nbsp;</i>" +
            //"</div>" +
          "<div ng-if=\"filterable\" class=\"ui-grid-filter-container\" ng-repeat=\"colFilter in col.filters\">" +
          "<input type=\"text\" class=\"ui-grid-filter-input\" ng-model=\"colFilter.term\" ng-click=\"$event.stopPropagation()\" ng-attr-placeholder=\"{{colFilter.placeholder || ''}}\">" +
          "<div class=\"ui-grid-filter-button\" ng-click=\"colFilter.term = null\">" +
          "<i class=\"ui-grid-icon-cancel right\" ng-show=\"!!colFilter.term\">&nbsp;</i> <!-- use !! because angular interprets 'f' as false -->" +
          "</div>" +
          "</div>" +
          "</div>";
      }

      function defaultRowTemplate() {
        return '<div ng-repeat="col in colContainer.renderedColumns track by col.colDef.name" class="ui-grid-cell" ui-grid-cell></div>';
      }

      function initVars() {
        var maxComputationTime = $scope.settings.maxComputationTime;
        var options = $scope.maxComputationTimes;
        var i;
        for (i = 0; i < options.length; i++) {
          if (options[i].val == maxComputationTime) {
            $scope.maxComputationTime = options[i];
            break;
          }
        }

        var maximumUnimprovedSecondsSpent = $scope.settings.maximumUnimprovedSecondsSpent;
        options = $scope.maximumUnimprovedSecondsSpents;
        for (i = 0; i < options.length; i++) {
          if (options[i].val == maximumUnimprovedSecondsSpent) {
            $scope.maximumUnimprovedSecondsSpent = options[i];
            break;
          }
        }

        $scope.rules = $scope.settings.ruleWeightMultipliers;
        $scope.rulesIsEnable = angular.copy($scope.settings.ruleWeightMultipliers);
        for (i in $scope.rulesIsEnable) {
          if ($scope.rulesIsEnable[i] > 0) {
            $scope.rulesIsEnable[i] = true;
          } else {
            $scope.rulesIsEnable[i] = false;
          }
        }
        $scope.rulesBackup = {};

        $scope.disableEnableRule = function (rule) {
          if ($scope.rulesIsEnable[rule]) {
            $scope.rules[rule] = $scope.rulesBackup[rule] || 1;
          } else {
            $scope.rulesBackup[rule] = $scope.rules[rule];
            $scope.rules[rule] = 0;
          }
        };
      }

      function getSettings() {

        dataService.getScheduleSettings($scope.schedule.id)
          .then(function (settings) {
            $scope.settings = settings;

            initVars();

            $scope.employees = settings.employees;

            angular.forEach($scope.employees, function (emp) {
              emp.employeeName = emp.firstName + ' ' + emp.lastName;
              angular.forEach($scope.overridesGridOptions.columnDefs, function (opt) {
                if (opt.field !== 'employeeName') {
                  emp[opt.field] = false;
                }
              });
            });

            var opts = settings.overrideOptions;
            // values of columns top checkboxes (select/clear all)
            $scope.headers = {};
            angular.forEach(settings.overrideOptions, function (opt, key) {
              $scope.headers[key] = false;
            });
            for (var i in opts) {
              var j;
              switch (opts[i].scope) {
                case "None":
                  break;
                case "All":
                  $scope.headers[i] = true;
                  for (j = 0; j < $scope.employees.length; j++) {
                    $scope.employees[j][i] = true;
                  }
                  break;
                case "Select":
                  for (j = 0; j < $scope.employees.length; j++) {
                    if (_.contains(opts[i].employeeIds, $scope.employees[j].id)) {
                      $scope.employees[j][i] = true;
                    }

                  }
                  break;
              }
            }
            $scope.overridesGridOptions.totalItems = $scope.employees.length;
            $scope.overridesData = $scope.employees;

          }, function (err) {
            applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
          });
      }

      $scope.extScope = {
        change: function (emp, optName) {
          var option = $scope.settings.overrideOptions[optName];
          var ids = option.employeeIds;
          if (emp[optName]) {
            ids.push(
              emp.id
            );
          } else {
            if (option.scope == "All") {
              for (var j = 0; j < $scope.employees.length; j++) {
                ids.push(
                  $scope.employees[j].id
                );
              }
            }
            var index = ids.indexOf(emp.id);
            ids.splice(index, 1);
          }
          switch (ids.length) {
            case 0:
              option.scope = "None";
              $scope.headers[optName] = false;
              break;
            case $scope.employees.length:
              option.scope = "All";
              ids.length = 0;
              $scope.headers[optName] = true;
              break;
            default :
              option.scope = "Select";
              $scope.headers[optName] = false;
              break;
          }
        },

        clear: function (optName) {
          var option = $scope.settings.overrideOptions[optName];
          var ids = option.employeeIds;
          option.scope = "None";
          ids.length = 0;
          for (var j = 0; j < $scope.employees.length; j++) {
            $scope.employees[j][optName] = false;
          }
        },

        all: function (optName) {
          var option = $scope.settings.overrideOptions[optName];
          var ids = option.employeeIds;
          option.scope = "All";
          ids.length = 0;
          for (var j = 0; j < $scope.employees.length; j++) {
            $scope.employees[j][optName] = true;
          }
        },

        changeAll: function (colName) {
          if ($scope.headers[colName]) {
            this.all(colName);
          } else {
            this.clear(colName);
          }
        },
        getTranslateName: function (name) {
          return 'overrides.' + name;
        }

      };

      /**
       * Generate Shifts
       */
      $scope.generateShifts = function () {
        dataService
          .generateShifts($scope.schedule.id)
          .then(function (elt) {
            $scope.schedule = elt;   // updated view with
            getSettings();
          }, function (error) {
            //dialogs.error("Error", error.data.message, 'lg');
            console.log("=====> Error: " + error.data.message);
          });
      };

      $scope.save = function () {
        var dto = $scope.settings;
        //dto.preservePreAssignedShifts = $scope.schedule.preservePreAssignedShifts;
        //childScope is isolate scope of bootstrap tab
        var childScope = angular.element('#general-settings').scope();
        dto.maxComputationTime = childScope.maxComputationTime.val;
        dto.maximumUnimprovedSecondsSpent = childScope.maximumUnimprovedSecondsSpent.val;
        updateScheduleSettings($scope.schedule.id, dto, 'Schedule settings has been updated successfully');
      };

      $scope.reset = function () {
        var dlg = dialogs.confirm('Please Confirm','Do you really want to reset schedule settings?');
        dlg.result.then(function(btn){
          dataService
            .resetScheduleSettings($scope.schedule.id).then(function (res) {
              $scope.settings = res;
              initVars();
              $scope.close();
              $scope.loadSchedule($scope.schedule.id);
              applicationContext.setNotificationMsgWithValues('Schedule settings has been restored successfully', 'success', true);
            }, function (error) {
              $scope.close();
              applicationContext.setNotificationMsgWithValues(JSON.stringify(error.data), 'danger', true);
            });
        });

      };

      $scope.saveOverrides = function () {
        var dto = $scope.settings;
        updateScheduleSettings($scope.schedule.id, dto, 'Overrides has been updated successfully');
      };

      function updateScheduleSettings(scheduleId, updateDto, successMsg) {
        dataService
          .updateScheduleSettings(scheduleId, updateDto)
          .then(function (res) {
            $scope.close();
            $scope.loadSchedule($scope.schedule.id);
            applicationContext.setNotificationMsgWithValues(successMsg, 'success', true);
          }, function (error) {
            $scope.close();
            applicationContext.setNotificationMsgWithValues(JSON.stringify(error.data), 'danger', true);
          });
      }

      // Close Modal
      $scope.close = function () {
        //$modalInstance.dismiss('cancel');
        $modalInstance.dismiss('cancel');
      };

      $scope.hasPermission = function (perm) {
        return authService.hasPermission(perm);
      };

      getSettings();
    }
  ]
);

;
var scheduleBuilder = angular.module('emlogis.schedule_builder');

scheduleBuilder.controller('ScheduleBuilderCreateSchedulesCtrl',
  [
    '$rootScope',
    '$scope',
    '$state',
    'applicationContext',
    'appFunc',
    'crudDataService',
    'dataService',
    '$modal',
    '$q',
    '$http',
    '$timeout',
    '$translate',
    '$stateParams',
    'scheduleService',
    'sseService',
    'wsService',
    'dialogs',
    'uiGridConstants',
    function(
      $rootScope,
      $scope,
      $state,
      applicationContext,
      appFunc,
      crudDataService,
      dataService,
      $modal,
      $q,
      $http,
      $timeout,
      $translate,
      $stateParams,
      scheduleService,
      sseService,
      wsService,
      dialogs,
      uiGridConstants
      ) {

      console.log('Schedule Builder Create controller');

      $scope.tabs[0].active = true;
      angular.element('.eml-top-tabs').scope().tabChecked = true;

      var baseUrl = applicationContext.getBaseRestUrl();
      var factory = _.clone(crudDataService);

      $scope.option = {startDate: '', length: '', name: '', editing: false, calendar: [],
        teamsForFilter: [], teamsForSite: []
      };

      $scope.originOption = {startDate: '', length: '', name: '', editing: false, calendar: [],
        teamsForFilter: [], teamsForSite: []
      };

      $scope.daysInWeek = ['calendar.SUNDAY', 'calendar.MONDAY', 'calendar.TUESDAY', 'calendar.WEDNESDAY',
        'calendar.THURSDAY', 'calendar.FRIDAY', 'calendar.SATURDAY'];
      // days
      $scope.days = [7, 14, 21, 28];
      $scope.schedule = null;
      $scope.originSchedule = {};

      $scope.downloadEngineRequest = function() {
        $http.get('../emlogis/rest/schedules/' + $scope.schedule.id + '/engine/assigmnentrequest').
          then(function(data) {
            angular.element('<a/>').attr({
              href: 'data:attachment/json;charset=utf-8,' + encodeURI(JSON.stringify(data)),
              target: '_blank',
              download: 'engineRequest.json'
            })[0].click();
          },
          function(err) {
            applicationContext.setNotificationMsgWithValues('Failed to download engine request file: ' + err.data.message, 'danger', true);
          });
      };

      $scope.downloadEngineResponse = function() {
        $http.get('../emlogis/rest/schedules/' + $scope.schedule.id + '/engine/assigmnentresponse').
          then(function(data) {
            angular.element('<a/>').attr({
              href: 'data:attachment/json;charset=utf-8,' + encodeURI(JSON.stringify(data)),
              target: '_blank',
              download: 'engineRespomse.json'
            })[0].click();
          },
          function(err) {
            applicationContext.setNotificationMsgWithValues('Failed to download engine response file: ' + err.data.message, 'danger', true);
          });
      };

      /**
       * Schedule Generating Variable
       * @type {{}}
       */
      $scope.generation = {};

      /**
       * Variables
       * 1. Shared.newScheduleOptionList: Used to create New Schedule
       * 3. $scope.availableShiftPatterns: shiftPatterns for the Site which can be used add shift pattern
       * 4. $scope.schedule: Schedule in main section
       * 5. $scope.site: The site which Schedule belongs
       * 6. $scope.option.teams: The teams which Schedule belongs
       * 7. $scope.schedule.patternElts: patternElts associated with the Schedule
       * 8. $scope.option.teamsForSite: The teams under site of schedule
       * 9. $scope.option.teamsForFilter: It will be initial copy of $scope.teams
       * 10. $scope.originSchedule: Original Schedule, can be used in restore
       */

      /**
       * Init Site / Team hierarchy
       */
      function initSiteTeamCollection() {
        //        loadSites().
        //          then(loadTeams).
        //          then(function(result) {
        //
        //            /**
        //             * We are safe to assign sites,teams to scope variable
        //             */
        //            $scope.sites = result.sites;
        //            $scope.teams = result.teams;
        //
        //            /**
        //             * Build site/teams relationship
        //             */
        //
        //          });


      }



      /**
       * it returns promise object of sites
       */
      function loadSites() {

        var deferred = $q.defer();

        factory.getElements("sites?limit=0&orderby=name&orderdir=ASC",{})
          .then(function (entities) {

            /**
             * resolves sites
             */
            deferred.resolve(entities.data);
          });

        return deferred.promise;
      }

      /**
       * Load all teams
       */
      function loadTeams(sites) {

        var deferred = $q.defer();

        factory.getElements('teams?limit=0&orderby=updated&orderdir=ASC', {})
          .then(function (entities) {

            /**
             * resolves teams
             */
            deferred.resolve({sites: sites, teams: entities.data});
          });
      }

      /**
       * accept list of shift patterns in create schedules module
       * generate shift pattern list to be used in quick pane
       */
      function buildShiftPatternsTree(shiftPatterns) {

        /**
         *
         * @type {Array}
         * it will contain site objects
         */
        $scope.shiftPatternsTree = [];

        angular.forEach($scope.treeMetaData, function (site) {

          /**
           * Insert New Site Node
           */
          $scope.shiftPatternsTree.push(site);
          site.teams = [];

          angular.forEach(site.children, function (team) {

            /**
             * Insert New Team Node
             */

            site.teams.push(team);
            team.skills = [];
            angular.forEach(team.children, function (skill) {

              /**
               * Insert New Skill Node
               */

              team.skills.push(skill);

              /**
               * Get Shift Patterns for general day
               */
              var generalPatterns = findShiftPatterns(shiftPatterns, site, team, skill, GENERAL);
              skill.generalPatterns = generalPatterns;

              /**
               * Load specific date patterns and organize by specific date
               */
              var specificPatterns = findShiftPatterns(shiftPatterns, site, team, skill, SPECIFIC);
              skill.specificPatterns = organizeSpecificPatterns(specificPatterns);

            });
          });


        });


      }

      /**
       * load Overall Structure of sites/teams/skills
       */
      function loadSiteTeamSkills() {

        var deferred = $q.defer();

        factory.getElements('sites/siteteamskills', {})
          .then(function (entities) {

            /**
             * resolve objects
             */
            deferred.resolve(entities.data);


          });

        return deferred.promise;
      }

      /**
       * call Api to retrieve teams which are associated with Schedule
       * @param scheduleId
       */
      function loadScheduleTeams(scheduleId) {
        var deferred = $q.defer();

        // No query parameters, it will show all shift patterns

        factory.getElements('schedules/' + scheduleId + '/teams?limit=0&orderby=name&orderdir=ASC', {})
          .then(function (entities) {

            deferred.resolve(entities.data);

          });

        return deferred.promise;
      }

      /**
       * call Api to retrieve shiftPatterns which are associated with Schedule
       * @param scheduleId
       */
      function loadSchedulePatternElts(scheduleId) {


        // No query parameters, it will show all shift patterns

        return factory.getElements('schedules/' + scheduleId + '/shiftpatterns?limit=0&orderby=name&orderdir=ASC', {});

      }

      /**
       * Load Shift Patterns, it will be used when user clicks 'Add Shift pattern'
       * Each shift pattern contains no shiftReqDto
       */
      function loadShiftPatterns() {


        // No query parameters, it will show all shift patterns
        return factory.getElements('shiftpatterns/list?limit=0&orderby=name&orderdir=ASC&filter=skill.isActive=true', {});
      }


      // Shows start date dialog box
      $scope.showDate = function ($event) {
        $event.preventDefault();
        $event.stopPropagation();

        $scope.startDateOpened = true;
      };


      // Load sites and teams into dropdown list
      // $scope.loadSites();
      // $scope.loadTeams();

      /**
       * This function will open settings dialog box
       */
      $scope.openSettings = function () {
        //Show Modal with settings for schedule, shift generation
        $modal.open({
          templateUrl: 'modules/schedule_builder/partials/schedule_builder_create_schedules_settings.html',
          controller: 'ScheduleBuilderCreateSettingsCtrl',
          windowClass: 'schedule-builder-create-settings',
          scope: $scope,
          resolve: {
            selectedSchedule: function() {
              return $scope.schedule;
            }
          }
        });
      };

      $scope.openOverrides = function () {
        $modal.open({
          templateUrl: 'modules/common/partials/schedule-settings-overrides.html',
          controller: 'ScheduleBuilderCreateSettingsCtrl',
          windowClass: 'overrides-modal',
          resolve: {
            selectedSchedule: function() {
              return $scope.schedule;
            }
          }
        });
      };

      $scope.$on('event:schedule-builder-new-schedule', function (event, args) {

        var schedule = args.schedule;
        var newScheduleId = null;
        newSchedule(schedule)
          .then(function (result) {

            applicationContext.setNotificationMsgWithValues(result.name + ' build', '', true);
            console.log("Schedule Saved : " + result.id);
            newScheduleId = result.id;
            /**
             * Load Schedule
             */
            return $scope.loadSchedule(newScheduleId);

          }, function (error) {
            applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
          })
        ;
      });

      /**
       * create new empty schedule
       * @param schedule
       */
      function newSchedule(schedule) {
        /**
         * Create New Schedule
         */
        /**
         * Save date type values site's timezone
         */

        var startDate = appFunc.getDateWithTimezone(
          schedule.startDate.getFullYear(),
          schedule.startDate.getMonth(),
          schedule.startDate.getDate(),
          schedule.site.timeZone
        );

//        var startDate = new Date(schedule.startDate);

        var dto = {
          startDate: startDate.getTime(),
          teamIds: [],
          scheduleType: 'ShiftPatternBased', // Constant
          scheduleLengthInDays: schedule.length,
          updateDto: {
            description: '',
            name: schedule.name
          }
        };

        for (var i in schedule.teams) {
          var team = schedule.teams[i];
          dto.teamIds.push(team.id);
        }

        return factory.createElement('schedules', dto);

      }

      /**
       * update schedule
       * name: contains schedule name / startDate, it can be used directly from save & save_as
       *
       * id: schedule id
       * @param schedule
       */
      function updateSchedule(id, option) {

        /**
         * Update Schedule & with shift patterns
         */

        /**
         * Save date type values site's timezone
         */

        var startDate = appFunc.getDateWithTimezone(
          option.startDate.getFullYear(),
          option.startDate.getMonth(),
          option.startDate.getDate(),
          $scope.site.timeZone
        );

        var dto = {
          scheduleUpdateDto: {},
          schedulePatternDtos: [],
          teamIds: []
        };

        for (var i in $scope.schedule.patternElts) {
          var patternElt = $scope.schedule.patternElts[i];
          dto.schedulePatternDtos.push({
              patternId: patternElt.patternId,
              cdDate: patternElt.cdDate,
              dayOffset: patternElt.dayOffset
            }
          );
        }

        dto.scheduleUpdateDto.name = option.name;
        dto.scheduleUpdateDto.startDate = startDate.getTime();
        dto.scheduleUpdateDto.scheduleLengthInDays = option.length;


        for (i in $scope.option.teams) {
          dto.teamIds.push($scope.option.teams[i].id);
        }

        return factory.updateElement('schedules', id + '/ops/fullupdate', dto);

      }

      /**
       * update Schedule Teams
       */
      function updateScheduleTeams() {
        /**
         * Update Schedule & with shift patterns
         */
        var teamsStr = $scope.option.teams.map(function (team) {
          return team.id;
        }).join(",");

        return $http.post(baseUrl + 'schedules/' + $scope.schedule.id + '/ops/setteams', teamsStr);
      }

      /**
       * Save Action from the main screen save button : create schedules
       */
      $scope.saveAction = function () {


        /**
         * Update Schedule & Save Patterns
         */
        return updateSchedule($scope.schedule.id, $scope.option)
          .then(function (result) {
            applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', 'success', true, result.name);
            //Load again
            $scope.option.editing = false;
            return $scope.loadSchedule(result.id);
          },
          function (error) {

            applicationContext.setNotificationMsgWithValues(error.data.message, 'danger', true, error.statusText);

            var deferred = $q.defer();
            deferred.reject(error);
            return deferred.promise;
          }
        );

      };

      $scope.deleteAction = function () {

        if (!$scope.schedule) {
          applicationContext.setNotificationMsgWithValues('schedule_builder.PLEASE_CREATE_ONE_SCHEDULE', '', true);
          return;
        }

        if ($scope.schedule.id) {

          return factory.deleteElement('schedules', $scope.schedule.id)
            .then(function (result) {

              applicationContext.setNotificationMsgWithValues('app.DELETED_SUCCESSFULLY', '', true);
              /**
               * Initialize Calendar, loadSchedules again
               */
              $scope.schedule = null;
              $scope.originSchedule = null;

              $scope.selectedTeamsForFilter.length = 0;

              $scope.option = {editing: false};
              $scope.originOption = {editing: false};
              $scope.option.teams = [];
              $scope.option.teamsForFilter = angular.copy($scope.option.teams);
//              loadSchedules()
//                .then(function (result) {
//                  $scope.schedules = result;
//
//                });


            }, function (error) {
              console.log(error);
              applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
            });
        }

      };

      //      /**
      //       * Save existing $scope.schedule.patternElts
      //       * @param teams
      //       */
      //      function saveSchedulePatternElts() {
      //        /**
      //         * Save Schedule
      //         */
      //        var deferred = $q.defer();
      //        var startDate = new Date($scope.option.startDate);
      //
      //        var dto = [];
      //        for (var i in $scope.schedule.patternElts) {
      //          var patternElt = $scope.schedule.patternElts[i];
      //          dto.push({
      //              patternId: patternElt.patternId,
      //              cdDate: patternElt.cdDate
      //            }
      //          );
      //        }
      //
      //        return factory.updateElement('schedules', $scope.schedule.id + '/shiftpatterns',dto)
      //          .then(function (result){
      //            deferred.resolve(result);
      //          }, function (error) {
      //            deferred.reject(error);
      //          });
      //
      //      }

      //      /**
      //       * Handle several process of loading Schedule
      //       * @param schedule
      //       */
      //
      //      function handleLoadingSchedule(schedule) {
      //
      //      }

      function getTimeDiff(start, end) {
        var diff = {m: 0, s: 0};
        if (start === '-' || end === '-') {
          return diff;
        }
        if (start <= 0 || end <=0 || start > end) {
          return diff;
        }

        var d = parseInt((end-start) / 1000);

        diff.m = parseInt(d/60);
        diff.s = parseInt(d % 60);

        return diff;
      }

      /**
       * create schedule module
       * Load Schedule into main screen
       * @param schedule: schedule
       */
      $scope.loadSchedule = function (scheduleId) {
        return $http.get(baseUrl + 'schedules/' + scheduleId, {})
          .then(function (result) {

            $scope.option.editing = false;
            $scope.schedule = result.data;

            /**
             * Add a few more properties to schedule
             */

            $scope.schedule.totalExeTime = getTimeDiff($scope.schedule.executionStartDate, $scope.schedule.executionEndDate);


            var now = new Date();

            // not using timezone conversion because it is getting the differences
            $scope.generation.elapsedTime = getTimeDiff($scope.schedule.executionStartDate, now.getTime());

            /**
             * Share $scope.schedule with settings
             */
            var tmp = scheduleService.getShared();
            tmp.schedule = $scope.schedule;

            scheduleService.setShared(tmp);

            $scope.generation.display = true;

            $scope.originSchedule = angular.copy($scope.schedule);

            $scope.$emit('event:loadSchedule');

            return result.data;

          })
          .then(function (schedule) { //Load associated teams

            return loadScheduleTeams(schedule.id)
              .then(function (teams) {

                $scope.option.teams = [];

                /**
                 * build $scope.teams
                 */
                for (var i in teams) {

                  $scope.option.teams.push(
                    {id: teams[i].id, name: teams[i].name, ticked: true, active: teams[i].active}
                  );
                }

                $scope.option.teamsForFilter = angular.copy($scope.option.teams);


              });
          })
          .then(function () {
            /**
             *  Load teamsForSite of the schedule. iterate tree structure of shared
             *  Assume schedule has at least one team
             */


            var destTeam = $scope.option.teams[0];
            $scope.option.teamsForSite = [];

            var shared = scheduleService.getShared();

            for (var i in shared.sites) {
              var site = shared.sites[i];

              for (var j in site.children) {
                var team = site.children[j];
                if (typeof destTeam !== 'undefined' && destTeam.id === team.id) {


                  $scope.option.teamsForSite = [];
                  /**
                   * build $scope.teams
                   */
                  for (var k in site.children) {

                    for (var ind=0; ind < $scope.option.teamsForSite.length; ind++) {
                      if ($scope.option.teamsForSite[ind].name > site.children[k].name) {
                        break;
                      }
                    }

                    $scope.option.teamsForSite.splice(ind,0,{
                      id: site.children[k].id, name: site.children[k].name, ticked: true
                    });

                  }

                  return site;

                }
              }
            }

//            return site;

          })
          .then(function (site) { // Load Site Info

            // It will load Site detail object

            return $http.get(applicationContext.getBaseRestUrl() + 'sites/' + site.id, {})
              .then(function (result) {

                $scope.site = result.data;
                $scope.schedule.site = $scope.site;

                /**
                 * convert startDate to browser's time stack
                 */
                  $scope.schedule.startDate = appFunc.convertToBrowserTimezone($scope.schedule.startDate, $scope.site.timeZone);

                var daysOfWeek = ['SUNDAY', 'MONDAY', 'TUESDAY', 'WEDNESDAY', 'THURSDAY', 'FRIDAY', 'SATURDAY'];

                for (var i in daysOfWeek) {
                  if (daysOfWeek[i] === $scope.site.firstDayOfWeek) {
                    break;
                  }
                }

                /**
                 * Rebuild calendar headers
                 */
                $scope.daysInWeek = [];
                $scope.site.firstDayIntOfWeek = parseInt(i);
                for (i = 0; i < 7; i++) {
                  $scope.daysInWeek.push('calendar.' + daysOfWeek[(i + $scope.site.firstDayIntOfWeek) % 7]);
                }
              });

          })
          .then(function () { //Load associated shift patterns

            return loadSchedulePatternElts($scope.schedule.id);

          })
          .then(function (result) {

            $scope.schedule.patternElts = result.data;
            $scope.originSchedule.patternElts = angular.copy($scope.schedule.patternElts);

            /**
             * LoadShiftPatterns using /shiftpatterns/list and filter by siteId
             */
            return loadShiftPatterns()
              .then(function (result) {
                $scope.allShiftPatterns = result.data;
                updateAvailableShiftPatterns($scope.allShiftPatterns);
                // Check digest is in the progress

                //              $timeout(function() {
                //
                //                angular.element('#startDate').scope().$apply();
                //              }, 500);

                /**
                 * Update Main Section
                 */
                $scope.option.name = $scope.schedule.name;
                $scope.option.startDate = new Date($scope.schedule.startDate);

                var lenInWeek = Math.ceil($scope.schedule.scheduleLengthInDays / 7);

                $scope.option.length = $scope.days[lenInWeek - 1];

                $scope.originOption = angular.copy($scope.option);

                $scope.updateScheduleCalendar();

              });

          });

      };

      function updateAvailableShiftPatterns(allShiftPatterns) {
        allShiftPatterns = angular.copy(allShiftPatterns);
        $scope.availableShiftPatterns = [];
        // set proper key & values;
        angular.forEach(allShiftPatterns, function (shiftPattern, key) {
          if (checkTeamExistsForShiftPattern(shiftPattern)) {
            shiftPattern.id = shiftPattern.shiftPatternId;
            shiftPattern.name = shiftPattern.shiftPatternName;
            delete shiftPattern.shiftPatternId;
            delete shiftPattern.shiftPatternName;
//                    $scope.availableShiftPatterns.push(shiftPattern);
            /**
             * Add shift patterns based on name sort
             */
            for (var i=0; i<$scope.availableShiftPatterns.length; i++) {
              if ($scope.availableShiftPatterns[i].name > shiftPattern.name) {
                break;
              }
            }
            $scope.availableShiftPatterns.splice(i,0,shiftPattern);
          }
        });
      }

      /**
       * checks whether this teamId belongs to $scope.teamsForSite or not
       * @param teamId
       */
      function checkTeamExistsForShiftPattern(shiftPattern) {

        for (var i in $scope.option.teamsForFilter) {
          var ele = $scope.option.teamsForFilter[i];
          if (ele.ticked === true && ele.id === shiftPattern.teamId) {
            return true;
          }
        }

        return false;
      }

      /**
       * check the condition when clicking add shift pattern
       * @param day
       * @param shiftPattern
       */
      $scope.isValidAvailableShiftPatternForDate = function (date, shiftPattern) {

        var generalDays = ['SUNDAY', 'MONDAY', 'TUESDAY', 'WEDNESDAY', 'THURSDAY', 'FRIDAY', 'SATURDAY'];

        if (checkTeamExistsForShiftPattern(shiftPattern) === false) {
          return false;
        }

        if (shiftPattern.shiftPatternCdDate !== null && shiftPattern.shiftPatternCdDate > 0) {

          var specificDate = new Date(shiftPattern.shiftPatternCdDate);
          if (specificDate.getYear() === date.getYear() && specificDate.getMonth() === date.getMonth() && specificDate.getDate() === date.getDate()) {
            return true;
          }
          else {
            return false;
          }
        }
        else {
          var generalDay = date.getDay();
          if (generalDays[generalDay] === shiftPattern.shiftPatternDayOfWeek) {
            /**
             * Check it is already included or not
             */
            if ($scope.schedule.patternElts) {
              for (var i=0; i < $scope.schedule.patternElts.length; i++) {
                var patternElt = $scope.schedule.patternElts[i];
                if (patternElt.patternId === shiftPattern.id) {

                  /**
                   * Checks the date as well
                   * @type {number}
                   */
                  var timeDiff = date.getTime() - $scope.option.startDate;
                  var diffDays = Math.ceil(timeDiff / (1000 * 3600 * 24));

                  if (diffDays == patternElt.dayOffset) {
                    return false;
                  }
                }
              }
            }

            return true;
          }
          else {
            return false;
          }
        }
        return false;
      };

      /**
       * check the condition when clicking add shift pattern
       * @param day
       * @param shiftPattern
       */
      $scope.isEmptyValidAvailableShiftPatternForDate = function (date) {

        for (var i in $scope.availableShiftPatterns) {
          var ele = $scope.availableShiftPatterns[i];
          if ($scope.isValidAvailableShiftPatternForDate(date, ele) === true) {
            return false;
          }

        }
        return true;

      };

      /**
       * Check teamsForSite belongs to teams
       * @param team
       * @returns {boolean}
       */
      $scope.isNotContainedInTeams = function (team) {
        for (var i in $scope.option.teams) {
          var ele = $scope.option.teams[i];
          if (ele.id === team.id) {
            return false;
          }
        }

        return true;
      };

      /**
       * Add team to teams
       * @param team
       */
      $scope.addScheduleTeam = function (team) {
        $scope.option.teams.push(team);
        team.ticked = true;
        $scope.option.teamsForFilter.push(team);
        $scope.delayedUpdateShiftPatterns();
        updateAvailableShiftPatterns($scope.allShiftPatterns);
        //$scope.dropDown.isopen = !$scope.dropDown.isopen;
        $scope.updateEditing();
      };

      /**
       * remove team from schedule.teams
       * @param team
       */
      $scope.removeScheduleTeam = function (team) {
        if ($scope.option.teams.length <= 1) {
          applicationContext.setNotificationMsgWithValues('schedule_builder.SCHEDULE_SHOULD_HAVE_AT_LEAST_ONE_TEAM', '', true);
          return;
        }
        var dlg = dialogs.confirm('app.PLEASE_CONFIRM', 'schedule_builder.TEAMS_WILL_BE_REMOVED_WILL_YOU_CONTINUE?');

        dlg.result.then(function (btn) {
          removeFromTeams($scope.option.teams, team);
          removeFromTeams($scope.option.teamsForFilter, team);
          $scope.delayedUpdateShiftPatterns();
          updateAvailableShiftPatterns($scope.allShiftPatterns);
          //$scope.removeSchedulePatternEltOfTeam(team);
          $scope.updateEditing();
          }, function (btn) {
          /**
           * Rollback origin option
           */
          }
        );
      };

      function removeFromTeams(teams, team) {
        if(!teams || !team){
          return;
        }
        for(var i = 0; i < teams.length; i++) {
          if(teams[i].id && teams[i].id == team.id) {
            teams.splice(i, 1);
            return;
          }
        }
      }

      /**
       * remove patternElt from schedule.patternElts
       * @param patternElt
       */
      $scope.removeSchedulePatternElt = function (patternElt) {

        var i = $scope.schedule.patternElts.indexOf(patternElt);
        if (i != -1) {
          $scope.schedule.patternElts.splice(i, 1);
        }

      };

      // remove the shift patterns according to option.teamsForFilter option
      $scope.delayedUpdateShiftPatterns = function() {

        $timeout(
          function() {

            for (var j = $scope.schedule.patternElts.length-1; j >= 0; j--)  {
              var patternElt = $scope.schedule.patternElts[j];

              if (typeof patternElt === "undefined") {
                return;
              }
              var existInFilterTeam = false;

              for (var i in $scope.option.teamsForFilter) {
                var team = $scope.option.teamsForFilter[i];

                if (team.ticked === true && team.name === patternElt.patternTeamName) {
                  existInFilterTeam = true;
                  break;
                }
              }

              if (existInFilterTeam === false) {
                $scope.schedule.patternElts.splice(j, 1);
              }
            }

          },
          1000
        );
      };

      //remove the schedule patterns which belongs to specfic team
      $scope.removeSchedulePatternEltOfTeam = function(team) {
        _.each($scope.schedule.patternElts, function(patternElt) {
          if (team.name === patternElt.patternTeamName) {
            var i = $scope.schedule.patternElts.indexOf(patternElt);
            if (i != -1) {
              $scope.schedule.patternElts.splice(i, 1);
            }
          }
        });
      };

      /**
       *
       * @param date
       * @param patternElt
       * @returns {boolean}
       */
      $scope.isValidScheduleShiftPatternForDate = function (date, patternElt) {

        var generalDays = ['SUNDAY', 'MONDAY', 'TUESDAY', 'WEDNESDAY', 'THURSDAY', 'FRIDAY', 'SATURDAY'];

        /**
         * Check cdDate is matching with PatternElt
         */

        /**
         * Check patternElt is belonging to teamsForFilter
         */
        var existInFilterTeam = false;

        for (var i in $scope.option.teamsForFilter) {
          var team = $scope.option.teamsForFilter[i];

          if (team.ticked === true && team.name === patternElt.patternTeamName) {
            existInFilterTeam = true;
            break;
          }
        }

        if (existInFilterTeam === false) {
          return false;
        }

        for (i = $scope.option.teamsForFilter; i >= 0; i--) {
          var ele = $scope.schedule.patternElts[i];
          if (ele.cdDate <= 0) { //This is dayOffset -based Pattern
            if (ele.dayOffset >= $scope.option.length) {
              $scope.schedule.patternElts.splice(i, 1);
            }
          }
        }

        if (patternElt.cdDate > 0) { //Calendar Specific Date

          var cdDate = new Date(patternElt.cdDate);
          if (cdDate.getYear() === date.getYear() && cdDate.getMonth() === date.getMonth() || cdDate.getDate() === date.getDate()) {
            return true;
          }
          else {
            return false;
          }
        }
        else {
          var timeDiff = date.getTime() - $scope.option.startDate;
          var diffDays = Math.ceil(timeDiff / (1000 * 3600 * 24));
          if (diffDays == patternElt.dayOffset) {
            return true;
          }
          else {
            return false;
          }
        }

        //        if (patternElt.patternCdDate !==null) {
        //
        //          var specificDate = new Date(patternElt.patternCdDate);
        //          if (specificDate.getYear() === date.getYear() && specificDate.getMonth() === date.getMonth() && specificDate.getDate() === date.getDate()) {
        //            return true;
        //          }
        //          else {
        //            return false;
        //          }
        //        }
        //        else {
        //          var generalDay = date.getDay();
        //          if (generalDays[generalDay] === patternElt.patternDayOfWeek) {
        //            return true;
        //          }
        //          else {
        //            return false;
        //          }
        //        }
        return false;
      };

      /**
       * Convert shiftpattern to patternElt and add to schedule.patternElts with updated attributes
       * @param date
       * @param shiftPattern
       */
      $scope.addShiftPattern = function (date, shiftPattern) {

        /**
         * create patternElt Obj
         */

        var patternElt = {};
        patternElt.cdDate = 0; //Calendar independent

        var timeDiff = date.getTime() - $scope.option.startDate.getTime(); //StartDate is integer value
        var diffDays = Math.ceil(timeDiff / (1000 * 3600 * 24));

        patternElt.dayOffset = diffDays;
        patternElt.patternName = shiftPattern.name;
        patternElt.patternId = shiftPattern.id;
        patternElt.patternCdDate = shiftPattern.shiftPatternCdDate;
        patternElt.patternDayOfWeek = shiftPattern.shiftPatternDayOfWeek;
        patternElt.patternTeamName = shiftPattern.teamName;

        for (var ind=0; ind < $scope.schedule.patternElts.length; ind++) {
          if ($scope.schedule.patternElts[ind].patternName > patternElt.patternName) {
            break;
          }
        }

        $scope.schedule.patternElts.splice(ind,0,patternElt);

//        $scope.schedule.patternElts.push(patternElt);

      };

      $scope.updateOption = function () {

      };

      /**
       * Enable only first day of the week based on site settings
       * @param date
       * @param mode
       */
      $scope.calendarDisabled = function (date, mode) {

        var daysOfWeek = ['SUNDAY', 'MONDAY', 'TUESDAY', 'WEDNESDAY', 'THURSDAY', 'FRIDAY', 'SATURDAY'];
        if (!$scope.site)
          return false;

        return ( mode === 'day' && ( daysOfWeek[date.getDay()] !== $scope.site.firstDayOfWeek ));
      };

      /**
       * Build main screen calendar
       * @param totalWeek
       * @param firstDayOfWeek
       */
      function buildScheduleCalendar(totalWeek, firstDayOfWeek) {
        $scope.option.calendar = [];
        $scope.originOption.calendar = [];

        for (var i = 0; i < totalWeek; i++) {
          var week = [];
          for (var j = 0; j < 7; j++) {

            var date = new Date(firstDayOfWeek.getTime() + (i * 7 + j) * 24 * 60 * 60 * 1000);
            week.push(date);
          }
          $scope.option.calendar.push(week);
          $scope.originOption.calendar.push(week);
        }

      }

      /**
       * Show save as modal window.
       */
      $scope.saveAsAction = function () {

        var schedule = {name: ''};

        var dlg = $modal.open({
          templateUrl: 'modules/schedule_builder/partials/schedule_builder_create_schedules_save_as_modal.html',
          windowClass: 'schedule-builder',
          controller: function ($scope, $modalInstance, schedule, applicationContext) {

            $scope.schedule = schedule;
            // When we go to login page we have to dismiss the modal.
            $scope.$on('event:auth-loginRequired', function () {
              $modalInstance.dismiss('cancel');
            });

            // Save Action
            $scope.save = function () {
              $modalInstance.close($scope.schedule);
            };

            // Close Modal
            $scope.close = function () {
              $modalInstance.dismiss('cancel');
            };

          },
          resolve: {
            schedule: function () {
              return schedule;
            }
          }

        });

        dlg.result.then(function (schedule) {
          /**
           * Save As
           */
          var tmp = angular.copy($scope.schedule);
          tmp.name = schedule.name;

          var tmpOption = angular.copy($scope.option);
          tmpOption.name = schedule.name;

          newSchedule(tmp)
            .then(function (result) {

              return updateSchedule(result.id, tmpOption);

            }, function (error) {
              applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
            })
            .then(function (result) {
              $scope.option.editing = false;
              applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', '', true, result.name);

            })
            ;

          }, function (reason) {
            console.log('Save as dismissed');
          }
        );
      };

      /**
       * Show duplicate modal window.
       */
      $scope.duplicateAction = function () {

        var schedule = {name: $scope.option.name + ' - Copy'};
        var firstDayIntOfWeek = $scope.site.firstDayIntOfWeek;

        var dlg = $modal.open({
          templateUrl: 'modules/schedule_builder/partials/schedule_builder_create_schedules_duplicate_modal.html',
          windowClass: 'schedule-builder',
          controller: function ($scope, $modalInstance, schedule, applicationContext) {

            $scope.modes = [
              {
                display: 'Dont carry Shifts over',
                value: 'NOASSIGNMENT'
              },
              {
                display: 'Carry over pre-assigned Shifts',
                value: 'PREASSIGNMENT'
              },
              {
                display: 'Carry over all Shifts',
                value: 'ALLASSIGNMENT'
              }
            ];

            $scope.schedule = schedule;
            $scope.schedule.mode = $scope.modes[0];
            $scope.dateOptions = {
              startingDay: firstDayIntOfWeek //Same as original schedule
            };

            // When we go to login page we have to dismiss the modal.
            $scope.$on('event:auth-loginRequired', function () {
              $modalInstance.dismiss('cancel');
            });

            // Duplicate Action
            $scope.duplicateAction = function () {
              $modalInstance.close($scope.schedule);
            };

            // Close Modal
            $scope.close = function () {
              $modalInstance.dismiss('cancel');
            };

            // Shows start date dialog box
            $scope.showDate = function ($event) {
              $event.preventDefault();
              $event.stopPropagation();
              $scope.startDateOpened = true;
            };


          },
          resolve: {
            schedule: function () {
              return schedule;
            }
          }

        });

        return dlg.result.then(function (schedule) {
            /**
             * Save As
             */
            var startDate = appFunc.getDateWithTimezone(
              schedule.startDate.getFullYear(),
              schedule.startDate.getMonth(),
              schedule.startDate.getDate(),
              $scope.site.timeZone
            );

            var dto= {
              name: schedule.name,
              startDate: startDate.getTime(),
              mode: schedule.mode.value
            };

            $http.post(baseUrl + 'schedules/' + $scope.schedule.id + '/ops/duplicate', dto)
              .then(function (result) {
                applicationContext.setNotificationMsgWithValues('app.DUPLICATED_SUCCESSFULLY', '', true, result.data.name);
                $state.go('authenticated.schedule_builder.create_schedules', {'id': result.data.id});
              })
              .catch(function(error) {
                if (error.message) {
                  applicationContext.setNotificationMsgWithValues(error.message, '', true, '');
                }
                else {
                  applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
                }
              });

          }, function (reason) {
            console.log('Save as dismissed');
          }
        );
      };



      /**
       * @param ui: true: it is from UI
       * Update schedule calendar in Main section
       */
      $scope.updateScheduleCalendar = function (ui) {

        /**
         * dirty checking
         */
        if (!$scope.option.startDate)
          return;

        if (ui === true ){
          $scope.option.editing = true;
        }

        if ($scope.option.length < $scope.originOption.length) {

          var dlg = dialogs.confirm('app.PLEASE_CONFIRM', 'schedule_builder.SCHEDULE_LENGTH_IS_SHRUNK.WILL_YOU_CONTINUE?');

          dlg.result.then(function (btn) {

            /**
             * Shrink patternElts
             */

            for (var i = $scope.schedule.patternElts.length - 1; i >= 0; i--) {
              var patternElt = $scope.schedule.patternElts[i];
              if (patternElt.cdDate <= 0) { //This is dayOffset -based Pattern
                if (patternElt.dayOffset >= $scope.option.length) {
                  $scope.schedule.patternElts.splice(i, 1);
                }
              }
            }

            var ret = reassignCalendarVariables();
            buildScheduleCalendar(ret.totalWeek, ret.firstDayOfWeek);

            $scope.originOption.length = $scope.option.length;


          }, function (btn) {
            /**
             * Rollback origin option
             */
            $scope.option.length = $scope.originOption.length;

            var ret = reassignCalendarVariables();
            buildScheduleCalendar(ret.totalWeek, ret.firstDayOfWeek);
          });

        }
        else {
          var ret = reassignCalendarVariables();
          buildScheduleCalendar(ret.totalWeek, ret.firstDayOfWeek);
        }

      };

      function reassignCalendarVariables() {

        var lenInWeek = Math.ceil($scope.option.length / 7);

        $scope.option.endDate = new Date($scope.option.startDate.getTime() + (( lenInWeek * 7 ) - 1) * 24 * 60 * 60 * 1000);

        /**
         * get First Day of the week
         */

        var day = $scope.option.startDate.getDay();
        var diff = day; // Start Day of week is Sunday


        var firstDayOfWeek = new Date($scope.option.startDate.getTime() - ((diff - $scope.site.firstDayIntOfWeek + 7) % 7) * 24 * 60 * 60 * 1000);

        var totalWeek = lenInWeek;
        if (day !== $scope.site.firstDayIntOfWeek) {
          totalWeek++;
        }

        return {totalWeek: totalWeek, firstDayOfWeek: firstDayOfWeek};
      }

      /**
       * It will show of 'save your work' dialog box and have a appropriate action: create schedules
       */
      function getSaveWorkDlg() {

        if ($scope.option.editing === false) {
          var deferred = $q.defer();

          deferred.resolve(SKIP);
          return deferred.promise;

        }
        else {

          var dlg = $modal.open({
            templateUrl: 'modules/_layouts/partials/authenticated_save_work_modal.html',
            windowClass: 'schedule-builder',
            controller: function ($scope, $modalInstance) {

              // When we go to login page we have to dismiss the modal.
              $scope.$on('event:auth-loginRequired', function () {
                $modalInstance.dismiss('cancel');
              });

              // Save Action
              $scope.save = function () {
                $modalInstance.close(SAVE);
              };

              // Discard Action
              $scope.discard = function () {
                $modalInstance.close(DISCARD);
              };

              // Close Modal
              $scope.close = function () {
                $modalInstance.dismiss('cancel');
              };


            }

          });

          return dlg.result.then(function (reason) {

            /**
             * here we just need Save, we don't need Discard, since it will be reloading anyway
             */
            if (reason === SAVE) {

              /**
               * Save, it will refresh every pattern.
               */
              return $scope.saveAction()
                .then(function (result) {
                  $scope.option.editing = false;
                  return reason;
                });

            }
            else if (reason === DISCARD) {
              /**
               * Rollback current pattern and proceed
               */
              $scope.option.editing = false;
              restoreOriginalSchedule();
              return reason;
            }

          }, function (reason) {

            console.log('dismissed');
            return $q.reject(reason);
          });
        }


      }

      /**
       * Generate/Execute a Schedule
       */
      $scope.executeScheduleAction = function () {

        getSaveWorkDlg().then(function (reason) {
          if (reason === DISCARD) {
            return;
          }
          console.log('Schedule Generation');

          $scope.generation.progress = 0;
          $scope.generation.hardScore = '';
          $scope.generation.mediumScore = '';
          $scope.generation.softScore = '';
          $scope.generation.progressInfo = '';

          var now = new Date();
          $scope.generation.elapsedTime = getTimeDiff($scope.schedule.executionStartDate, now.getTime());
          var dto = {
            maxComputationTime: $scope.schedule.maxComputationTime,
            maximumUnimprovedSecondsSpent: $scope.schedule.maximumUnimprovedSecondsSpent
          };

          dataService
            .executeSchedule($scope.schedule.id, dto)
            .then(function (elt) {
                //TODO: Uncomment if required! Check if completion is aborted or failed.
              //if(!elt || elt.completion != "OK") {
              //  $scope.schedule.completion = elt.completion;
              //  $scope.schedule.completionInfo = elt.completionInfo;
              //  applicationContext.setNotificationMsgWithValues(elt.completionInfo, 'danger', true, elt.completion);
              //  return;
              //}
              pollScheduleStatus.start($scope.schedule.id);
              console.log('--> executed[' + elt.name + ': ' + elt.id + ']');
              $scope.elt = elt;  // update view with updated schedule
            }, function (error) {
              applicationContext.setNotificationMsgWithValues(error.data.message, 'danger', true, error.statusText);
            });
        });

      };


      /*
       * Abort a Schedule Generation
       */
      $scope.abortGeneration = function () {

        dataService
          .abortSchedule($scope.schedule.id)
          .then(function (elt) {
            console.log('--> abort sent[' + elt.name + ': ' + elt.id + ']');
            $scope.elt = elt;  // update view with update schedule
          }, function (error) {
            applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
          });
      };

      /**
       * Close Button of generation panel
       */
      $scope.hideGenerationPanel = function () {
        $scope.generation.display = false;
      };

      /**
       * Update Editing Status: Create Schedules
       */
      $scope.updateEditing = function () {
        if ($scope.option.editing !== true) {
          $scope.option.editing = true;
        }
      };

      /**
       * open schedule action, it will open up a dialog box: create schedules module
       */
      $scope.openScheduleAction = function() {

        getSaveWorkDlg().then(function (reason) {

          var dlg = $modal.open({
            templateUrl: 'scheduleSelectorModal.html',
            controller: 'ScheduleSelectorModalInstanceCtrl',
            size: 'lg',
            windowClass: 'schedules-modal',
            resolve: {
              checkboxModel: function() {
                return {
                  simulationGenerated: true,
                  production: false,
                  posted: false
                };
              },
              customFilter: function() {
                return {key: 'scheduleType', value: 'ShiftPatternBased'};
              }
            }
          });

          return dlg.result.then(function(selectedSchedule) {
            $state.go('authenticated.schedule_builder.create_schedules', {'id': selectedSchedule.id});
          }, function (reason) {
            console.log('dismissed');
            return $q.reject(reason);
          });

        });

      };



      /**
       * Redirect to Employee Schedule
       * @param schedule
       */
      $scope.goToEmployeeSchedule = function(schedule) {
        $state.go('authenticated.employeeSchedules.weekView.schedule', {'scheduleId': schedule.id});
      };

      /**
       * It
       */
      function restoreOriginalSchedule() {
        angular.copy($scope.originSchedule, $scope.schedule);
        angular.copy($scope.originOption, $scope.option);
        $scope.updateScheduleCalendar();
      }

      // register an event consumer to diplay the progression of the schedule execution
      // ideally we should unregister this listener when leaving this page.
      // possibly need to register a stateLeve event to do that

      //"<SysNotifications><jcso><><Schedule><Progress><bf2f0a13-b1c1-4db6-bd39-2dd351e39dd6>"

      // TODO REMOVE
      /*
      sseService.registerConsumer({
        id: 'scheduleCtlrProgressHandler',
        selector: function (key) {
          if ($scope.schedule && $scope.schedule.id) {
            var keyselector = '<SysNotifications><.*><><Schedule><Progress><' + $scope.schedule.id + '>';
            var match = key.match(keyselector);
            //console.log("Schedule Progress event:: " + key + " with: " + keyselector + " -> " + match);
            return key.match(keyselector);
          }
          return false;                    // for now, subscribe to all events
        },
        callback: function (key, serverEvent) {
          $scope.$apply(function () {     // use $scope.$apply to refresh the view
            console.log("Gen progress: ", serverEvent.msg);
            $scope.generation.progress = serverEvent.progress;
            $scope.generation.hardScore = (serverEvent.hardScore == -999999 ? '' : serverEvent.hardScore);
            $scope.generation.mediumScore = (serverEvent.mediumScore == -999999 ? '' : serverEvent.mediumScore);
            $scope.generation.softScore = (serverEvent.softScore == -999999 ? '' : serverEvent.softScore);
            $scope.generation.progressInfo = serverEvent.msg;

            var now = new Date();
            $scope.generation.elapsedTime = getTimeDiff($scope.schedule.executionStartDate, now.getTime());
          });
        },
        scope: $scope,
        params: []
      });

      sseService.registerConsumer({
        id: 'scheduleCtlrUpdateHandler',
        selector: function (key) {
          if ($scope.schedule && $scope.schedule.id) {
            var keyselector = '<ObjLifecycle><.*><><Schedule><Update><' + $scope.schedule.id + '>';
            var match = key.match(keyselector);
            //console.log("Schedule Update event: " + key + " with: " + keyselector + " -> " + match);
            return key.match(keyselector);
          }
          return false;                    // for now, subscribe to all events
        },
        callback: function (key, serverEvent) {
          $scope.$apply(function () {     // use $scope.$apply to refresh the view
            console.log("Gen UPDATE: ", serverEvent.completion, serverEvent.completionInfo);
            var updatedElt = serverEvent;
            // convert date attributes from longs to Js dates (done by dataservice layer normally)
            var dateAttributes = ['created', 'updated', 'startDate', 'endDate',
              'executionStartDate', 'requestSentDate', 'executionAckDate', 'responseReceivedDate', 'executionEndDate'
            ];

            for (var i = 0; i < dateAttributes.length; i++) {
              var dateAttr = dateAttributes[i];
              if (updatedElt[dateAttr] > 0) {
                $scope.schedule[dateAttr] = updatedElt[dateAttr];
              }
              else {
                $scope.schedule[dateAttr] = '-';
              }
            }

            var tmpPatternElts = $scope.schedule.patternElts;
            $scope.schedule = serverEvent;
            $scope.schedule.patternElts = tmpPatternElts;

            $scope.schedule.totalExeTime = getTimeDiff($scope.schedule.executionStartDate, $scope.schedule.executionEndDate);
            angular.copy($scope.schedule, $scope.originSchedule);
            //console.log('update generation callback');
            //console.log(serverEvent);
            // then update current elt in scope

          });
        },
        scope: $scope,
        params: []
      });
      */
      // register WebSocket Event listeners
      wsService.registerConsumer({
        id: 'scheduleCtlrProgressHandler',
        selector: function (key) {
          if ($scope.schedule && $scope.schedule.id) {
            var keyselector = '<SysNotifications><.*><><Schedule><Progress><' + $scope.schedule.id + '>';
            var match = key.match(keyselector);
            console.log("Schedule Progress event:: " + key + " with: " + keyselector + " -> " + match);
            return key.match(keyselector);
          }
          return false;                    // for now, subscribe to all events
        },
        callback: function (key, serverEvent) {
          $scope.$apply(function () {     // use $scope.$apply to refresh the view
            console.log(serverEvent);
            $scope.generation.progress = serverEvent.progress;
            $scope.generation.hardScore = (serverEvent.hardScore == -999999 ? '' : serverEvent.hardScore);
            $scope.generation.mediumScore = (serverEvent.mediumScore == -999999 ? '' : serverEvent.mediumScore);
            $scope.generation.softScore = (serverEvent.softScore == -999999 ? '' : serverEvent.softScore);
            $scope.generation.progressInfo = serverEvent.msg;

            var now = new Date();
            $scope.generation.elapsedTime = getTimeDiff($scope.schedule.executionStartDate, now.getTime());
            $scope.generation.remainingTime = getTimeDiff(($scope.generation.elapsedTime.m * 60 + $scope.generation.elapsedTime.s) * 1000, $scope.schedule.maxComputationTime * 1000);
          });
        },
        scope: $scope,
        params: []
      });

      wsService.registerConsumer({
        id: 'scheduleCtlrUpdateHandler',
        selector: function (key) {
          if ($scope.schedule && $scope.schedule.id) {
            var keyselector = '<ObjLifecycle><.*><><Schedule><Update><' + $scope.schedule.id + '>';
            var match = key.match(keyselector);
            console.log("Schedule Update event: " + key + " with: " + keyselector + " -> " + match);
            return key.match(keyselector);
          }
          return false;                    // for now, subscribe to all events
        },
        callback: function (key, serverEvent) {
          $scope.$apply(function () {     // use $scope.$apply to refresh the view
            refillSchedule(serverEvent);
            console.log('update generation callback');
            console.log(serverEvent);
            // then update current elt in scope
          });
        },
        scope: $scope,
        params: []
      });
      
      function refillSchedule(newSchedule) {
        var updatedElt = newSchedule;
        // convert date attributes from longs to Js dates (done by dataservice layer normally)
        var dateAttributes = ['created', 'updated', 'startDate', 'endDate',
          'executionStartDate', 'requestSentDate', 'executionAckDate', 'responseReceivedDate', 'executionEndDate'
        ];

        for (var i = 0; i < dateAttributes.length; i++) {
          var dateAttr = dateAttributes[i];
          if (updatedElt[dateAttr] > 0) {
            $scope.schedule[dateAttr] = updatedElt[dateAttr];
          }
          else {
            $scope.schedule[dateAttr] = '-';
          }
        }

        var tmpPatternElts = $scope.schedule.patternElts;
        $scope.schedule = newSchedule;
        $scope.schedule.patternElts = tmpPatternElts;

        if($scope.isGenerationComplete(newSchedule)) {
          pollScheduleStatus.stop();
        }

        $scope.schedule.totalExeTime = getTimeDiff($scope.schedule.executionStartDate, $scope.schedule.executionEndDate);
        angular.copy($scope.schedule, $scope.originSchedule);
      }

      $scope.isGenerationComplete = function(schedule) {
        return schedule.completion=='OK' && (schedule.state == 'Complete' || schedule.state == 'Idle');
      };

      var pollScheduleStatus = (function(){
        var config = {
          timeInterval: 30000,  //30s
          maxPollsCounter: 10
        };

        var poller = null;
        var pollsCounter = 0;

        function startPolling(scheduleId) {
          poller = setInterval(function () {
            pollsCounter++;
            if(pollsCounter > config.maxPollsCounter) {
              pollScheduleStatus.stop();
            }
            onPoll(scheduleId);
          }, config.timeInterval);
        }

        function onPoll(scheduleId) {
          factory.getElement("schedules", scheduleId)
              .then(function success(schedule) {
                console.log("Polled schedule state: ", schedule.state);
                if($scope.isGenerationComplete(schedule)) {
                  refillSchedule(schedule);
                }
              }, function error(response) {
                console.log("Schedule state polling error: ", response);
              });
        }

        function clear() {
          clearInterval(poller);
          pollsCounter = 0;
        }

        return {
          start: function(scheduleId) {
            console.log("Schedule state polling started!");
            startPolling(scheduleId);
          },
          stop: function() {
            console.log("Schedule state polling stopped!");
            clear();
          }
        };
      }());

      /**
       * Load schedule from url with id
       */
      if ($stateParams.id && $stateParams.id !== '') {
        $scope.loadSchedule($stateParams.id);
      }
      else {
        //prevent to load selectorModal html
        $timeout( function(){ $scope.openScheduleAction(); }, 1000);
      }

      /**
       * Load tree structure of sites/teams/skills
       */
      loadSiteTeamSkills()
        .then(function (sites) {

          /**
           * the highest object levels are sites.
           */

          var tmp = scheduleService.getShared();
          tmp.sites = sites;

          /**
           * For the New schedule dropdown list it will show only new schedule dropdown
           */
          tmp.newScheduleOptionList = angular.copy(sites);
          tmp.option = $scope.option;
          scheduleService.setShared(tmp);
        });

      /**
       * Register call back function, for confirmation Dialog
       */
      var working = applicationContext.getWorking();

      working.option = $scope.option;
      working.restoreFunc = restoreOriginalSchedule;
      working.saveFunc = $scope.saveAction;
      working.entityName = 'schedule_builder.SCHEDULE';


    }
  ]

);

;
var scheduleBuilder = angular.module('emlogis.schedule_builder');

scheduleBuilder.controller('ScheduleBuilderGenerationReportCtrl',
  [
    '$scope',
    '$state',
    '$stateParams',
    '$http',
    '$filter',
    'applicationContext',
    'dataService',
    '$modal',
    'scheduleService',
    'authService',
    'uiGridConstants',
    function ($scope, $state, $stateParams, $http, $filter, applicationContext, dataService, $modal, scheduleService,
              authService, uiGridConstants) {

      $scope.Math = window.Math;

      /**
       * open schedule action, it will open up a dialog box
       */
      $scope.openScheduleAction = function () {
        var dlg = $modal.open({
          templateUrl: 'scheduleSelectorModal.html',
          controller: 'ScheduleSelectorModalInstanceCtrl',
          size: 'lg',
          windowClass: 'schedules-modal',
          resolve: {
            checkboxModel: function () {
              return {
                simulationGenerated: true,
                production: false,
                posted: false
              };
            },
            customFilter: function() {
              return {key: 'states', value: [5]};
            }
          }
        });
        return dlg.result.then(function(selectedSchedule) {
          var tmp = scheduleService.getShared();
          tmp.schedule = null;
          scheduleService.setShared(tmp);
          $state.go('authenticated.schedule_builder.generation_report', {'id': selectedSchedule.id});
        }, function (reason) {
          console.log('dismissed');
          //return $q.reject(reason);
        });
      };

      var temp = scheduleService.getShared();
      $scope.schedule = temp.schedule;

      $scope.isScheduleEmpty = function () {
        return _.isEmpty($scope.schedule);
      };

      if ($scope.isScheduleEmpty() || (!$scope.isScheduleEmpty() && $scope.schedule.shiftGenerationDuration === -1)) {
        if ($stateParams.id !== undefined) {
          if (($stateParams.id !== '')) {
            $http.get(applicationContext.getBaseRestUrl() + 'schedules/' + $stateParams.id, {})
              .then(function (res) {
                $scope.schedule = res.data;
                var tmp = scheduleService.getShared();
                tmp.schedule = $scope.schedule;
                scheduleService.setShared(tmp);
                $scope.loadReport();
              });
          } else {
            $scope.openScheduleAction();
          }
        }
      }

      $scope.isValid = function () {
        return $scope.schedule && ($scope.schedule.state === 'Complete') && ($scope.schedule.executionStartDate > 0) && ($scope.schedule.executionEndDate > 0)
          && ($scope.schedule.executionStartDate < $scope.schedule.executionEndDate);
      };

      $scope.initVars = function () {
        $scope.employeeSummaryGridData = [];
        $scope.employeeGridData = [];
        $scope.openShiftsGridData = [];
        $scope.summaryBySkillGridData = [];
        $scope.scheduleExecutionReport = {};
      };

      $scope.loadReport = function () {
        $scope.initVars();
        if (!$scope.isScheduleEmpty()) {
          getReport();
          var executionDuration = $scope.schedule.executionEndDate - $scope.schedule.executionStartDate;
          $scope.executionDuration = new Date(executionDuration);
        }
      };

      $scope.loadReport();


      $scope.selectMainTab = function (tabName) {
        $scope.selectedMainTab = tabName;
      };

      $scope.selectSubTab = function (tabName) {
        $scope.selectedSubTab = tabName;
      };

      var pageSize = 25;

      $scope.summaryBySkillOptions = {
        enableColumnResizing: true,
        enableScrollbars: false,
        paginationPageSize: pageSize,
        enablePaginationControls: false,
        data: 'summaryBySkillGridData',
        rowHeight: 70,
        //rowTemplate: defaultRowTemplate(),
        columnDefs: [
          {field: 'name', displayName: 'Summary By Skill', minWidth: 150},
          {field: 'resources', displayName: 'Resources', minWidth: 150},
          {field: 'resourcesAssignments', displayName: 'Assigned Resources', minWidth: 150},
          {field: 'shifts', displayName: 'Shifts', minWidth: 150, cellTemplate: skillCountsTpl()},
          {field: 'shiftsDetails', visible: false},
          {
            field: 'assignedShifts',
            displayName: 'Assigned Shifts',
            minWidth: 150,
            cellTemplate: skillCountsShiftsAssignTpl()
          },
          {field: 'assignedShiftsDetails', visible: false},
          {field: 'openShifts', displayName: 'Open Shifts', minWidth: 150, cellTemplate: skillCountsTpl()},
          {field: 'openShiftsDetails', visible: false},
          {field: 'hours', displayName: 'Hours', minWidth: 150, cellTemplate: skillCountsTpl()},
          {field: 'hoursDetails', visible: false},
          {field: 'assignedHours', displayName: 'Assigned Hours', minWidth: 150, cellTemplate: skillCountsTpl()},
          {field: 'assignedHoursDetails', visible: false},
          {field: 'resourcesHours', displayName: 'Resources Hours', minWidth: 150}
        ]
      };

      $scope.employeeGridOptions = {
        enableColumnResizing: true,
        enableScrollbars: false,
        paginationPageSize: pageSize,
        enablePaginationControls: false,
        data: 'employeeGridData | filter: employeeScheduleSearchText',
        rowTemplate: defaultRowTemplate(),
        columnDefs: [
          {field: 'employeeName', displayName: 'Employee', minWidth: 150},
          {field: 'employeeSkills', displayName: 'Employee Skills', minWidth: 150, cellTemplate: skillCellTpl()},
          {field: 'totalHours'},
          {field: 'availableHours'}
        ]
      };

      $scope.employeeGridOptions.onRegisterApi = onRegApi;

      $scope.employeeSummaryGridOptions = {
        enableScrollbars: false,
        paginationPageSize: pageSize,
        enablePaginationControls: false,
        data: 'employeeSummaryGridData | filter: employeeSummarySearchText',
        rowTemplate: defaultRowTemplate(),
        columnDefs: [
          {field: 'employeeName', displayName: 'Employee'},
          {field: 'employeeSkills', displayName: 'Employee Skills', cellTemplate: skillCellTpl()},
          {field: 'totalHours'},
          {field: 'availableHours'},
          {field: 'hardScore', cellTemplate: cellTpl('col.field')},
          {field: 'mediumScore', cellTemplate: cellTpl('col.field')},
          {field: 'softScore'}
        ]
      };

      $scope.employeeSummaryGridOptions.onRegisterApi = onRegApi;

      $scope.openShiftsGridOptions = {
        enableScrollbars: false,
        useExternalPagination: true,
        useExternalSorting: true,
        paginationPageSize: pageSize,
        enablePaginationControls: false,
        data: 'openShiftsGridData | filter: tempsearchtext',
        rowTemplate: defaultRowTemplate(),
        columnDefs: [
          {field: 'id', minWidth: 150},
          {field: 'startDateTime', minWidth: 150},
          {field: 'endDateTime', minWidth: 150},
          {field: 'teamName', minWidth: 150},
          {field: 'shiftLengthName', minWidth: 150},
          {field: 'skillName', minWidth: 150}
        ],
        paginationCurrentPage: 1,
        queryParams: {
          filter: 'assignmentType is null',
          returnedfields: 'id,startDateTime,endDateTime,teamName,shiftLengthName,skillName'
        }
      };

      $scope.openShiftsGridOptions.onRegisterApi = function (gridApi) {
        $scope.gridApi = gridApi;
        getOpenShifts();
        $scope.gridApi.core.on.sortChanged($scope, function (grid, sortColumns) {

          $scope.openShiftsGridOptions.queryParams.orderby = sortColumns[0] ? sortColumns[0].field : undefined;
          $scope.openShiftsGridOptions.queryParams.orderdir = sortColumns[0] ? sortColumns[0].sort.direction.toUpperCase() : undefined;
          getOpenShifts();
        });
        $scope.gridApi.pagination.on.paginationChanged($scope, function (newPage) {
          //$scope.openShiftsGridOptions.paginationPageSize = pageSize;
          $scope.openShiftsGridOptions.paginationCurrentPage = newPage;
          getOpenShifts();
        });
      };

      function getOpenShifts() {
        var params = _.pick($scope.openShiftsGridOptions.queryParams, 'returnedfields', 'filter', 'orderby', 'orderdir');
        params.offset = ($scope.openShiftsGridOptions.paginationCurrentPage - 1) * $scope.openShiftsGridOptions.paginationPageSize;
        params.limit = $scope.openShiftsGridOptions.paginationPageSize;
        dataService.getScheduleShiftsOps($scope.schedule.id, params)
          .then(function (res) {
            createOpenShiftsGridData(res.data.result);
            $scope.openShiftsGridOptions.totalItems = res.data.total;
          }, function (err) {
            console.log("=====> Error: " + err.data.message);
          });
      }

      $scope.tplGridOptions = {
        enableScrollbars: false,
        paginationPageSize: pageSize,
        enablePaginationControls: false,
        data: null,
        rowTemplate: defaultRowTemplate(),
        columnDefs: [
          {field: 'employeeName', displayName: 'Employee', enableFiltering: true},
          {
            field: 'employeeSkills',
            displayName: 'Employee Skills',
            enableFiltering: true,
            cellTemplate: skillCellTpl()
          },
          {field: 'weightsDetails', visible: false}
        ]
      };

      function onRegApi(gridApi) {
        $scope.gridApi = gridApi;
      }

      function cellTpl(constrName) {
        return '<div title="{{grid.appScope.extScope.getDetails(row.entity[col.field+\'Details\'])}}" ' +
          'class="gridCell">' +
          '<span class="{{grid.appScope.extScope.isHard(row.entity[col.field], ' + constrName + ')}}">{{row.entity[col.field]}}</span> ' +
          '<span>{{grid.appScope.extScope.getUnit(' + constrName + ', row.entity[col.field])}} ' +
          '{{grid.appScope.extScope.getDetails(row.entity[col.field+"Details"])}}</span></div>';
      }

      function skillCellTpl() {
        return '<div  ' +
          'class="gridCell">' +
          '<span style="font-weight: bold">{{row.entity[col.field][0].join()}}</span> ' +
          '<span>/ {{row.entity[col.field][1].join()}}</span></div>';
      }

      function skillCountsTpl() {
        return '<div class="gridCell"> ' +
          '<div>Total: {{row.entity[col.field+\'Details\'].total}}</div>' +
          '<div>Regular: {{row.entity[col.field+\'Details\'].regular}}</div>' +
          '<div ng-if="row.entity[col.field+\'Details\'].excess>0">Excess: {{row.entity[col.field+\'Details\'].excess}}</div>' +
          '</div>';
      }

      function skillCountsShiftsAssignTpl() {
        return '<div class="gridCell"> ' +
          '<div >' + //row.entity[col.field+\'Details\'].total/row.entity[\'shiftsDetails\'].total<0.6
          'Total: <span class="{{grid.appScope.getShiftCountColor(row.entity[col.field+\'Details\'].total, row.entity[\'shiftsDetails\'].total)}}">' +
          '{{row.entity[col.field+\'Details\'].total }}</span> {{grid.appScope.getShiftPersent(row.entity[col.field+\'Details\'].total, row.entity[\'shiftsDetails\'].total)}}' +
          '</div>' +
          '<div>Regular: {{row.entity[col.field+\'Details\'].regular}}</div>' +
          '<div ng-if="row.entity[col.field+\'Details\'].excess>0">Excess: {{row.entity[col.field+\'Details\'].excess}}</div>' +
          '</div>';
      }

      function defaultRowTemplate() {
        return '<div ng-repeat="col in colContainer.renderedColumns track by col.colDef.name" class="ui-grid-cell" ui-grid-cell></div>';
      }

      function headerCellTemplate() {
        return "<div ng-class=\"{ 'sortable': sortable }\">" +
          "<div class=\"ui-grid-vertical-bar\">&nbsp;</div>" +
          "<div class=\"ui-grid-cell-contents\" col-index=\"renderIndex\" ><span translate>{{grid.appScope.extScope.getTranslateName(col.name) CUSTOM_FILTERS }} </span>" +
          "<span>(<span class=\"{{grid.appScope.extScope.isHard(grid.appScope.extScope.getTotal(col.field), col.field)}}\">{{grid.appScope.extScope.getTotal(col.field)}}</span>)" +
          "<span ui-grid-visible=\"col.sort.direction\" class='ui-grid-icon-my' ng-class=\"{ 'ui-grid-icon-up-dir': col.sort.direction == asc, 'ui-grid-icon-down-dir': col.sort.direction == desc, 'ui-grid-icon-blank': !col.sort.direction }\">&nbsp;</span></span>" +
          "</div>" +
          "<div class=\"ui-grid-column-menu-button\" ng-if=\"grid.options.enableColumnMenus && !col.isRowHeader  && col.colDef.enableColumnMenu !== false\" class=\"ui-grid-column-menu-button\" ng-click=\"toggleMenu($event)\">" +
          "<i class=\"ui-grid-icon-angle-down\">&nbsp;</i>" +
          "</div>" +
          "<div ng-if=\"filterable\" class=\"ui-grid-filter-container\" ng-repeat=\"colFilter in col.filters\">" +
          "<input type=\"text\" class=\"ui-grid-filter-input\" ng-model=\"colFilter.term\" ng-click=\"$event.stopPropagation()\" ng-attr-placeholder=\"{{colFilter.placeholder || ''}}\">" +
          "<div class=\"ui-grid-filter-button\" ng-click=\"colFilter.term = null\">" +
          "<i class=\"ui-grid-icon-cancel right\" ng-show=\"!!colFilter.term\">&nbsp;</i> <!-- use !! because angular interprets 'f' as false -->" +
          "</div>" +
          "</div>" +
          "</div>";
      }

      function getReport() {

        if ($scope.schedule.returnedOpenShifts == -1 || $scope.schedule.returnedAssignedShifts == -1) {
          $scope.readyEmployeeGridData = true;
          return;
        } else {
          $scope.readyEmployeeGridData = false;
          dataService.getScheduleReport($scope.schedule.id)
            .then(function (report) {
              $scope.$emit('event:loadSchedule');

              $scope.report = report;
              $scope.report.completionReport = angular.fromJson(report.completionReport);
              createSummaryBySkillData();
              if ($scope.report.completionReport !== null) {
                createEmployeeScheduleGridData();
                createEmployeeSummaryGridData();
                createScheduleExecutionGridOptions();
              }
              $scope.readyEmployeeGridData = true;
            }, function (error) {
              $scope.readyEmployeeGridData = true;
              console.log("=====> Error: " + error.data.message);
            });
        }
      }

      function createSummaryBySkillData() {
        angular.forEach($scope.report.summaryBySkill, function (elem, index) {
          var gridRow = {};
          //gridRow.id = elem.id;
          gridRow.name = elem.name;
          gridRow.resources = elem.report.resources;
          gridRow.resourcesAssignments = elem.report.resourcesAssignments;
          gridRow.shifts = elem.report.shifts.total;
          gridRow.shiftsDetails = elem.report.shifts;
          gridRow.assignedShifts = elem.report.assignedShifts.total;
          gridRow.assignedShiftsDetails = elem.report.assignedShifts;
          gridRow.openShiftsDetails = {
            regular: gridRow.shiftsDetails.regular - gridRow.assignedShiftsDetails.regular,
            excess: gridRow.shiftsDetails.excess - gridRow.assignedShiftsDetails.excess,
            total: gridRow.shiftsDetails.total - gridRow.assignedShiftsDetails.total
          };
          gridRow.openShifts = gridRow.openShiftsDetails.total;
          gridRow.hours = elem.report.hours.total;
          gridRow.hoursDetails = elem.report.hours;
          gridRow.assignedHours = elem.report.assignedHours.total;
          gridRow.assignedHoursDetails = elem.report.assignedHours;
          gridRow.resourcesHours = elem.report.resourcesHours[0];
          $scope.summaryBySkillGridData.push(gridRow);
        });
      }

      // create model for employee Schedule Report
      function createEmployeeScheduleGridData() {
        $scope.employeeGridOptions.columnDefs = [
          {field: 'employeeName', displayName: 'Employee', minWidth: 150},
          {field: 'employeeSkills', displayName: 'Employee Skills', minWidth: 150, cellTemplate: skillCellTpl()},
          {field: 'totalHours'},
          {field: 'availableHours'}
        ];
        var i;
        var completionReportAll = [];
        for (i = 0; i < $scope.report.completionReport.length; i++) {
          if ($scope.report.completionReport[i].constraintName !== 'requiredEmployeeSizePerShift') {
            $scope.employeeGridOptions.columnDefs.push({
                field: $scope.report.completionReport[i].constraintName,
                cellTemplate: cellTpl('col.field'),
                headerCellTemplate: headerCellTemplate(),
                minWidth: 100
              }
            );
            $scope.employeeGridOptions.columnDefs.push({
                field: $scope.report.completionReport[i].constraintName + 'Details',
                visible: false
              }
            );
            for (var j = 0; j < $scope.report.completionReport[i].constraintMatchSet.length; j++) {
              completionReportAll.push($scope.report.completionReport[i].constraintMatchSet[j]);
            }
          }
        }
        var completionReportAllGrouped = _.groupBy(
          completionReportAll,
          function (elem) {
            return elem.employeeId;
          }
        );
        $scope.report.employeeScheduleReport = _.map(
          completionReportAllGrouped, iteratorReport);

        angular.forEach($scope.report.employeeScheduleReport, function (elem, index) {
          var gridRow = {};
          if (elem.employeeId !== '') {
            gridRow.employeeName = elem.employeeName;
            gridRow.employeeSkills = elem.employeeSkills;
            gridRow.totalHours = $scope.getEmployeeTotalHours(elem.employeeId);
            gridRow.availableHours = $scope.getEmployeeAvailableHours(elem.employeeId);
            for (i = 0; i < $scope.report.completionReport.length; i++) {
              var cName = $scope.report.completionReport[i].constraintName;
              if (elem.weightsPerConstr[cName]) {
                gridRow[cName + 'Details'] = elem.weightsPerConstr[cName];
                gridRow[cName] = _.reduce(elem.weightsPerConstr[cName], function (memo, num) {
                  return memo + num;
                }, 0);
              }
            }
            $scope.employeeGridData.push(gridRow);
          }

        });

      }

      function createEmployeeSummaryGridData() {
        var i;
        angular.forEach($scope.report.employees, function (empl, index) {
          var gridRow = {};

          gridRow.employeeName = empl.firstName + ' ' + empl.lastName;
          gridRow.employeeSkills = $scope.getSkills(empl);
          gridRow.totalHours = empl.totalHours;
          gridRow.availableHours = empl.availableHours;

          var emplInReport = $scope.findInArrayByProperty($scope.report.employeeScheduleReport, 'employeeId', empl.id);
          if (emplInReport) {
            gridRow.hardScore = 0;
            gridRow.softScore = 0;
            gridRow.mediumScore = 0;
            for (i = 0; i < $scope.report.completionReport.length; i++) {
              var cName = $scope.report.completionReport[i].constraintName;
              if (emplInReport.weightsCountPerConstr[cName]) {
                if (emplInReport.weightsCountPerConstr[cName] < 0) {
                  if (_.contains($scope.mediumConstraints, cName)) {
                    gridRow.mediumScore += emplInReport.weightsCountPerConstr[cName];
                  } else {
                    gridRow.hardScore += emplInReport.weightsCountPerConstr[cName];
                  }
                } else {
                  gridRow.softScore += emplInReport.weightsCountPerConstr[cName];
                }
              }
            }
          }

          $scope.employeeSummaryGridData.push(gridRow);
        });
      }

      // create model for schedule Execution Report
      function createScheduleExecutionGridOptions() {
        var i;
        var constraintMatchSetGrouped = [];
        for (i = 0; i < $scope.report.completionReport.length; i++) {
          constraintMatchSetGrouped[i] = _.groupBy(
            $scope.report.completionReport[i].constraintMatchSet,
            function (elem) {
              return elem.employeeId;
            }
          );
          $scope.report.completionReport[i].scheduleExecReport = _.map(
            constraintMatchSetGrouped[i], iteratorReport);


          $scope.report.completionReport[i].gridOptions = angular.copy($scope.tplGridOptions);
          $scope.report.completionReport[i].gridOptions.columnDefs.push({
            field: 'weights',
            displayName: 'Weights',
            cellTemplate: cellTpl('\'' + $scope.report.completionReport[i].constraintName + '\'')
          });
          $scope.report.completionReport[i].gridOptions.onRegisterApi = onRegApi;
          $scope.scheduleExecutionReport[$scope.report.completionReport[i].constraintName] =
            $scope.report.completionReport[i].scheduleExecReport;
          $scope.report.completionReport[i].gridOptions.data = 'scheduleExecutionReport.' +
            $scope.report.completionReport[i].constraintName + ' | filter: tempsearchtext';

        }
      }

      function createOpenShiftsGridData(shifts) {
        $scope.openShiftsGridData.length = 0;
        angular.forEach(shifts, function (shift, index) {
          var gridRow = {};

          gridRow.id = shift[0];
          gridRow.teamName = shift[3];
          gridRow.shiftLengthName = shift[4];
          gridRow.startDateTime = new Date(shift[1]);
          gridRow.endDateTime = new Date(shift[2]);
          gridRow.skillName = shift[5];

          $scope.openShiftsGridData.push(gridRow);
        });
      }

      // iterator for mapping object model of reports to array
      function iteratorReport(obj, key) {
        var weights = [];
        var weightsPerConstr = {};
        var weightsCountPerConstr = {};
        var isHard = false;
        angular.forEach(obj, function (val, index) {
          weights.push(val.weight);
          if (!weightsPerConstr[val.constraintName]) {
            weightsPerConstr[val.constraintName] = [];
            weightsCountPerConstr[val.constraintName] = val.weight;
            weightsPerConstr[val.constraintName].push(val.weight);
          } else {
            weightsPerConstr[val.constraintName].push(val.weight);
            weightsCountPerConstr[val.constraintName] += val.weight;
          }
          if (val.weight < 0 && !isHard) isHard = true;
        });
        return {
          employeeId: key,
          employeeName: $scope.getEmployeeName(key),
          employeeSkills: $scope.getEmployeeSkills(key),
          constraints: obj,
          weights: _.reduce(weights, function (memo, num) {
            return memo + num;
          }, 0),
          weightsDetails: weights,
          weightsPerConstr: weightsPerConstr,
          weightsCountPerConstr: weightsCountPerConstr,
          isHard: isHard
        };
      }

      $scope.findInArrayByProperty = function (list, prop, val) {
        return _.find(list, function (e) {
          return e[prop] == val;
        });
      };

      $scope.getHardTotal = function () {
        if ($scope.readyEmployeeGridData) {
          var counts = _.countBy($scope.report.employeeScheduleReport, function (obj) {
            return obj.isHard;
          });
          return counts.true;
        }
      };

      $scope.scheduleOverview = {
        'shifts': {
          'name': 'Shifts in Schedule'
        },
        'hours': {
          'name': 'Hours in Schedule'
        },
        'shiftsAssignments': {
          'name': 'Assigned Shifts'
        },
        'hoursAssignments': {
          'name': 'Assigned Hours'
        }
      };

      $scope.summaryBySkill = {
        'shifts': {
          'name': 'Shifts',
          'regularexcess': true
        },
        'hours': {
          'name': 'Hours',
          'regularexcess': true
        },
        'resources': {
          'name': 'Resources',
          'singlevalue': true
        },
        'resourcesAssignments': {
          'name': 'Assigned Resources',
          'singlevalue': true
        },
        'resourcesHours': {
          'name': 'Resources Hours',
          'minmax': true
        },
        'assignedShifts': {
          'name': 'Assigned Shifts',
          'regularexcess': true
        },
        'assignedHours': {
          'name': 'Assigned Hours',
          'regularexcess': true
        }
      };

      $scope.getEmployeeName = function (employeeId) {
        var emp = _.find($scope.report.employees, function (e) {
          return e.id == employeeId;
        });
        if (emp) return emp.firstName + " " + emp.lastName;
      };

      $scope.getEmployeeSkills = function (employeeId) {
        var emp = _.find($scope.report.employees, function (e) {
          return e.id == employeeId;
        });
        if (emp) {
          return $scope.getSkills(emp);
        }
      };

      $scope.getSkills = function (employee) {
        if (employee.skills.length > 0) {
          var skills = _.partition(employee.skills, function (e) {
            return e.isPrimary;
          });

          var primary = [];
          if (skills[0][0] !== undefined) {
            primary = [skills[0][0].name];
          }
          var notPrimary = [];
          angular.forEach(skills[1], function (val, index) {
            notPrimary.push(val.name);
          });
          return [primary, notPrimary];
        }
      };

      $scope.getEmployeeTotalHours = function (employeeId) {
        var emp = _.find($scope.report.employees, function (e) {
          return e.id == employeeId;
        });
        if (emp) return emp.totalHours;
      };

      $scope.getEmployeeAvailableHours = function (employeeId) {
        var emp = _.find($scope.report.employees, function (e) {
          return e.id == employeeId;
        });
        if (emp) return emp.availableHours;
      };

      // Close Modal
      $scope.close = function () {
        //$modalInstance.dismiss('cancel');
        $modalInstance.dismiss('cancel');
      };

      $scope.hasPermission = function (perm) {
        return authService.hasPermission(perm);
      };

      $scope.toUpperCaseUnderscore = function (string) {
        return string.replace(/([A-Z])/g, function ($1) {
          return "_" + $1.toLowerCase();
        }).toUpperCase();
      };

      $scope.getTotal = function (constraintName) {
        for (var i = 0; i < $scope.report.completionReport.length; i++) {
          if ($scope.report.completionReport[i].constraintName == constraintName) {
            return $scope.report.completionReport[i].weightTotal;
          }
        }
      };

      $scope.mediumConstraints = [
        "requiredEmployeeSizePerShift",
        "minHoursPrimeSkillPerWeek",
        "minHoursPerWeek",
        "minHoursPerDay"
      ];

      $scope.extScope = {
        isHard: function (val, constName) {
          if (val < 0) {
            if (_.contains($scope.mediumConstraints, constName) || constName === 'mediumScore') {
              return 'mediumCell';
            } else return 'hardCell';
          } else return 'softCell';
        },
        getTotal: function (constraintName) {
          for (var i = 0; i < $scope.report.completionReport.length; i++) {
            if ($scope.report.completionReport[i].constraintName == constraintName) {
              return $scope.report.completionReport[i].weightTotal;
            }
          }
        },
        getTranslateName: function (name) {
          return 'constraints.' + $scope.toUpperCaseUnderscore(name);
        },
        getDetails: function (array) {
          if (array && array.length > 0) {
            return '(' + array.join() + ')';
          }
        },
        getUnit: function (field, val) {
          if (val) {
            var unit = '';
            if (field.indexOf("Hours") > -1) {
              unit = 'hours';
            }
            if (field.indexOf("Days") > -1) {
              unit = 'days';
            }
            return unit;
          }
        }
      };

      $scope.showValue = function (val) {
        if (angular.isArray(val)) {
          if (val.length == 2) {
            if (val[0] > 0) {
              return val[0] + " (-" + val[1] + "/-" + Math.round(val[1] / (val[0] + val[1]) * 100) + "%)";
            } else {
              return val[0];
            }
          } else if (val.length == 1) {
            return val[0];
          }
        } else {
          return val;
        }
      };

      $scope.getShiftCountColor = function (assigned, total) {
        if (total > 0 && assigned / total != 1) {
          if (assigned / total < 0.6) {
            return 'hardCell';
          } else if (assigned / total >= 0.6 && assigned / total < 0.9) {
            return 'mediumCell';
          } else if (assigned / total > 0.9) {
            return 'goodCell';
          }
        } else return '';
      };

      $scope.getShiftPersent = function (assigned, total) {
        if (total > 0 && assigned / total != 1) {
          return " (-" + (total - assigned) + "/-" + Math.round((total - assigned) / total * 100) + "%)";
        }
      };

    }
  ]
);

;
var scheduleBuilder = angular.module('emlogis.schedule_builder');
//depricated controller
scheduleBuilder.controller('ScheduleBuilderOpenScheduleCtrl',
  [
    '$scope',
    '$modalInstance',
    '$translate',
    '$q',
    '$http',
    'crudDataService',
    'uiGridConstants',
    'scheduleFilter',
    'appFunc',
    function (
      $scope,
      $modalInstance,
      $translate,
      $q,
      $http,
      crudDataService,
      uiGridConstants,
      scheduleFilter,
      appFunc
      ) {

      var factory = _.clone(crudDataService);

      /**
       * Schedule Statuses
       * @type {{id: number, title: string}[]}
       */
      $scope.statuses = [
        {id:0, title: 'Simulation'},
        {id:1, title: 'Production'},
        {id:2, title: 'Posted'}
      ];

      // When we go to login page we have to dismiss the modal.
      $scope.$on('event:auth-loginRequired', function () {
        $modalInstance.dismiss('cancel');
      });


      // Close Modal
      $scope.close = function () {
        $modalInstance.dismiss('cancel');
      };

      /**
       * it returns promise object of sites
       */
      $scope.listSchedules = function () {

        var deferred = $q.defer();

        var filter = "name like '%" + $scope.browser.filterTxt + "%'";

        if ($scope.browser.filterStatus !== null) {
          filter = ';status=' + $scope.browser.filterStatus.id;
        }

        if (scheduleFilter.length > 0 ){
          filter = filter + ';' + scheduleFilter;
        }

        var schedulesListUrl = '../emlogis/rest/schedules/ops/query';//?filter=' + encodeURIComponent(filter);

        //schedulesListUrl += "&orderby="+$scope.browser.orderBy + "&orderdir="+$scope.browser.orderDir;

        $scope.preparePageParam();

        //schedulesListUrl += "&offset="+$scope.browser.offset + "&limit="+$scope.browser.limit;

        var params = {
          filter: filter,
          orderby: $scope.browser.orderBy,
          orderdir: $scope.browser.orderDir,
          limit: $scope.browser.limit,
          offset: $scope.browser.offset
        };

        $http.get(schedulesListUrl, {params: params})
          .then(function (response) {

            var resultSet = factory.toResultSet(response);

            $scope.gridOptions.data = resultSet.data;

            /**
             * convert startdate to browser timezone
             */

//            for (var i=0; i < $scope.gridOptions.data.length; i++) {
//              var schedule = $scope.gridOptions.data[i];
//              schedule.startDate = appFunc.convertToBrowserTimezone(schedule.startDate, $scope.site.timeZone);
//            }

            $scope.browser.totalRecords = resultSet.total;

            deferred.resolve(resultSet.data);
          });

        return deferred.promise;
      };

      $scope.browser = {
        filterTxt: "",
        filterStatus: null,
        orderBy: "startDate",
        orderDir: "desc",
        pageSize: 25,
        currentPage: 1
      };

      /*
       *This header cell template is almost same as default cell template except
       * it has translate directive inside so grid header will support i18n as well
       */
      var headerCellTemplate = function () {
        return "<div ng-class=\"{ 'sortable': sortable }\">" +
          "<div class=\"ui-grid-vertical-bar\">&nbsp;</div>" +
          "<div class=\"ui-grid-cell-contents\" col-index=\"renderIndex\" ><span translate>{{ col.name CUSTOM_FILTERS }} </span>" +
          "<span ui-grid-visible=\"col.sort.direction\" ng-class=\"{ 'ui-grid-icon-up-dir': col.sort.direction == asc, 'ui-grid-icon-down-dir': col.sort.direction == desc, 'ui-grid-icon-blank': !col.sort.direction }\">&nbsp;</span>" +
          "</div>" +
          "<div class=\"ui-grid-column-menu-button\" ng-if=\"grid.options.enableColumnMenus && !col.isRowHeader  && col.colDef.enableColumnMenu !== false\" class=\"ui-grid-column-menu-button\" ng-click=\"toggleMenu($event)\">" +
          "<i class=\"ui-grid-icon-angle-down\">&nbsp;</i>" +
          "</div>" +
          "<div ng-if=\"filterable\" class=\"ui-grid-filter-container\" ng-repeat=\"colFilter in col.filters\">" +
          "<input type=\"text\" class=\"ui-grid-filter-input\" ng-model=\"colFilter.term\" ng-click=\"$event.stopPropagation()\" ng-attr-placeholder=\"{{colFilter.placeholder || ''}}\">" +
          "<div class=\"ui-grid-filter-button\" ng-click=\"colFilter.term = null\">" +
          "<i class=\"ui-grid-icon-cancel right\" ng-show=\"!!colFilter.term\">&nbsp;</i> <!-- use !! because angular interprets 'f' as false -->" +
          "</div>" +
          "</div>" +
          "</div>";
      };

      // ColumnDef Info
      $scope.columnDef = [
        {
          name: 'app.NAME',
          field: 'name',
          headerCellTemplate: headerCellTemplate()
        },
        {
          name: 'schedule_builder.STATUS',
          field: 'status',
          headerCellTemplate: headerCellTemplate()
        },
        {
          name: 'schedule_builder.START_DATE',
          field: 'startDate',
          headerCellTemplate: headerCellTemplate(),
          cellTemplate: dateCellTemplate()
        },
        {
          name: 'schedule_builder.LENGTH',
          field: 'scheduleLengthInDays',
          headerCellTemplate: headerCellTemplate(),
          cellTemplate: lengthCellTemplate()
        },
        {
          name: 'schedule_builder.TEAMS',
          field: 'teamNames',
          headerCellTemplate: headerCellTemplate()
        },
        {
          name: 'schedule_builder.DESCRIPTION',
          field: 'description',
          headerCellTemplate: headerCellTemplate(),
          visible: false
        },
        {
          name: 'schedule_builder.GENERATION',
          enableSorting: false,
          enableColumnMenu: false,
          field: '',
          headerCellTemplate: headerCellTemplate(),
          cellTemplate: generationCellTemplate()
        },
        {
          name: 'app.ACTION',
          enableSorting: false,
          disableColumnMenu: true,
          disableHiding: true,
          headerCellTemplate: headerCellTemplate(),
          cellClass: 'action-cell',
          cellTemplate: actionCellTemplate()
        }
      ];

      // Row Template
      function rowTemplate() {
        return '<div title="This is row tooltip" ng-dblclick="grid.appScope.extScope.onDblClickRow(row.entity)" ng-repeat="col in colContainer.renderedColumns track by col.colDef.name" class="ui-grid-cell" ui-grid-cell></div>';
      }

      // Action Cell Template

      function actionCellTemplate(row) {
        return '<div style="text-align: left; padding-left: 10px;"> <a ng-click="grid.appScope.extScope.closeWithSchedule(row.entity)" translate>app.OPEN</a> </div>';
        //return '<div style="text-align: left; padding-left: 10px;"> <a href ui-sref="authenticated.schedule_builder.create_schedules({ id: \'' + row.entity.id +'\' }" translate>app.OPEN</a> </div>';
      }

      /**
       * Schedule Length Field Template
       * @returns {string}
       */
      function lengthCellTemplate() {
        return '<div class="ui-grid-cell-contents"> {{COL_FIELD}}  {{"schedule_builder.DAYS" | translate}} </div>';
      }

      /**
       * Start Date Template
       * @returns {string}
       */
      function dateCellTemplate() {
        return '<div class="ui-grid-cell-contents"> {{COL_FIELD | date: "MM/dd/yyyy"}} </div>';
      }

      function generationCellTemplate() {
        return '<div class="ui-grid-cell-contents"> ' +
          '<span ng-if="row.entity.state ==\'Complete\' && row.entity.completion ==\'OK\' "><i class="fa fa-check"></i></span>' +
          '<span ng-if="row.entity.state ==\'Complete\' && (row.entity.completion ==\'Error\' || row.entity.completion ==\'Aborted\') "><i class="fa fa-remove"></i></span>' +
          '</div>';
      }

      $scope.gridOptions = {
        useExternalSorting: true,  // It will call backend api
        enableColumnResizing: true,
        enableGridMenu: true,
        enableColumnMenus: true,
        gridMenuTitleFilter: $translate, // Translate Grid Menu column name
        columnDefs: angular.copy($scope.columnDef),
        rowTemplate: rowTemplate(), //Row Template
        onRegisterApi: function (gridApi) {
          $scope.gridApi = gridApi;
          $scope.gridApi.core.on.sortChanged($scope, function (grid, sortColumns) {
            if (sortColumns.length === 0) {
              console.log('Impersonation column length : 0');
            }
            else {

              if (sortColumns[0].field == "id") {
                $scope.browser.orderBy = "primaryKey.id";

              }
              else {
                $scope.browser.orderBy = sortColumns[0].field;
              }


              if (sortColumns[0].sort.direction == uiGridConstants.DESC) {
                $scope.browser.orderDir = "DESC";
              }
              else {
                $scope.browser.orderDir = "ASC";
              }

              // search again
              $scope.listSchedules();

            }
          });
        }
      };


      // External Scope Module
      $scope.extScope = {

        closeWithSchedule: function (schedule) {
          console.log('--> Open Schedule' + schedule.name);
          $modalInstance.close(schedule);
        },
        onDblClickRow: function (schedule) {
          // On a double click event , it will move to employee detail page to show employee detail
          $modalInstance.close(schedule);
        }
      };

      // Prepare Page Offset and Limit
      $scope.preparePageParam = function () {

        $scope.browser.offset = ($scope.browser.currentPage - 1) * $scope.browser.pageSize;
        $scope.browser.limit = $scope.browser.pageSize;
      };

      // Keydown event on page user filter input box
      $scope.userFilterKeyDown = function ($event) {

        //detect Enter Key
        if ($event.keyCode == 13) {
          $scope.listSchedules();
        }
      };

      // change page and refresh view
      $scope.pageChanged = function () {
        $scope.listSchedules();
      };

      // Auto Complete List
      $scope.getName = function (val) {


        var filter = "name like '%" + $scope.browser.filterTxt + "%'";

        if (scheduleFilter.length > 0 ){
          filter = filter + ';' + scheduleFilter;
        }

        var params = {
          filter: filter
        };

        var schedulesListUrl = '../emlogis/rest/schedules/ops/query?limit=0';


        return $http.get(schedulesListUrl, {params: params}).then(function (response) {

          var resultSet = factory.toResultSet(response);

          return resultSet.data.map(function (item) {
            return item.name;
          });

        });
      };

      // Call Search function when dialog box loads
      /**
       * Load all schedules and it will be used in selector
       */
      $scope.listSchedules();

    }
  ]);

;
var scheduleBuilder = angular.module('emlogis.schedule_builder');

scheduleBuilder.controller('ScheduleBuilderShiftBiddingBreadcrumbCtrl', ['$scope', 'applicationContext',
    function($scope,applicationContext) {

        console.log('Schedule Builder Shift Bidding breadcrumb controller');

        // These variables are used in entities-list-breadcrumb.js file
//        //$scope.moduleName = "nav.EMPLOYEES";
//        $scope.newEntity = "employees.NEW_EMPLOYEE";
//        $scope.entity = "employees.EMPLOYEE";
//        $scope.entityResource = "employees";

    }
]);

;
var scheduleBuilder = angular.module('emlogis.schedule_builder');

scheduleBuilder.controller('ScheduleBuilderShiftBiddingCtrl',
    [
        '$scope',
        '$state',
        'applicationContext',
        'crudDataService',
        'uiGridConstants',
        function($scope, $state, applicationContext, crudDataService,
                 uiGridConstants  ) {

            console.log('Schedule Builder Shift Bidding controller');

            $scope.tabs[2].active = true;

        }
    ]
);

;
var scheduleBuilder = angular.module('emlogis.schedule_builder');

scheduleBuilder.controller('ScheduleBuilderShiftPatternsBreadcrumbCtrl', ['$scope', 'applicationContext',
    function($scope,applicationContext) {

        console.log('Schedule Builder Shift Patterns breadcrumb controller');


    }
]);

;

var scheduleBuilder = angular.module('emlogis.schedule_builder');
var GENERAL = "GENERAL";
var SPECIFIC = "SPECIFIC";

scheduleBuilder.controller('ScheduleBuilderShiftPatternsCtrl',
  [
    '$scope',
    '$state',
    '$modal',
    '$translate',
    '$http',
    '$q',
    '$timeout',
    'applicationContext',
    'crudDataService',
    'appFunc',
    'dialogs',
    'patternGraph',
    'patternList',
    function(
      $scope, $state, $modal, $translate, $http, $q, $timeout, applicationContext,
      crudDataService,
      appFunc,
      dialogs,
      patternGraph,
      patternList
    ) {

      // const variable
      var MIN_PER_HOUR = 60;
      var demandCellMin = 30;
      var defaultMaxDemandCount = 5;

      // CrudDataService
      var factory = _.clone(crudDataService);

      /**
       * This variable will be used to indicate whether ui is on the process of loading shift patterns or not
       */
      $scope.shiftPatternsLoading = false;

      $scope.minCalendarDate = new Date();

      /**
       * Scope Variables in Shift Pattern
       * 1. $scope.patternCalendar.demandShiftLengths : checkbox which is used when user select demand-based
       * 2. $scope.patternCalendar.currentShiftPattern.demandHeaderItems : contains number of dots in graph for shift demands
       * 3. scaleMin : minutes in one cell in shift demand graph
       * 4. $scope.site.shiftTypes: ShiftTypes which is used for shift pattern generation
       * 5. demandShiftLengths: DemandShiftLengths which can be used
       * 6. $scope.sites: have all sites detailed objects
       * 7. $scope.teams: have teams for selected site which are displaying on dropdown list
       * 8. $scope.allTeams: all teams object
       * 9. $scope.skills: have skills for selected team which are displaying on dropdown list
       * 10. $scope.allSkills: all skills object
       * 11. $scope.shiftPatternDayCollection: shiftPatternHierarcy pattern list table
       * 12: graph: graph related object
       * 13: $scope.site.manualShiftLengths: manual-based pattern: dropdown of shift type of each row
       * 14: $scope.patternCalendar.currentShiftPattern.demands: automatic-based shift pattern demands: circles
       * 15: $scope.patternCalendar.currentShiftPattern.maxDemandCount
       */


      console.log('Schedule Builder Shift Patterns controller');
      angular.element('.eml-top-tabs').scope().tabChecked = true;

      // Activate Shift Pattern tab

      $scope.tabs[1].active = true;

      var graph = null;

      /**
       * Initialize all the variables
       */

      $scope.init = function() {
        $scope.isGenerationProcessActive = false;
        $scope.patternCalendar = patternList.getPatternCalendar();

        // days
        $scope.days = [];
        for (var i=1; i < 31; i++){
          $scope.days.push(i+' days');
        }

        // Create empty current currentShiftPattern and currentShiftPatternDay
        $scope.patternCalendar.currentShiftPattern = {};
        $scope.patternCalendar.currentShiftPatternDay = {};

        /**
         * It contains fir
         * @type {null}
         */
        $scope.patternCalendar.originShiftPattern = {};

        // To be used for shift patterns generation
        $scope.patternCalendar.currentShiftPattern.shifts = []; // Shift value
        $scope.patternCalendar.currentShiftPattern.shiftIds = []; // Shift value
        $scope.patternCalendar.currentShiftPattern.hours = []; // Contains required and excess hours
        $scope.patternCalendar.currentShiftPattern.shiftLengths = [];

        // Set default dayType, cdDate
        $scope.patternCalendar.option = {dayType: GENERAL, cdDate: '', editing: false};

        $scope.graph = patternGraph.getGraph();

        /**
         * This function will also load all detail of sites, teams and skills.
         * And build initial dropdown list
         */

        $scope.site = null;
        $scope.team = null;
        $scope.skill = null;

        loadTreeMetaData()
          .then(function(entities) {
            /**
             * It loads meta data tree structure of site->teams->skills
             */
            $scope.shiftPatternMetaData = entities.data;

            /**
             * Load sites, it will load sites, site Ids are already loaded
             * and this function will add more details info to Sites variable
             */
            return $scope.loadSites();
          })
          .then(function(entities) {

            var sites = [];
            // Filter only name attributes
            for(var i in entities.data) {

              /**
               * get appropriate shiftpatternmetadata
               */
              var siteMeta = null;

              for (var j=0; j<$scope.shiftPatternMetaData.length; j++) {

                if ($scope.shiftPatternMetaData[j].id == entities.data[i].id) {
                  siteMeta =$scope.shiftPatternMetaData[j];
                  break;
                }
              }

              var daysOfWeek = ['SUNDAY', 'MONDAY', 'TUESDAY', 'WEDNESDAY', 'THURSDAY', 'FRIDAY', 'SATURDAY'];

              for (j in daysOfWeek) {
                if (daysOfWeek[j] === entities.data[i].firstDayOfWeek) {
                  break;
                }
              }

              var ticked = false;
              if (parseInt(i) ===0 ) {
                ticked = true;
              }

              sites.push(
                {id: entities.data[i].id, name: entities.data[i].name, ticked: ticked,
                  teams: [], metaData: siteMeta, timeZone: entities.data[i].timeZone,
                  firstDayOfWeek: entities.data[i].firstDayOfWeek,
                  firstDayIntOfWeek: parseInt(j)
                }
              );
            }

            // Save the filtered properties into scope variable: Shift Patterns
            $scope.sites = sites;


              //load all teams
            return $scope.loadAllTeams();

          })
          .then(function(entities) { //teams

            var allTeams = [];
            // Filter only name attributes
            for(var i in entities.data) {

              /**
               * get appropriate shiftpatternMetaData
               */
              var teamMeta = null;
              var site = null;

              for (var j=0; j<$scope.sites.length; j++) {
                site =$scope.sites[j];

                if (site.metaData ===null) {
                  continue;
                }

                for (var k=0; k < site.metaData.children.length; k++) {

                  if (site.metaData.children[k].id == entities.data[i].id) {
                    teamMeta =site.metaData.children[k];
                    break;
                  }
                }

                if (teamMeta !==null) {
                  break;
                }
              }

              var team = {
                id: entities.data[i].id,
                name: entities.data[i].name,
                abbreviation: entities.data[i].abbreviation,
                ticked: false,
                skills: [],
                metaData: teamMeta
              };

              allTeams.push(team);

              //add it to site
              if (site !==null) {
                site.teams.push(team);
              }
            }

            // Save the filtered properties into scope variable
            $scope.allTeams = allTeams;

            //set site
            return $scope.loadAllSkills();

          })
          .then(function(entities) { //entities = skills,

            /**
             * this function will build site->team->skill structure
             * @type {Array}
             */
            var allSkills = [];
            var team= null;
            var skillMeta = null;

            for(var i in entities.data) {

              var skill = null;

              for (var j=0; j<$scope.allTeams.length; j++) {

                team =$scope.allTeams[j];

                if (team.metaData ===null) {
                  continue;
                }

                for (var k=0; k < team.metaData.children.length; k++) {

                  if (team.metaData.children[k].id == entities.data[i].id) {
                    skillMeta =team.metaData.children[k];
                    break;
                  }
                }

                if (skillMeta !==null) { //skill can belong to multiple teams

                  skill = {
                    id: entities.data[i].id,
                    name: entities.data[i].name,
                    abbreviation: entities.data[i].abbreviation,
                    ticked: false
                  };

                  if (skill === null) {
                    allSkills.push(skill);
                  }

                  //add it to site
                  if (team !==null) {
                    team.skills.push(skill);
                  }

                  skillMeta = null; //reset skillMeta

                }
              }


            }

            // Save the filtered properties into scope variable
            $scope.allSkills = allSkills;

            /**
             * select default $scope.team
             */
            if ($scope.site && $scope.site.teams.length > 0) {
              $scope.team =$scope.site.teams[0];
            }


            // Make Default Selection for DropdownList

            $scope.teams = [];
            $scope.skills = [];

            if ($scope.sites.length > 0) {
              $scope.sites[0].ticked = true;
              $scope.site = $scope.sites[0];

              $scope.teams = $scope.site.teams;

              if ($scope.teams.length > 0) {
                $scope.teams[0].ticked = true;
                $scope.team = $scope.teams[0];

                $scope.skills = $scope.team.skills;

                if ($scope.skills.length > 0) {
                  $scope.skills[0].ticked = true;
                  $scope.skill = $scope.skills[0];
                }
              }
            }

            /**
             * remove metaDataVariable from sites,teams,skills after building structure
             * to save memory
             */

            angular.forEach($scope.sites, function(site,key) {

              delete site.metaData;
            });

            angular.forEach($scope.sites, function(site,key) {
              delete site.metaData;
            });

            angular.forEach($scope.allTeams, function(team,key) {
              delete team.metaData;
            });

            angular.forEach($scope.skills, function(skill,key) {
              delete skill.metaData;
            });

           return $scope.loadShiftPatterns(); //load shiftPatterns Meta Data

          })
          .then(function(entities) { // load shift lengths
            return $scope.loadShiftLengths($scope.site);
          })
          .then(function(entities) { //loadshifttypes
            return $scope.loadShiftTypes($scope.site);
          })
          .then(function(entities) { //shift patterns

//            processAssignShiftPatterns();
            patternList.processAssignShiftPatterns({
              site: $scope.site,
              team: $scope.team,
              skill: $scope.skill
            });
            setDefaultPatternInSkill();

          })
          .catch(function(error) {
            applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
          })
        ;

        $scope.patternCalendar.option.patternType = 'Set';
        $scope.optimumCols = 24; // Time frames in dots panel

        /**
         * if true: it will display shiftReqDtos.
         * false: it will display generate shift patterns button
         * @type {boolean}
         */
        $scope.patternCalendar.option.demandPatternGenerated = false;

        // Clear Graph Area
        patternGraph.initializeGridTimes();

        /**
         * requiredHeaderItems: it will be used with automatic
         */

          // Required & Excess
        patternGraph.initializeRequiredHeaderItems();
        patternGraph.initializeExcessHeaderItems();

        patternGraph.emptyGridTimes();


        patternList.clearDemandHeaderItems($scope.patternCalendar.currentShiftPattern);

        /**
         * Max Rows in schedule demand creation, the dots graph
         */
        $scope.patternCalendar.currentShiftPattern.maxDemandCount = 100;

        patternList.clearDemands($scope.patternCalendar.currentShiftPattern, $scope.patternCalendar.currentShiftPattern.maxDemandCount);
        $scope.patternCalendar.option.demandCount = $scope.patternCalendar.currentShiftPattern.maxDemandCount; //default demand Count
        $scope.demandMouseDown = false;


//        // Load all demand based shift lengths
//        factory.getElements("shiftlengths/ops/query?orderby=id&limit=0&hasshifttype=true",{})
//          .then(function(entities){
//            $scope.demandShiftLengths = entities.data;
//          }
//        );

//        patternList.initShiftPatternDayCollection();

        $scope.patternCalendar.currentShiftPattern.excess = 0;
        $scope.patternCalendar.currentShiftPattern.base = 0;

        /**
        * Register call back function, for confirmation Dialog
        */
        var working = applicationContext.getWorking();

        working.option = $scope.patternCalendar.option;
        working.restoreFunc = restoreOriginalShiftPattern;
        working.saveFunc = processSave;
        working.entityName = 'schedule_builder.SHIFT_PATTERNS';

      };

      /**
       * getShiftPattern by patternId,
       * Mostly used for correct shiftpattern indication after loading
       * @param patternId
       * @returns {*}
       */
      function getShiftPatternFromMeta(patternId) {

        var pattern = null;
        angular.forEach($scope.shiftPatterns, function(ele, key) {

          if (ele.id === patternId) {
            pattern = ele;
          }

        });


        return pattern;
      }


      // Update Max Pattern Count per Day

      $scope.updateMaxDayPatternCount = function() {

        $scope.patternCalendar.maxDayPatternCount = 0;

        angular.forEach($scope.shiftPatternDayCollection, function(shiftPatternDay, key) {

          if (shiftPatternDay.patterns.length > $scope.patternCalendar.maxDayPatternCount){
            $scope.patternCalendar.maxDayPatternCount = shiftPatternDay.patterns.length;
          }

        });
      };

     

      // Load sites into dropdown list
      $scope.loadSites = function() {

        // No query parameters, it will show all sites
        return factory.getElements("sites?limit=0&orderby=name&orderdir=ASC",{});

      };

      /**
       * This function is called when user clicks discard button in save the work dialog
       */
      function restoreOriginalShiftPattern() {

        $scope.patternCalendar.option.editing = false;
        angular.copy($scope.patternCalendar.originShiftPattern, $scope.patternCalendar.currentShiftPattern);
        //$scope.patternCalendar.currentShiftPattern.selected = true;
        /**
         * reconfigure shifts: it should be reconfigured
         * @type {Array}
         */
        //$scope.patternCalendar.currentShiftPattern.shifts = [];
        //
        //for (var i in $scope.patternCalendar.originShiftPattern.shifts) {
        //  var shift = $scope.patternCalendar.originShiftPattern.shifts[i];
        //  $scope.patternCalendar.currentShiftPattern.shifts.push(patternList.getShiftType(shift.id));
        //
        //}
        //
        //patternList.processAssignShiftPatterns({
        //  site: $scope.site,
        //  team: $scope.team,
        //  skill: $scope.skill
        //});
        //setDefaultPatternInSkill();
      }



      /**
       * Internal Load Skills Process
       */
      function processLoadingSkills(team, defaultSkill) {

        $scope.skills = team.skills;

        if ( (defaultSkill || null) === null) {
          $scope.skill =null;
        }
        else {
          $scope.skill = findSkillInTeam($scope.team, defaultSkill);
        }


        if ($scope.skill === null && $scope.skills.length > 0) {
          $scope.skill = $scope.skills[0];
        }

        angular.forEach($scope.skills, function(skill, key) {
          skill.ticked = false;
        });

        if ($scope.skill !== null) {
          $scope.skill.ticked = true;
        }

      }

        /**
         * Internal Load Team Process: Shift Pattern
         */
      function processLoadingTeams(site, defaultTeam) {

        $scope.teams = site.teams;
        $scope.team = defaultTeam || null;

        //clear $scope.skills
        $scope.skills = [];

        if (defaultTeam === null && $scope.teams.length > 0) {
          $scope.team = $scope.teams[0];
        }

        angular.forEach($scope.teams, function(team, key) {
          team.ticked = false;
        });

        if ($scope.team !== null) {
          $scope.team.ticked = true;
//          $scope.loadSkills($scope.team);
          processLoadingSkills($scope.team);
        }

        if ($scope.teams.length ===0) {

          patternList.processAssignShiftPatterns({
            cleanOnly: true
          });

          $scope.skill = null;
        }

      }


      /**
       * call this function after dialog box action of save-discard modal
       */
      function assistLoadingTeams (site, defaultTeam) {
        //originalSite = angular.copy($scope.site);

        //originalSkill = angular.copy($scope.skill);
        //originalTeam = angular.copy($scope.team);

        site = findSiteInMetaStructure(site);

        //Load Shift lengths
        $scope.loadShiftLengths(site)
          .then (function () {
            return $scope.loadShiftTypes(site);
          })
          .then(function(entities) {
            patternList.setDefaultOptions();
            processLoadingTeams(site,defaultTeam);
            patternList.processAssignShiftPatterns({
              site: site,
              team: $scope.team,
              skill: $scope.skill
            });
            setDefaultPatternInSkill();

            /**
             * update $scope.site
             * @type {site}
             */
            $scope.site = site;
          });

      }


      /**
       * Load teams into dropdown list  based on the site : Shift Pattern
       * @param site: loads all teams for the site
       * @param defaultTeam: default selection item, if not, first item will be selected, null: it means from UI click
       */
      $scope.loadTeams = function(site, defaultTeam) {


        if ($scope.patternCalendar.option.editing ===  true ) {
          appFunc.getSaveWorkDlg()
            .then(function(reason){

              var working = applicationContext.getWorking();

              /**
               * here we just need Save, we don't need Discard, since it will be reloading anyway
               */
              if (reason === SAVE) {

                /**
                 * Save, and load teams
                 */
                //patternList.setDefaultOptions();
                //
                //return saveOnModalFromChangingFilters(originalSite, originalTeam, originalSkill);

                working.saveFunc(site, $scope.team, $scope.skill)
                  .then(function(result) {
                    assistLoadingTeams(site, defaultTeam);
                  }, function(error) {
                    //do nothing.
                  });

              }
              else if (reason === DISCARD) {
                /**
                 * Rollback current pattern and proceed
                 */
                $scope.patternCalendar.option.editing = false;
                //patternList.setDefaultOptions();
                restoreOriginalShiftPattern();
                assistLoadingTeams(site, defaultTeam);

              }


            }, function(reason) {
              /**
               * It is cancellation.
               * Just rollback site checking option
               */
              restoreSite($scope.site);

              console.log('dismissed');
            });
        }
        else {
          assistLoadingTeams(site, defaultTeam);
        }



        /**
         * This value will be used when user click 'cancel' in save work dialog box
         */
        //var originalSite = angular.copy($scope.site);
        //$scope.site = findSiteInMetaStructure(site);
        //var originalSkill = angular.copy($scope.skill);
        //var originalTeam = angular.copy($scope.team);
        //
        ////Load Shift lengths
        //$scope.loadShiftLengths($scope.site)
        //  .then (function () {
        //    return $scope.loadShiftTypes($scope.site);
        //  })
        //  .then(function(entities) {
        //    patternList.setDefaultOptions();
        //    processLoadingTeams($scope.site,defaultTeam);
        //    patternList.processAssignShiftPatterns({
        //      site: $scope.site,
        //      team: $scope.team,
        //      skill: $scope.skill
        //    });
        //    setDefaultPatternInSkill();
        //
        //  });
      };

      /**
       * Load all teams, mostly called at initialization process
       */
      $scope.loadAllTeams = function() {

        return factory.getElements('teams?limit=0&orderby=name&orderdir=ASC',{});

      };

      /**
       * Load all skills, mostly called at initialization process
       */
      $scope.loadAllSkills = function() {

        return factory.getElements('skills?limit=0&orderby=name&orderdir=ASC&filter=isActive=true',{});

      };


      /**
      * Load skills into dropdown list based on the team : ShiftPattern
      * @param team: loads all skills for the team
      * @param defaultSkill: default selection item, if not, first item will be selected, if null it is from UI Click
      */
      $scope.loadSkills = function(team, defaultSkill) {

        /**
         * This value will be used when user click 'cancel' in save work dialog box
         */

        var originalSite = angular.copy($scope.site);
        var originalSkill = angular.copy($scope.skill);
        var originalTeam = angular.copy($scope.team);

        /**
         * assign scope team variable
         */
        $scope.team = findTeam(team.id);

        /**
         * check shiftpattern editing status
         */
        if (defaultSkill === null && $scope.patternCalendar.option.editing) {

          appFunc.getSaveWorkDlg()
            .then(function(reason){

              var working = applicationContext.getWorking();

              /**
               * here we just need Save, we don't need Discard, since it will be reloading anyway
               */
              if (reason === SAVE) {

                  /**
                   * Save, it will refresh every pattern.
                   */
                  patternList.setDefaultOptions();
                return saveOnModalFromChangingFilters(originalSite, originalTeam, originalSkill);


              }
              else if (reason === DISCARD) {
                $scope.patternCalendar.option.editing = false;
                /**
                 * Rollback current pattern and proceed
                 */
                restoreOriginalShiftPattern();
                patternList.setDefaultOptions();
                processLoadingSkills(team, defaultSkill);

                patternList.processAssignShiftPatterns({
                  site: $scope.site,
                  team: $scope.team,
                  skill: $scope.skill
                });
                setDefaultPatternInSkill();

              }


          }, function(reason) {
            /**
             * It is cancellation.
             * Just rollback site checking option
             */
            restoreTeam(originalTeam);
            console.log('dismissed');
          });

          return;

        }
        else {
          patternList.setDefaultOptions();
        }

        processLoadingSkills(team, defaultSkill);

        patternList.processAssignShiftPatterns({
          site: $scope.site,
          team: $scope.team,
          skill: $scope.skill
        });
        setDefaultPatternInSkill();


      };


      /**
       * Load Shift Patterns into tree dropdown list, This is related to db,
       * build tree structure
       * It  contains metadata of shift patterns
       * Each shift pattern contains no shiftReqDto
       */
      $scope.loadShiftPatterns = function() {

        var deferred = $q.defer();
        $scope.shiftPatterns = [];
        $scope.shiftPatternsLoading = true;

        // No query parameters, it will show all shift patterns
        return factory.getElements("shiftpatterns/list?limit=0&orderby=name&orderdir=ASC",{})
          .then(function(entities){

            // set proper key & values;
            angular.forEach(entities.data, function(shift, key) {
              shift.id = shift.shiftPatternId;
              shift.name = shift.shiftPatternName;

              if (shift.shiftPatternCdDate) {
                shift.shiftPatternCdDate = appFunc.convertToBrowserTimezone(shift.shiftPatternCdDate, $scope.site.timeZone);
              }

              delete shift.shiftPatternId;
              delete shift.shiftPatternName;
            });


            /**
             * Check scope skills are loaded if not wait.
             * Skills are last node in site->team->skills, if it has value sites,teams variables have value
             */
            if ($scope.skills) {
              buildShiftPatternsTree(entities.data);
            }
            else {
              /**
               * Wait for skills variable becomes active
               */
              var skillsListener = $scope.$watch('skills', function(newValue, oldValue) {

                if ((typeof newValue !== 'undefined') && (typeof oldValue === 'undefined')) {
                  buildShiftPatternsTree(entities.data);

                  //destroy watch
                  skillsListener();
                }
                else {
                  return;
                }

              });
            }


            // Save the filtered properties into scope variable
            $scope.shiftPatterns = entities.data;
            $scope.shiftPatternsLoading = false;

          });
      };

        // Load Shift Types Names into dropdown list
      $scope.loadShiftTypes = function(site) {


        var deferred = $q.defer();

        if ((site || null) === null) {
          //returns empty array
          deferred.resolve([]);
          return deferred.promise;
        }
        else if ((site.shiftTypes || null) ===null ) {

          // No query parameters, it will show all sites
          return factory.getElements('sites/' + site.id +'/shifttypes?limit=0&orderby=shiftLength.lengthInMin&orderdir=ASC',{})
            .then(function(entities){

              var shiftTypes = [];
              var ticked = true;

              // Save the filtered properties into scope variable
              site.shiftTypes = entities.data;

              // This code should be removed, adding manual start point

              angular.forEach(site.shiftTypes, function(shift, key) {

                /**
                 * StartTime is in longValue (miliseconds)
                 *
                 * @type {number}
                 */
                shift.start = shift.startTime / 1000 / 60 / 60;
                /**
                 * Start, End time scale will be displayed like 12:00 Am, 4:30PM ,etc
                 */
                shift.startHourStr = $scope.getTimeString(shift.start);
                shift.endHourStr = $scope.getTimeString(shift.start + shift.shiftLengthLength / MIN_PER_HOUR);

              });

              /*
               Used to parse to shift pattern list directive, it should be wrapped inside JSON
               */
              $scope.patternCalendar.option.shiftTypes = site.shiftTypes;

            });
        }
        else {
          //restore pattern calendar
          $scope.patternCalendar.option.shiftTypes = site.shiftTypes;
          deferred.resolve( site.shiftTypes);
          return deferred.promise;
        }



      };

      /**
       * load Shift lengths of the site, if it is already loaded skip
       */

      $scope.loadShiftLengths = function(site) {

        var deferred = $q.defer();

        if ((site || null) === null) {
          deferred.resolve([]);
          return deferred.promise;
        }
        else if ((site.manualShiftLengths || null) === null ) {

          // No query parameters, it will show all shift patterns
          return factory.getElements('sites/' + site.id +'/shiftlengths?limit=0&orderby=lengthInMin&orderdir=ASC',{})
            .then(function(entities){
              $scope.patternCalendar.demandShiftLengths = entities.data;
              site.manualShiftLengths = angular.copy(entities.data);
              $scope.patternCalendar.option.manualShiftLengths = site.manualShiftLengths;
            });
        }
        else {
          // update pattern calendar and option
          $scope.patternCalendar.demandShiftLengths = angular.copy(site.manualShiftLengths);
          $scope.patternCalendar.option.manualShiftLengths = site.manualShiftLengths;

          deferred.resolve([]);
          return deferred.promise;
        }
      };

      $scope.getTimeString = function (scale){

        // set default date
        var dt = new Date(214,1,1,0,0,0);
        var newDateObj = new Date(dt.getTime() + scale * 60 * 60 * 1000); // add by hours
        return _.strftime (newDateObj, '%I:%M %p');

      };

      $scope.getShiftLengthTimeString = function(shiftLengthObj) {
        var lengthInMinutes = parseInt(shiftLengthObj.lengthInMin);
        if(isNaN(lengthInMinutes) || lengthInMinutes === 0) {
          return shiftLengthObj.name;
        }
        var timeString = parseFloat(lengthInMinutes/60).toFixed(1);

        return timeString;
      };

      // Shows start date dialog box
      $scope.showDate = function($event) {
        $event.preventDefault();
        $event.stopPropagation();

        $scope.cdDateOpened = true;
      };



      //calculate base,net and excess
      $scope.calculateTotals = function() {

        $scope.patternCalendar.currentShiftPattern.base = 0;
        $scope.patternCalendar.currentShiftPattern.excess = 0;
        $scope.patternCalendar.currentShiftPattern.resources = 0;

        if (!$scope.patternCalendar.currentShiftPattern.shifts) {
          return;
        }
        for (var i = 0; i < $scope.patternCalendar.currentShiftPattern.shifts.length; i++) {
          var ele = $scope.patternCalendar.currentShiftPattern.shifts[i];
          if (!ele || !ele.id)
              continue;
          var hour = $scope.patternCalendar.currentShiftPattern.hours[i];
          $scope.patternCalendar.currentShiftPattern.base +=  hour.required * ele.shiftLengthLength / MIN_PER_HOUR;
          $scope.patternCalendar.currentShiftPattern.excess +=  hour.excess * ele.shiftLengthLength / MIN_PER_HOUR;
          $scope.patternCalendar.currentShiftPattern.resources += hour.required + hour.excess;
        }
      };


      // Add one Shift
      $scope.addShift = function() {

        // check all existing shifts are valid
        for (var i = 0; i < $scope.patternCalendar.currentShiftPattern.shifts.length; i++) {
          var shift = $scope.patternCalendar.currentShiftPattern.shifts[i];
          var hour = $scope.patternCalendar.currentShiftPattern.hours[i];

          if (!shift || !shift.id) {
            applicationContext.setNotificationMsgWithValues('schedule_builder.PLEASE_SELECT_VALID_SHIFT_VALUES', '', true);
            return;
          }

          if (!hour || hour.required <= 0 ) {
            applicationContext.setNotificationMsgWithValues('schedule_builder.PLEASE_SELECT_VALID_HOUR_VALUES', '', true);
            return;
          }


        }
        if ($scope.patternCalendar.option.editing !== true) {
          $scope.patternCalendar.option.editing = true;
        }

        $scope.patternCalendar.currentShiftPattern.shifts.push({});
        $scope.patternCalendar.currentShiftPattern.shiftIds.push('');
        $scope.patternCalendar.currentShiftPattern.shiftLengths.push({});
        $scope.patternCalendar.currentShiftPattern.hours.push({'required': 1, 'excess': 0});
      };

      // Remove current Shift
      $scope.removeShift = function($index) {
        if ($scope.patternCalendar.option.editing !== true) {
          $scope.patternCalendar.option.editing = true;
        }
        $scope.patternCalendar.currentShiftPattern.shifts.splice($index, 1);
        $scope.patternCalendar.currentShiftPattern.shiftIds.splice($index, 1);
        $scope.patternCalendar.currentShiftPattern.hours.splice($index, 1);
        $scope.patternCalendar.currentShiftPattern.shiftLengths.splice($index, 1);
      };

      // Get Current Skill Id
      function getSkill() {

        for (var i = 0; i < $scope.skills.length; i++) {
          var ele = $scope.skills[i];
          if (ele.ticked === true) {
            return ele;
          }
        }
      }

      // Get Current Team Id
      function getTeam() {

        for (var i = 0; i < $scope.teams.length; i++) {
          var ele = $scope.teams[i];
          if (ele.ticked === true) {
            return ele;
          }
        }
      }

      /**
       * update skill dropdown list
       * @param skill
       */
      function setSkillFilter(skill) {

        angular.forEach($scope.skills, function(ele) {
          if (ele.id == skill.id) {
            ele.ticked = true;
          }
          else {
            ele.ticked = false;
          }
        });
      }

      /**
       * update team dropdown list
       * @param team
       */
      function setTeamFilter(team) {

        angular.forEach($scope.teams, function(ele) {
          if (ele.id == team.id) {
            ele.ticked = true;
          }
          else {
            ele.ticked = false;
          }
        });
      }

        /**
         * Update Site Dropdown List
         * @param site
         */

      function setSiteFilter(site) {

        angular.forEach($scope.sites, function(ele) {
          if (ele.id == site.id) {
            ele.ticked = true;
          }
          else {
            ele.ticked = false;
          }
        });
      }


      /**
       * Shift Pattern Save:
       * @param site:
       * @param team: if not specified, scope.team will be used
       * @param skill: if not specified, scope.skill will be used
       */
      $scope.save = function(site, team,skill) {

        var deferred = $q.defer();

        processSave(site,team,skill)
          .then(function (result) {
            //update
            if ($scope.patternCalendar.currentShiftPattern.id) {
              $scope.patternCalendar.option.editing = false; //initialize the option editing variable

              applicationContext.setNotificationMsgWithValues($scope.patternCalendar.currentShiftPattern.name + ' build', 'success', true);
              console.log("ShiftPattern Updated : " + $scope.patternCalendar.currentShiftPattern.id);
            }
            else {

              $scope.patternCalendar.currentShiftPattern.id = result.id;
              result.shifts = [];
              result.shiftIds = [];
              result.hours = [];


              applicationContext.setNotificationMsgWithValues(result.name + ' build', 'success', true);
              console.log("ShiftPattern Saved : " + result.id);
            }

            /**
             * // Reload shift patterns and filters
             * This function initialize shift patterns variable
             */
            return $scope.loadShiftPatterns()
              .then(function(entities) {

                $scope.patternCalendar.option.editing = false;

                processUpdatingShiftPatternFilters($scope.site, $scope.team, $scope.skill);

                if ($scope.patternCalendar.currentShiftPattern.id) {
                  var cur = getShiftPatternFromMeta($scope.patternCalendar.currentShiftPattern.id);
                  if (cur !== null) {
                    if (cur.shiftPatternCdDate !==null) {
                      $scope.patternCalendar.currentShiftPatternDay = patternList.getShiftPatternDay(cur.shiftPatternCdDate, SPECIFIC, $scope.site.firstDayIntOfWeek);
                    }
                    else {
                      $scope.patternCalendar.currentShiftPatternDay = patternList.getShiftPatternDay(cur.shiftPatternDayOfWeek, GENERAL);
                    }

                    patternList.selectShiftPattern(cur);
                  }
                }

              });

          });

//        if (!$scope.patternCalendar.currentShiftPatternDay.day) {
//          applicationContext.setNotificationMsgWithValues('schedule_builder.PLEASE_ADD_SHIFT_PATTERN_UNDER_SPECIFIC_DAY', '', true);
//          deferred.reject('Error');
//          return deferred.promise;
//        }
//
//        /**
//         * these variables are using in update/save scenario
//         */
//        var i,shift,hour,dt, dtFormat;
//        var shiftLengths = [];
//        var ele = null;
//
//        /**
//         * Check whether it contains null shift
//         */
//        var nullShift = _.find(
//          $scope.patternCalendar.currentShiftPattern.shifts, function(shift){
//            return shift === null || !shift.id;
//          }
//        );
//
//        if (typeof nullShift !== 'undefined' && $scope.patternCalendar.currentShiftPattern.shifts.length>0) {
//          applicationContext.setNotificationMsgWithValues('schedule_builder.PLEASE_SELECT_A_SHIFT', '', true);
//          deferred.reject('Error');
//          return deferred.promise;
//        }
//
//
//        var emptyHour = _.find(
//          $scope.patternCalendar.currentShiftPattern.hours, function(hour){
//            return hour === null || hour.required<=0 || hour.excess<0;
//          }
//        );
//
//        if (typeof emptyHour !== 'undefined' && $scope.patternCalendar.currentShiftPattern.hours.length>0) {
//          applicationContext.setNotificationMsgWithValues('schedule_builder.PLEASE_SPECIFY_VALID_HOURS', '', true);
//          deferred.reject('Error');
//          return deferred.promise;
//        }
//
//        if ($scope.patternCalendar.currentShiftPattern.id) {
//          /**
//           * User can not update specific date nor day in general day
//           */
//          var updateDto = {
//            name: $scope.patternCalendar.currentShiftPattern.name,
//            shiftReqDtos: $scope.patternCalendar.currentShiftPattern.shiftReqDtos
//          };
//
//          if ($scope.patternCalendar.option.dayType === 'GENERAL') {
//            updateDto.dayOfWeek = $scope.patternCalendar.currentShiftPatternDay.day;
//          }
//          else {
//            if (!$scope.patternCalendar.option.cdDate) {
//              applicationContext.setNotificationMsgWithValues('schedule_builder.PLEASE_SPECIFY_SPECIFIC_DATE', '', true );
//              deferred.reject('Error');
//              return deferred.promise;
//            }
//
//            updateDto.cdDate = appFunc.getDateWithTimezone(
//              $scope.patternCalendar.option.cdDate.getFullYear(),
//              $scope.patternCalendar.option.cdDate.getMonth(),
//              $scope.patternCalendar.option.cdDate.getDate(),
//              $scope.site.timeZone
//            ).getTime();
//
//          }
//
//          if ($scope.patternCalendar.option.patternType === 'Demand') { //demand based
//            updateDto.type = 'Demand';
//
//            /**
//             * build shiftLengthList
//             */
//            shiftLengths = [];
//            ele = null;
//
//            for (i in $scope.patternCalendar.demandShiftLengths) {
//              ele = $scope.patternCalendar.demandShiftLengths[i];
//              if (ele.checked === true) {
//                shiftLengths.push(ele.id);
//              }
//            }
//
//            updateDto.shiftLengthList = shiftLengths.join();
//
//            /**
//             * build shiftDemandDtos
//             */
//            updateDto.shiftDemandDtos = [];
//            fo// r (i in $scope.patternCalendar.currentShiftPattern.demandHeaderItems) {
//              ele = $scope.patternCalendar.currentShiftPattern.demandHeaderItems[i];
//              if (ele.value > 0) {
//                updateDto.shiftDemandDtos.push(
//                  {
//                    "startTime": i* demandCellMin * 60 * 1000,
//                    "lengthInMin" : demandCellMin,
//                    "employeeCount": ele.value
//                  }
//                );
//              }
//            }
//
//          }
//          else {
//            //Manual Based Pattern
//            updateDto.type = 'Set';
//            updateDto.shiftReqDtos = [];
//
//            /**
//             * build shiftReqDto for shift pattern
//             */
//            for (i in $scope.patternCalendar.currentShiftPattern.shifts) {
//              shift = $scope.patternCalendar.currentShiftPattern.shifts[i];
//              hour = $scope.patternCalendar.currentShiftPattern.hours[i];
//              updateDto.shiftReqDtos.push({
//                'employeeCount': hour.required,
//                'excessCount': hour.excess,
//                'shiftTypeId': shift.id
//              });
//            }
//          }
//
//          $scope.patternCalendar.option.editing = false; //initialize the option editing variable
//
//          return factory.updateElement('shiftpatterns',$scope.patternCalendar.currentShiftPattern.id, updateDto)
//            .then(function (result){
//
////            $scope.patternCalendar.currentShiftPattern = result;
//              console.log("ShiftPattern Updated : " + result.id);
//
//              applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', '', true , result.name);
//              /**
//               * This function initialize shift patterns variable
//               */
//              return $scope.loadShiftPatterns()
//                .then(function() {
//
//                  $scope.patternCalendar.option.editing = false;
//
//                  processUpdatingShiftPatternFilters(site, $scope.team, $scope.skill);
//
//                  if ($scope.patternCalendar.currentShiftPattern.id) {
//                    var cur = getShiftPatternFromMeta($scope.patternCalendar.currentShiftPattern.id);
//                    if (cur !== null) {
//                      patternList.selectShiftPattern(cur);
//                    }
//                  }
//
//                });
//
//
//            }, function (error) {
//              console.log(error);
//
//              applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
//              deferred.reject('Error');
//              return deferred.promise;
//            });
//
//        }
//        else {
//          /*
//          Create ShiftPattern on db
//           */
//          if (!team) {
//            team = getTeam();
//          }
//
//          if (!skill) {
//            skill = getSkill();
//          }
//
//          if (!skill) {
//            applicationContext.setNotificationMsgWithValues('schedule_builder.PLEASE_SELECT_A_SKILL', '', true);
//            deferred.reject('Error');
//            return deferred.promise;
//
//          }
//
//          var dto = {
//            skillId: skill.id,
//            teamId: team.id,
//            name : $scope.patternCalendar.currentShiftPattern.name,
//            updateDto: {
//              description : '',
//              shiftReqDtos: []
//            }
//          };
//
//          /**
//           * Put cdDate and dayOfWeek
//           */
//          if ($scope.patternCalendar.option.dayType === 'SPECIFIC') {
//            if (!$scope.patternCalendar.option.cdDate) {
//              applicationContext.setNotificationMsgWithValues('schedule_builder.PLEASE_SPECIFY_SPECIFIC_DATE', '', true );
//              deferred.reject('Error');
//              return deferred.promise;
//            }
//
//            /**
//             * Save the cdDate with site timezone
//             */
//            dto.updateDto.cdDate = appFunc.getDateWithTimezone(
//              $scope.patternCalendar.option.cdDate.getFullYear(),
//              $scope.patternCalendar.option.cdDate.getMonth(),
//              $scope.patternCalendar.option.cdDate.getDate(),
//              $scope.site.timeZone
//            ).getTime();
//
//          }
//          else {
//            dto.updateDto.dayOfWeek = $scope.patternCalendar.currentShiftPatternDay.day;
//          }
//
//          /**
//           * Prepare param for creation for demand based and manual pattern
//           */
//          if ($scope.patternCalendar.option.patternType === 'Demand') { //demand based
//
//            dto.updateDto.type = 'Demand';
//
//            /**
//             * build shiftLengthList
//             */
//            shiftLengths = [];
//            ele = null;
//
//            for (i in $scope.patternCalendar.demandShiftLengths) {
//              ele = $scope.pat ternCalendar.demandShiftLengths[i];
//              if (ele.checked === true) {
//                shiftLengths.push(ele.id);
//              }
//            }
//
//            dto.updateDto.shiftLengthList = shiftLengths.join();
//
//            /**
//             * build shiftDemandDtos
//             */
//            dto.updateDto.shiftDemandDtos = [];
//            for (i in $scope.patternCalendar.currentShiftPattern.demandHeaderItems) {
//              ele = $scope.patternCalendar.currentShiftPattern.demandHeaderItems[i];
//              if (ele.value > 0) {
//                dto.updateDto.shiftDemandDtos.push(
//                  {
//                    "startTime": i* demandCellMin * 60 * 1000,
//                    "lengthInMin" : demandCellMin,
//                    "employeeCount": ele.value
//                  }
//                );
//              }
//            }
//
//            //"shiftDemandDtos":[{"startTime":0, "lengthInMin":30, "employeeCount":1}
//
//
//          }
//          else { // Manual Shift Pattern
//            dto.updateDto.type = 'Set';
//
//            /**
//             * build shiftReqDto for shift pattern
//             */
//            dto.updateDto.shiftReqDtos = [];
//            for (i in $scope.patternCalendar.currentShiftPattern.shifts) {
//              shift = $scope.patternCalendar.currentShiftPattern.shifts[i];
//              hour = $scope.patternCalendar.currentShiftPattern.hours[i];
//              dto.updateDto.shiftReqDtos.push({
//                'employeeCount': hour.required,
//                'excessCount': hour.excess,
//                'shiftTypeId': shift.id
//              });
//            }
//
//          }
//
//          $scope.patternCalendar.option.editing = false; //initialize the option editing variable
//          return factory.createElement('shiftpatterns',dto)
//            .then(function (result){
//
//              $scope.patternCalendar.currentShiftPattern.id = result.id;
//              result.shifts = [];
//              result.shiftIds = [];
//              result.hours = [];
//
//              // Reload shift patterns and filters
//
//              applicationContext.setNotificationMsgWithValues(result.name + ' build', '', true);
//              console.log("ShiftPattern Saved : " + result.id);
//              /**
//               * This function initialize shift patterns variable
//               */
//              return $scope.loadShiftPatterns()
//                .then(function(entities) {
//
//                  $scope.patternCalendar.option.editing = false;
//
//                  processUpdatingShiftPatternFilters($scope.site, $scope.team, $scope.skill);
//
//                  if ($scope.patternCalendar.currentShiftPattern.id) {
//                    var cur = getShiftPatternFromMeta($scope.patternCalendar.currentShiftPattern.id);
//                    if (cur !== null) {
//                      patternList.selectShiftPattern(cur);
//                    }
//                  }
//
//                });
//
//
//
//            }, function (error) {
//              applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
//              deferred.reject('gError');
//              return deferred.promise;
//            });
//        }
      };

      /**
       * Delete Current Shift Pattazern
       */
      $scope.delete = function() {
        if (typeof $scope.patternCalendar.currentShiftPattern.name === 'undefined') {
          applicationContext.setNotificationMsgWithValues('schedule_builder.PLEASE_CREATE_ONE_SHIFT_PATTERN', '', true);
          return;
        }

        var dlg = dialogs.confirm('Please Confirm','Do you really want to delete shift pattern ' + $scope.patternCalendar.currentShiftPattern.name +'?');

        dlg.result.then(function(btn){

          if ($scope.patternCalendar.currentShiftPattern.id) {

            factory.deleteElement('shiftpatterns', $scope.patternCalendar.currentShiftPattern.id)
              .then(function (result) {
                console.log('delete shiftpattern id:' + $scope.patternCalendar.currentShiftPattern.id + " :result " + result);
                applicationContext.setNotificationMsgWithValues('app.DELETED_SUCCESSFULLY','success',true);

                /**
                 * This function initialize shift patterns variable
                 */
                $scope.loadShiftPatterns()
                  .then(function() {
                    $scope.patternCalendar.option.editing = false;

                    processUpdatingShiftPatternFilters($scope.site, $scope.team, $scope.skill);

                    setDefaultPatternInSkill();

                  });

              }, function (error) {
                console.log(error);
                applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
              });
          }
          else {
            applicationContext.setNotificationMsgWithValues('Deleted on the browser', '', true);

            // refresh grid
            patternList.processAssignShiftPatterns({
              site: $scope.site,
              team: $scope.team,
              skill: $scope.skill
            });

            setDefaultPatternInSkill();
          }


        },function(btn){
          console.log("entity not deleted");
        });

      };

      /**
       * On Click Action on the shift graph
       * Listens an event
       * @param shift
       */
      $scope.selectShiftInGraph = function(shift) {

        if (!shift.id)
          return false;

        var dlg = $modal.open({
          templateUrl: 'modules/schedule_builder/partials/schedule_builder_shift_pattern_shift_graph_modal.html',
          windowClass: 'schedule-builder',
          controller: function($scope, $modalInstance, shift, hours) {

            $scope.isModalOpen = true;
            $scope.shift = shift;
            $scope.required = shift.required;
            $scope.excess = shift.excess;

            // When we go to login page we have to dismiss the modal.
            $scope.$on('event:auth-loginRequired', function () {

              //if ($scope.isModalOpen === true){
              $modalInstance.dismiss('cancel');
              //  $scope.isModalOpen = false;
              //}

            });

            // Update Shift in select-shift as well as in graph
            $scope.update = function(shift) {
              hours[shift.index].required = $scope.required;
              hours[shift.index].excess = $scope.excess;
              $modalInstance.close('update');
            };

            // Close Modal
            $scope.close = function(){
              $modalInstance.dismiss('cancel');
            };

            /**
             * In ShiftPattern Graph Modal Dialog
             */
            $scope.filterZero = function(evt) {

              var elem = null;

              if (evt.which !== 48 && evt.which !== 96) {
                return;
              }

              if (evt.srcElement)
                elem = evt.srcElement;
              else if (evt.target)
                elem = evt.target;

              if (elem !== null ){
                if (elem.value.indexOf('0') === 0) {
                  elem.value = Math.abs(parseInt(elem.value)) || 0;
                }
              }

            };

            /**
             *
             * updateShiftHours: In ShiftPattern Graph Modal Dialog
             */
            $scope.updateShiftHours = function() {

              $scope.required = Math.abs(parseInt($scope.required)) || 0;
              $scope.excess = Math.abs(parseInt($scope.excess)) || 0;

            };


          },
          resolve: {
            shift: function() {
              return shift;
            },
            hours: function() {
              return $scope.patternCalendar.currentShiftPattern.hours;
            }
          }

        });

        dlg.result.then(function(result){
          console.log(result);
          // Update graph
          patternList.generateShiftPattern();

        }, function(reason) {
          console.log('dismissed');
        });
      };

      function processUpdatingShiftPatternFilters(site, team, skill) {

        /**
         * update drop down lists
         */

        processLoadingTeams(site,team);
        processLoadingSkills(team,skill);
        //setSiteFilter(site);

        patternList.processAssignShiftPatterns({
          site: site,
          team: $scope.team,
          skill: $scope.skill
        });

      }
      /**
       * Update the filter parameters and refresh the grid from tree panel
       * @param site
       * @param team
       * @param skill
       */
      $scope.updateShiftPatternFilters = function (site, team, skill) {


        // if try to load same site,team,skill then reject
        if ($scope.site === site && $scope.team === team && $scope.skill === skill) {
          return;
        }

        if ($scope.patternCalendar.option.editing) {

          appFunc.getSaveWorkDlg()
            .then(function(reason){

              var working = applicationContext.getWorking();

              /**
               * here we just need Save, we don't need Discard, since it will be reloading anyway
               */
              if (reason === SAVE) {

                working.saveFunc($scope.site, $scope.team, $scope.skill)
                  .then(function(result) {
                    $scope.patternCalendar.option.editing = false;
                    assistUpdatingShiftPatternFilters(site, team, skill);

                  }, function(error) {
                    //do nothing.
                  });

              }
              else if (reason === DISCARD) {
                /**
                 * Rollback current pattern and proceed
                 */
                $scope.patternCalendar.option.editing = false;
                restoreOriginalShiftPattern();
                assistUpdatingShiftPatternFilters(site, team, skill);
              }


            }, function(reason) {
              /**
               * It is cancellation.
               * Just rollback site checking option
               */
              console.log('dismissed');
            });

        }
        else {
          assistUpdatingShiftPatternFilters(site, team, skill);
        }

      };


      /**
       * assist function of update shift pattern filters
       */
      function assistUpdatingShiftPatternFilters (site, team, skill) {


        /**
         * should load shiftlengths and shifttypes
         */
        $scope.loadShiftLengths(site)
          .then (function () {
            return $scope.loadShiftTypes(site);
          })
          .then(function() {
            $scope.team = team;
            $scope.skill = skill;


            processUpdatingShiftPatternFilters(site, team, skill);
            setSiteFilter(site);
            /**
             * Select default pattern
             */
            $scope.site = site;
            setDefaultPatternInSkill();

          });
      }

        // Duplicate current Shift Pattern
      $scope.duplicateShiftPattern = function () {

        if (!$scope.patternCalendar.currentShiftPattern.id) {
          applicationContext.setNotificationMsgWithValues('schedule_builder.PLEASE_CREATE_ONE_SHIFT_PATTERN', '', true);
          return;
        }

        var generalDays = [
          {id: 'Sunday', display: 'calendar.SUNDAY', checked: false},
          {id: 'Monday', display: 'calendar.MONDAY', checked: false},
          {id: 'Tuesday', display: 'calendar.TUESDAY', checked: false},
          {id: 'Wednesday', display: 'calendar.WEDNESDAY', checked: false},
          {id: 'Thursday', display: 'calendar.THURSDAY', checked: false},
          {id: 'Friday', display: 'calendar.FRIDAY', checked: false},
          {id: 'Saturday', display: 'calendar.SATURDAY', checked: false}
        ];

        /**
         * generalDays: Comma separated strings, cdDate: specificDate
         */
        var duplicate = {generalDays: '', cdDate: '', type: 'GENERAL'};

        var dlg = $modal.open({
          templateUrl: 'modules/schedule_builder/partials/schedule_builder_shift_pattern_duplicate_modal.html',
          windowClass: 'schedule-builder',
          controller: function($scope, $modalInstance, generalDays, duplicate) {

            $scope.generalDays = generalDays;
            $scope.duplicate = duplicate;

            // When we go to login page we have to dismiss the modal.
            $scope.$on('event:auth-loginRequired', function () {
                $modalInstance.dismiss('cancel');
            });

            $scope.open = function($event) {
                $event.preventDefault();
                $event.stopPropagation();
                $scope.dateOpened = true;
            };

            $scope.selectedGeneralDays = function () {

              var tmpArray = [];
              for (var i in generalDays) {
                var ele = generalDays[i];
                if (ele.checked === true) {
                  tmpArray.push(ele.id);
                }
              }

              duplicate.generalDays = tmpArray.join();
            };

            // DuplicateAction
            $scope.duplicateAction = function() {
              $modalInstance.close('duplicate');
            };

            // Close Modal
            $scope.close = function(){
              $modalInstance.dismiss('cancel');
            };

          },
          resolve: {
            generalDays: function() {
              return generalDays;
            },
            duplicate: function() {
              return duplicate;
            }
          }

        });

        dlg.result.then(function(reason) {
          //shiftpatterns/{patternId}/ops/duplicate
          var url = applicationContext.getBaseRestUrl() + 'shiftpatterns/' + $scope.patternCalendar.currentShiftPattern.id + '/ops/duplicate';
          var dto = {days:'', cdDate: 0};


          if (duplicate.type === GENERAL) {
              dto.days = duplicate.generalDays;
          }
          else {
              dto.cdDate = duplicate.cdDate.getTime();
          }

          $http.post(url,dto)
            .success(function(data) {
              applicationContext.setNotificationMsgWithValues('schedule_builder.DUPLICATED_SUCCESSFULLY', '', true , $scope.patternCalendar.currentShiftPattern.name);

              /**
               * This function initialize shift patterns variable
               */
              $scope.loadShiftPatterns()
                .then(function() {
                  $scope.patternCalendar.option.editing = false;

                  processUpdatingShiftPatternFilters($scope.site, $scope.team, $scope.skill);

                  if ($scope.patternCalendar.currentShiftPattern.id) {
                    var cur = getShiftPatternFromMeta($scope.patternCalendar.currentShiftPattern.id);
                    if (cur !== null) {
                      patternList.selectShiftPattern(cur);
                    }
                  }

                });

            })
            .error(function(error) {
                applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
            });

        }, function(reason) {
            console.log('dismissed');
        });

      };

      /**
       * It will generate pattern name following some rules
       */
      $scope.genDefaultName = function() {

        /**
         * Check whether it contains null shift
         */
        var nullShift = _.find(
          $scope.patternCalendar.currentShiftPattern.shifts, function(shift){
            return shift === null || !shift.id;
          }
        );

        if(typeof nullShift  !== "undefined" && $scope.patternCalendar.currentShiftPattern.shifts.length>0) {
          applicationContext.setNotificationMsgWithValues('schedule_builder.PLEASE_SELECT_A_SHIFT', '', true);
          return;
        }

        if ($scope.patternCalendar.option.editing !== true) {
          $scope.patternCalendar.option.editing = true;
        }

        var minStartTime = null, maxEndTime = null;
        var shifts = $scope.patternCalendar.currentShiftPattern.shifts;

        if (shifts.length > 0) {

          if (shifts[0] !==null && typeof shifts[0].start !== 'undefined' && shifts[0].start !== null ) {
            minStartTime = shifts[0].start;
            maxEndTime = shifts[0].start + shifts[0].shiftLengthLength / MIN_PER_HOUR;
          }

        }

        for (var i = 1; i<shifts.length; i++) {

          if (shifts[i] !== null && shifts[i].start !== null && typeof shifts[i].start !== 'undefined') {

            if (minStartTime > shifts[i].start) {
              minStartTime = shifts[i].start;
            }

            if (maxEndTime < shifts[i].start + shifts[i].shiftLengthLength / MIN_PER_HOUR) {
              maxEndTime = shifts[i].start + shifts[i].shiftLengthLength / MIN_PER_HOUR;
            }

          }

        }

        var defaultName = '';

        if (minStartTime !== null) {
          defaultName =  $scope.getTimeString(minStartTime) ;
        }
        else {
          defaultName = 'NoStart Time';
        }

        if (maxEndTime !== null) {
          defaultName += '-' + $scope.getTimeString(maxEndTime) ;
        }
        else {
          defaultName += '-' + 'NoEnd Time';
        }

        //patternCalendar.currentShiftPattern.name
        //        <startTime> - <end Time> <Skill>  * N (<Team>)

        if ($scope.skill === null) {
          defaultName += ' ' + 'No Skill';
        }
        else if ($scope.skill.abbreviation !== '' && $scope.skill.abbreviation !== null) {
          defaultName += ' ' + $scope.skill.abbreviation;
        }
        else {
          defaultName += ' ' + $scope.skill.name ;
        }

        defaultName += '  * ' + ( getResourcesCount($scope.patternCalendar.currentShiftPattern)  || '0' ) +' ';

        if ($scope.team === null) {
          defaultName += +' ' + '(No Team)';
        }
        else if ($scope.team.abbreviation !== '' && $scope.team.abbreviation !== null) {
          defaultName += '(' + $scope.team.abbreviation + ')';
        }
        else {
          defaultName += '(' + $scope.team.name + ')';
        }

        $scope.patternCalendar.currentShiftPattern.name = defaultName;


      };

      function getResourcesCount(shiftPattern) {
        var count = 0;
        if(!shiftPattern.shiftReqDtos) {
          return count;
        }
        angular.forEach(shiftPattern.shiftReqDtos, function(requestDto) {
          count += requestDto.employeeCount ? requestDto.employeeCount : 0;
        });
        return count;
      }


      /**
       * It is called when user change the item in skills
       * If the user change one of the site and team, eventually skill is changed,
       * and this this function will be fired
       * @param skill
       * @param clicked: true: it is clicked from user
       */
      $scope.assignShiftPatterns = function(skill ) {

        /**
         * This value will be used when user click 'cancel' in save work dialog box
         */
        var originalSite = angular.copy($scope.site);
        var originalSkill = angular.copy($scope.skill);
        var originalTeam = angular.copy($scope.team);


        /**
         * assign scope skill variable
         */
        $scope.skill = findSkillInTeam($scope.team,skill);


        /**
         * check shiftpattern editing status
         */
        if ($scope.patternCalendar.option.editing) {

          appFunc.getSaveWorkDlg()
            .then(function(reason) {

              var working = applicationContext.getWorking();

              if (reason === SAVE ) {
                patternList.setDefaultOptions();
                return saveOnModalFromChangingFilters(originalSite, originalTeam, originalSkill);
              }
              else if (reason === DISCARD) {
                $scope.patternCalendar.option.editing = false;
                patternList.setDefaultOptions();
                /**
                 * Rollback current pattern and proceed
                 */

                if (working.option !==null)
                  working.option.editing = false;
                working.restoreFunc();

                patternList.processAssignShiftPatterns({
                  site: $scope.site,
                  team: $scope.team,
                  skill: $scope.skill
                });
                setDefaultPatternInSkill();

              }

            }, function(reason) {
              /**
               * It is cancellation.
               * Just rollback site checking option
               */

              restoreSkill(originalSkill);
              console.log('dismissed');
            });

            return;

        }
        else {
          patternList.setDefaultOptions();

          patternList.processAssignShiftPatterns({
            site: $scope.site,
            team: $scope.team,
            skill: $scope.skill
          });
          setDefaultPatternInSkill();
        }

      };


      /**
       * @returns site in siteteamskills
       */
      function findSiteInMetaStructure(site) {

        for (var i in $scope.sites) {
          var ele = $scope.sites[i];
          if (ele.id == site.id) {
            return ele;
          }
        }
        return null;
      }

      /**
       * @returns team in dropdown list
       */
      function findTeam(teamId) {

        for (var i in $scope.teams) {

          var ele = $scope.teams[i];
          if (ele.id == teamId) {
            return ele;
          }
        }
        return null;
      }

      /**
       *
       * @param site
       * @returns {*}
       */
      function findSiteInTree(shiftPattern){

          for (var i in $scope.shiftPatternsTree) {
              var ele = $scope.shiftPatternsTree[i];
              if (ele.id == shiftPattern.siteId) {
                  return ele;
              }
          }

          return null;
      }


      /**
       *
       * @param team
       * @param skill
       * @returns {*}
       */
      function findSkillInTeam(team, skill) {

        if ((skill || null)=== null) {
          return null;
        }

        for (var i in team.skills) {
          var ele = team.skills[i];

          if (ele.id == skill.id) {
            return ele;
          }
        }

        return null;
      }

      /**
       * Returns array of shift patterns matching site,team,skill
       * @param shiftPatterns
       * @param site
       * @param team
       * @param skill
       * @param dayType
       */
      function findShiftPatterns(shiftPatterns, site,team,skill, dayType) {
        var res = [];

        angular.forEach(shiftPatterns, function(shiftPattern) {
          if ((shiftPattern.siteId === site.id) && (shiftPattern.teamId === team.id) && (shiftPattern.skillId === skill.id)) {

//                  if ((dayType === GENERAL) && (shiftPattern.shiftPatternDayOfWeek !== null)) {
            if ((dayType === GENERAL) && (shiftPattern.shiftPatternCdDate === null)) {
              res.push(shiftPattern);
            }

            if ((dayType === SPECIFIC) && (shiftPattern.shiftPatternCdDate !== null)) {
              res.push(shiftPattern);
            }

          }
        });
        return res;
      }

      /**
       * accept list of shift patterns in shift pattern module
       * generate shift pattern list to be used in quick pane
       */
      function buildShiftPatternsTree(shiftPatterns) {

        /**
         *
         * @type {Array}
         * it will contain site objects
         */
//        $scope.shiftPatternsTree = [];
        $scope.shiftPatternsTree = $scope.sites;

        angular.forEach($scope.sites, function(site) {

//          /**
//           * Insert New Site Node
//           */
//          $scope.shiftPatternsTree.push(site);


          angular.forEach(site.teams, function(team) {

            /**
             * Insert New Team Node
             */

//            site.teams.push(team);
//            team.skills = [];
            angular.forEach(team.skills, function(skill) {

              /**
               * Insert New Skill Node
               */

//                team.skills.push(skill);

              /**
               * Get Shift Patterns for general day
               */
              var generalPatterns = findShiftPatterns(shiftPatterns, site,team,skill, GENERAL );
              skill.generalPatterns = generalPatterns;

              /**
               * Load specific date patterns and organize by specific date
               */
              var specificPatterns = findShiftPatterns(shiftPatterns, site,team,skill, SPECIFIC );
//                skill.specificPatterns = organizeSpecificPatterns(specificPatterns); //maybe we will not use this method
              skill.specificPatterns = specificPatterns;

            });
          });



        });

      }

      /**
       * load Overall Structure of shift pattern metadata
       */
      function loadTreeMetaData() {

        return factory.getElements("sites/siteteamskills",{});
      }

      /**
       *
       * @param date
       * @returns {dateString}
       */
      function getDateString(date) {

        if (!date)
            return null;
        var year = date.getFullYear().toString();
        var month = (1 + date.getMonth()).toString();
        month = month.length > 1 ? month : '0' + month;
        var day = date.getDate().toString();
        day = day.length > 1 ? day : '0' + day;
        return year + '-' + month + '-' + day;

      }

      function organizeSpecificPatterns(specificPatterns) {

        /**
         * It will have following structure
         * [
         *  { date: '2014-11-02', patterns: [{#pattern1}, {#pattern2}]}
         *  { date: '2014-11-05', patterns: [{#pattern3}, {#pattern4}]}
         * ]
         */
        var organizedPatterns = [];
        /**
         * iterate specificPatterns
         */
        angular.forEach(specificPatterns, function(pattern) {

          var node = null;
          var nodeDateStr = getDateString(new Date(pattern.shiftPatternCdDate));
          var found = false;
          for (var i in organizedPatterns) {
            node = organizedPatterns[i];
            if (nodeDateStr === node.date ) {
              found = true;
              break;
            }
          }

          if (found === false ) {
            /**
             * If it is new node create a node with one value pattern inside
             */
            organizedPatterns.push({date: nodeDateStr, patterns: [pattern]});
          }
          else {
            /**
             * when it founds a node, append the pattern
             */
            node.patterns.push(pattern);
          }

        });

        return organizedPatterns;
      }

      $scope.updateSpecificDate = function() {
        console.log($scope.patternCalendar.option.cdDate);

        patternList.processAssignShiftPatterns({
          site: $scope.site,
          team: $scope.team,
          skill: $scope.skill
        });
      };


        /**
         * Save As Action. it will require one modal dialog with new Name and save
         */
        $scope.saveAs = function() {

          /**
           * Check whether current shift pattern has valid ID or not
           */
          if (!$scope.patternCalendar.currentShiftPattern.id) {
              applicationContext.setNotificationMsgWithValues('schedule_builder.PLEASE_CREATE_ONE_SHIFT_PATTERN', '', true);
              return;
          }

          /**
           * Check whether it contains null shift
           */
          var nullShift = _.find(
            $scope.patternCalendar.currentShiftPattern.shifts, function(shift){
              return shift === null || !shift.id;
            }
          );

          if(typeof nullShift  !== "undefined" && $scope.patternCalendar.currentShiftPattern.shifts.length>0) {
            applicationContext.setNotificationMsgWithValues('schedule_builder.PLEASE_SELECT_A_SHIFT', '', true);
            return;
          }

          var pattern = {name: ''};

          var dlg = $modal.open({
            templateUrl: 'modules/schedule_builder/partials/schedule_builder_shift_pattern_save_as_modal.html',
            windowClass: 'schedule-builder',
            controller: function($scope, $modalInstance, pattern) {

              $scope.pattern = pattern;

              // When we go to login page we have to dismiss the modal.
              $scope.$on('event:auth-loginRequired', function () {
                $modalInstance.dismiss('cancel');
              });


              // DuplicateAction
              $scope.save = function() {
                $modalInstance.close('save');
              };

              // Close Modal
              $scope.close = function(){
                $modalInstance.dismiss('cancel');
              };


            },
            resolve: {
              pattern: function() {
                return pattern;
              }
            }

          });

          dlg.result.then(function(reason) {
            /**
             * Copy current shift pattern into new one and save it with different name
             * these variables are using in update/save scenario
             */
            var i,shift,hour;

            if(pattern.name.trim === '') {
              applicationContext.setNotificationMsgWithValues('schedule_builder.ENTER_SHIFT_PATTERN_NAME', '', true);
              return;
            }

            /*
             Create ShiftPattern on db
             */

            var dto = {
              skillId: $scope.skill.id,
              teamId: $scope.team.id,
              name : pattern.name,
              updateDto: {
                description : '',
                type: 'Set',
                shiftReqDtos: []
              }
            };

            /**
             * build shiftReqDto for shift pattern
             */

            for (i in $scope.patternCalendar.currentShiftPattern.shifts) {
              shift = $scope.patternCalendar.currentShiftPattern.shifts[i];
              hour = $scope.patternCalendar.currentShiftPattern.hours[i];
              dto.updateDto.shiftReqDtos.push({
                'employeeCount': hour.required,
                'excessCount': hour.excess,
                'shiftTypeId': shift.id
              });
            }

            if ($scope.patternCalendar.currentShiftPattern.shiftPatternCdDate) {
              /**
               * Save the cdDate with site timezone
               */
              dto.updateDto.cdDate = appFunc.getDateWithTimezone(
                $scope.patternCalendar.currentShiftPattern.shiftPatternCdDate.getFullYear(),
                $scope.patternCalendar.currentShiftPattern.shiftPatternCdDate.getMonth(),
                $scope.patternCalendar.currentShiftPattern.shiftPatternCdDate.getDate(),
                $scope.site.timeZone
              ).getTime();

            }

            if ($scope.patternCalendar.currentShiftPattern.shiftPatternDayOfWeek) {
              dto.updateDto.dayOfWeek = $scope.patternCalendar.currentShiftPattern.shiftPatternDayOfWeek;
            }


            factory.createElement('shiftpatterns',dto)
              .then(function (result){
                $scope.patternCalendar.currentShiftPattern.id = result.id;
                result.shifts = [];
                result.shiftIds = [];
                result.hours = [];

                /**
                 * This function initialize shift patterns variable
                 */
                $scope.loadShiftPatterns()
                  .then(function(entities) {

                    $scope.patternCalendar.option.editing = false;

                    processUpdatingShiftPatternFilters($scope.site, $scope.team, $scope.skill);

                    if ($scope.patternCalendar.currentShiftPattern.id) {
                      var cur = getShiftPatternFromMeta($scope.patternCalendar.currentShiftPattern.id);
                      if (cur !== null) {
                        patternList.selectShiftPattern(cur);
                      }
                    }

                  });


              }, function (error) {
                applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
              });


          }, function(reason) {
            console.log('dismissed');
          });

        };

        /**
         * It will show of 'save your work' dialog box and have a appropriate action
         */
        function showSaveWorkDlg() {

          var dlg = $modal.open({
            templateUrl: 'modules/_layouts/partials/authenticated_save_work_modal.html',
            windowClass: 'schedule-builder',
            controller: function($scope, $modalInstance) {

              // When we go to login page we have to dismiss the modal.
              $scope.$on('event:auth-loginRequired', function () {
                $modalInstance.dismiss('cancel');
              });

              // Save Action
              $scope.save = function() {
                $modalInstance.close('save');
              };

              // Discard Action
              $scope.discard = function() {
                $modalInstance.close('discard');
              };

              // Close Modal
              $scope.close = function(){
                $modalInstance.dismiss('cancel');
              };

            }

          });

          dlg.result.then(function(reason){
            console.log(reason);


          }, function(reason) {
            console.log('dismissed');
          });
        }

      /**
       * returns true, if team contains any patterns.
       * @param team
       * @returns {boolean}
       */
      $scope.canShowTreeTeam = function(team) {

        if (team.skills.length === 0) {
          return false;
        }

        for (var i in team.skills) {
          var skill = team.skills[i];
          if (skill.generalPatterns.length > 0) {
            return true;
          }

        }
        return false;

      };

      /**
       * returns true, if site contains any patterns.
       * @param team
       * @returns {boolean}
       */
      $scope.canShowTreeSite = function(site) {
        if (site.teams.length === 0) {
          return false;
        }

        for (var i in site.teams) {
          var team = site.teams[i];
          if ($scope.canShowTreeTeam(team) === true ) {
            return true;
          }
        }
        return false;

      };

      /**
       *
       */
      $scope.updateEditing = function() {
        /**
         * if it none of the patterns are not assigned to any of column, make it false.
         */
        if (!$scope.patternCalendar.currentShiftPatternDay.day) {
          $scope.patternCalendar.option.editing = false;
          return;
        }
        if ($scope.patternCalendar.option.editing !== true) {
          $scope.patternCalendar.option.editing = true;
        }
      };


      /**
       * Using in demand shift pattern dots header
       * @param $index
       * @param isGridTime
       * @returns {boolean}
       */
      $scope.inOptimumCols = function($index, isGridTime) {

        if (isGridTime === true) {
          return ($index < $scope.optimumCols );
        }
        else {
          return ($index < $scope.optimumCols * 2 );
        }

      };

      /**
       * Update Circles
       */
      $scope.updateDemandHeaderItems = function (headerItem, $index) {

        if ($scope.patternCalendar.option.editing !== true) {
          $scope.patternCalendar.option.editing = true;
        }

        /**
         * Update maxDemandCount, if the value is bigger than that
         */
        var i =0;
        var headerValue =parseInt(headerItem.value) || 0;

        if (parseInt($scope.patternCalendar.currentShiftPattern.maxDemandCount) < headerValue) {

          for (i=0; i<headerItem.value-$scope.patternCalendar.currentShiftPattern.maxDemandCount; i++) {
            var rowData = {
              row: i+1,
              data: new Array($scope.patternCalendar.currentShiftPattern.demandHeaderItems.length)
            };

            $scope.patternCalendar.currentShiftPattern.demands.unshift(rowData);
          }


          $scope.patternCalendar.currentShiftPattern.maxDemandCount= headerValue;
          $scope.patternCalendar.option.demandCount = $scope.patternCalendar.currentShiftPattern.maxDemandCount;

        }

        for (i=0; i<$scope.patternCalendar.currentShiftPattern.maxDemandCount; i++) {
          var demandRow = $scope.patternCalendar.currentShiftPattern.demands[i];
          demandRow.row = i+1;

          if (i< $scope.patternCalendar.currentShiftPattern.maxDemandCount - headerValue) {
            demandRow.data[$index] = 0; // empty
          }
          else {
            demandRow.data[$index] = 1; //show circle
          }
        }
      };

      /**
       * Update Circles
       */
      $scope.updateDemandCircles = function (demand, $index) {

        /**
         * Update maxDemandCount, if the value is bigger than that
         */
        if ($scope.demandMouseDown === false) {
          return;
        }

        var demandCount =demand.row;

        var difference = 1; // it will be 0 to add
        if (demand.data[$index] !==0 ) {
          difference = 0;
        }

        $scope.patternCalendar.option.demandPatternGenerated = false;
        $scope.patternCalendar.currentShiftPattern.shiftReqDtos = [];

        for (var i=0; i<$scope.patternCalendar.currentShiftPattern.maxDemandCount; i++) {
          var demandRow = $scope.patternCalendar.currentShiftPattern.demands[i];
          if (i <  parseInt(demandCount)-difference) {
            demandRow.data[$index] = 0; // empty
          }
          else {

            /**
             *
             */

            //if ($scope.patternCalendar.currentShiftPattern.demandHeaderItems[$index].allowed === false) {
            //  return;
            //}

            demandRow.data[$index] = 1; //show circle
          }
        }

        $scope.patternCalendar.currentShiftPattern.demandHeaderItems[$index].value = $scope.patternCalendar.currentShiftPattern.maxDemandCount - (parseInt(demandCount)-difference);
      };

      $scope.setDemandMouseDown = function(value,demand,$index) {
        $scope.demandMouseDown = value;

        if (value===true && $scope.patternCalendar.option.editing !== true) {
          $scope.patternCalendar.option.editing = true;
        }

        if (value === true) {
          $scope.updateDemandCircles(demand,$index);
        }

      };

      //TODO: This module + html component has to be a directive
      var LoadingIndicatorManager = (function(){
        var config = {
          delayMillis: 1000
        };
        var timeouts = {};

        function prepareDelay(delayMillis) {
          delayMillis = parseInt(delayMillis);
          return isNaN(delayMillis) ? config.delayMillis : delayMillis;
        }

        function skipTimeout(flagName) {
          clearTimeout(timeouts[flagName]);
        }

        return {
          show: function(id, onShow, delayMillis) {
            timeouts[id] = setTimeout(function() {
              onShow();
            }, prepareDelay(delayMillis));
          },
          hide: function(id, onHide) {
            skipTimeout(id);
            onHide();
          }
        };
      }());

      function toggleGenerateShiftPatternsButton() {
        $("#generate_shift_patterns_btn_loader").toggle();
        $("#generate_shift_patterns_btn").toggle();
      }

      /**
       * Generate ShiftReqDtos from shift demand, only available for shift demand
       */
      $scope.generateShiftReqs = function() {
        var url = applicationContext.getBaseRestUrl() + 'shiftpatterns/ops/draftcomputeshiftreqs';
        var dto = {};

        /**
         * build shiftLengthList
         */
        var shiftLengths = [];
        var ele = null;

        for (var i in $scope.patternCalendar.demandShiftLengths) {
          ele = $scope.patternCalendar.demandShiftLengths[i];
          if (ele.checked === true) {
            shiftLengths.push(ele.id);
          }
        }

        dto.allowedShiftLengthIds = shiftLengths;

        /**
         * build shiftDemandDtos
         */
        dto.shiftDemandDtos = [];
        for (i in $scope.patternCalendar.currentShiftPattern.demandHeaderItems) {
          ele = $scope.patternCalendar.currentShiftPattern.demandHeaderItems[i];
          if (ele.value > 0) {
            dto.shiftDemandDtos.push(
              {
                "startTime": i* demandCellMin * 60 * 1000,
                "lengthInMin" : demandCellMin,
                "employeeCount": ele.value
              }
            );
          }
        }

        LoadingIndicatorManager.show("generate_shift_patterns_btn", toggleGenerateShiftPatternsButton);
        $http.post(url,dto)
          .success(function(result) { //result: array of shiftReqDtos
            LoadingIndicatorManager.hide("generate_shift_patterns_btn", toggleGenerateShiftPatternsButton);
            $scope.patternCalendar.currentShiftPattern.shiftLengthList = shiftLengths.join();
            $scope.patternCalendar.currentShiftPattern.shifts = [];
            $scope.patternCalendar.currentShiftPattern.shiftIds = [];
            $scope.patternCalendar.currentShiftPattern.hours = [];
            $scope.patternCalendar.currentShiftPattern.shiftReqDtos = result;

            angular.forEach(result, function(shiftReqDto, key) {
              /*
               Set shift type id
               */
              //var shift = getShiftType(shiftReqDto.shiftTypeId);
              $scope.patternCalendar.currentShiftPattern.shifts.push(angular.copy(patternList.getShiftType(shiftReqDto.shiftTypeId)));
              $scope.patternCalendar.currentShiftPattern.shiftIds.push(shiftReqDto.shiftTypeId);
              $scope.patternCalendar.currentShiftPattern.hours.push({'required': shiftReqDto.employeeCount, 'excess': shiftReqDto.excessCount});
              //$scope.patternCalendar.currentShiftPattern.shiftLengths.push(patternList.getShiftLength(shiftReqDto.shiftLengthId));

            });

            /**
             * Update Option Pattern Type Value
             */
            if (!$scope.patternCalendar.currentShiftPattern.shifts || $scope.patternCalendar.currentShiftPattern.shifts.length ===0) {
              $scope.patternCalendar.option.demandPatternGenerated = false;
            }
            else {
              $scope.patternCalendar.option.demandPatternGenerated = true;
            }

            //update demands circle shifts graph area

            var ele = null;
            var j = 0;

            if ($scope.patternCalendar.option.demandPatternGenerated === true) {

              $timeout(function(){
                patternGraph.buildGraph($scope.patternCalendar.currentShiftPattern);

                patternList.clearDemands($scope.patternCalendar.currentShiftPattern, $scope.patternCalendar.currentShiftPattern.maxDemandCount);

                /**
                 * Apply shiftDemandDtos
                 */

                for (i=0; i<dto.shiftDemandDtos.length; i++) {

                  ele = dto.shiftDemandDtos[i];
                  var index = ele.startTime / ele.lengthInMin / 60 / 1000;

                  $scope.patternCalendar.currentShiftPattern.demandHeaderItems[index].value = ele.employeeCount;

                  for (j =0; j < $scope.patternCalendar.currentShiftPattern.maxDemandCount; j++) {

                    if (j< $scope.patternCalendar.currentShiftPattern.maxDemandCount - parseInt(ele.employeeCount)) {
                      $scope.patternCalendar.currentShiftPattern.demands[j].data[index] = 0; // empty
                    }
                    else {
                      $scope.patternCalendar.currentShiftPattern.demands[j].data[index] = 1; //show circle
                    }

                  }

                }

                /**
                 * compare requiredHeaderItems:ShiftReqDtos and demandHeaderItems:DemandHeaderItems
                 * and show dots in demands with yellow color
                 */

                for (i=0; i< $scope.graph.requiredHeaderItems.length; i++) {
                  var required = $scope.graph.requiredHeaderItems[i];
                  var demand = $scope.patternCalendar.currentShiftPattern.demandHeaderItems[i];
                  var diff = 0;

                  if (required.value > (demand.value || 0)) {
                    diff = required.value - (demand.value || 0);
                    /**
                     * Show yellow dots for the difference
                     */
                    var end = $scope.patternCalendar.currentShiftPattern.maxDemandCount - (demand.value || 0) ;
                    for (j =end -diff ; j < end; j++) {
                      $scope.patternCalendar.currentShiftPattern.demands[j].data[i] = 2; // empty
                    }


                  }
                }
              });

            }


          })
          .error(function(error) {
            LoadingIndicatorManager.hide("generate_shift_patterns_btn", toggleGenerateShiftPatternsButton);
            applicationContext.setNotificationMsgWithValues(error.message, '', true, error.statusText);
          });
      };

      /**
       * return shifttype object with matching id of shiftlength
       */
      function getShiftTypeFromShiftLength(shiftLengthId) {

        for (var i =0; i<$scope.site.shiftTypes.length; i++) {

          var ele = $scope.site.shiftTypes[i];
          if (ele.shiftLengthId === shiftLengthId) {
            return ele;
          }

        }
        return null;
      }

      /**
       * Update ShiftDemandDtos -> allowable
       * if site == null, return blank
       */
      $scope.updateDemandShiftLengths = function(mouse) {
        
        // call Service function
        patternList.updateDemandShiftLengths(mouse);
        if (mouse === true) {
          $scope.patternCalendar.option.demandPatternGenerated = false;
        }
      };

      

      function setDefaultPatternInSkill() {
        var pattern = null;

        if ($scope.skill !==null && $scope.skill.generalPatterns.length > 0) {
          pattern = $scope.skill.generalPatterns[0];
        }
        else if ($scope.skill !==null  && $scope.skill.specificPatterns.length > 0) {
          pattern = $scope.skill.specificPatterns[0];
        }

        if (pattern === null) {
          patternList.assignEmptyShiftPattern();
        }
        else {
          patternList.selectShiftPattern(pattern);
        }

      }

      /**
       * Reset Sites Filter in dropdown box : ShiftPattern
       */
      $scope.resetSitesFilter = function() {

        if ($scope.sites.length > 0) {
          $scope.loadTeams($scope.sites[0], null);
        }
      };

      /**
       * Reset Teams Filter in dropdown box : ShiftPattern
       */
      $scope.resetTeamsFilter = function() {

        if ($scope.teams.length > 0) {
          $scope.loadSkills($scope.teams[0], null);
        }
      };

      /**
       * Reset Skills Filter in dropdown box : ShiftPattern
       */
      $scope.resetSkillsFilter = function() {

        if ($scope.skills.length > 0) {
          $scope.assignShiftPatterns($scope.skills[0]);
        }
      };


      /**
       * Shift Pattern Main Section
       * @param evt
       */
      $scope.filterZero = function(evt) {

        var elem = null;

        if (evt.which !== 48 && evt.which !== 96) {
          return;
        }

        if (evt.srcElement)
          elem = evt.srcElement;
        else if (evt.target)
          elem = evt.target;

        if (elem !== null ){
          if (elem.value.indexOf('0') === 0) {
            elem.value = Math.abs(parseInt(elem.value)) || 0;
          }
        }

      };

      /**
       * Saving Pattern on Save & Discard Modal by changing filters such as (Site,Team,Skill)
       */
      function saveOnModalFromChangingFilters(originalSite,originalTeam,originalSkill) {

        var working = applicationContext.getWorking();

        return working.saveFunc(originalSite, originalTeam, originalSkill)
          .then(
            function(result) {

              patternList.processAssignShiftPatterns({
                site: $scope.site,
                team: $scope.team,
                skill: $scope.skill
              });
              setDefaultPatternInSkill();
            },function (reason){

              /**
               * Change back the filters
               */

              restoreSite(originalSite);
              restoreTeam(originalTeam);
              restoreSkill(originalSkill);

            }
          );
      }

      /**
       * restoreSite filter in dropdown
       * @param originalSite
       */
      function restoreSite(originalSite) {
        if (originalSite && $scope.site && originalSite.id !== $scope.site.id) {

          $scope.site.ticked = false;
          $scope.site = findSiteInMetaStructure(originalSite);
          $scope.site.ticked = true;

        }
      }

      /**
       * restoreTeam filter in dropdown
       * @param originalTeam
       */
      function restoreTeam(originalTeam) {
        if (originalTeam && $scope.team && originalTeam.id !== $scope.team.id) {

          $scope.team.ticked = false;
          $scope.team = findTeam(originalTeam.id);
          $scope.team.ticked = true;

        }
      }

      /**
       * restoreSkill filter in dropdown
       * @param originalSkill
       */
      function restoreSkill(originalSkill) {
        if (originalSkill && $scope.skill && originalSkill.id !== $scope.skill.id) {
          $scope.skill.ticked = false;
          $scope.skill = findSkillInTeam($scope.team, originalSkill);
          $scope.skill.ticked = true;
        }

      }

      /**
       * updatePatternGraph
       */
      $scope.updatePatternGraph = function(index) {

        $scope.updateEditing();
        $scope.patternCalendar.currentShiftPattern.hours[index].required = Math.abs(parseInt($scope.patternCalendar.currentShiftPattern.hours[index].required)) || 0;
        $scope.patternCalendar.currentShiftPattern.hours[index].excess = Math.abs(parseInt($scope.patternCalendar.currentShiftPattern.hours[index].excess)) || 0;

        $scope.calculateTotals();
        patternList.generateShiftPattern();
      };


      $scope.updateShiftFromId = function(index) {
        $scope.patternCalendar.currentShiftPattern.shifts[index] = angular.copy(patternList.getShiftType($scope.patternCalendar.currentShiftPattern.shiftIds[index]));
      };

      $scope.setDemandPatternGenerated = function(value) {
        $scope.patternCalendar.option.demandPatternGenerated = value;
      };

      $scope.refreshWholeGraphs = function() {
        patternList.generateShiftPattern();
      };


      /**
       * Demand Shift lengths : Check
       */
      $scope.checkAllDemandShiftLengths = function() {
        patternList.checkAllDemandShiftLengths();
      };

      /**
       * Demand Shift lengths : Uncheck
       */
      $scope.uncheckAllDemandShiftLengths = function() {
        patternList.uncheckAllDemandShiftLengths();
      };

      /**
       * restrict shifttypes with shiftlength
       * @param shiftType
       */
      $scope.matchShiftTypes = function(shiftType, shiftLength){
        return shiftLength && shiftLength.id && shiftType && shiftType.shiftLengthId === shiftLength.id;
      };

      /**
       * Shift Pattern Save:
       * @param site:
       * @param team: if not specified, scope.team will be used
       * @param skill: if not specified, scope.skill will be used
       */

      function processSave(site,team,skill) {
        var deferred = $q.defer();

        if (!$scope.patternCalendar.currentShiftPatternDay.day) {
          applicationContext.setNotificationMsgWithValues('schedule_builder.PLEASE_ADD_SHIFT_PATTERN_UNDER_SPECIFIC_DAY', '', true);
          deferred.reject('Error');
          return deferred.promise;
        }

        /**
         * these variables are using in update/save scenario
         */
        var i,shift,hour,dt, dtFormat;
        var shiftLengths = [];
        var ele = null;

        /**
         * Check whether it contains null shift
         */
        var nullShift = _.find(
          $scope.patternCalendar.currentShiftPattern.shifts, function(shift){
            return shift === null || !shift.id;
          }
        );

        if (typeof nullShift !== 'undefined' && $scope.patternCalendar.currentShiftPattern.shifts.length>0) {
          applicationContext.setNotificationMsgWithValues('schedule_builder.PLEASE_SELECT_A_SHIFT', '', true);
          deferred.reject('Error');
          return deferred.promise;
        }


        var emptyHour = _.find(
          $scope.patternCalendar.currentShiftPattern.hours, function(hour){
            return hour === null || !(hour.required>0 || hour.excess>0);
          }
        );

        if (typeof emptyHour !== 'undefined' && $scope.patternCalendar.currentShiftPattern.hours.length>0) {
          applicationContext.setNotificationMsgWithValues('schedule_builder.PLEASE_SPECIFY_VALID_HOURS', '', true);
          deferred.reject('Error');
          return deferred.promise;
        }

        if ($scope.patternCalendar.currentShiftPattern.id) {
          /**
           * User can not update specific date nor day in general day
           */
          var updateDto = {
            name: $scope.patternCalendar.currentShiftPattern.name,
            shiftReqDtos: $scope.patternCalendar.currentShiftPattern.shiftReqDtos
          };

          if ($scope.patternCalendar.option.dayType === 'GENERAL') {
            updateDto.dayOfWeek = $scope.patternCalendar.currentShiftPatternDay.day;
          }
          else {
            if (!$scope.patternCalendar.option.cdDate) {
              applicationContext.setNotificationMsgWithValues('schedule_builder.PLEASE_SPECIFY_SPECIFIC_DATE', '', true );
              deferred.reject('Error');
              return deferred.promise;
            }

            updateDto.cdDate = appFunc.getDateWithTimezone(
              $scope.patternCalendar.option.cdDate.getFullYear(),
              $scope.patternCalendar.option.cdDate.getMonth(),
              $scope.patternCalendar.option.cdDate.getDate(),
              $scope.site.timeZone
            ).getTime();

          }

          if ($scope.patternCalendar.option.patternType === 'Demand') { //demand based
            updateDto.type = 'Demand';

            /**
             * build shiftLengthList
             */
            shiftLengths = [];
            ele = null;

            for (i in $scope.patternCalendar.demandShiftLengths) {
              ele = $scope.patternCalendar.demandShiftLengths[i];
              if (ele.checked === true) {
                shiftLengths.push(ele.id);
              }
            }

            updateDto.shiftLengthList = shiftLengths.join();

            /**
             * build shiftDemandDtos
             */
            updateDto.shiftDemandDtos = [];
            for (i in $scope.patternCalendar.currentShiftPattern.demandHeaderItems) {
              ele = $scope.patternCalendar.currentShiftPattern.demandHeaderItems[i];
              if (ele.value > 0) {
                updateDto.shiftDemandDtos.push(
                  {
                    "startTime": i* demandCellMin * 60 * 1000,
                    "lengthInMin" : demandCellMin,
                    "employeeCount": ele.value
                  }
                );
              }
            }

          }
          else {
            //Manual Based Pattern
            updateDto.type = 'Set';
            updateDto.shiftReqDtos = [];

            /**
             * build shiftReqDto for shift pattern
             */
            for (i in $scope.patternCalendar.currentShiftPattern.shifts) {
              shift = $scope.patternCalendar.currentShiftPattern.shifts[i];
              hour = $scope.patternCalendar.currentShiftPattern.hours[i];
              updateDto.shiftReqDtos.push({
                'employeeCount': hour.required,
                'excessCount': hour.excess,
                'shiftTypeId': shift.id
              });
            }
          }


          return factory.updateElement('shiftpatterns',$scope.patternCalendar.currentShiftPattern.id, updateDto)
            .then(function (result){

              console.log("ShiftPattern Updated : " + result.id);

              applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', '', true , result.name);

            }, function (error) {
              console.log(error);

              applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
              deferred.reject('Error');
              return deferred.promise;
            });

        }
        else {
          /*
           Create ShiftPattern on db
           */
          if (!team) {
            team = getTeam();
          }

          if (!skill) {
            skill = getSkill();
          }

          if (!skill) {
            applicationContext.setNotificationMsgWithValues('schedule_builder.PLEASE_SELECT_A_SKILL', '', true);
            deferred.reject('Error');
            return deferred.promise;

          }

          var dto = {
            skillId: skill.id,
            teamId: team.id,
            name : $scope.patternCalendar.currentShiftPattern.name,
            updateDto: {
              description : '',
              shiftReqDtos: []
            }
          };

          /**
           * Put cdDate and dayOfWeek
           */
          if ($scope.patternCalendar.option.dayType === 'SPECIFIC') {
            if (!$scope.patternCalendar.option.cdDate) {
              applicationContext.setNotificationMsgWithValues('schedule_builder.PLEASE_SPECIFY_SPECIFIC_DATE', '', true );
              deferred.reject('Error');
              return deferred.promise;
            }

            /**
             * Save the cdDate with site timezone
             */
            dto.updateDto.cdDate = appFunc.getDateWithTimezone(
              $scope.patternCalendar.option.cdDate.getFullYear(),
              $scope.patternCalendar.option.cdDate.getMonth(),
              $scope.patternCalendar.option.cdDate.getDate(),
              $scope.site.timeZone
            ).getTime();

          }
          else {
            dto.updateDto.dayOfWeek = $scope.patternCalendar.currentShiftPatternDay.day;
          }

          /**
           * Prepare param for creation for demand based and manual pattern
           */
          if ($scope.patternCalendar.option.patternType === 'Demand') { //demand based

            dto.updateDto.type = 'Demand';

            /**
             * build shiftLengthList
             */
            shiftLengths = [];
            ele = null;

            for (i in $scope.patternCalendar.demandShiftLengths) {
              ele = $scope.patternCalendar.demandShiftLengths[i];
              if (ele.checked === true) {
                shiftLengths.push(ele.id);
              }
            }

            dto.updateDto.shiftLengthList = shiftLengths.join();

            /**
             * build shiftDemandDtos
             */
            dto.updateDto.shiftDemandDtos = [];
            for (i in $scope.patternCalendar.currentShiftPattern.demandHeaderItems) {
              ele = $scope.patternCalendar.currentShiftPattern.demandHeaderItems[i];
              if (ele.value > 0) {
                dto.updateDto.shiftDemandDtos.push(
                  {
                    "startTime": i* demandCellMin * 60 * 1000,
                    "lengthInMin" : demandCellMin,
                    "employeeCount": ele.value
                  }
                );
              }
            }

            //"shiftDemandDtos":[{"startTime":0, "lengthInMin":30, "employeeCount":1}


          }
          else { // Manual Shift Pattern
            dto.updateDto.type = 'Set';

            /**
             * build shiftReqDto for shift pattern
             */
            dto.updateDto.shiftReqDtos = [];
            for (i in $scope.patternCalendar.currentShiftPattern.shifts) {
              shift = $scope.patternCalendar.currentShiftPattern.shifts[i];
              hour = $scope.patternCalendar.currentShiftPattern.hours[i];
              dto.updateDto.shiftReqDtos.push({
                'employeeCount': hour.required,
                'excessCount': hour.excess,
                'shiftTypeId': shift.id
              });
            }

          }


          return factory.createElement('shiftpatterns',dto)
            .then(function (result){

              applicationContext.setNotificationMsgWithValues(result.name + ' build', '', true);
              console.log("ShiftPattern Saved : " + result.id);

              return result;

            }, function (error) {
              applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
              deferred.reject('Error');
              return deferred.promise;
            });
        }
      }

      // Listens for current Shift Pattern changed from shift-pattern-list directive
      //$scope.$watch('patternCalendar.currentShiftPattern', function(newValue, oldValue) {
      //
      //  /**
      //   * Update Option Pattern Type Value
      //   */
      //  if (!newValue.shifts || newValue.shifts.length ===0) {
      //    $scope.patternCalendar.option.demandPatternGenerated = false;
      //  }
      //  else {
      //    $scope.patternCalendar.option.demandPatternGenerated = true;
      //  }
      //
      //  if (!newValue.type) {
      //    $scope.patternCalendar.option.patternType = 'Set';
      //  }
      //  else {
      //    $scope.patternCalendar.option.patternType = newValue.type;
      //  }
      //
      //  console.log('old:' + oldValue.id + " new:" + newValue.id);
      //
      //  if (oldValue.id) {
      //
      //
      //    var oldPattern = patternList.getShiftPatternById(oldValue.id);
      //
      //    if (oldPattern !== null ) {
      //      oldPattern.selected = false;
      //    }
      //    else {
      //      oldValue.selected = false;
      //    }
      //
      //  }
      //  else {
      //    oldValue.selected = false;
      //  }
      //
      //  if (newValue.id) {
      //    var newPattern = patternList.getShiftPatternById(newValue.id);
      //    if (newPattern !== null ) {
      //      newPattern.selected = true;
      //    }
      //  }
      //  else {
      //    newValue.selected = true;
      //  }
      //
      //  clearDemands($scope.patternCalendar.currentShiftPattern.maxDemandCount);
      //  patternList.generateShiftPattern();
      //});

      /**
       * Listens for demand related attribute change
       */
      //$scope.$watch('patternCalendar.currentShiftPattern.shiftLengthList', function(newValue, oldValue) {
      //  patternList.generateShiftPattern();
      //});

      /**
       * Listens for demand yellow dots
       * Third parameter is true for value detection
       */
      //$scope.$watch('graph.requiredHeaderItems', function(newValue, oldValue) {
      //  patternList.generateShiftPattern();
      //}, true);


      /*
       Listen for required & excess change in select-shifts area
      Third parameter is true for value detection
       */

//      $scope.$watch('patternCalendar.currentShiftPattern.hours', function(newValue, oldValue) {
//        $scope.calculateTotals();
//        patternList.generateShiftPattern();
//      }, true);

      //$scope.$watch('patternCalendar.currentShiftPattern.shifts', function(newValue, oldValue) {
      //  /**
      //   * Update Option Pattern Type Value
      //   */
      //  if (!$scope.patternCalendar.currentShiftPattern.shifts || $scope.patternCalendar.currentShiftPattern.shifts.length ===0) {
      //    $scope.patternCalendar.option.demandPatternGenerated = false;
      //  }
      //  else {
      //    $scope.patternCalendar.option.demandPatternGenerated = true;
      //  }
      //
      //  $scope.calculateTotals();
      //  patternList.generateShiftPattern();
      //}, true);

      $scope.toggledShiftPatternsDropdown = function(open) {
        console.log('Dropdown is now: ', open);
      };

    }
  ]
);

;
var scheduleBuilder = angular.module('emlogis.schedule_builder');

scheduleBuilder.controller('ScheduleBuilderCtrl',
  [
    '$scope',
    '$rootScope',
    '$state',
    '$q',
    '$modal',
    'applicationContext',
    'appFunc',
    'scheduleService',
    'stateManager',
    function ($scope, $rootScope, $state, $q, $modal, applicationContext, appFunc,
              scheduleService, stateManager) {

      console.log('Schedule Builder controller');

      $scope.hasReport = function () {
        var temp = scheduleService.getShared();
        //todo check this
        //return temp.schedule.executionEndDate > 0;
        return temp.schedule.requestGenerationDuration > 0;
      };

      $scope.tabs = [
        {
          heading: "schedule_builder.CREATE_SCHEDULES",
          route: 'authenticated.schedule_builder.create_schedules',
          active: false
        },
        {
          heading: "schedule_builder.SHIFT_PATTERNS",
          route: 'authenticated.schedule_builder.shift_patterns',
          active: false
        }
        //{
        //  heading: "schedule_builder.SCHEDULE_GENERATION_REPORT",
        //  route: 'authenticated.schedule_builder.generation_report',
        //  active: false,
        //  hide: true
        //}
        //{ heading: "schedule_builder.SHIFT_BIDDING", route: 'authenticated.schedule_builder.shift_bidding', active:false }
      ];

      /**
       * Custom variable to be prevent showing save_work dialog twice
       * @type {boolean}
       */
      $scope.tabChecked = false;

      /**
       * Tabset Tab Click LInk
       * @param tab
       */
      $scope.goState = function (tab) {
        console.log('Schedule builder Tab: goState');
        /**
         * It is tab library issue which shows confirmation dialog box twice, because active state is changed
         */
        //if ($scope.tabChecked === true) {
        //  $scope.tabChecked = false;
        //  return;
        //}

        //prevent double loading
        if (tab.route === $state.current.name) {
          return;
        }

        /**
         * if create schedules are clicked, open with id
         */
        var param = null;
        if (tab.route === 'authenticated.schedule_builder.create_schedules' || tab.route === 'authenticated.schedule_builder.generation_report') {
          var tmp = scheduleService.getShared();

          if (tmp.schedule && tmp.schedule.id) {
            param = {'id': tmp.schedule.id};
          }
          else {
            param = {'id': ''};
          }
        }

        /**
         * Schedule Builder: Tab Switch
         */
        appFunc.getSaveWorkDlg().then(
          function (reason) {
            var working = applicationContext.getWorking();

            if (reason === DISCARD || reason === SKIP) {
              if (working.option !== null)
                working.option.editing = false;
              $state.go(tab.route, param);
            }
            else if (reason === SAVE) {
              working.saveFunc()
                .then(function (result) {
                  $state.go(tab.route, param);
                }, function (error) {
                  console.log('Saving is failed because of error');
                  cancelTabSwitch();
                }
              );
            }
            else {
              /**
               * the last condition is discard which we don't need to care, because state will be changed
               */
              if (working.option !== null)
                working.option.editing = false;
              $state.go(tab.route, param);
            }
          },
          function (reject) {
            /**
             * Cancel Pressed, roll back the tab states
             */
            console.log('Cancel pressed');
            cancelTabSwitch();
          }
        );
      };

      /**
       * Cancel Tab Switch
       */
      function cancelTabSwitch() {
        if ($state.$current.name.indexOf('create_schedules') > -1) {
          $scope.tabs[0].active = true;
          $scope.tabs[1].active = false;
        }
        else {
          $scope.tabs[0].active = false;
          $scope.tabs[1].active = true;
        }
        $scope.tabChecked = true;
        console.log('Rollback Tab Switch');
      }

      $scope.active = function (route) {
        return $state.is(route);
      };

      $scope.$on("$stateChangeSuccess", function () {
        console.log('on $state change success: schedule builder');
        $scope.tabs.forEach(function (tab) {

          if (tab.active !== true) {
            tab.active = $scope.active(tab.route);
          }

        });
      });

      $scope.$on('event:loadSchedule', function (event, args) {
    	  if ($scope.tabs[2]!==null){
    		  $scope.tabs[2].hide = !$scope.hasReport();
    	  }
      });
    }
  ]
);

/**
 * Create Schedule page has common objects between breadcrumb and main section,
 * and this scheduleService is serving that purpose
 */
scheduleBuilder.service('scheduleService', function () {

  /**
   * createOptionSites: will be used in New Schedule Dropdown
   * option: it includes Name, startDate, etc
   */
  var shared = {sites: [], newScheduleOptionList: [], option: {}, schedule: {}};
  return {
    getShared: function () {
      return shared;
    },
    setShared: function (value) {
      shared = value;
    }
  };
});

scheduleBuilder.filter('toTranslate', function () {
  return function (val, transaltePath) {
    return transaltePath + val;
  };
});
;
(function () {

  //console.log('In Shift Pattern Graph Service.');

  var defaultMaxDemandCount = 100;

  angular.module('emlogis.schedule_builder')

  .service('patternGraph', function () {

    var graph = {
    };

    // const variable
    var MIN_PER_HOUR = 60;
    var MIN_PER_SCALE = 30;



    return {
      initializeGridTimes: function() {

        // Define Shift Graph Time Scale
        graph.gridTimes = [
          {
            label: "12A",
            colspan: 2
          },
          {
            label: "1A",
            colspan: 2
          },
          {
            label: "2A",
            colspan: 2
          },
          {
            label: "3A",
            colspan: 2
          },
          {
            label: "4A",
            colspan: 2
          },
          {
            label: "5A",
            colspan: 2
          },
          {
            label: "6A",
            colspan: 2
          },
          {
            label: "7A",
            colspan: 2
          },
          {
            label: "8A",
            colspan: 2
          },
          {
            label: "9A",
            colspan: 2
          },
          {
            label: "10A",
            colspan: 2
          },
          {
            label: "11A",
            colspan: 2
          },
          {
            label: "12P",
            colspan: 2
          },
          {
            label: "1P",
            colspan: 2
          },
          {
            label: "2P",
            colspan: 2
          },
          {
            label: "3P",
            colspan: 2
          },
          {
            label: "4P",
            colspan: 2
          },
          {
            label: "5P",
            colspan: 2
          },
          {
            label: "6P",
            colspan: 2
          },
          {
            label: "7P",
            colspan: 2
          },
          {
            label: "8P",
            colspan: 2
          },
          {
            label: "9P",
            colspan: 2
          },
          {
            label: "10P",
            colspan: 2
          },
          {
            label: "11P",
            colspan: 2
          },
          {
            label: "12A",
            colspan: 2
          },
          {
            label: "1A",
            colspan: 2
          },
          {
            label: "2A",
            colspan: 2
          },
          {
            label: "3A",
            colspan: 2
          },
          {
            label: "4A",
            colspan: 2
          },
          {
            label: "5A",
            colspan: 2
          },
          {
            label: "6A",
            colspan: 2
          },
          {
            label: "7A",
            colspan: 2
          },
          {
            label: "8A",
            colspan: 2
          },
          {
            label: "9A",
            colspan: 2
          },
          {
            label: "10A",
            colspan: 2
          },
          {
            label: "11A",
            colspan: 2
          },
          {
            label: "12P",
            colspan: 2
          },
          {
            label: "1P",
            colspan: 2
          },
          {
            label: "2P",
            colspan: 2
          },
          {
            label: "3P",
            colspan: 2
          },
          {
            label: "4P",
            colspan: 2
          },
          {
            label: "5P",
            colspan: 2
          },
          {
            label: "6P",
            colspan: 2
          },
          {
            label: "7P",
            colspan: 2
          },
          {
            label: "8P",
            colspan: 2
          },
          {
            label: "9P",
            colspan: 2
          },
          {
            label: "10P",
            colspan: 2
          },
          {
            label: "11P",
            colspan: 2
          }
        ];

      },
      // Initialize Required HeaderItems
      initializeRequiredHeaderItems: function() {
        graph.requiredHeaderItems = [];
      },
      initializeExcessHeaderItems: function() {
        graph.excessHeaderItems = [];
      },
      //Empty Grid Items, Header Items with all 0
      emptyGridTimes: function() {

        angular.forEach(graph.gridTimes, function(gridTime, key) {

          /*
           Required Header Items
           */
          graph.requiredHeaderItems.push(
            {
              label: gridTime.label + "1", //separate half an hour, mostly it will not used
              value: 0
            }
          );

          graph.requiredHeaderItems.push(
            {
              label: gridTime.label + "2", //separate half an hour, mostly it will not used
              value: 0
            }
          );

          /*
           Excess Header Items
           */
          graph.excessHeaderItems.push(
            {
              label: gridTime.label + "1", //separate half an hour, mostly it will not used
              value: 0
            }
          );

          graph.excessHeaderItems.push(
            {
              label: gridTime.label + "2", //separate half an hour, mostly it will not used
              value: 0
            }
          );
        });

      },

      /**
       * Build the Bar-Style Graph of Shifts : Manual & Demand
       * @param currentShiftPattern
       */
      buildGraph: function(currentShiftPattern){

        /**
         * Empty requiredHeaderItems and excessheaderitems
         */
        angular.forEach(graph.requiredHeaderItems, function(item) {
          item.value = 0;
        });

        angular.forEach(graph.excessHeaderItems, function(item) {
          item.value = 0;
        });

        var idx = 0;
        graph.requiredItems = {'totalRow': 0}; //initialize totalRow of requiredItems
        graph.excessItems = {'totalRow': 0}; //initialize totalRow of excessItems

        // Calculate Items

        graph.renderedRequiredShifts = [];
        graph.renderedExcessShifts = [];

        var _this = this;

        angular.forEach(currentShiftPattern.shifts, function(shift, key) {

          /**
           * Same Shift is pointing at same shift type
           * Assign each shift with copy of shift
           */

          if (!shift || shift.hasOwnProperty('id') === false) {
            //alert('Please select all of your shift types'); // Localization should be applied
            return;
          }

          var requiredShift = angular.copy(shift);
          var excessShift = angular.copy(shift);

          // add required,excess count
          requiredShift.required = currentShiftPattern.hours[idx].required;
          requiredShift.excess = currentShiftPattern.hours[idx].excess;
          excessShift.required = currentShiftPattern.hours[idx].required;
          excessShift.excess = currentShiftPattern.hours[idx].excess;

          requiredShift.x = requiredShift.start * 2; // get cell index, x
          excessShift.x = excessShift.start * 2; // get cell index, x

          /*
           Save Index to Shift it will be used in shift modal update
           */
          requiredShift.index = idx;
          excessShift.index = idx;

          var requiredNum = parseInt(currentShiftPattern.hours[idx].required) || 0;
          var excessNum = parseInt(currentShiftPattern.hours[idx].excess) || 0;

          for (var i = 0; i < shift.shiftLengthLength / MIN_PER_HOUR * 2; i++) {
            graph.requiredHeaderItems[requiredShift.x + i].value += requiredNum;
            graph.excessHeaderItems[excessShift.x + i].value += excessNum;
          }

          //calculate y for required

          var isShiftAssigned = false;
          if (requiredShift.required > 0 ) {

            for(i = 0; i < graph.requiredItems.totalRow; i++) { //i : row
              if (_this.checkShiftOverlap(graph.renderedRequiredShifts, requiredShift, i) === false ){
                requiredShift.y = i;

                graph.renderedRequiredShifts.push(requiredShift);
                isShiftAssigned = true;
                break;
              }
            }

            if (isShiftAssigned === false){

              /**
               * All rows are full, increase row and assign
               */
              requiredShift.y = graph.requiredItems.totalRow;
              graph.renderedRequiredShifts.push(requiredShift);
              graph.requiredItems.totalRow++;
            }
          }

          // calculate for excess
          isShiftAssigned = false;
          if (excessShift.excess > 0 ) {

            for(i = 0; i < graph.excessItems.totalRow; i++) { //i : row
              if (_this.checkShiftOverlap(graph.renderedExcessShifts, excessShift, i) === false ){
                excessShift.y = i;

                graph.renderedExcessShifts.push(excessShift);
                isShiftAssigned = true;
                break;
              }
            }

            if (isShiftAssigned === false){

              /**
               * All rows are full, increase row and assign
               */
              excessShift.y = graph.excessItems.totalRow;
              graph.renderedExcessShifts.push(excessShift);
              graph.excessItems.totalRow++;
            }
          }

          idx++;
        });

        var row = [];
        var renderedShift = null;
        var j;

        // Build Required Items Cell
        graph.requiredItems.data = [];
        for (i = 0; i < graph.requiredItems.totalRow; i++) {
          /**
           *  Iterate all columns
           */
          row = [];

          for (j = 0; j < 48 / MIN_PER_SCALE * MIN_PER_HOUR; j++) {

            // Check whether it is occupied with any shift or not
            renderedShift = _this.getOverlapShift(graph.renderedRequiredShifts,j,i);
            if ( renderedShift === null) {
              renderedShift = {
                shiftLengthLength: MIN_PER_SCALE,
                x: j
              };

              if (j % 2 === 0) {
                renderedShift.class = "no-border-right";
              } else {
                renderedShift.class = "no-border-left";
              }
              row.push(renderedShift); //30 mins cell
            }
            else {
              renderedShift.class = "selected";
              row.push(renderedShift);
              j += renderedShift.shiftLengthLength / MIN_PER_HOUR * 2 -1; // increased column index
            }
          }
          graph.requiredItems.data.push(row);

        }

        // Build Excess Items Cell
        graph.excessItems.data = [];
        for (i = 0; i < graph.excessItems.totalRow; i++) {
          /**
           *  Iterate all columns
           */
          row = [];

          for (j = 0; j < 48 / MIN_PER_SCALE * MIN_PER_HOUR; j++) {

            // Check whether it is occupied with any shift or not
            renderedShift = _this.getOverlapShift(graph.renderedExcessShifts, j,i);
            if ( renderedShift === null) {
              renderedShift = {
                shiftLengthLength: MIN_PER_SCALE,
                x: j
              };

              if (j % 2 === 0) {
                renderedShift.class = "no-border-right";
              } else {
                renderedShift.class = "no-border-left";
              }
              row.push(renderedShift); //30 mins cell
            }
            else {
              renderedShift.class = "selected";
              row.push(renderedShift);
              j += renderedShift.shiftLengthLength / MIN_PER_HOUR * 2 -1; // increased column index
            }
          }
          graph.excessItems.data.push(row);

        }

        graph.optimumCols = 24;
        var ele = null;
        /**
         * Calculate optimumCols
         */
        for (var i in graph.renderedRequiredShifts) {
          ele = graph.renderedRequiredShifts[i];
          if (ele.x + ele.shiftLengthLength / MIN_PER_HOUR * 2 > graph.optimumCols * 2) {
            graph.optimumCols += 12;
          }
        }

        for (i in graph.renderedRequiredShifts) {
          ele = graph.renderedRequiredShifts[i];
          if (ele.x + ele.shiftLengthLength / MIN_PER_HOUR * 2 > graph.optimumCols * 2) {
            graph.optimumCols += 12;
          }
        }
      },
      /**
       *
       * @param x
       * @param y
       */
      getOverlapShift: function(shiftCollection, x, y) {

        // Use native javascript for - loop because it contains break & continue
        for (var i=0; i < shiftCollection.length; i++) {
          var ele = shiftCollection[i];

          if (ele.y != y ){
            continue;
          }
          // check the overlap between rendered shift and new shift
          if  ((ele.x <= x) && (x < ele.x + ele.shiftLengthLength / MIN_PER_HOUR * 2)){
            return ele;
          }

        }

        return null;

      },
      /**
       * Check Overlap for shift
       * @param shiftCollection
       * @param shift
       * @param y
       */
      checkShiftOverlap: function(shiftCollection, shift, y) {

        // Use native javascript for - loop because it contains break & continue
        for (var i=0; i < shiftCollection.length; i++) {
          var ele = shiftCollection[i];

          if (ele.y != y ){
            continue;
          }
          // check the overlap between rendered shift and new shift
          /**
           * Shift.shiftLengthLength are 1 hour so should multiply by 2
           */
          if  ((ele.x <= shift.x) && (shift.x < ele.x + ele.shiftLengthLength / MIN_PER_HOUR * 2)){
            return true;
          }

          if  ((ele.x < shift.x + shift.shiftLengthLength / MIN_PER_HOUR *2 ) && (shift.x + shift.shiftLengthLength / MIN_PER_HOUR * 2 < ele.x + ele.shiftLengthLength / MIN_PER_HOUR * 2)){
            return true;
          }

          /**
           * check vice versa
           */
          if  ((shift.x <= ele.x) && (ele.x < shift.x + shift.shiftLengthLength / MIN_PER_HOUR * 2)){
            return true;
          }

          if  ((shift.x < ele.x + ele.shiftLengthLength / MIN_PER_HOUR *2 ) && (ele.x + ele.shiftLengthLength / MIN_PER_HOUR * 2 < shift.x + shift.shiftLengthLength / MIN_PER_HOUR * 2)){
            return true;

          }
        }

        return false;

      },
      getGraph: function() {
        return graph;
      },
      setGraph: function(value) {
        graph = value;
      }
    };
  })


  .service('patternList', ['$timeout', 'applicationContext', 'crudDataService','patternGraph',
    function ($timeout, applicationContext,crudDataService,patternGraph) {


      var factory = _.clone(crudDataService);
      var patternCalendar = {
        originShiftPattern: {},
        currentShiftPattern: {},
        demandShiftLengths: null
      };
      var graph = patternGraph.getGraph();

      var defaultPatternName = 'New Shift';
      var _this = this;

      return {

        /**
         * Init shift pattern day collection
         * if specificDateOnly is true, only clear last patternDay
         */

        initShiftPatternDayCollection: function(firstDayIntOfWeek) {

          var daysOfWeek =[
            {
              "day": "SUNDAY",
              "display": "calendar.SUNDAY",
              "patterns": []
            },
            {
              "day": "MONDAY",
              "display": "calendar.MONDAY",
              "patterns": []
            },
            {
              "day": "TUESDAY",
              "display": "calendar.TUESDAY",
              "patterns": []
            },
            {
              "day": "WEDNESDAY",
              "display": "calendar.WEDNESDAY",
              "patterns": []
            },
            {
              "day": "THURSDAY",
              "display": "calendar.THURSDAY",
              "patterns": []
            },
            {
              "day": "FRIDAY",
              "display": "calendar.FRIDAY",
              "patterns": []
            },
            {
              "day": "SATURDAY",
              "display": "calendar.SATURDAY",
              "patterns": []
            }
          ];

          /**
           * Empty the patterns only, keep the shiftpatternday object as a reference
           */

          if ((patternCalendar.shiftPatternDayCollection || null) === null) {
            patternCalendar.shiftPatternDayCollection = [];
          }
          else {
            patternCalendar.shiftPatternDayCollection.length = 0;
          }
          for (var i = 0; i < 7; i++) {
            patternCalendar.shiftPatternDayCollection.push(daysOfWeek[(i + firstDayIntOfWeek) % 7]);
          }

          //else {
          //  angular.forEach(patternCalendar.shiftPatternDayCollection, function(shiftPatternDay,key) {
          //    shiftPatternDay.patterns = [];
          //  });
          //}


          patternCalendar.maxDayPatternCount = 0;

        },
        /**
         *
         * @param column: Monday-Sunday (for General), date (for Specific), existing shiftPatternDay object (for existing)
         * @param dayType
         * @returns {*}
         */
        getShiftPatternDay: function(column, dayType, firstDayIntOfWeek) {
          /**
           * in case shift pattern is not assigned it will be assigned to Monday
           */
          var i = null;
          if (dayType === GENERAL ) {
            for (i in patternCalendar.shiftPatternDayCollection) {
              if (patternCalendar.shiftPatternDayCollection[i].day == column){
                return patternCalendar.shiftPatternDayCollection[i];
              }
            }
          }
          else if (dayType === SPECIFIC) {

            /**
             * day contains specific date now
             */
            var dayOfWeek = (new Date(column)).getDay();
            return patternCalendar.shiftPatternDayCollection[(dayOfWeek - firstDayIntOfWeek + 7) % 7 ];
          }
          else {
            /**
             * day represents previous existing shiftpatternday
             */
            for (i in patternCalendar.shiftPatternDayCollection) {
              if (patternCalendar.shiftPatternDayCollection[i].day == column) {
                return patternCalendar.shiftPatternDayCollection[i];
              }
            }
          }


          return null;
        },

        /**
         * This is internal function after user pass validation for array
         * @param shiftPatternDay
         * @param newPattern
         */
        processAddShiftPatternForDay: function(shiftPatternDay, newPattern) {

          /**
           * Insert the pattern into ShiftPatternDay in a sorted manner
           */

          for (var i=0; i<shiftPatternDay.patterns.length; i++) {
            if (shiftPatternDay.patterns[i].name > newPattern.name) {
              break;
            }
          }

          shiftPatternDay.patterns.splice(i,0,newPattern);

          this.updateMaxDayPatternCount();
        },

        // Update Max Pattern Count per Day
        updateMaxDayPatternCount: function() {

          patternCalendar.maxDayPatternCount = 0;

          angular.forEach(patternCalendar.shiftPatternDayCollection, function(shiftPatternDay, key) {

            if (shiftPatternDay.patterns.length > patternCalendar.maxDayPatternCount){
              patternCalendar.maxDayPatternCount = shiftPatternDay.patterns.length;
            }

          });

        },
        /**
         * get ShiftType based on id from shiftType collection
         * @param shiftTypeIdprocessAddShiftPatternForDay
         * @returns {shiftType}
         */
        getShiftType: function(shiftTypeId) {

          var shiftTypes = patternCalendar.option.shiftTypes;
          for (var i in shiftTypes) {
            var ele = shiftTypes[i];
            if (ele.id === shiftTypeId) {
              return ele;
            }
          }

          return null;

        },
        getShiftLength: function(shiftLengthId) {

          var shiftLengths = patternCalendar.option.manualShiftLengths;
          for (var i in shiftLengths) {
            var ele = shiftLengths[i];
            if (ele.id === shiftLengthId) {
              return ele;
            }
          }

          return null;

        },

        /**
        * Listens for changing current pattern
        */
        selectShiftPattern: function(pattern) {

          if (pattern.shiftPatternDayOfWeek) {
            this.processSetCurrentShiftPattern(pattern, this.getShiftPatternDay(pattern.shiftPatternDayOfWeek));
          }
          else {

            this.processSetCurrentShiftPattern(pattern,patternCalendar.currentShiftPatternDay);
          }

        },

        // Listens for shift pattern add
        addShiftPattern: function(pattern) {

          this.processAddShiftPatternForDay(this.getShiftPatternDay(pattern.shiftPatternDayOfWeek), pattern);

        },


        /**
         * getShiftPattern Obj from loaded shift patterns;
         * mostly shiftPattern object references are refreshed after reloading
         * @param shiftPatternDay
         * @param id
         */
        getShiftPattern: function(shiftPatternDay,id) {
          for (var i in shiftPatternDay.patterns) {
            var ele = shiftPatternDay.patterns[i];
            if (ele.id === id ) {
              return ele;
            }
          }
          return null;
        },

        /**
         * getShiftPattern Obj from loaded shift patternCollection;
         * mostly shiftPattern object references are refreshed after reloading
         * @param shiftPatternDay
         * @param id
         */
        getShiftPatternById: function(id) {
          for (var i in patternCalendar.shiftPatternDayCollection) {
            var shiftPatternDay = patternCalendar.shiftPatternDayCollection[i];

            for (var j in shiftPatternDay.patterns) {
              var ele = shiftPatternDay.patterns[j];
              if (ele.id === id ) {
                return ele;
              }
            }

          }
          return null;
        },

        /**
         * Set Current Shift Pattern, Loads shifts as well
         * Sometimes it is necessary to watch currentShiftPattern variable
         * @param pattern
         * @param shiftPatternDay
        */
        processSetCurrentShiftPattern: function(pattern, shiftPatternDay) {

          patternCalendar.currentShiftPattern.selected = false; // make current one not-selected
          pattern.selected = true;
          /**
           * Keep original one
           */
          patternCalendar.currentShiftPatternDay = shiftPatternDay;
          patternCalendar.currentShiftPattern = pattern;
          var originPattern = angular.copy(pattern, patternCalendar.originShiftPattern);


          if (pattern.loaded !== true) {
            /**
             * if it has id, load shift types for shift pattern
             */
            var _this = this;

  //          patternCalendar.currentShiftPattern = pattern;
  //          angular.copy(pattern, patternCalendar.originShiftPattern);

            factory.getElement("shiftpatterns" , pattern.id)
              .then(function(result){

                pattern.loaded = true;
                pattern.shifts = [];
                pattern.shiftIds = [];
                pattern.hours = [];
                pattern.shiftLengths = [];
                pattern.shiftReqDtos = result.shiftReqDtos;

                /**
                 * Max Rows in schedule demand creation, the dots graph
                 */
                //patternCalendar.currentShiftPattern.maxDemandCount = defaultMaxDemandCount;
                //patternCalendar.option.demandCount = patternCalendar.currentShiftPattern.maxDemandCount; //default demand Count
                //_this.clearDemands(patternCalendar.currentShiftPattern, patternCalendar.currentShiftPattern.maxDemandCount);
                /**
                 * This is used for manual shift pattern
                 */
                angular.forEach(result.shiftReqDtos, function(shiftReqDto, key) {
                  /*
                   Set shift type id
                   */
                  //var shift = getShiftType(shiftReqDto.shiftTypeId);
                  pattern.shifts.push(angular.copy(_this.getShiftType(shiftReqDto.shiftTypeId)));
                  pattern.shiftIds.push(shiftReqDto.shiftTypeId);
                  pattern.hours.push({'required': shiftReqDto.employeeCount, 'excess': shiftReqDto.excessCount});
                  pattern.shiftLengths.push(_this.getShiftLength(shiftReqDto.shiftLengthId));

                });

                angular.copy(pattern.shifts, originPattern.shifts);
                angular.copy(pattern.shiftIds, originPattern.shiftIds);
                angular.copy(pattern.hours, originPattern.hours);
                angular.copy(pattern.shiftLengths, originPattern.shiftLengths);

                /**
                 * below is used for demand based pattern
                 */

                pattern.shiftLengthList = result.shiftLengthList;
                pattern.shiftDemandDtos = result.shiftDemandDtos;
                pattern.shiftDemands = null;

                pattern.type = result.type;

                /**
                 * Update Option Values
                 */
                patternCalendar.option.patternType = pattern.shiftPatternType;
                patternCalendar.option.cdDate = pattern.shiftPatternCdDate;
                if (pattern.shiftPatternCdDate === null) {
                  patternCalendar.option.dayType = 'GENERAL';
                }
                else {
                  patternCalendar.option.dayType = 'SPECIFIC';
                }

                if (patternCalendar.option.patternType === 'Demand') {
                  if (pattern.shifts.length > 0) {
                    patternCalendar.option.demandPatternGenerated = true; //graph is already generated
                  }

                }
                _this.generateShiftPattern(pattern);
                //                    angular.copy(pattern.shiftLengthList, $scope.originShiftPattern.shiftLengthList);
                //                      angular.forEach(result.shiftDemandDtos, function(demandDto, key) {
                //                        /*
                //                         Set shift type id
                //                         */
                //                        //var shift = getShiftType(shiftReqDto.shiftTypeId);
                //                        pattern.shifts.push(getShiftType(shiftReqDto.shiftTypeId));
                //                        pattern.hours.push({'required': shiftReqDto.employeeCount, 'excess': shiftReqDto.excessCount});
                //
                //                        angular.copy(pattern.shifts, $scope.originShiftPattern.shifts);
                //                        angular.copy(pattern.hours, $scope.originShiftPattern.hours);
                //
                //                      });
  //              patternCalendar.currentShiftPattern = pattern;
  //              angular.copy(pattern, patternCalendar.originShiftPattern);

  //              var shiftPatternDay = null;
  //              if (pattern.shiftPatternCdDate !==null) {
  //                shiftPatternDay = _this.getShiftPatternDay(pattern.shiftPatternCdDate, SPECIFIC);
  //              }
  //              else {
  //                shiftPatternDay = _this.getShiftPatternDay(pattern.shiftPatternDayOfWeek, GENERAL);
  //              }
  //
  //              patternCalendar.currentShiftPatternDay = shiftPatternDay;

              }, function (error) {
                console.log(error);
                applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
              });
          }
          else {

            /**
             * Update Option Values
             */

            patternCalendar.option.patternType = pattern.shiftPatternType;
            patternCalendar.option.cdDate = pattern.shiftPatternCdDate;
            if (pattern.shiftPatternCdDate === null) {
              patternCalendar.option.dayType = 'GENERAL';
            }
            else {
              patternCalendar.option.dayType = 'SPECIFIC';
            }

            this.generateShiftPattern(pattern);
          }

        },

        /**
         * Update the shift pattern grid according to the condition
         */
        processAssignShiftPatterns: function(args) {

          var site = args.site;
          var team = args.team;
          var skill = args.skill;
          var shiftPatterns = [];

          if ((skill || null) !==null) {
            shiftPatterns = skill.generalPatterns.concat(skill.specificPatterns);
          }

          /**
           * Update Main Screen Specific Date
           */
          var cleanOnly = args.cleanOnly;

          /**
           * It will be used selected shift pattern after assign
           */
          var firstShirtPattern = null;

          /**
           * if CurrentPattern is contained in this list, we can select it otherwise select first element
           */
          var isCurrentPatternContained = false;
          var currentShiftPatternId = patternCalendar.currentShiftPattern.id;
          var currentShiftPattern = null;
          var shiftPatternDay = null;

          // Init Shift PatternDay Collection
          if (site === null ) {
            this.initShiftPatternDayCollection(0);
          }
          else {
            this.initShiftPatternDayCollection(site.firstDayIntOfWeek);
          }


          if (cleanOnly !== true ) {
            for (var i in shiftPatterns) {
              var ele = shiftPatterns[i];

  //            ele.shifts = [];
  //            ele.hours = [];
  //            ele.loaded = false;

              /* Conditions to Check */
              if ((site.id != ele.siteId) || (team.id != ele.teamId) || (skill.id != ele.skillId)) {
                continue;
              }

              if (currentShiftPatternId === ele.id ) {
                currentShiftPattern = ele;
                currentShiftPattern.shifts = ele.shifts;
                currentShiftPattern.shiftIds = ele.shiftIds;
                currentShiftPattern.hours = ele.hours;
                isCurrentPatternContained = true;
              }

              if (firstShirtPattern === null ) {
                firstShirtPattern = ele;
              }

              /*
               Check site, team and skill of pattern to match with dropdown list settings
               It will also assign the current shift pattern
               */
              shiftPatternDay = null;

              /**
               * It will only load into grid if pattern belongs to general day
               * Sometimes, for some reason shiftPatternDayOfWeek contains null value
               */


              if (ele.shiftPatternCdDate !==null) {
                shiftPatternDay = this.getShiftPatternDay(ele.shiftPatternCdDate, SPECIFIC, site.firstDayIntOfWeek);
              }
              else {
                shiftPatternDay = this.getShiftPatternDay(ele.shiftPatternDayOfWeek, GENERAL);
              }

              if (shiftPatternDay !== null) {
                this.processAddShiftPatternForDay(shiftPatternDay, ele);
              }

            }

            if (isCurrentPatternContained === true) {

              if (currentShiftPattern.shiftPatternCdDate !==null) {
                shiftPatternDay = this.getShiftPatternDay(currentShiftPattern.shiftPatternCdDate, SPECIFIC);
              }
              else {
                shiftPatternDay = this.getShiftPatternDay(currentShiftPattern.shiftPatternDayOfWeek, GENERAL);
              }

              this.processSetCurrentShiftPattern(currentShiftPattern,shiftPatternDay);
            }
            else if (firstShirtPattern !==null ) {

              if (firstShirtPattern.shiftPatternCdDate !==null) {
                shiftPatternDay = this.getShiftPatternDay(firstShirtPattern.shiftPatternCdDate, SPECIFIC);
              }
              else {
                shiftPatternDay = this.getShiftPatternDay(firstShirtPattern.shiftPatternDayOfWeek, GENERAL);
              }

              this.processSetCurrentShiftPattern(firstShirtPattern,shiftPatternDay);
            }
          }

          // Update Max Day Pattern
          this.updateMaxDayPatternCount();

          // Set first shift pattern as selected
          if (firstShirtPattern === null) {
            this.assignEmptyShiftPattern();
          }

        },

        getPatternCalendar: function() {
          return patternCalendar;
        },
        setPatternCalendar: function(value) {
          patternCalendar = value;
        },
        setDefaultOptions: function() {
          patternCalendar.option.patternType = 'Set';
          patternCalendar.option.dayType = 'GENERAL';
          patternCalendar.option.cdDate = null;
          patternCalendar.option.shiftPatternType = 'Set';
          patternCalendar.option.shiftPatternCdDate = null;
        },
        updateDemandShiftLengths: function (pattern, mouse) {

          if (mouse === true && patternCalendar.option.editing !== true) {
            patternCalendar.option.editing = true;
            pattern.shiftReqDtos = [];
          }

          /**
           * Clear the allowed property for demandHeaderItems
           */
          //angular.forEach($scope.demandHeaderItems, function(demandHeaderItem, key) {
          //  demandHeaderItem.allowed = false;
          //});

          //angular.forEach($scope.patternCalendar.demandShiftLengths, function(demandShiftLength, key){
          //
          //  if (demandShiftLength.checked) {
          //
          //    var shiftType = getShiftTypeFromShiftLength(demandShiftLength.id);
          //
          //    if (shiftType !== null) {
          //      for (var j=0; j< shiftType.shiftLengthLength / demandCellMin; j++ ) {
          //        $scope.demandHeaderItems[j+shiftType.start * MIN_PER_HOUR / demandCellMin ].allowed = true;
          //      }
          //    }
          //  }
          //
          //});

        },

        //clear dots area
        clearDemands: function(pattern, count) {

          pattern.demands = [];
          this.clearDemandHeaderItems(pattern);

          this.updateDemandShiftLengths(pattern); //update demand dto selection

          for (var i = 1; i <= count; i++) {
            var rowData = {
              row: i,
              data: []
            };

            pattern.demands.push(rowData);

            for (var j = 0; j < pattern.demandHeaderItems.length; j++) {
              rowData.data.push(0); //0: nothing, 1: it has demand, 2: unexpected extra
            }
          }
        },

        /**
         * Clear DemandHeaderItems: Dots Area
         */
        clearDemandHeaderItems: function(pattern) {
          pattern.demandHeaderItems = [];

          //Initialize Header Items with all 0
          angular.forEach(graph.gridTimes, function(gridTime, key) {

            /*
             Required Header Items
             */
            pattern.demandHeaderItems.push(
              {
                label: gridTime.label + "1", //separate half an hour, mostly it will not used
                value: '',
                allowed: false
              }
            );

            pattern.demandHeaderItems.push(
              {
                label: gridTime.label + "2", //separate half an hour, mostly it will not used
                value: '',
                allowed: false
              }
            );

          });
        },
        
        //Generate Shift Graph including circle demands and bar graphs
        generateShiftPattern: function() {
          if (patternCalendar.option.patternType === 'Demand') { //if only demand pattern

            if (!patternCalendar.currentShiftPattern.shiftDemandDtos) {
              // The data is not loaded completely
              return;
            }

            var ele = null;
            var j = 0;
            var i = 0;


            /**
             * Update the Demand Pattern ShiftLengths
             */
            if (!patternCalendar.currentShiftPattern.shiftLengthList) {
              this.checkAllDemandShiftLengths();
            } else {
              for (i=0; i < patternCalendar.demandShiftLengths.length; i++) {
                ele = patternCalendar.demandShiftLengths[i];
                ele.checked = false;
                if (patternCalendar.currentShiftPattern.shiftLengthList.indexOf(ele.id) > -1) {
                  ele.checked = true;
                }
              }
            }


            /**
             * Update MaxDemandCount
             */
            patternCalendar.currentShiftPattern.maxDemandCount = 0;


            for (i=0; i<patternCalendar.currentShiftPattern.shiftDemandDtos.length; i++) {
              ele = patternCalendar.currentShiftPattern.shiftDemandDtos[i];
              if (patternCalendar.currentShiftPattern.maxDemandCount < ele.employeeCount) {
                patternCalendar.currentShiftPattern.maxDemandCount = ele.employeeCount;
              }
            }

            if (patternCalendar.currentShiftPattern.maxDemandCount < defaultMaxDemandCount) {
              patternCalendar.currentShiftPattern.maxDemandCount = defaultMaxDemandCount;
            }

            this.clearDemands(patternCalendar.currentShiftPattern, patternCalendar.currentShiftPattern.maxDemandCount);
            patternCalendar.option.demandCount = patternCalendar.currentShiftPattern.maxDemandCount;

            /**
             * Apply shiftDemandDtos
             */
            for (i=0; i<patternCalendar.currentShiftPattern.shiftDemandDtos.length; i++) {

              ele = patternCalendar.currentShiftPattern.shiftDemandDtos[i];
              var index = ele.startTime / ele.lengthInMin / 60 / 1000;

              patternCalendar.currentShiftPattern.demandHeaderItems[index].value = ele.employeeCount;

              for (j =0; j < patternCalendar.currentShiftPattern.maxDemandCount; j++) {

                if (j< patternCalendar.currentShiftPattern.maxDemandCount - parseInt(ele.employeeCount)) {
                  patternCalendar.currentShiftPattern.demands[j].data[index] = 0; // empty
                }
                else {
                  patternCalendar.currentShiftPattern.demands[j].data[index] = 1; //show circle
                }

              }

            }

            if (patternCalendar.option.demandPatternGenerated === true) {

              $timeout(function(){
                patternGraph.buildGraph(patternCalendar.currentShiftPattern);

                /**
                 * compare requiredHeaderItems:ShiftReqDtos and demandHeaderItems:DemandHeaderItems
                 * and show dots in demands with yellow color
                 */

                for (i=0; i< graph.requiredHeaderItems.length; i++) {
                  var required = graph.requiredHeaderItems[i];
                  var demand = patternCalendar.currentShiftPattern.demandHeaderItems[i];
                  var diff = 0;

                  if (required.value > (demand.value || 0)) {
                    diff = required.value - (demand.value || 0);
                    /**
                     * Show yellow dots for the difference
                     */
                    var end = patternCalendar.currentShiftPattern.maxDemandCount - (demand.value || 0) ;
                    for (j =end -diff ; j < end; j++) {
                      patternCalendar.currentShiftPattern.demands[j].data[i] = 2; // empty
                    }

                  }
                }

              });
            }



          }
          else { //manual pattern

            $timeout(function(){
              patternGraph.buildGraph(patternCalendar.currentShiftPattern);
            });
          }  
        },

        /**
         * Demand Shift lengths : Check
         */
        checkAllDemandShiftLengths: function() {
          _.each(patternCalendar.demandShiftLengths, function(ele) {
            ele.checked = true;
          });
        },

        /**
         * Demand Shift lengths : Uncheck
         */
        uncheckAllDemandShiftLengths: function() {
          _.each(patternCalendar.demandShiftLengths, function(ele) {
            ele.checked = false;
          });
        },

        /**
         * Setup default demands with demandcount : circleArea
         */
        initializeDefaultDemands: function(pattern) {
          pattern.maxDemandCount = defaultMaxDemandCount;
          patternCalendar.option.demandCount = pattern.maxDemandCount; //default demand Count
          this.clearDemands(pattern, pattern.maxDemandCount);
        },

        /**
         * create and select empty shift pattern
         */
        assignEmptyShiftPattern: function() {
          var emptyPattern = {loaded: true, name: ''};
          patternCalendar.option.shiftPatternType = 'Set';
          patternCalendar.option.shiftPatternCdDate = null;
          var emptyPatternDay = {};


          // To be used for shift patterns generation
          emptyPattern.shifts = []; // Shift value
          emptyPattern.shiftIds = [];
          emptyPattern.hours = []; // Contains required and excess hours
          emptyPattern.shiftLengths = [];

          this.processSetCurrentShiftPattern(emptyPattern, emptyPatternDay);
          this.setDefaultOptions();
        }
      };
    }
  ]);


}());

;
angular.module('emlogis.settings', ['ui.bootstrap', 'ui.router', 'http-auth-interceptor', 'ui.grid', 'ui.grid.moveColumns',
  'ui.grid.pagination', 'ui.grid.selection', 'ui.grid.resizeColumns', 'emlogis.commonservices', 'emlogis.commonDirectives',
  'frapontillo.bootstrap-switch', 'emlogis.rules'])
  .config(['$stateProvider', '$urlRouterProvider', '$locationProvider', '$httpProvider', '$breadcrumbProvider',
    function ($stateProvider, $urlRouterProvider, $locationProvider, $httpProvider, $breadcrumbProvider) {

      $urlRouterProvider.when('/settings', '/settings/accounts');
      $urlRouterProvider.when('/settings/', '/settings/accounts');
      $urlRouterProvider.when('/settings/accounts', '/settings/accounts/groups');
      $urlRouterProvider.when('/settings/accounts/', '/settings/accounts/groups');
      $urlRouterProvider.when('/settings/accounts/groups', '/settings/accounts/groups/list');
      $urlRouterProvider.when('/settings/accounts/groups/', '/settings/accounts/groups/list');
      $urlRouterProvider.when('/settings/accounts/users', '/settings/accounts/users/list');
      $urlRouterProvider.when('/settings/accounts/users/', '/settings/accounts/users/list');
      $urlRouterProvider.when('/settings/accounts/roles', '/settings/accounts/roles/list');
      $urlRouterProvider.when('/settings/accounts/roles/', '/settings/accounts/roles/list');

      function permissionsUserAccount (authService) {
        return authService.hasPermissionIn(
            ['Account_Mgmt','Account_View','Demand_Mgmt','Availability_RequestMgmt','Shift_RequestMgmt','Shift_Mgmt']);
      }
      //Admin Role RW, ScheduleCreator & ShiftMngr RO
      function permissionsSettings (authService) {
        return authService.hasPermissionIn(
          ['SystemConfiguration_View','SystemConfiguration_Mgmt','Demand_View','Demand_Mgmt','Shift_Mgmt']);
      }//Admin Role RW, ScheduleCreator & ShiftMngr RO
      function permissionsRoles (authService) {
        return authService.hasPermissionIn(['Role_Mgmt','Support']);
      }

      $stateProvider.state('authenticated.settings', {
        url: '/settings',
        abstract: true,
        views: {
          'content@authenticated': {
            templateUrl: 'modules/settings/partials/settings.html',
            controller: 'SettingsCtrl'
          },
          'breadcrumb@authenticated': {
            templateUrl: 'modules/settings/partials/settings-breadcrumb.html',
            controller: 'SettingsBreadcrumbCtrl'
          }
        },
        data: {
          ncyBreadcrumbLabel: '{{"nav.SETTINGS" | translate}}'
        }
      })
        .state('authenticated.settings.accounts', {
          url: '/accounts',
          views: {
            'settingsContent@authenticated.settings': {
              templateUrl: 'modules/settings/partials/accounts/settings-accounts.html',
              controller: 'SettingsAccountsCtrl'
            },
            'settingsBreadcrumb@authenticated.settings': {
              templateUrl: 'modules/settings/partials/accounts/settings-accounts-breadcrumb.html',
              controller: 'SettingsAccountsBreadcrumbCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"settings.ACCOUNTS" | translate}}',
            permissions: function (authService) {
              return permissionsUserAccount(authService);
            }
          }
        })
        .state('authenticated.settings.accounts.groups', {
          url: '/groups',
          views: {
            'settingsAccountsContent@authenticated.settings.accounts': {
              templateUrl: 'modules/settings/partials/accounts/groups/settings-accounts-groups.html',
              controller: 'SettingsAccountsGroupsCtrl'
            },
            'settingsAccountsBreadcrumb@authenticated.settings.accounts': {
              templateUrl: 'modules/settings/partials/accounts/groups/settings-accounts-groups-breadcrumb.html',
              controller: 'SettingsAccountsGroupsBreadcrumbCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"settings.accounts.GROUPS" | translate}}',
            permissions: function (authService) {
              return permissionsUserAccount(authService);
            }
          }
        })
        .state('authenticated.settings.accounts.groups.list', {
          url: '/list',
          views: {
            'settingsAccountsGroupsContent@authenticated.settings.accounts.groups': {
              templateUrl: 'modules/settings/partials/accounts/groups/settings-accounts-groups-list.html',
              controller: 'SettingsAccountsGroupsListCtrl'
            },
            'settingsAccountsGroupsBreadcrumb@authenticated.settings.accounts.groups': {
              templateUrl: 'modules/settings/partials/accounts/groups/settings-accounts-groups-list-breadcrumb.html',
              controller: 'SettingsAccountsGroupsListBreadcrumbCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"app.LIST" | translate}}',
            permissions: function (authService) {
              return permissionsUserAccount(authService);
            }
          }
        })
        .state('authenticated.settings.accounts.groups.groupDetails', {
          url: '/:entityId/details',
          views: {
            'settingsAccountsGroupsContent@authenticated.settings.accounts.groups': {
              templateUrl: 'modules/settings/partials/accounts/groups/settings-accounts-groups-group-details.html',
              controller: 'SettingsAccountsGroupsGroupDetailsCtrl'
            },
            'settingsAccountsGroupsBreadcrumb@authenticated.settings.accounts.groups': {
              templateUrl: 'modules/settings/partials/accounts/groups/settings-accounts-groups-group-details-breadcrumb.html',
              controller: 'SettingsAccountsGroupsGroupDetailsBreadcrumbCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"app.DETAILS" | translate}}',
            permissions: function (authService) {
              return permissionsUserAccount(authService);
            }
          }
        })
        .state('authenticated.settings.accounts.groups.groupEdit', {
          url: '/:entityId/edit',
          views: {
            'settingsAccountsGroupsContent@authenticated.settings.accounts.groups': {
              templateUrl: 'modules/settings/partials/accounts/groups/settings-accounts-groups-group-edit.html',
              controller: 'SettingsAccountsGroupsGroupEditCtrl'
            },
            'settingsAccountsGroupsBreadcrumb@authenticated.settings.accounts.groups': {
              templateUrl: 'modules/settings/partials/accounts/groups/settings-accounts-groups-group-edit-breadcrumb.html',
              controller: 'SettingsAccountsGroupsGroupEditBreadcrumbCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"app.EDIT" | translate}}',
            permissions: function (authService) {
              return authService.hasPermission('Account_Mgmt');
            }
          }
        })
        .state('authenticated.settings.accounts.groups.create', {
          url: '/create',
          views: {
            'settingsAccountsGroupsContent@authenticated.settings.accounts.groups': {
              templateUrl: 'modules/settings/partials/accounts/groups/settings-accounts-groups-create.html',
              controller: 'SettingsAccountsGroupsCreateCtrl'
            },
            'settingsAccountsGroupsBreadcrumb@authenticated.settings.accounts.groups': {
              templateUrl: 'modules/settings/partials/accounts/groups/settings-accounts-groups-create-breadcrumb.html',
              controller: 'SettingsAccountsGroupsCreateBreadcrumbCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"app.CREATE" | translate}}',
            permissions: function (authService) {
              return authService.hasPermission('Account_Mgmt');
            }
          }
        })
        .state('authenticated.settings.accounts.users', {
          url: '/users',
          views: {
            'settingsAccountsContent@authenticated.settings.accounts': {
              templateUrl: 'modules/settings/partials/accounts/users/settings-accounts-users.html',
              controller: 'SettingsAccountsUsersCtrl'
            },
            'settingsAccountsBreadcrumb@authenticated.settings.accounts': {
              templateUrl: 'modules/settings/partials/accounts/users/settings-accounts-users-breadcrumb.html',
              controller: 'SettingsAccountsUsersBreadcrumbCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"settings.accounts.USERS" | translate}}',
            permissions: function (authService) {
              return permissionsUserAccount(authService);
            }
          }
        })
        .state('authenticated.settings.accounts.users.list', {
          url: '/list',
          views: {
            'settingsAccountsUsersContent@authenticated.settings.accounts.users': {
              templateUrl: 'modules/settings/partials/accounts/users/settings-accounts-users-list.html',
              controller: 'SettingsAccountsUsersListCtrl'
            },
            'settingsAccountsUsersBreadcrumb@authenticated.settings.accounts.users': {
              templateUrl: 'modules/settings/partials/accounts/users/settings-accounts-users-list-breadcrumb.html',
              controller: 'SettingsAccountsUsersListBreadcrumbCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"app.LIST" | translate}}',
            permissions: function (authService) {
              return permissionsUserAccount(authService);
            }
          }
        })
        .state('authenticated.settings.accounts.users.userDetails', {
          url: '/:entityId/details',
          views: {
            'settingsAccountsUsersContent@authenticated.settings.accounts.users': {
              templateUrl: 'modules/settings/partials/accounts/users/settings-accounts-users-user-details.html',
              controller: 'SettingsAccountsUsersUserDetailsCtrl'
            },
            'settingsAccountsUsersBreadcrumb@authenticated.settings.accounts.users': {
              templateUrl: 'modules/settings/partials/accounts/users/settings-accounts-users-user-details-breadcrumb.html',
              controller: 'SettingsAccountsUsersUserDetailsBreadcrumbCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"app.DETAILS" | translate}}',
            permissions: function (authService) {
              return permissionsUserAccount(authService);
            }
          }
        })
        .state('authenticated.settings.accounts.users.create', {
          url: '/create',
          views: {
            'settingsAccountsUsersContent@authenticated.settings.accounts.users': {
              templateUrl: 'modules/settings/partials/accounts/users/settings-accounts-users-create.html',
              controller: 'SettingsAccountsUsersCreateCtrl'
            },
            'settingsAccountsUsersBreadcrumb@authenticated.settings.accounts.users': {
              templateUrl: 'modules/settings/partials/accounts/users/settings-accounts-users-create-breadcrumb.html',
              controller: 'SettingsAccountsUsersCreateBreadcrumbCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"app.CREATE" | translate}}',
            permissions: function (authService) {
              return authService.hasPermission('Account_Mgmt');
            }
          }
        })
        .state('authenticated.settings.accounts.roles', {
          url: '/roles',
          views: {
            'settingsAccountsContent@authenticated.settings.accounts': {
              templateUrl: 'modules/settings/partials/accounts/roles/settings-accounts-roles.html',
              controller: 'SettingsAccountsRolesCtrl'
            },
            'settingsAccountsBreadcrumb@authenticated.settings.accounts': {
              templateUrl: 'modules/settings/partials/accounts/roles/settings-accounts-roles-breadcrumb.html',
              controller: 'SettingsAccountsRolesBreadcrumbCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"settings.accounts.ROLES" | translate}}',
            permissions: function (authService) {
              return permissionsRoles(authService);
            }
          }
        })
        .state('authenticated.settings.accounts.roles.list', {
          url: '/list',
          views: {
            'settingsAccountsRolesContent@authenticated.settings.accounts.roles': {
              templateUrl: 'modules/settings/partials/accounts/roles/settings-accounts-roles-list.html',
              controller: 'SettingsAccountsRolesListCtrl'
            },
            'settingsAccountsRolesBreadcrumb@authenticated.settings.accounts.roles': {
              templateUrl: 'modules/settings/partials/accounts/roles/settings-accounts-roles-list-breadcrumb.html',
              controller: 'SettingsAccountsRolesListBreadcrumbCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"app.LIST" | translate}}',
            permissions: function (authService) {
              return permissionsRoles(authService);
            }
          }
        })
        .state('authenticated.settings.accounts.roles.roleDetails', {
          url: '/:entityId/details',
          views: {
            'settingsAccountsRolesContent@authenticated.settings.accounts.roles': {
              templateUrl: 'modules/settings/partials/accounts/roles/settings-accounts-roles-role-details.html',
              controller: 'SettingsAccountsRolesRoleDetailsCtrl'
            },
            'settingsAccountsRolesBreadcrumb@authenticated.settings.accounts.roles': {
              templateUrl: 'modules/settings/partials/accounts/roles/settings-accounts-roles-role-details-breadcrumb.html',
              controller: 'SettingsAccountsRolesRoleDetailsBreadcrumbCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"app.DETAILS" | translate}}',
            permissions: function (authService) {
              return permissionsRoles(authService);
            }
          }
        })
        .state('authenticated.settings.accounts.roles.roleEdit', {
          url: '/:entityId/edit',
          views: {
            'settingsAccountsRolesContent@authenticated.settings.accounts.roles': {
              templateUrl: 'modules/settings/partials/accounts/roles/settings-accounts-roles-role-edit.html',
              controller: 'SettingsAccountsRolesRoleEditCtrl'
            },
            'settingsAccountsRolesBreadcrumb@authenticated.settings.accounts.roles': {
              templateUrl: 'modules/settings/partials/accounts/roles/settings-accounts-roles-role-edit-breadcrumb.html',
              controller: 'SettingsAccountsRolesRoleEditBreadcrumbCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"app.EDIT" | translate}}',
            permissions: function (authService) {
              return permissionsRoles(authService);
            }
          }
        })
        .state('authenticated.settings.accounts.roles.create', {
          url: '/create',
          views: {
            'settingsAccountsRolesContent@authenticated.settings.accounts.roles': {
              templateUrl: 'modules/settings/partials/accounts/roles/settings-accounts-roles-create.html',
              controller: 'SettingsAccountsRolesCreateCtrl'
            },
            'settingsAccountsRolesBreadcrumb@authenticated.settings.accounts.roles': {
              templateUrl: 'modules/settings/partials/accounts/roles/settings-accounts-roles-create-breadcrumb.html',
              controller: 'SettingsAccountsRolesCreateBreadcrumbCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"app.CREATE" | translate}}',
            permissions: function (authService) {
              return permissionsRoles(authService);
            }
          }
        })
        //.state('authenticated.settings.passwordPolicy', {
        //  url: '/password-policy',
        //  views: {
        //    'settingsContent@authenticated.settings': {
        //      templateUrl: 'modules/settings/partials/password-policy/settings-password-policy.html',
        //      controller: 'SettingsPasswordPolicyCtrl'
        //    },
        //    'settingsBreadcrumb@authenticated.settings': {
        //      templateUrl: 'modules/settings/partials/password-policy/settings-password-policy-breadcrumb.html',
        //      controller: 'SettingsPasswordPolicyBreadcrumbCtrl'
        //    }
        //  },
        //  data: {
        //    ncyBreadcrumbLabel: '{{"settings.PASSWORD_POLICY" | translate}}',
        //    permissions: function (authService) {
        //      return permissionsSettings(authService);
        //    }
        //  }
        //})
        ;
    }
  ])
  .run(['$rootScope', '$http', function ($rootScope, $http) {
    $rootScope.consts = {
      entityTypes: {
        group: 'group',
        user: 'user',
        role: 'role',
        accessControl: 'access control',
        permission: 'permission'
      }
    };
  }]);

;
angular.module('emlogis.settings').controller('EntityDetailsContainerCtrl', ['$scope', '$state', '$modal', '$timeout', 'applicationContext', 'crudDataService', 'uiGridConstants', 'SettingsAccountsService', 'UtilsService',
  function ($scope, $state, $modal, $timeout, applicationContext, crudDataService, uiGridConstants, SettingsAccountsService, UtilsService) {

    $scope.entity = null;
    $scope.entityDetails = {};

    $scope.fillEntityDetails = function () {
      $scope.entityDetails = $scope.populateEntityDetails($scope.entity);
    };

    $scope.selectSubTab = function (relatedEntity) {
      angular.forEach($scope.entityDetails.relatedEntities, function (item) {
        item.selected = false;
      });

      relatedEntity.selected = true;
    };

    $scope.openDuplicateEntityModal = function () {
      var modalInstance = $modal.open({
        templateUrl: 'duplicateEntity.html',
        controller: 'DuplicateEntityModalInstanceCtrl',
        backdrop: false,
        windowClass: 'duplicate-entity-modal',
        resolve: {
          entityName: function () {
            return $scope.entityName;
          },
          fieldsToRedefineInDuplication: function () {
            return $scope.entityDetails.fieldsToRedefineInDuplication;
          }
        }
      });

      /*$timeout(function() {
       var duplicateEntityButtonPosition = $('.btn-duplicate-entity').offset();
       $('.duplicate-entity-modal').css('position', 'absolute');
       $('.duplicate-entity-modal').css('top', duplicateEntityButtonPosition.top + 30);
       $('.duplicate-entity-modal').css('left', duplicateEntityButtonPosition.left - 400);
       }, 0);*/

      modalInstance.result.then(function (fieldsToRedefineInDuplication) {
        var inputJson = {};
        angular.forEach(fieldsToRedefineInDuplication, function (field) {
          inputJson[field.key] = field.value;
        });

        SettingsAccountsService.duplicateEntity($scope.entityType, $scope.entityId, inputJson).then(function (response) {
          applicationContext.setNotificationMsgWithValues('app.DUPLICATED_SUCCESSFULLY', 'success', true);
          var newEntityId = response.data.id;
          $state.go($scope.entityDetailsStateName, {entityId: newEntityId});
        }, function (err) {
          applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
        });
      });
    };

    $scope.goToEntityEditState = function () {
      if ($scope.entityType === $scope.consts.entityTypes.role && $scope.entityDetails.id === 'adminrole') {
        applicationContext.setNotificationMsgWithValues('settings.accounts.DEFAULT_ADMIN_ROLE_CANT_BE_EDITED', 'success', true);
        return;
      }
      $state.go($scope.entityEditStateName, {entityId: $scope.entityId});
    };

    $scope.confirmDeleteEntity = function () {
      if ($scope.entityType === $scope.consts.entityTypes.user && $scope.entityDetails.id === 'admin') {
        applicationContext.setNotificationMsgWithValues('settings.accounts.DEFAULT_ADMIN_USER_ACCOUNT_CANT_BE_DELETED', 'success', true);
        return;
      }

      if ($scope.entityType === $scope.consts.entityTypes.role && $scope.entityDetails.id === 'adminrole') {
        applicationContext.setNotificationMsgWithValues('settings.accounts.DEFAULT_ADMIN_ROLE_CANT_BE_DELETED', 'success', true);
        return;
      }

      SettingsAccountsService.deleteEntity($scope.entityType, $scope.entityId).then(function (response) {
        applicationContext.setNotificationMsgWithValues('app.DELETED_SUCCESSFULLY', 'success', true);
        $state.go($scope.entityListStateName);
      }, function (err) {
        applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
      });
    };

    $scope.getEntityDetails = function () {
      SettingsAccountsService.getEntityDetails($scope.entityType, $scope.entityId).then(function (response) {
        $scope.entity = response.data;
        $scope.fillEntityDetails();
      }, function (err) {
        applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
      });
    };

    $scope.getEntityDetails();
  }
]);

angular.module('emlogis.settings').controller('DuplicateEntityModalInstanceCtrl', ['$scope', '$modalInstance', 'entityName', 'fieldsToRedefineInDuplication',
  function ($scope, $modalInstance, entityName, fieldsToRedefineInDuplication) {
    $scope.entityDetails = {
      entityName: entityName
    };
    $scope.fieldsToRedefineInDuplication = fieldsToRedefineInDuplication;

    $scope.confirmDuplicateEntity = function () {
      $modalInstance.close($scope.fieldsToRedefineInDuplication);
    };

    $scope.cancel = function () {
      $modalInstance.dismiss('cancel');
    };
  }
]);
;
angular.module('emlogis.settings').controller('EntityEditContainerCtrl', ['$scope', '$q', '$state', '$modal', '$timeout', 'SettingsAccountsService', 'applicationContext',
  function ($scope, $q, $state, $modal, $timeout, SettingsAccountsService, applicationContext) {

    $scope.entity = null;
    $scope.entityDetails = {};
    $scope.submitClicked = false;

    $scope.fillEntityDetails = function () {
      $scope.entityDetails = $scope.populateEntityDetails($scope.entity);
      $scope.originalEntityDetails = {
        id: $scope.entityDetails.id,
        entityType: $scope.entityType
      };
    };

    $scope.selectSubTab = function (relatedEntity) {
      angular.forEach($scope.entityDetails.relatedEntities, function (item) {
        item.selected = false;
      });

      relatedEntity.selected = true;
    };

    $scope.addRelatedEntities = function (relatedEntityDetails, selectedEntityIds) {
      var deferred = $q.defer();
      SettingsAccountsService.operateOnRelatedEntity('add', $scope.entityType, $scope.entityId, relatedEntityDetails.entityType, selectedEntityIds).then(function (response) {
        deferred.resolve('Added Successfully!!!');
      }, function (err) {
        applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
        deferred.reject('Error occurred while trying to add related entities');
      });
      return deferred.promise;
    };

    $scope.removeRelatedEntities = function (relatedEntityDetails, selectedEntities) {
      var deferred = $q.defer();
      var selectedEntityIds = [];

      angular.forEach(selectedEntities, function(entity) {
        if (relatedEntityDetails.entityType === $scope.consts.entityTypes.role &&
          entity.id === 'adminrole' && $scope.entityType === $scope.consts.entityTypes.user &&
          $scope.entityDetails.id === 'admin') {
          applicationContext.setNotificationMsgWithValues('settings.accounts.ASSOCIATED_ADMIN_ROLE_CANT_BE_REMOVED', 'success', true);
        } else {
          selectedEntityIds.push(entity.id);
        }
      });

      SettingsAccountsService.operateOnRelatedEntity('remove', $scope.entityType, $scope.entityId, relatedEntityDetails.entityType, selectedEntityIds).then(function (response) {
        deferred.resolve('Removed Successfully!!!');
      }, function (err) {
        applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
        deferred.reject('Error occurred while trying to remove related entities');
      });
      return deferred.promise;
    };

    $scope.applyEdit = function (isValid) {

      $scope.submitClicked = true;
      if (!isValid) {
        applicationContext.setNotificationMsgWithValues('app.PLEASE_FILL_CORRECT_DATA_IN_FIELDS', 'danger', true);
        return;
      }

      var editPromise = null;
      $scope.entityEditDetails = {};
      angular.forEach($scope.entityDetails.info, function (rowData) {
        angular.forEach(rowData, function (infoField) {
          $scope.entityEditDetails[infoField.key] = infoField.value;
        });
      });

      if ($scope.editMode === 'New') {
        editPromise = SettingsAccountsService.createEntity($scope.entityType, $scope.entityEditDetails);
      } else {
        editPromise = SettingsAccountsService.updateEntity($scope.entityType, $scope.entityDetails.id, $scope.entityEditDetails);
      }
      editPromise.then(function (response) {
        if ($scope.editMode === 'New') {
          applicationContext.setNotificationMsgWithValues('app.CREATED_SUCCESSFULLY', 'success', true);
        } else {
          applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', 'success', true);
        }
        $state.go($scope.entityEditStateName, {entityId: response.data.id});
      }, function (err) {
        applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
        $state.go($scope.entityListStateName);
      });
    };

    $scope.closeEdit = function () {
      if ($scope.editMode === 'New') {
        $state.go($scope.entityListStateName);
      } else {
        $state.go($scope.entityDetailsStateName, {entityId: $scope.entityDetails.id});
      }
    };

    $scope.initEditDetails = function () {
      if ($scope.editMode === 'New') {
        $scope.entity = {};
        $scope.fillEntityDetails();
      } else {
        SettingsAccountsService.getEntityDetails($scope.entityType, $scope.entityId).then(function (response) {
          $scope.entity = response.data;
          $scope.fillEntityDetails();
        }, function (err) {
          applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
        });
      }
    };

    $scope.initEditDetails();
  }
]);

;
angular.module('emlogis.settings').controller('EntityListContainerCtrl', ['$scope', '$state', '$q', '$http', '$filter', 'applicationContext', 'crudDataService', 'uiGridConstants', 'SettingsAccountsService', 'UtilsService',
  function ($scope, $state, $q, $http, $filter, applicationContext, crudDataService, uiGridConstants, SettingsAccountsService, UtilsService) {
    $scope.filter = {
      filterTxt: '',
      confirmedFilterTxt: ''
    };

    $scope.filterList = function () {
      $scope.filter.confirmedFilterTxt = $scope.filter.filterTxt;
    };

    $scope.getEntityList = function () {
      var deferred = $q.defer();
      var offset = 0;
      var limit = 0;
      SettingsAccountsService.getEntityList($scope.entityDetails.entityType, $scope.filter.filterTxt, offset, limit).then(function (response) {
        if (response.data) {
          deferred.resolve({data: response.data.result});
        } else {
          deferred.reject('Error Occurred while trying to get Entity List');
        }
      }, function (err) {
        applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
        deferred.reject('Error Occurred while trying to get Entity List');
      });
      return deferred.promise;
    };

    //list for pagnination
    $scope.getEntityListForPagination = function (entityListGridOptions, paginationOptions) {
      var deferred = $q.defer();
      var offset = (paginationOptions.pageNumber - 1) * paginationOptions.pageSize;
      var limit = paginationOptions.pageSize;
      var orderBy = paginationOptions.orderBy;
      var orderDir = paginationOptions.orderDir;
      SettingsAccountsService.getEntityList($scope.entityDetails.entityType, $scope.filter.filterTxt, offset, limit, orderBy, orderDir).then(function (response) {
        if (response.data) {
          entityListGridOptions.totalItems = response.data.total;
          deferred.resolve({data: response.data.result});
        } else {
          deferred.reject('Error Occurred while trying to get Entity List');
        }
      }, function (err) {
        applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
        deferred.reject('Error Occurred while trying to get Entity List');
      });
      return deferred.promise;
    };

    //refresh the page.
    $scope.refresh = function() {
      $scope.getEntityListForPagination();
    };
  }
]);


;
angular.module('emlogis.settings').controller('entitySelectionListModalCtrl', ['$scope', '$q', '$modalInstance', 'SettingsAccountsService', 'originalEntityDetails', 'entityDetails', 'convertEntityToGridRow',
  function ($scope, $q, $modalInstance, SettingsAccountsService, originalEntityDetails, entityDetails, convertEntityToGridRow) {

    $scope.data = {
      entityList: [],
      selectedEntityIds: [],
      originalEntityDetails: originalEntityDetails,
      entityDetails: entityDetails,
      convertEntityToGridRow: function (entity) {
        return convertEntityToGridRow({message: entity});
      }
    };

    $scope.processSelectedRow = function (row) {
      if (row.isSelected) {
        $scope.data.selectedEntityIds.push(row.entity.id);
      } else {
        var idIndex = $scope.data.selectedEntityIds.indexOf(row.entity.id);
        $scope.data.selectedEntityIds.splice(idIndex, 1);
      }
    };

    $scope.ok = function () {
      $modalInstance.close($scope.data.selectedEntityIds);
    };

    $scope.cancel = function () {
      $modalInstance.dismiss('cancel');
    };

    $scope.getEntityList = function () {
      var deferred = $q.defer();
      var offset = 0;
      var limit = 0;
      SettingsAccountsService.getRelatedEntities($scope.data.originalEntityDetails.entityType, $scope.data.originalEntityDetails.id, $scope.data.entityDetails.entityType, false, null, offset, limit).then(function (response) {
        if (response.data) {
          deferred.resolve({data: response.data.result});
        } else {
          deferred.reject('Error Occurred while trying to get Entity List');
        }
      }, function (err) {
        console.log(err);
        deferred.reject('Error Occurred while trying to get Entity List');
      });
      return deferred.promise;
    };

    $scope.getEntityListForPagination = function (entityListGridOptions, paginationOptions) {
      var deferred = $q.defer();
      var offset = (paginationOptions.pageNumber - 1) * paginationOptions.pageSize;
      var limit = paginationOptions.pageSize;
      SettingsAccountsService.getRelatedEntities($scope.data.originalEntityDetails.entityType, $scope.data.originalEntityDetails.id, $scope.data.entityDetails.entityType, false, null, offset, limit).then(function (response) {
        if (response.data) {
          entityListGridOptions.totalItems = response.data.total;
          deferred.resolve({data: response.data.result});
        } else {
          deferred.reject('Error Occurred while trying to get Entity List');
        }
      }, function (err) {
        console.log(err);
        deferred.reject('Error Occurred while trying to get Entity List');
      });
      return deferred.promise;
    };
  }
]);
;
(function () {
  "use strict";

  var settings = angular.module('emlogis.settings');

  settings.controller('SettingsAccountsGroupsAclModalCtrl',
    [
      '$rootScope',
      '$scope',
      '$timeout',
      '$modalInstance',
      'uiGridConstants',
      'applicationContext',
      'dataService',
      'SettingsAccountsService',
      'group',
      'acl',
      function ($rootScope,$scope, $timeout, $modalInstance, uiGridConstants, applicationContext, dataService,
                SettingsAccountsService, group, acl) {

        //--------------------------------------------------------------------
        // Defaults for Employees Modal
        //--------------------------------------------------------------------

        var te = this;

        te.group = group;
        te.acl = acl;

        // checkbox action for all sites/teams
        te.updateAllSitesStatus = function() {

          if (te.acl.allSitesAccessType === 'RW') {
            _.each(te.acl.result, function(site) {
              site.accessType = 'RW';
              site.teamsDto.allTeamsAccessType = 'Void';

              _.each(site.teamsDto.teamDtos, function(team) {
                team.accessType = 'Void';
              });

            });
          }
          //else {
          //  _.each(te.acl.result, function(site) {
          //    site.accessType = 'Void';
          //    site.teamsDto.allTeamsAccessType = 'Void';
          //
          //    _.each(site.teamsDto.teamDtos, function(team) {
          //      team.accessType = 'Void';
          //    });
          //
          //  });
          //}

        };

        // checkbox action for site all teams
        te.updateSiteAllTeamsStatus = function(site){

          if (site.teamsDto.allTeamsAccessType === 'RW') {
            site.accessType = 'RW';
            _.each(site.teamsDto.teamDtos, function(team) {
              team.accessType = 'Void';
            });
          }
          else {
            site.accessType = 'Void';
            //_.each(site.teamsDto.teamDtos, function(team) {
            //  team.accessType = 'Void';
            //});
          }

        };

        // checkbox of individual team
        te.updateSiteTeamStatus = function(site,team) {
          var checkedTeam = _.findWhere(site.teamsDto.teamDtos, {'accessType': 'RW'});
          if (checkedTeam) {
            site.accessType = 'RW';
          }
          else {
            site.accessType = 'Void';
          }


          // update site-all-teams checkbox
          //site.teamsDto.allTeamsAccessType = te.getSiteAllTeamsStatus(site);

          // update all sites-teams check
          //te.acl.allSitesAccessType = te.getAllSitesStatus();

        };

        te.getAllSitesStatus = function() {
          var uncheckedSite = _.find(te.acl.result, function(site) {
            return site.teamsDto.allTeamsAccessType === 'Void';
          });

          if (uncheckedSite) {
            return 'Void';
          }
          else {
            return 'RW';
          }
        };

        te.getSiteAllTeamsStatus = function(site) {
          var uncheckedTeam = _.findWhere(site.teamsDto.teamDtos, {'accessType': 'Void'});
          if (uncheckedTeam) {
            return 'Void';
          }
          else {
            return 'RW';
          }
        };

        /**
         * Update Acl of groups: Settings->Accounts->Groups->Acl
         */
        te.updateGroupAcl = function() {

          SettingsAccountsService.operateOnRelatedEntity(null, $rootScope.consts.entityTypes.group, te.group.id, $rootScope.consts.entityTypes.accessControl, te.acl).then(function (response) {
            $modalInstance.close();
          }, function (err) {
            applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
          });
        };

        //--------------------------------------------------------------------
        // Modal methods: ACCOUNTS-GROUPS-ACL-MODAL.JS
        //--------------------------------------------------------------------

        te.closeModal = function () {
          $modalInstance.dismiss('cancel');
        };

        //
        // If user navigates away from the page,
        // dismiss the modal

        $scope.$on('$stateChangeStart', function(){
            $modalInstance.dismiss('cancel');
          }
        );

      }
    ]);
})();
;
angular.module('emlogis.settings').controller('SettingsAccountsGroupsBreadcrumbCtrl', ['$scope', '$state', '$translate', 'applicationContext',
  function ($scope, $state, $translate, applicationContext) {
    $scope.entityName = "settings.accounts.groups.NAME";
    $scope.entityResource = "settings.accounts.GROUPS";
    $scope.entityQuickSearchUrl = "groupaccounts/ops/quicksearch";

    $scope.selectEntitySearchValue = function (item, model, label) {
      $state.go('authenticated.settings.accounts.groups.groupDetails', {entityId: item.id});
    };

    $scope.goToNewEntityState = function () {
      $state.go('authenticated.settings.accounts.groups.create');
    };

    $scope.hasMgmtPermission = function () {
      return $scope.hasPermission('Account_Mgmt');
    };

    $scope.hasViewPermission = function () {
      return $scope.hasPermission('Account_View');
    };
  }
]);

;
angular.module('emlogis.settings').controller('SettingsAccountsGroupsCreateBreadcrumbCtrl', ['$scope', '$translate', 'applicationContext',
  function ($scope, $translate, applicationContext) {

  }
]);

;
angular.module('emlogis.settings').controller('SettingsAccountsGroupsCreateCtrl', ['$scope', '$q', '$timeout', '$state', '$modal', '$http', '$filter', 'applicationContext', 'crudDataService', 'uiGridConstants', 'SettingsAccountsService', 'UtilsService',
  function ($scope, $q, $timeout, $state, $modal, $http, $filter, applicationContext, crudDataService, uiGridConstants, SettingsAccountsService, UtilsService) {

    $scope.editMode = 'New';
    $scope.editLabel = 'app.CREATE';
    $scope.entityId = null;

    $scope.populateEntityDetails = function (entity) {
      var entityDetails = {};

      entityDetails.id = null;
      entityDetails.name = null;
      entityDetails.info = [
        [
          {
            label: 'app.NAME',
            key: 'name',
            placeHolder: 'app.NAME',
            value: null,
            class: 'col-sm-3',
            type: 'text',
            validation: 'required'
          },
          {
            label: 'settings.accounts.DESCRIPTION',
            key: 'description',
            placeHolder: 'settings.accounts.DESCRIPTION',
            value: null,
            class: 'col-sm-3',
            type: 'text',
            validation: 'none'
          }
        ]
      ];

      return entityDetails;
    };
  }
]);

;
angular.module('emlogis.settings').controller('SettingsAccountsGroupsGroupDetailsBreadcrumbCtrl', ['$scope', '$translate', 'applicationContext',
  function ($scope, $translate, applicationContext) {

  }
]);

;
angular.module('emlogis.settings')
  .controller('SettingsAccountsGroupsGroupDetailsCtrl',
  [
    '$scope',
    '$state',
    '$stateParams',
    '$q',
    '$http',
    '$filter',
    '$modal',
    '$log',
    'applicationContext',
    'crudDataService',
    'uiGridConstants',
    'SettingsAccountsService',
    'UtilsService',
    'dataService',
    function ($scope, $state, $stateParams, $q, $http, $filter, $modal, $log, applicationContext, crudDataService,
              uiGridConstants, SettingsAccountsService, UtilsService, dataService) {


      // init function: settings/accounts/group-detail
      $scope.init = function() {
        $scope.entityId = $stateParams.entityId;
        $scope.getEntityDetails();
      };


      $scope.getEntityDetails = function () {
        SettingsAccountsService.getEntityDetails($scope.entityType, $scope.entityId).then(function (response) {
          $scope.entity = response.data;
          $scope.fillEntityDetails();
        }, function (err) {
          applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
        });
      };

      $scope.fillEntityDetails = function () {
        $scope.entityDetails = $scope.populateEntityDetails($scope.entity);
      };

      $scope.populateEntityDetails = function (entity) {
        var entityDetails = {};

        entityDetails.id = entity.id;
        entityDetails.name = entity.name;
        entityDetails.info = [
          [
            {
              label: 'app.NAME',
              key: 'name',
              placeHolder: 'app.NAME',
              value: entity.name,
              class: 'col-sm-4',
              type: 'text',
              validation: 'required'
            }
          ],
          [
            {
              label: 'settings.accounts.DESCRIPTION',
              key: 'description',
              placeHolder: 'settings.accounts.DESCRIPTION',
              value: entity.description,
              class: 'col-sm-8',
              type: 'text',
              validation: 'none'
            }

          ]
        ];

        entityDetails.users = {};
        entityDetails.roles = {};
        entityDetails.acl = {};

        // Get list of users & roles & acls
        $scope.loadRelatedEntities($scope.consts.entityTypes.user, entityDetails.users);
//        $scope.loadRelatedEntitiesWithFilter($scope.consts.entityTypes.role, entityDetails.roles, "primaryKey.id NOT Like 'acl-%'");
        $scope.loadRelatedEntitiesWithFilter($scope.consts.entityTypes.role, entityDetails.roles, "primaryKey.id+NOT+Like+%27acl-%25%27");
        $scope.loadRelatedEntities($scope.consts.entityTypes.accessControl, entityDetails.acl);

        entityDetails.canDuplicate = false;

        return entityDetails;
      };

      /**
       * Eml Object related functions
       */
      $scope.openRolesModal = function (group) {

        var modalInstance = $modal.open({
          templateUrl: 'modules/settings/partials/include/settings-accounts-groups-roles-modal.tmpl.html',
          controller: 'SettingsAccountsGroupsRolesModalCtrl as te',
          size: 'lg',
          resolve: {
            group: function () {
              return group;
            }
          }
        });

        modalInstance.result.then(function () {
//          $scope.loadRelatedEntities($scope.consts.entityTypes.role, $scope.entityDetails.roles);
          $scope.loadRelatedEntitiesWithFilter($scope.consts.entityTypes.role, $scope.entityDetails.roles, "primaryKey.id+NOT+Like+%27acl-%25%27");
        }, function () {
          $log.info('Modal dismissed at: ' + new Date());
        });
      };

      $scope.openUsersModal = function (group) {

        var modalInstance = $modal.open({
          templateUrl: 'modules/settings/partials/include/settings-accounts-groups-users-modal.tmpl.html',
          controller: 'SettingsAccountsGroupsUsersModalCtrl as te',
          size: 'lg',
          resolve: {
            group: function () {
              return group;
            }
          }
        });

        modalInstance.result.then(function () {
          $scope.loadRelatedEntities($scope.consts.entityTypes.user, $scope.entityDetails.users);

        }, function () {
          $log.info('Modal dismissed at: ' + new Date());
        });
      };

      $scope.openAclModal = function (group) {

        var modalInstance = $modal.open({
          templateUrl: 'modules/settings/partials/include/settings-accounts-groups-acl-modal.tmpl.html',
          controller: 'SettingsAccountsGroupsAclModalCtrl as te',
          size: 'lg',
          resolve: {
            group: function () {
              return group;
            },
            acl: function () {
              return angular.copy($scope.entityDetails.acl);
            }
          }
        });

        modalInstance.result.then(function (response) {
          $scope.loadRelatedEntities($scope.consts.entityTypes.accessControl, $scope.entityDetails.acl);
        }, function () {
          $log.info('Modal dismissed at: ' + new Date());
        });
      };

      /**
       * Tag Directive Related Func
       */

      $scope.removeMemberFromGroup = function(member) {

        return dataService.removeMemberFromGroup($scope.entity.id, member.id)
          .then(function(res){
            $scope.loadRelatedEntities($scope.consts.entityTypes.user, $scope.entityDetails.users);
          }, function(error) {
            if (error.message) {
              applicationContext.setNotificationMsgWithValues(error.message, '', true, '');
            }
            else {
              applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
            }
          });

      };

      $scope.removeRoleFromGroup = function(role) {

        return dataService.removeRoleFromGroup($scope.entity.id, role.id)
          .then(function(res){
            //$scope.loadRelatedEntities($scope.consts.entityTypes.role, $scope.entityDetails.roles);
            $scope.loadRelatedEntitiesWithFilter($scope.consts.entityTypes.role, $scope.entityDetails.roles, "primaryKey.id+NOT+Like+%27acl-%25%27");
          }, function(error) {
            if (error.message) {
              applicationContext.setNotificationMsgWithValues(error.message, '', true, '');
            }
            else {
              applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
            }
          });
      };


      /**
       * Load related entities
       */
      $scope.loadRelatedEntities = function(relatedEntityType, relatedEntities) {

        return $scope.loadRelatedEntitiesWithFilter(relatedEntityType, relatedEntities);
      };


      /**
       * Load related entities, passing a filter via query param
       */
      $scope.loadRelatedEntitiesWithFilter = function(relatedEntityType, relatedEntities, filter) {

        var deferred = $q.defer();

        SettingsAccountsService.getRelatedEntities($scope.entityType, $scope.entityId, relatedEntityType, true, filter).then(function (response) {
          if (response.data) {
            angular.copy(response.data, relatedEntities);
            deferred.resolve(relatedEntities);
          } else {
            applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
            deferred.reject('Error Occurred while trying to get ' + relatedEntityType + ' List');
          }
        }, function (err) {
          applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
          deferred.reject('Error Occurred while trying to get ' + relatedEntityType + ' List');
        });

        return deferred.promise;
      };


      /**
       * Update Entity: Group Details
       */
      $scope.updateEntityDetails = function () {

        $scope.submitClicked = true;

        var editPromise = null;
        $scope.entityEditDetails = {};


        if (!$scope.entityDetails.info[0][0].value) { //name
          applicationContext.setNotificationMsgWithValues('app.PLEASE_FILL_CORRECT_DATA_IN_FIELDS', 'danger', true);
          return;
        }

        $scope.entityEditDetails['name'] = $scope.entityDetails.info[0][0].value; //name
        $scope.entityEditDetails['description'] = $scope.entityDetails.info[1][0].value; //description


        if ($scope.editMode === 'New') {
          editPromise = SettingsAccountsService.createEntity($scope.entityType, $scope.entityEditDetails);
        } else {
          editPromise = SettingsAccountsService.updateEntity($scope.entityType, $scope.entityDetails.id, $scope.entityEditDetails);
        }
        editPromise.then(function (response) {
          if ($scope.editMode === 'New') {
            applicationContext.setNotificationMsgWithValues('app.CREATED_SUCCESSFULLY', 'success', true);
          } else {
            applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', 'success', true);
          }
          $state.go($scope.entityDetailsStateName, {entityId: response.data.id});
        }, function (err) {
          applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
          $state.go($scope.entityListStateName);
        });
      };

      /**
       * Fired when user click user name
       */
      $scope.viewUser = function(object) {
        $state.go('authenticated.settings.accounts.users.userDetails', {entityId: object.id});
      };

      /**
       * Fired when user click Role Name
       */
      $scope.viewRole = function(object) {
        $state.go('authenticated.settings.accounts.roles.roleDetails', {entityId: object.id});
      };

      $scope.confirmDeleteEntity = function () {
        if ($scope.entityType === $scope.consts.entityTypes.user && $scope.entityDetails.id === 'admin') {
          applicationContext.setNotificationMsgWithValues('settings.accounts.DEFAULT_ADMIN_USER_ACCOUNT_CANT_BE_DELETED', 'success', true);
          return;
        }

        if ($scope.entityType === $scope.consts.entityTypes.role && $scope.entityDetails.id === 'adminrole') {
          applicationContext.setNotificationMsgWithValues('settings.accounts.DEFAULT_ADMIN_ROLE_CANT_BE_DELETED', 'success', true);
          return;
        }

        SettingsAccountsService.deleteEntity($scope.entityType, $scope.entityId).then(function (response) {
          applicationContext.setNotificationMsgWithValues('app.DELETED_SUCCESSFULLY', 'success', true);
          $state.go($scope.entityListStateName);
        }, function (err) {
          applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
        });
      };

      //call initialization file
      $scope.init();
    }
]);

;
angular.module('emlogis.settings').controller('SettingsAccountsGroupsGroupEditBreadcrumbCtrl', ['$scope', '$translate', 'applicationContext',
  function ($scope, $translate, applicationContext) {

  }
]);

;
angular.module('emlogis.settings').controller('SettingsAccountsGroupsGroupEditCtrl', ['$scope', '$state', '$q', '$stateParams', '$http', '$filter', 'applicationContext', 'crudDataService', 'uiGridConstants', 'SettingsAccountsService', 'UtilsService',
  function ($scope, $state, $q, $stateParams, $http, $filter, applicationContext, crudDataService, uiGridConstants, SettingsAccountsService, UtilsService) {

    $scope.editMode = 'Edit';
    $scope.editLabel = 'app.UPDATE';
    $scope.entityId = $stateParams.entityId;

    $scope.populateEntityDetails = function (entity) {
      var entityDetails = {};

      entityDetails.id = entity.id;
      entityDetails.name = entity.name;
      entityDetails.info = [
        [
          {
            label: 'app.NAME',
            key: 'name',
            placeHolder: 'app.NAME',
            value: entity.name,
            class: 'col-sm-3',
            type: 'text',
            validation: 'required'
          },
          {
            label: 'settings.accounts.DESCRIPTION',
            key: 'description',
            placeHolder: 'settings.accounts.DESCRIPTION',
            value: entity.description,
            class: 'col-sm-3',
            type: 'text',
            validation: 'none'
          }
        ]
      ];

      entityDetails.relatedEntities = [
        {
          entityDetails: {
            entityType: $scope.consts.entityTypes.user,
            tabHeading: 'settings.accounts.USERS',
            entityColumnDefs: [
              { field: 'id', visible: false },
              { field: 'name', width: '12%' },
              { field: 'login', width: '12%' },
              { field: 'status', width: '8%' },
              { field: 'employeeAccount', width: '10%', enableSorting: false },
              { field: 'groups', width: '13%', enableSorting: false },
              { field: 'roles', width: '13%', enableSorting: false },
              { field: 'created', width: '12%' },
              { field: 'updated', width: '12%' },
              { field: 'ownedBy', width: '8%' }
            ],
            needPagination: true
          },
          isSelectionList: true,
          getEntityList: function (entityListGridOptions, paginationOptions) {
            var deferred = $q.defer();
            var self = this;
            var offset = (paginationOptions.pageNumber - 1) * paginationOptions.pageSize;
            var limit = paginationOptions.pageSize;
            var orderBy = paginationOptions.orderBy;
            var orderDir = paginationOptions.orderDir;
            SettingsAccountsService.getRelatedEntities($scope.entityType, $scope.entityId, self.entityDetails.entityType, true, null, offset, limit, orderBy, orderDir).then(function (response) {
              if (response.data) {
                entityListGridOptions.totalItems = response.data.total;
                deferred.resolve({data: response.data.result});
              } else {
                deferred.reject('Error Occurred while trying to get Users List');
              }
            }, function (err) {
              applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
              deferred.reject('Error Occurred while trying to get Users List');
            });
            return deferred.promise;
          },
          selected: true,
          convertEntityToGridRow: function (user) {
            var gridRow = {};

            gridRow.id = user.id;
            gridRow.name = user.name;
            gridRow.login = user.login;
            gridRow.status = user.status;

            if (typeof user.employeeId !== 'undefined' && user.employeeId !== null) {
              gridRow.employeeAccount = user.employeeFirstName + ' ' + user.employeeLastName;
            } else {
              gridRow.employeeAccount = '?';
            }

            gridRow.groups = user.groups;
            gridRow.roles = user.roles;
            gridRow.created = new Date(user.created).toString();
            gridRow.updated = new Date(user.updated).toString();
            gridRow.ownedBy = user.ownedBy;

            return gridRow;
          },
          templateUrl: 'modules/settings/partials/include/entity-selection-list-wrapper.html'
        },
        {
          entityDetails: {
            entityType: $scope.consts.entityTypes.role,
            tabHeading: 'settings.accounts.ROLES',
            entityColumnDefs: [
              { field: 'id', visible: false },
              { field: 'name', width: '12%' },
              { field: 'description', width: '15%' },
              { field: 'groups', width: '15%' },
              { field: 'userAccounts', width: '20%' },
              { field: 'created', width: '13%' },
              { field: 'updated', width: '13%' },
              { field: 'ownedBy', width: '12%' }
            ],
            needPagination: false
          },
          isSelectionList: true,
          getEntityList: function () {
            var deferred = $q.defer();
            var self = this;
            var offset = 0;
            var limit = 0;
            SettingsAccountsService.getRelatedEntities($scope.entityType, $scope.entityId, self.entityDetails.entityType, true, null, offset, limit).then(function (response) {
              if (response.data) {
                deferred.resolve({data: response.data.result});
              } else {
                deferred.reject('Error Occurred while trying to get Roles List');
              }
            }, function (err) {
              applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
              deferred.reject('Error Occurred while trying to get Roles List');
            });
            return deferred.promise;
          },
          selected: false,
          convertEntityToGridRow: function (role) {
            var gridRow = {};

            gridRow.id = role.id;
            gridRow.name = role.name;
            gridRow.description = role.description;
            gridRow.groups = role.groups;
            gridRow.userAccounts = role.userAccounts;
            gridRow.created = new Date(role.created).toString();
            gridRow.updated = new Date(role.updated).toString();
            gridRow.ownedBy = role.ownedBy;

            return gridRow;
          },
          templateUrl: 'modules/settings/partials/include/entity-selection-list-wrapper.html'
        }
      ];

      return entityDetails;
    };
  }
]);

;
angular.module('emlogis.settings').controller('SettingsAccountsGroupsListBreadcrumbCtrl', ['$scope', '$translate', 'applicationContext',
  function ($scope, $translate, applicationContext) {

  }
]);

;
angular.module('emlogis.settings').controller('SettingsAccountsGroupsListCtrl',
  [
    '$scope',
    '$state',
    '$http',
    '$filter',
    '$q',
    '$translate',
    'applicationContext',
    'crudDataService',
    'uiGridConstants',
    'SettingsAccountsService',
    'UtilsService',
    function ($scope, $state, $http, $filter, $q, $translate, applicationContext, crudDataService,
              uiGridConstants, SettingsAccountsService, UtilsService) {

      var baseUrl = applicationContext.getBaseRestUrl();
      var factory = _.clone(crudDataService);

      $scope.entityDetails = {
        entityType: $scope.consts.entityTypes.group,
        entityColumnDefs: [
          { field: 'id', visible: false },
          { field: 'name', width: '15%' },
          { field: 'description', width: '27%' },
          { field: 'members', width: '8%', enableSorting: false },
          { field: 'roles' },
          { field: 'created', width: '15%', visible: false },
          { field: 'updated', width: '15%', visible: false },
          { field: 'ownedBy', width: '12%', visible: false }
        ],
        needPagination: true,
        entityDetailsStateName: 'authenticated.settings.accounts.groups.groupDetails'
      };

      $scope.convertEntityToGridRow = function (group) {
        var gridRow = {};

        gridRow.id = group.id;
        gridRow.name = group.name;
        gridRow.description = group.description;
        gridRow.members = group.nbOfMembers;
        gridRow.roles = group.roles;
        gridRow.created = new Date(group.created).toString();
        gridRow.updated = new Date(group.updated).toString();
        gridRow.ownedBy = group.ownedBy;

        return gridRow;
      };

      /**
       * Team managers Grid: Additional Field
       */

      var headerCellTemplate = function(){
        return "<div ng-class=\"{ 'sortable': sortable }\">" +
          "<div class=\"ui-grid-vertical-bar\">&nbsp;</div>" +
          "<div class=\"ui-grid-cell-contents\" col-index=\"renderIndex\" ><span translate>{{ col.name CUSTOM_FILTERS }} </span>" +
          "<span ui-grid-visible=\"col.sort.direction\" ng-class=\"{ 'ui-grid-icon-up-dir': col.sort.direction == asc, 'ui-grid-icon-down-dir': col.sort.direction == desc, 'ui-grid-icon-blank': !col.sort.direction }\">&nbsp;</span>" +
          "</div>" +
          "<div class=\"ui-grid-column-menu-button\" ng-if=\"grid.options.enableColumnMenus && !col.isRowHeader  && col.colDef.enableColumnMenu !== false\" class=\"ui-grid-column-menu-button\" ng-click=\"toggleMenu($event)\">" +
          "<i class=\"ui-grid-icon-angle-down\">&nbsp;</i>" +
          "</div>" +
          "<div ng-if=\"filterable\" class=\"ui-grid-filter-container\" ng-repeat=\"colFilter in col.filters\">" +
          "<input type=\"text\" class=\"ui-grid-filter-input\" ng-model=\"colFilter.term\" ng-click=\"$event.stopPropagation()\" ng-attr-placeholder=\"{{colFilter.placeholder || ''}}\">" +
          "<div class=\"ui-grid-filter-button\" ng-click=\"colFilter.term = null\">" +
          "<i class=\"ui-grid-icon-cancel right\" ng-show=\"!!colFilter.term\">&nbsp;</i> <!-- use !! because angular interprets 'f' as false -->" +
          "</div>" +
          "</div>" +
          "</div>";
      };

      // Row Template: Homepage Dashboard Manager Request Approval
      function rowTemplate() {

        return '<div ng-class="{\'row-hovered\' : hover}" ' +
          '     ng-mouseenter="hover = true" ' +
          '     ng-mouseleave="hover = false" ' +
  //            '     ng-click="grid.appScope.loadCurRequest(row.entity.requestId)">' +
          '     >' +
          '  <div ng-repeat="(colRenderIndex, col) in colContainer.renderedColumns track by col.colDef.name" ' +
          '       class="ui-grid-cell" ' +
          '       ng-class="{ \'ui-grid-row-header-cell\': col.isRowHeader }"  ' +
          '       ui-grid-cell>' +
          '  </div>' +
          '</div>';
      }

      // Header Template
      function headerTemplate() {
        return '<div ng-style="{ height: col.headerRowHeight }" ng-repeat="col in renderedColumns" ng-class="col.colIndex()" class="ngHeaderCell" ng-header-cell></div>';
      }

      $scope.columnDef = [
        {
          name: 'app.TEAM',
          field: 'teamName',
          headerCellTemplate: headerCellTemplate(),
          width: '20%'
        },
        {
          name: 'settings.accounts.MANAGERS',
          field: 'managerNames',
          headerCellTemplate: headerCellTemplate()
        }
      ];

      $scope.teamManagerGridOptions = {
        enableColumnResizing: true,
        enableRowHeaderSelection: false,
        modifierKeysToMultiSelect: false,
        noUnselect: true,
        enableGridMenu: true,
        columnDefs: $scope.columnDef, //
        rowTemplate: rowTemplate(), //Row Template,
        enableHorizontalScrollbar: 0,
        enableVerticalScrollbar: 0,
        enableColumnMenus: false,
        useExternalFiltering: true,

  //        enableColumnMenus: true,
          gridMenuTitleFilter: $translate, // Translate Grid Menu column name

        onRegisterApi: function( gridApi ) {
          $scope.gridApi = gridApi;

        }
      };

      /**
       * Load Team Managers
       */
      $scope.loadTeamManagers = function() {
  //      http://localhost:8080/scheduler-server/emlogis/rest/org/ops/getmanagersbyteams

        var deferred = $q.defer();

        factory.getElements('org/ops/getmanagersbyteams',{})
          .then(function (entities) {

            /**
             * resolves sites
             */
            var teams = entities.data;

            angular.forEach(teams, function(team) {

              team.managerNames = '';

              _.each(team.managers, function(manager, key) {

                if (key !== 0) {
                  team.managerNames +=', ';
                }

                team.managerNames += manager.name;
                if (manager.employeeId !== null ) {
                  team.managerNames += ' (Employee)';
                }

              });

            });

            $scope.teamManagerGridOptions.data = teams;

            deferred.resolve(teams);

          }, function(error) {
            deferred.reject(error);
            applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
          });



        return deferred.promise;
      };

      //load teamManagers
      if ($scope.isTenantType('Customer')){
        $scope.loadTeamManagers();
      }
    }
]);

;
(function () {
  "use strict";

  var settings = angular.module('emlogis.settings');

  settings.controller('SettingsAccountsGroupsRolesModalCtrl',
    [
      '$scope',
      '$timeout',
      '$modalInstance',
      'uiGridConstants',
      'applicationContext',
      'dataService',
      'rulesTeamsService',
      'group',
      function ($scope, $timeout, $modalInstance, uiGridConstants, applicationContext, dataService,
                rulesTeamsService, group) {

        //--------------------------------------------------------------------
        // Defaults for Employees Modal
        //--------------------------------------------------------------------

        var te = this,
            totalUnnassociatedUsers;

        te.group = group;
        te.numOfRows = 15;
        te.isEditing = false;
        te.queryParams = {
          filter: "primaryKey.id NOT Like 'acl-%' AND primaryKey.id NOT Like 'employeerole%'",   // filter out 'hidden' roles, ie those starting with acl-
          orderby:'name',
          orderdir:'ASC'
        };

        te.unassociatedRoles = null;
        te.unassociatedRolesInit = null;
        te.usersToAdd = [];

        //
        // Load Unassociated Employees
        // that don't belong to this Team

        var loadGroupUnassociatedRoles = function(groupId, queryParams, pageNum, perPage){
          
          return dataService.getUnassociatedGroupAccountRoles('groupaccounts', groupId, queryParams, pageNum, perPage)
            .then(function(res) {
            console.log('+++ Loaded GroupunassociatedRoles:', res);    //DEV mode

            prepareData(res);

            $timeout(function() {
              prepareObjectsGrid(te.unassociatedRoles);
            });

            }, function(err) {
              applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
            })
          ;
        };

        loadGroupUnassociatedRoles(te.group.id, te.queryParams, 1, te.numOfRows);

        var prepareData = function(res){
          totalUnnassociatedUsers = res.total;
          te.unassociatedRolesInit = res.data;

          angular.forEach(te.unassociatedRolesInit, function(role) {
            role.isSelected = false;
          });

          te.unassociatedRoles = angular.copy(te.unassociatedRolesInit);
        };



        //--------------------------------------------------------------------
        // Grid settings
        //--------------------------------------------------------------------

        var prepareObjectsGrid = function(unassociatedRoles){
          console.log('+++ unassociatedRoles', unassociatedRoles);

          te.gridOptions = {
            data: unassociatedRoles,
            totalItems: totalUnnassociatedUsers,
            minRowsToShow: unassociatedRoles.length < te.numOfRows ? unassociatedRoles.length : te.numOfRows,

            enableHorizontalScrollbar: 0,
            enableVerticalScrollbar: 0,
            enableColumnMenus: false,

            enableFiltering: true,
            useExternalFiltering: true,

            enableSorting: true,
            useExternalSorting: true,

            needPagination: true,
            useExternalPagination: true,
            enablePaginationControls: false,
            paginationPageSize: te.numOfRows,
            paginationCurrentPage: 1,

            enableSelectAll: true,
            enableRowSelection: true,
            enableFullRowSelection: true,                   // full row selection

            columnDefs: [
              {
                field: 'name',
                enableFiltering: true,
                minWidth: '150',
                sort: {
                  direction: uiGridConstants.ASC
                }
              },
              { field: 'description',enableFiltering: false, minWidth: '100' }
            ],
            onRegisterApi: function(gridApi) {
              te.gridApi = gridApi;

              //
              // Row selection
              
              gridApi.selection.on.rowSelectionChanged($scope, function (row) {
                row.entity.isSelected = row.isSelected;
                te.updateEditing();
              });

              gridApi.selection.on.rowSelectionChangedBatch($scope,function(rows){
                _.each(rows, function(row){
                  row.entity.isSelected = row.isSelected;
                });
                te.updateEditing();
              });

              //
              // Back-end filtering
              gridApi.core.on.filterChanged( $scope, function() {
                var grid = this.grid;
                var filterTerm = grid.columns[1].filters[0].term;
                //console.log('~~~ filter changed - grid', grid);

                if (filterTerm === null || filterTerm === '' || filterTerm === undefined ){
                  te.queryParams = {
                    orderby : te.queryParams.orderby,
                    orderdir: te.queryParams.orderdir
                  };
                } else {
                  var filterName = 'name';
                  te.queryParams.filter = filterName + " LIKE '" + filterTerm + "%'";
                }
                getPage();
              });


              //
              // Back-end sorting

              gridApi.core.on.sortChanged($scope, function(grid, sortColumns) {
                if (sortColumns.length === 0) {
                  te.queryParams.orderdir = 'ASC';
                  te.queryParams.orderby = 'name';
                  
                } else {
                  te.queryParams.orderdir = sortColumns[0].sort.direction;

                  switch (sortColumns[0].field) {
                    case "name":
                      te.queryParams.orderby = 'name';
                      break;
                    case "description":
                      te.queryParams.orderby = 'description';
                      break;
                    default:
                      te.queryParams.orderby = 'getUnassociatedGroupAccountRoles';
                      break;
                  }
                }
                getPage();
              });


              //
              // Back-end pagination

              gridApi.pagination.on.paginationChanged($scope, function (newPage, pageSize) {
                te.gridOptions.paginationCurrentPage = newPage;
                getPage();
              });

              var getPage = function() {
                console.log('te.gridOptions.queryParams', te.queryParams);

                dataService.getUnassociatedGroupAccountRoles('groupaccounts', te.group.id, te.queryParams, te.gridOptions.paginationCurrentPage, te.numOfRows)
                  .then( function(res){
                    console.log('~~~ res grid upd', res);
                    refreshGrid(res);
                });
              };

            }
          };
        };


        //--------------------------------------------------------------------
        // CRUD
        //--------------------------------------------------------------------


        var refreshGrid = function(res){
          prepareData(res);
          te.gridOptions.totalItems = totalUnnassociatedUsers;
          te.gridOptions.data = te.unassociatedRoles;
          te.gridOptions.minRowsToShow = totalUnnassociatedUsers < te.numOfRows ? totalUnnassociatedUsers : te.numOfRows;
        };


        te.updateEditing = function(){
          te.isEditing = !angular.equals(te.unassociatedRolesInit, te.unassociatedRoles);
        };


        /**
         * Add users to groups: Settings->Accounts->Groups->Roles
         */
        te.associateRoles = function(){

          //prepare selected rows
          var toAdd = te.gridApi.selection.getSelectedRows();
          console.log('toAdd', toAdd);

          var dto = [];
          angular.forEach(toAdd, function(row){
            dto.push(row.id);
          });
          console.log('toAddDto', {roleIdList: dto});

          dataService.addRolesToGroup(te.group.id, dto).then(function(res){

            te.closeModal();

          }, function(err) {
            applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
          });
        };


        //--------------------------------------------------------------------
        // Modal methods
        //--------------------------------------------------------------------


        te.closeModal = function () {
          $modalInstance.close(te.group);
        };


        //
        // If user navigates away from the page,
        // dismiss the modal

        $scope.$on('$stateChangeStart', function(){
            $modalInstance.dismiss('cancel');
          }
        );

      }
    ]);
})();
;
(function () {
  "use strict";

  var settings = angular.module('emlogis.settings');

  settings.controller('SettingsAccountsGroupsUsersModalCtrl',
    [
      '$scope',
      '$timeout',
      '$modalInstance',
      'uiGridConstants',
      'applicationContext',
      'dataService',
      'rulesTeamsService',
      'group',
      function ($scope, $timeout, $modalInstance, uiGridConstants, applicationContext, dataService,
                rulesTeamsService, group) {

        //--------------------------------------------------------------------
        // Defaults for Employees Modal
        //--------------------------------------------------------------------

        var te = this,
            totalUnnassociatedUsers;

        te.group = group;
        te.numOfRows = 15;
        te.isEditing = false;
        te.queryParams = {
          orderby:'lastName',
          orderdir:'ASC'
        };

        te.unassociatedUsers = null;
        te.unassociatedUsersInit = null;
        te.usersToAdd = [];

        //
        // Load Unassociated Employees
        // that don't belong to this Team

        var loadGroupUnassociatedUsers = function(groupId, queryParams, pageNum, perPage){
          
          return dataService.getUnassociatedGroupMembers(groupId, queryParams, pageNum, perPage)
            .then(function(res) {
            console.log('+++ Loaded GroupUnassociatedUsers:', res);    //DEV mode

            prepareData(res);

            $timeout(function() {
              prepareUsersGrid(te.unassociatedUsers);
            });

            }, function(err) {
              applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
            })
          ;
        };

        loadGroupUnassociatedUsers(te.group.id, te.queryParams, 1, te.numOfRows);

        var prepareData = function(res){
          totalUnnassociatedUsers = res.total;
          te.unassociatedUsersInit = res.data;

          angular.forEach(te.unassociatedUsersInit, function(user) {
            user.isSelected = false;

            if (typeof user.employeeId !== 'undefined' && user.employeeId !== null) {
              user.employeeAccount = user.firstName + ' ' + user.lastName;
            } else {
              user.employeeAccount = '?';
            }

          });

          te.unassociatedUsers = angular.copy(te.unassociatedUsersInit);
        };



        //--------------------------------------------------------------------
        // Grid settings
        //--------------------------------------------------------------------

        var prepareUsersGrid = function(unassociatedUsers){
          console.log('+++ unassociatedUsers', unassociatedUsers);

          te.gridOptions = {
            data: unassociatedUsers,
            totalItems: totalUnnassociatedUsers,
            minRowsToShow: unassociatedUsers.length < te.numOfRows ? unassociatedUsers.length : te.numOfRows,

            enableHorizontalScrollbar: 0,
            enableVerticalScrollbar: 0,
            enableColumnMenus: false,

            enableFiltering: true,
            useExternalFiltering: true,

            enableSorting: true,
            useExternalSorting: true,

            needPagination: true,
            useExternalPagination: true,
            enablePaginationControls: false,
            paginationPageSize: te.numOfRows,
            paginationCurrentPage: 1,

            enableSelectAll: true,
            enableRowSelection: true,
            enableFullRowSelection: true,                   // full row selection

            columnDefs: [
              {
                field: 'lastName',
                enableFiltering: true,
                minWidth: '150',
                sort: {
                  direction: uiGridConstants.ASC
                }
              },
              { field: 'firstName',        enableFiltering: false, minWidth: '100' },
              { field: 'login', enableFiltering: false, minWidth: '150' },
              { field: 'employeeAccount',     enableFiltering: false, minWidth: '150', enableSorting: false}
            ],
            onRegisterApi: function(gridApi) {
              te.gridApi = gridApi;

              //
              // Row selection
              
              gridApi.selection.on.rowSelectionChanged($scope, function (row) {
                row.entity.isSelected = row.isSelected;
                te.updateEditing();
              });

              gridApi.selection.on.rowSelectionChangedBatch($scope,function(rows){
                _.each(rows, function(row){
                  row.entity.isSelected = row.isSelected;
                });
                te.updateEditing();
              });

              //
              // Back-end filtering

              gridApi.core.on.filterChanged( $scope, function() {
                var grid = this.grid;
                var filterTerm = grid.columns[1].filters[0].term;
                //console.log('~~~ filter changed - grid', grid);

                if (filterTerm === null || filterTerm === '' || filterTerm === undefined ){
                  te.queryParams = {
                    orderby : te.queryParams.orderby,
                    orderdir: te.queryParams.orderdir
                  };
                } else {
                  var filterName = 'lastName';
                  te.queryParams.filter = filterName + " LIKE '" + filterTerm + "%'";
                }
                getPage();
              });


              //
              // Back-end sorting

              gridApi.core.on.sortChanged($scope, function(grid, sortColumns) {
                if (sortColumns.length === 0) {
                  te.queryParams.orderdir = 'ASC';
                  te.queryParams.orderby = 'lastName';
                  
                } else {
                  te.queryParams.orderdir = sortColumns[0].sort.direction;

                  switch (sortColumns[0].field) {
                    case "lastName":
                      te.queryParams.orderby = 'lastName';
                      break;
                    case "firstName":
                      te.queryParams.orderby = 'firstName';
                      break;
                    case "login":
                      te.queryParams.orderby = 'login';
                      break;
                    default:
                      te.queryParams.orderby = 'lastName';
                      break;
                  }
                }
                getPage();
              });


              //
              // Back-end pagination

              gridApi.pagination.on.paginationChanged($scope, function (newPage, pageSize) {
                te.gridOptions.paginationCurrentPage = newPage;
                getPage();
              });

              var getPage = function() {
                console.log('te.gridOptions.queryParams', te.queryParams);

                dataService.getUnassociatedGroupMembers(te.group.id, te.queryParams, te.gridOptions.paginationCurrentPage, te.numOfRows)
                  .then( function(res){
                    console.log('~~~ res grid upd', res);
                    refreshGrid(res);
                });
              };

            }
          };
        };


        //--------------------------------------------------------------------
        // CRUD
        //--------------------------------------------------------------------


        var refreshGrid = function(res){
          prepareData(res);
          te.gridOptions.totalItems = totalUnnassociatedUsers;
          te.gridOptions.data = te.unassociatedUsers;
          te.gridOptions.minRowsToShow = totalUnnassociatedUsers < te.numOfRows ? totalUnnassociatedUsers : te.numOfRows;
        };


        te.updateEditing = function(){
          te.isEditing = !angular.equals(te.unassociatedUsersInit, te.unassociatedUsers);
        };


        /**
         * Add users to groups: Settings->Accounts->Groups->Users
         */
        te.associateUsers = function(){

          //prepare selected rows
          var toAdd = te.gridApi.selection.getSelectedRows();
          console.log('toAdd', toAdd);

          var memberIdList = [];
          angular.forEach(toAdd, function(row){
            memberIdList.push(row.id);
          });
          console.log('toAddDto', {memberIdList: memberIdList});

          dataService.addMembersToGroup(te.group.id, memberIdList).then(function(res){

            te.closeModal();

          }, function(err) {
            applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
          });
        };


        //--------------------------------------------------------------------
        // Modal methods
        //--------------------------------------------------------------------


        te.closeModal = function () {
          $modalInstance.close(te.group);
        };


        //
        // If user navigates away from the page,
        // dismiss the modal

        $scope.$on('$stateChangeStart', function(){
            $modalInstance.dismiss('cancel');
          }
        );

      }
    ]);
})();
;
angular.module('emlogis.settings').controller('SettingsAccountsGroupsCtrl', ['$scope', '$state', '$http', '$filter', 'applicationContext', 'crudDataService', 'uiGridConstants', 'SettingsAccountsService', 'UtilsService',
  function ($scope, $state, $http, $filter, applicationContext, crudDataService, uiGridConstants, SettingsAccountsService, UtilsService) {
    var entityFilter = applicationContext.getEntityFilter();

    entityFilter.url = 'groupaccounts/ops/quicksearch';
    entityFilter.searchFields = 'name';
    entityFilter.returnedFields = 'id,name';

    applicationContext.setEntityFilter(entityFilter);

    $scope.entityType = $scope.consts.entityTypes.group;
    $scope.entityName = "settings.accounts.groups.NAME";
    $scope.entityListStateName = 'authenticated.settings.accounts.groups.list';
    $scope.entityDetailsStateName = 'authenticated.settings.accounts.groups.groupDetails';
    $scope.entityEditStateName = 'authenticated.settings.accounts.groups.groupDetails';

    $scope.hasMgmtPermission = function () {
      return $scope.hasPermission('Account_Mgmt');
    };

    $scope.hasViewPermission = function () {
      return $scope.hasPermission('Account_View');
    };
  }
]);

;
angular.module('emlogis.settings').controller('RolesAccessControlListCtrl', ['$scope', '$state', '$stateParams', '$http', '$filter', 'crudDataService', 'uiGridConstants', 'SettingsAccountsService', 'UtilsService', 'applicationContext',
  function ($scope, $state, $stateParams, $http, $filter, crudDataService, uiGridConstants, SettingsAccountsService, UtilsService, applicationContext) {

    $scope.isInEdit = ($scope.editMode === 'Edit');
    $scope.allSites = {
      readAccess: false,
      writeAccess: false
    };
    $scope.sites = [];
    $scope.parsedSites = [];

    $scope.convertAccessTypeToAccess = function (accessType, dstElement) {
      if (accessType === 'RO') {
        dstElement.readAccess = true;
        dstElement.writeAccess = false;
      } else if (accessType === 'RW') {
        dstElement.readAccess = true;
        dstElement.writeAccess = true;
      } else if (accessType === 'Void') {
        dstElement.readAccess = false;
        dstElement.writeAccess = false;
      } else {
        // do other operations
      }
    };

    $scope.convertAccessToAccessType = function (srcElement, dstElement) {
      if (srcElement.readAccess && srcElement.writeAccess) {
        dstElement.accessType = 'RW';
      } else if (srcElement.readAccess && !srcElement.writeAccess) {
        dstElement.accessType = 'RO';
      } else if (!srcElement.readAccess && !srcElement.writeAccess) {
        dstElement.accessType = 'Void';
      } else {
        //do other operations
      }
    };

    $scope.parseEntityListForCheck = function () {
      $scope.parsedSites = [];
      angular.forEach($scope.sites, function (site) {
        var siteElement = {};
        siteElement.name = site.name;
        $scope.convertAccessTypeToAccess(site.accessType, siteElement);
        siteElement.originalEntity = site;
        siteElement.expanded = false;
        siteElement.allTeams = {};
        $scope.convertAccessTypeToAccess(site.teamsDto.allTeamsAccessType, siteElement.allTeams);
        siteElement.teams = [];
        angular.forEach(site.teamsDto.teamDtos, function (team) {
          var teamElement = {};
          teamElement.name = team.name;
          $scope.convertAccessTypeToAccess(team.accessType, teamElement);
          teamElement.originalEntity = team;
          siteElement.teams.push(teamElement);
        });
        $scope.parsedSites.push(siteElement);
      });
    };

    $scope.allSitesReadAccessChanged = function () {
      if (!$scope.allSites.readAccess) {
        if ($scope.allSites.writeAccess) {
          $scope.allSites.writeAccess = false;
          $scope.allSitesWriteAccessChanged();
        }
      }
      angular.forEach($scope.parsedSites, function (parsedSite) {
        parsedSite.readAccess = $scope.allSites.readAccess;
        $scope.convertAccessToAccessType(parsedSite, parsedSite.originalEntity);
        if (!parsedSite.readAccess) {
          parsedSite.allTeams.readAccess = false;
          parsedSite.originalEntity.teamsDto.allTeamsAccessType = 'Void';
          angular.forEach(parsedSite.teams, function (parsedTeam) {
            parsedTeam.readAccess = parsedSite.readAccess;
            $scope.convertAccessToAccessType(parsedTeam, parsedTeam.originalEntity);
          });
        }
      });
    };

    $scope.allSitesWriteAccessChanged = function () {
      if ($scope.allSites.writeAccess) {
        if (!$scope.allSites.readAccess) {
          $scope.allSites.readAccess = true;
          $scope.allSitesReadAccessChanged();
        }
      }
      angular.forEach($scope.parsedSites, function (parsedSite) {
        parsedSite.writeAccess = $scope.allSites.writeAccess;
        $scope.convertAccessToAccessType(parsedSite, parsedSite.originalEntity);
      });
    };

    $scope.siteReadAccessChanged = function (parsedSite) {
      var findElement = _.find($scope.parsedSites, function (siteIterator) {
        return siteIterator.readAccess !== parsedSite.readAccess;
      });
      if (typeof findElement === 'undefined') {
        $scope.allSites.readAccess = parsedSite.readAccess;
      } else {
        $scope.allSites.readAccess = false;
      }

      if (!parsedSite.readAccess) {
        if (parsedSite.writeAccess) {
          parsedSite.writeAccess = false;
          $scope.siteWriteAccessChanged(parsedSite);
        }
      }
      $scope.convertAccessToAccessType(parsedSite, parsedSite.originalEntity);
      if (!parsedSite.readAccess) {
        parsedSite.allTeams.readAccess = false;
        parsedSite.originalEntity.teamsDto.allTeamsAccessType = 'Void';
        angular.forEach(parsedSite.teams, function (parsedTeam) {
          parsedTeam.readAccess = parsedSite.readAccess;
          $scope.convertAccessToAccessType(parsedTeam, parsedTeam.originalEntity);
        });
      }
    };

    $scope.siteWriteAccessChanged = function (parsedSite) {
      var findElement = _.find($scope.parsedSites, function (siteIterator) {
        return siteIterator.writeAccess !== parsedSite.writeAccess;
      });
      if (typeof findElement === 'undefined') {
        $scope.allSites.writeAccess = parsedSite.writeAccess;
      } else {
        $scope.allSites.writeAccess = false;
      }

      if (parsedSite.writeAccess) {
        if (!parsedSite.readAccess) {
          parsedSite.readAccess = true;
          $scope.siteReadAccessChanged(parsedSite);
        }
      }
      $scope.convertAccessToAccessType(parsedSite, parsedSite.originalEntity);
    };

    $scope.allTeamsReadAccessChanged = function (parsedSite) {
      if (parsedSite.allTeams.readAccess) {
        if (!parsedSite.readAccess) {
          parsedSite.readAccess = true;
          $scope.siteReadAccessChanged(parsedSite);
        }
        if (parsedSite.allTeams.writeAccess) {
          parsedSite.originalEntity.teamsDto.allTeamsAccessType = 'RW';
        } else {
          parsedSite.originalEntity.teamsDto.allTeamsAccessType = 'RO';
        }
      } else {
        if (parsedSite.allTeams.writeAccess) {
          parsedSite.allTeams.writeAccess = false;
          $scope.allTeamsWriteAccessChanged(parsedSite);
        }
        parsedSite.originalEntity.teamsDto.allTeamsAccessType = 'Void';
      }
      angular.forEach(parsedSite.teams, function (parsedTeam) {
        parsedTeam.readAccess = parsedSite.allTeams.readAccess;
        $scope.convertAccessToAccessType(parsedTeam, parsedTeam.originalEntity);
      });
    };

    $scope.allTeamsWriteAccessChanged = function (parsedSite) {
      if (parsedSite.allTeams.writeAccess) {
        if (!parsedSite.allTeams.readAccess) {
          parsedSite.allTeams.readAccess = true;
          $scope.allTeamsReadAccessChanged(parsedSite);
        }
        parsedSite.originalEntity.teamsDto.allTeamsAccessType = 'RW';
      } else {
        if (parsedSite.allTeams.readAccess) {
          parsedSite.originalEntity.teamsDto.allTeamsAccessType = 'RO';
        } else {
          parsedSite.originalEntity.teamsDto.allTeamsAccessType = 'Void';
        }
      }
      angular.forEach(parsedSite.teams, function (parsedTeam) {
        parsedTeam.writeAccess = parsedSite.allTeams.writeAccess;
        $scope.convertAccessToAccessType(parsedTeam, parsedTeam.originalEntity);
      });
    };

    $scope.teamReadAccessChanged = function (parsedSite, parsedTeam) {
      if (!parsedTeam.readAccess) {
        if (parsedTeam.writeAccess) {
          parsedTeam.writeAccess = false;
          $scope.teamWriteAccessChanged(parsedSite, parsedTeam);
        }
      }
      $scope.convertAccessToAccessType(parsedTeam, parsedTeam.originalEntity);

      var findElement = _.find(parsedSite.teams, function (teamIterator) {
        return teamIterator.readAccess !== parsedTeam.readAccess;
      });
      if (typeof findElement === 'undefined') {
        parsedSite.allTeams.readAccess = parsedTeam.readAccess;
      } else {
        parsedSite.allTeams.readAccess = false;
      }
      if (parsedSite.allTeams.readAccess) {
        if (parsedSite.allTeams.writeAccess) {
          parsedSite.originalEntity.teamsDto.allTeamsAccessType = 'RW';
        } else {
          parsedSite.originalEntity.teamsDto.allTeamsAccessType = 'RO';
        }
      } else {
        parsedSite.originalEntity.teamsDto.allTeamsAccessType = 'Void';
      }

      if (parsedTeam.readAccess) {
        if (!parsedSite.readAccess) {
          parsedSite.readAccess = true;
          $scope.siteReadAccessChanged(parsedSite);
        }
      }
    };

    $scope.teamWriteAccessChanged = function (parsedSite, parsedTeam) {
      if (parsedTeam.writeAccess) {
        if (!parsedTeam.readAccess) {
          parsedTeam.readAccess = true;
          $scope.teamReadAccessChanged(parsedSite, parsedTeam);
        }
      }
      $scope.convertAccessToAccessType(parsedTeam, parsedTeam.originalEntity);

      var findElement = _.find(parsedSite.teams, function (teamIterator) {
        return teamIterator.writeAccess !== parsedTeam.writeAccess;
      });
      if (typeof findElement === 'undefined') {
        parsedSite.allTeams.writeAccess = parsedTeam.writeAccess;
      } else {
        parsedSite.allTeams.writeAccess = false;
      }
      if (parsedSite.allTeams.writeAccess) {
        parsedSite.originalEntity.teamsDto.allTeamsAccessType = 'RW';
      } else {
        if (parsedSite.allTeams.readAccess) {
          parsedSite.originalEntity.teamsDto.allTeamsAccessType = 'RO';
        } else {
          parsedSite.originalEntity.teamsDto.allTeamsAccessType = 'Void';
        }
      }
    };

    $scope.updateAccessControl = function () {
      var accessType = null;
      if ($scope.allSites.readAccess && $scope.allSites.writeAccess) {
        accessType = 'RW';
      } else if ($scope.allSites.readAccess && !$scope.allSites.writeAccess) {
        accessType = 'RO';
      } else if (!$scope.allSites.readAccess && !$scope.allSites.writeAccess) {
        accessType = 'Void';
      }
      var payLoad = {
        allSitesAccessType: accessType,
        result: $scope.sites
      };
      SettingsAccountsService.operateOnRelatedEntity('set', $scope.entityType, $scope.entityId, $scope.relatedEntity.entityDetails.entityType, payLoad).then(function (response) {
        applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', 'success', true);
        $scope.initializeList();
      }, function (err) {
        applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
      });
    };

    function comparator(firstElement, secondElement) {
      if (firstElement.name.toLowerCase() < secondElement.name.toLowerCase())
        return -1;
      if (firstElement.name.toLowerCase() > secondElement.name.toLowerCase())
        return 1;
      return 0;
    }

    $scope.initializeList = function () {
      $scope.relatedEntity.getEntityList().then(function (response) {
        if (response.data.allSitesAccessType === 'Void') {
          $scope.allSites.readAccess = false;
          $scope.allSites.writeAccess = false;
        } else if (response.data.allSitesAccessType === 'RO') {
          $scope.allSites.readAccess = true;
          $scope.allSites.writeAccess = false;
        } else if (response.data.allSitesAccessType === 'RW') {
          $scope.allSites.readAccess = true;
          $scope.allSites.writeAccess = true;
        } else {
          // do other operations
        }
        $scope.sites = response.data.result;
        $scope.sites.sort(comparator);
        angular.forEach($scope.sites, function (site) {
          site.teamsDto.teamDtos.sort(comparator);
        });
        $scope.parseEntityListForCheck();
      }, function (err) {
        applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
      });
    };

    $scope.initializeList();
  }
]);

;
angular.module('emlogis.settings').controller('RolesPermissionsCtrl', ['$scope', '$state', '$stateParams', '$q', '$http', '$filter', 'crudDataService', 'uiGridConstants', 'SettingsAccountsService', 'UtilsService', 'applicationContext',
  function ($scope, $state, $stateParams, $q, $http, $filter, crudDataService, uiGridConstants, SettingsAccountsService, UtilsService, applicationContext) {

    $scope.isInEdit = ($scope.editMode === 'Edit');
    $scope.permissions = [];
    $scope.originalAssociatedPermissions = [];

    $scope.updatePermissions = function () {
      var addedIds = [], removedIds = [];
      var promiseItem = null;
      var promises = [];
      angular.forEach($scope.permissions, function (permission) {
        var found = _.find($scope.originalAssociatedPermissions, function (originalPermission) {
          return originalPermission.id === permission.id;
        });
        if (typeof found !== 'undefined') {
          if (!permission.associated) {
            removedIds.push(permission.id);
          }
        } else {
          if (permission.associated) {
            addedIds.push(permission.id);
          }
        }
      });
      if (addedIds.length > 0) {
        promiseItem = SettingsAccountsService.operateOnRelatedEntity('add', $scope.entityType, $scope.entityId, $scope.consts.entityTypes.permission, addedIds);
        promises.push(promiseItem);
      }
      if (removedIds.length > 0) {
        promiseItem = SettingsAccountsService.operateOnRelatedEntity('remove', $scope.entityType, $scope.entityId, $scope.consts.entityTypes.permission, removedIds);
        promises.push(promiseItem);
      }

      $q.all(promises).then(function (responses) {
        applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', 'success', true);
        $scope.populateAllPermissions();
      }, function (err) {
        applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
        $scope.populateAllPermissions();
      });
    };

    function comparator(firstPermission, secondPermission) {
      if (firstPermission.name.toLowerCase() < secondPermission.name.toLowerCase())
        return -1;
      if (firstPermission.name.toLowerCase() > secondPermission.name.toLowerCase())
        return 1;
      return 0;
    }

    $scope.populateAllPermissions = function () {
      var promises = [];

      promises.push($scope.relatedEntity.getEntityList());
      promises.push($scope.relatedEntity.getUnassociatedEntityList());
      $q.all(promises).then(function (responses) {
        angular.forEach(responses, function (response, responseIndex) {
          angular.forEach(response.data, function (permission) {
            if (responseIndex === 0) {
              permission.associated = true;
              $scope.originalAssociatedPermissions.push(permission);
            } else {
              permission.associated = false;
            }
            $scope.permissions.push(permission);
          });
        });
        $scope.permissions.sort(comparator);
      }, function (err) {
        applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
      });
    };

    $scope.populateAllPermissions();
  }
]);

;
(function () {
  "use strict";

  var settings = angular.module('emlogis.settings');

  settings.controller('SettingsAccountsRolesAclModalCtrl',
    [
      '$rootScope',
      '$scope',
      '$timeout',
      '$modalInstance',
      'uiGridConstants',
      'applicationContext',
      'dataService',
      'SettingsAccountsService',
      'role',
      'acl',
      function ($rootScope,$scope, $timeout, $modalInstance, uiGridConstants, applicationContext, dataService,
                SettingsAccountsService, role, acl) {

        //--------------------------------------------------------------------
        // Defaults for Employees Modal
        //--------------------------------------------------------------------

        var te = this;

        te.role = role;
        te.acl = acl;

        // checkbox action for all sites/teams
        te.updateAllSitesStatus = function() {

          if (te.acl.allSitesAccessType === 'RW') {
            _.each(te.acl.result, function(site) {
              site.accessType = 'RW';
              site.teamsDto.allTeamsAccessType = 'Void';

              _.each(site.teamsDto.teamDtos, function(team) {
                team.accessType = 'Void';
              });

            });
          }

        };

        // checkbox action for site all teams
        te.updateSiteAllTeamsStatus = function(site){

          if (site.teamsDto.allTeamsAccessType === 'RW') {
            site.accessType = 'RW';
            _.each(site.teamsDto.teamDtos, function(team) {
              team.accessType = 'Void';
            });
          }
          else {
            site.accessType = 'Void';
            //_.each(site.teamsDto.teamDtos, function(team) {
            //  team.accessType = 'Void';
            //});
          }

        };

        // checkbox of individual team
        te.updateSiteTeamStatus = function(site,team) {
          var checkedTeam = _.findWhere(site.teamsDto.teamDtos, {'accessType': 'RW'});
          if (checkedTeam) {
            site.accessType = 'RW';
          }
          else {
            site.accessType = 'Void';
          }


          // update site-all-teams checkbox
          //site.teamsDto.allTeamsAccessType = te.getSiteAllTeamsStatus(site);

          // update all sites-teams check
          //te.acl.allSitesAccessType = te.getAllSitesStatus();

        };

        te.getAllSitesStatus = function() {
          var uncheckedSite = _.find(te.acl.result, function(site) {
            return site.teamsDto.allTeamsAccessType === 'Void';
          });

          if (uncheckedSite) {
            return 'Void';
          }
          else {
            return 'RW';
          }
        };

        te.getSiteAllTeamsStatus = function(site) {
          var uncheckedTeam = _.findWhere(site.teamsDto.teamDtos, {'accessType': 'Void'});
          if (uncheckedTeam) {
            return 'Void';
          }
          else {
            return 'RW';
          }
        };

        /**
         * Update Acl of roles: Settings->Accounts->Roles->Acl
         */
        te.updateGroupAcl = function() {

          SettingsAccountsService.operateOnRelatedEntity(null, $rootScope.consts.entityTypes.role, te.role.id, $rootScope.consts.entityTypes.accessControl, te.acl).then(function (response) {
            $modalInstance.close();
          }, function (err) {
            applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
          });
        };

        //--------------------------------------------------------------------
        // Modal methods: ACCOUNTS-GROUPS-ACL-MODAL.JS
        //--------------------------------------------------------------------

        te.closeModal = function () {
          $modalInstance.dismiss('cancel');
        };

        //
        // If user navigates away from the page,
        // dismiss the modal

        $scope.$on('$stateChangeStart', function(){
            $modalInstance.dismiss('cancel');
          }
        );

      }
    ]);
})();
;
angular.module('emlogis.settings').controller('SettingsAccountsRolesBreadcrumbCtrl', ['$scope', '$state', '$translate', 'applicationContext',
  function ($scope, $state, $translate, applicationContext) {
    $scope.entityName = "settings.accounts.roles.NAME";
    $scope.entityResource = "settings.accounts.ROLES";
    $scope.entityQuickSearchUrl = "roles/ops/quicksearch";

    $scope.selectEntitySearchValue = function (item, model, label) {
      $state.go('authenticated.settings.accounts.roles.roleDetails', {entityId: item.id});
    };

    $scope.goToNewEntityState = function () {
      $state.go('authenticated.settings.accounts.roles.create');
    };

    $scope.hasMgmtPermission = function () {
      return $scope.hasPermission('Role_Mgmt');
    };

    $scope.hasViewPermission = function () {
      return $scope.hasPermission('Role_View');
    };
  }
]);

;
angular.module('emlogis.settings').controller('SettingsAccountsRolesCreateBreadcrumbCtrl', ['$scope', '$translate', 'applicationContext',
  function ($scope, $translate, applicationContext) {

  }
]);

;
angular.module('emlogis.settings').controller('SettingsAccountsRolesCreateCtrl', ['$scope', '$state', '$http', '$filter', 'applicationContext', 'crudDataService', 'uiGridConstants', 'SettingsAccountsService', 'UtilsService',
  function ($scope, $state, $http, $filter, applicationContext, crudDataService, uiGridConstants, SettingsAccountsService, UtilsService) {

    $scope.editMode = 'New';
    $scope.editLabel = 'app.CREATE';
    $scope.entityId = null;

    $scope.populateEntityDetails = function (entity) {
      var entityDetails = {};

      entityDetails.id = null;
      entityDetails.name = null;
      entityDetails.info = [
        [
          {
            label: 'app.NAME',
            key: 'name',
            placeHolder: 'app.NAME',
            value: null,
            class: 'col-sm-3',
            type: 'text',
            validation: 'required'
          },
          {
            label: 'settings.accounts.DESCRIPTION',
            key: 'description',
            placeHolder: 'settings.accounts.DESCRIPTION',
            value: null,
            class: 'col-sm-4',
            type: 'text',
            validation: 'none'
          },
          {
            label: 'settings.accounts.LABEL',
            key: 'label',
            placeHolder: 'settings.accounts.LABEL',
            value: null,
            class: 'col-sm-3',
            type: 'text',
            validation: 'none'
          }
        ]
      ];

      return entityDetails;
    };
  }
]);

;
(function () {
  "use strict";

  var settings = angular.module('emlogis.settings');

  settings.controller('SettingsAccountsRolesGroupsModalCtrl',
    [
      '$scope',
      '$timeout',
      '$modalInstance',
      'uiGridConstants',
      'applicationContext',
      'dataService',
      'rulesTeamsService',
      'role',
      function ($scope, $timeout, $modalInstance, uiGridConstants, applicationContext, dataService,
                rulesTeamsService, role) {

        //--------------------------------------------------------------------
        // Defaults for Employees Modal
        //--------------------------------------------------------------------

        var te = this,
            totalUnassociatedGroups;

        te.role = role;
        te.numOfRows = 15;
        te.isEditing = false;
        te.queryParams = {
          orderby:'name',
          orderdir:'ASC'
        };

        te.unassociatedGroups = null;
        te.unassociatedGroupsInit = null;
        te.usersToAdd = [];

        //
        // Load Unassociated Employees
        // that don't belong to this Team

        var loadRoleUnassociatedGroups = function(roleId, queryParams, pageNum, perPage){
          
          return dataService.getUnassociatedRolesGroups('roles', roleId, queryParams, pageNum, perPage)
            .then(function(res) {
            console.log('+++ Loaded RoleUnassociatedGroups:', res);    //DEV mode

            prepareData(res);

            $timeout(function() {
              prepareObjectsGrid(te.unassociatedGroups);
            });

            }, function(err) {
              applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
            })
          ;
        };

        loadRoleUnassociatedGroups(te.role.id, te.queryParams, 1, te.numOfRows);

        var prepareData = function(res){
          totalUnassociatedGroups = res.total;
          te.unassociatedGroupsInit = res.data;

          angular.forEach(te.unassociatedGroupsInit, function(obj) {
            obj.isSelected = false;
          });

          te.unassociatedGroups = angular.copy(te.unassociatedGroupsInit);
        };



        //--------------------------------------------------------------------
        // Grid settings
        //--------------------------------------------------------------------

        var prepareObjectsGrid = function(unassociatedGroups){
          console.log('+++ unassociatedRoles', unassociatedGroups);

          te.gridOptions = {
            data: unassociatedGroups,
            totalItems: totalUnassociatedGroups,
            minRowsToShow: unassociatedGroups.length < te.numOfRows ? unassociatedGroups.length : te.numOfRows,

            enableHorizontalScrollbar: 0,
            enableVerticalScrollbar: 0,
            enableColumnMenus: false,

            enableFiltering: true,
            useExternalFiltering: true,

            enableSorting: true,
            useExternalSorting: true,

            needPagination: true,
            useExternalPagination: true,
            enablePaginationControls: false,
            paginationPageSize: te.numOfRows,
            paginationCurrentPage: 1,

            enableSelectAll: true,
            enableRowSelection: true,
            enableFullRowSelection: true,                   // full row selection

            columnDefs: [
              {
                field: 'name',
                enableFiltering: true,
                minWidth: '150',
                sort: {
                  direction: uiGridConstants.ASC
                }
              },
              { field: 'description',enableFiltering: false, minWidth: '100' }
            ],
            onRegisterApi: function(gridApi) {
              te.gridApi = gridApi;

              //
              // Row selection
              
              gridApi.selection.on.rowSelectionChanged($scope, function (row) {
                row.entity.isSelected = row.isSelected;
                te.updateEditing();
              });

              gridApi.selection.on.rowSelectionChangedBatch($scope,function(rows){
                _.each(rows, function(row){
                  row.entity.isSelected = row.isSelected;
                });
                te.updateEditing();
              });

              //
              // Back-end filtering

              gridApi.core.on.filterChanged( $scope, function() {
                var grid = this.grid;
                var filterTerm = grid.columns[1].filters[0].term;
                //console.log('~~~ filter changed - grid', grid);

                if (filterTerm === null || filterTerm === '' || filterTerm === undefined ){
                  te.queryParams = {
                    orderby : te.queryParams.orderby,
                    orderdir: te.queryParams.orderdir
                  };
                } else {
                  var filterName = 'name';
                  te.queryParams.filter = filterName + " LIKE '" + filterTerm + "%'";
                }
                getPage();
              });


              //
              // Back-end sorting

              gridApi.core.on.sortChanged($scope, function(grid, sortColumns) {
                if (sortColumns.length === 0) {
                  te.queryParams.orderdir = 'ASC';
                  te.queryParams.orderby = 'name';
                  
                } else {
                  te.queryParams.orderdir = sortColumns[0].sort.direction;

                  switch (sortColumns[0].field) {
                    case "name":
                      te.queryParams.orderby = 'name';
                      break;
                    case "description":
                      te.queryParams.orderby = 'description';
                      break;
                    default:
                      te.queryParams.orderby = 'getUnassociatedRolesAccounts';
                      break;
                  }
                }
                getPage();
              });


              //
              // Back-end pagination

              gridApi.pagination.on.paginationChanged($scope, function (newPage, pageSize) {
                te.gridOptions.paginationCurrentPage = newPage;
                getPage();
              });

              var getPage = function() {
                console.log('te.gridOptions.queryParams', te.queryParams);

                dataService.getUnassociatedRolesGroups('roles', te.role.id, te.queryParams, te.gridOptions.paginationCurrentPage, te.numOfRows)
                  .then( function(res){
                    console.log('~~~ res grid upd', res);
                    refreshGrid(res);
                });
              };

            }
          };
        };


        //--------------------------------------------------------------------
        // CRUD
        //--------------------------------------------------------------------


        var refreshGrid = function(res){
          prepareData(res);
          te.gridOptions.totalItems = totalUnassociatedGroups;
          te.gridOptions.data = te.unassociatedGroups;
          te.gridOptions.minRowsToShow = totalUnassociatedGroups < te.numOfRows ? totalUnassociatedGroups : te.numOfRows;
        };


        te.updateEditing = function(){
          te.isEditing = !angular.equals(te.unassociatedGroupsInit, te.unassociatedGroups);
        };


        /**
         * Add groups to roles: Settings->Accounts->Roles->Groups
         */
        te.associate = function(){

          //prepare selected rows
          var toAdd = te.gridApi.selection.getSelectedRows();
          console.log('toAdd', toAdd);

          var dto = [];
          angular.forEach(toAdd, function(row){
            dto.push(row.id);
          });
          console.log('toAddDto', {groupIdList: dto});

          dataService.addGroupsToRole(te.role.id, dto).then(function(res){

            te.closeModal();

          }, function(err) {
            applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
          });
        };


        //--------------------------------------------------------------------
        // Modal methods
        //--------------------------------------------------------------------


        te.closeModal = function () {
          $modalInstance.close(te.group);
        };


        //
        // If user navigates away from the page,
        // dismiss the modal

        $scope.$on('$stateChangeStart', function(){
            $modalInstance.dismiss('cancel');
          }
        );

      }
    ]);
})();
;
angular.module('emlogis.settings').controller('SettingsAccountsRolesListBreadcrumbCtrl', ['$scope', '$translate', 'applicationContext',
  function ($scope, $translate, applicationContext) {

  }
]);

;
angular.module('emlogis.settings').controller('SettingsAccountsRolesListCtrl',
  [
    '$scope',
    '$state',
    '$http',
    '$filter',
    'applicationContext',
    'crudDataService',
    'uiGridConstants',
    'SettingsAccountsService',
    'UtilsService',
    function ($scope, $state, $http, $filter, applicationContext, crudDataService, uiGridConstants,
              SettingsAccountsService, UtilsService) {

      $scope.entityDetails = {
        entityType: $scope.consts.entityTypes.role,
        entityColumnDefs: [
          { field: 'id', visible: false },
          { field: 'name', width: '12%' },
          { field: 'description', width: '15%' },
          { field: 'groups', width: '15%' },
          { field: 'userAccounts', enableSorting: false },
          { field: 'created', width: '13%', visible: false },
          { field: 'updated', width: '13%', visible: false },
          { field: 'ownedBy', width: '12%', visible: false }
        ],
        needPagination: true,
        entityDetailsStateName: 'authenticated.settings.accounts.roles.roleDetails'
      };

      $scope.convertEntityToGridRow = function (role) {
        var gridRow = {};

        gridRow.id = role.id;
        gridRow.name = role.name;
        gridRow.description = role.description;
        gridRow.groups = role.groups;
        gridRow.userAccounts = role.userAccounts;
        gridRow.created = new Date(role.created).toString();
        gridRow.updated = new Date(role.updated).toString();
        gridRow.ownedBy = role.ownedBy;

        return gridRow;
      };
    }
  ]
);

;
(function () {
  "use strict";

  var settings = angular.module('emlogis.settings');

  settings.controller('SettingsAccountsRolesPermissionsModalCtrl',
    [
      '$scope',
      '$timeout',
      '$modalInstance',
      'uiGridConstants',
      'applicationContext',
      'dataService',
      'rulesTeamsService',
      'role',
      function ($scope, $timeout, $modalInstance, uiGridConstants, applicationContext, dataService,
                rulesTeamsService, role) {

        //--------------------------------------------------------------------
        // Defaults for Employees Modal
        //--------------------------------------------------------------------

        var te = this,
            totalUnassociatedPermissions;

        te.role = role;
        te.numOfRows = 15;
        te.isEditing = false;
        te.queryParams = {
          orderby:'name',
          orderdir:'ASC'
        };

        te.unassociatedPermissions = null;
        te.unassociatedPermissionsInit = null;
        te.usersToAdd = [];

        //
        // Load Unassociated Employees
        // that don't belong to this Team

        var loadRoleUnassociatedPermissions = function(roleId, queryParams, pageNum, perPage){
          
          return dataService.getUnassociatedRolesPermissions('roles', roleId, queryParams, pageNum, perPage)
            .then(function(res) {
            console.log('+++ Loaded RoleUnassociatedPermissions:', res);    //DEV mode

            prepareData(res);

            $timeout(function() {
              prepareObjectsGrid(te.unassociatedPermissions);
            });

            }, function(err) {
              applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
            })
          ;
        };

        loadRoleUnassociatedPermissions(te.role.id, te.queryParams, 1, te.numOfRows);

        var prepareData = function(res){
          totalUnassociatedPermissions = res.total;
          te.unassociatedPermissionsInit = res.data;

          angular.forEach(te.unassociatedPermissionsInit, function(obj) {
            obj.isSelected = false;
          });

          te.unassociatedPermissions = angular.copy(te.unassociatedPermissionsInit);
        };



        //--------------------------------------------------------------------
        // Grid settings
        //--------------------------------------------------------------------

        var prepareObjectsGrid = function(unassociatedPermissions){
          console.log('+++ unassociatedPermissions', unassociatedPermissions);

          te.gridOptions = {
            data: unassociatedPermissions,
            totalItems: totalUnassociatedPermissions,
            minRowsToShow: unassociatedPermissions.length < te.numOfRows ? unassociatedPermissions.length : te.numOfRows,

            enableHorizontalScrollbar: 0,
            enableVerticalScrollbar: 0,
            enableColumnMenus: false,

            enableFiltering: true,
            useExternalFiltering: true,

            enableSorting: true,
            useExternalSorting: true,

            needPagination: true,
            useExternalPagination: true,
            enablePaginationControls: false,
            paginationPageSize: te.numOfRows,
            paginationCurrentPage: 1,

            enableSelectAll: true,
            enableRowSelection: true,
            enableFullRowSelection: true,                   // full row selection

            columnDefs: [
              {
                field: 'name',
                enableFiltering: true,
                minWidth: '150',
                sort: {
                  direction: uiGridConstants.ASC
                }
              },
              { field: 'description',enableFiltering: false, minWidth: '100' }
            ],
            onRegisterApi: function(gridApi) {
              te.gridApi = gridApi;

              //
              // Row selection
              
              gridApi.selection.on.rowSelectionChanged($scope, function (row) {
                row.entity.isSelected = row.isSelected;
                te.updateEditing();
              });

              gridApi.selection.on.rowSelectionChangedBatch($scope,function(rows){
                _.each(rows, function(row){
                  row.entity.isSelected = row.isSelected;
                });
                te.updateEditing();
              });

              
              //
              // Back-end filtering

              gridApi.core.on.filterChanged( $scope, function() {
                var grid = this.grid;
                var filterTerm = grid.columns[1].filters[0].term;
                //console.log('~~~ filter changed - grid', grid);

                if (filterTerm === null || filterTerm === '' || filterTerm === undefined ){
                  te.queryParams = {
                    orderby : te.queryParams.orderby,
                    orderdir: te.queryParams.orderdir
                  };
                } else {
                  var filterName = 'name';
                  te.queryParams.filter = filterName + " LIKE '" + filterTerm + "%'";
                }
                getPage();
              });


              //
              // Back-end sorting

              gridApi.core.on.sortChanged($scope, function(grid, sortColumns) {
                if (sortColumns.length === 0) {
                  te.queryParams.orderdir = 'ASC';
                  te.queryParams.orderby = 'name';
                  
                } else {
                  te.queryParams.orderdir = sortColumns[0].sort.direction;

                  switch (sortColumns[0].field) {
                    case "name":
                      te.queryParams.orderby = 'name';
                      break;
                    case "description":
                      te.queryParams.orderby = 'description';
                      break;
                    default:
                      te.queryParams.orderby = 'getUnassociatedRolesPermissions';
                      break;
                  }
                }
                getPage();
              });


              //
              // Back-end pagination

              gridApi.pagination.on.paginationChanged($scope, function (newPage, pageSize) {
                te.gridOptions.paginationCurrentPage = newPage;
                getPage();
              });

              var getPage = function() {
                console.log('te.gridOptions.queryParams', te.queryParams);

                dataService.getUnassociatedRolesPermissions('roles', te.role.id, te.queryParams, te.gridOptions.paginationCurrentPage, te.numOfRows)
                  .then( function(res){
                    console.log('~~~ res grid upd', res);
                    refreshGrid(res);
                });
              };

            }
          };
        };


        //--------------------------------------------------------------------
        // CRUD
        //--------------------------------------------------------------------


        var refreshGrid = function(res){
          prepareData(res);
          te.gridOptions.totalItems = totalUnassociatedPermissions;
          te.gridOptions.data = te.unassociatedPermissions;
          te.gridOptions.minRowsToShow = totalUnassociatedPermissions < te.numOfRows ? totalUnassociatedPermissions : te.numOfRows;
        };


        te.updateEditing = function(){
          te.isEditing = !angular.equals(te.unassociatedPermissionsInit, te.unassociatedPermissions);
        };


        /**
         * Add users to groups: Settings->Accounts->Groups->Roles
         */
        te.associate = function(){

          //prepare selected rows
          var toAdd = te.gridApi.selection.getSelectedRows();
          console.log('toAdd', toAdd);

          var dto = [];
          angular.forEach(toAdd, function(row){
            dto.push(row.id);
          });
          console.log('toAddDto', {roleIdList: dto});

          dataService.addPermissionsToRole(te.role.id, dto).then(function(res){

            te.closeModal();

          }, function(err) {
            applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
          });
        };


        //--------------------------------------------------------------------
        // Modal methods
        //--------------------------------------------------------------------


        te.closeModal = function () {
          $modalInstance.close(te.group);
        };


        //
        // If user navigates away from the page,
        // dismiss the modal

        $scope.$on('$stateChangeStart', function(){
            $modalInstance.dismiss('cancel');
          }
        );

      }
    ]);
})();
;
angular.module('emlogis.settings').controller('SettingsAccountsRolesRoleDetailsBreadcrumbCtrl', ['$scope', '$translate', 'applicationContext',
  function ($scope, $translate, applicationContext) {

  }
]);

;
angular.module('emlogis.settings')
  .controller('SettingsAccountsRolesRoleDetailsCtrl',
  [
    '$scope',
    '$state',
    '$stateParams',
    '$q',
    '$translate',
    '$http',
    '$modal',
    '$log',
    '$filter',
    'applicationContext',
    'crudDataService',
    'uiGridConstants',
    'SettingsAccountsService',
    'UtilsService',
    'dataService',
    function ($scope, $state, $stateParams, $q, $translate, $http, $modal, $log, $filter, applicationContext, crudDataService,
              uiGridConstants, SettingsAccountsService, UtilsService, dataService) {

      // init function: settings/accounts/roles
      $scope.init = function() {

        $translate('settings.accounts.ARE_YOU_SURE_DELETE_ROLE?').
          then(function (translation) {
            $scope.confirmationToDeleteRole = translation;
          });

        $scope.entityId = $stateParams.entityId;
        $scope.getEntityDetails();
      };

      $scope.getEntityDetails = function () {
        SettingsAccountsService.getEntityDetails($scope.entityType, $scope.entityId).then(function (response) {
          $scope.entity = response.data;
          $scope.fillEntityDetails();
        }, function (err) {
          applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
        });
      };

      $scope.fillEntityDetails = function () {
        $scope.entityDetails = $scope.populateEntityDetails($scope.entity);
      };

      $scope.populateEntityDetails = function (entity) {
        var entityDetails = {};

        entityDetails.id = entity.id;
        entityDetails.name = entity.name;
        entityDetails.info = [
          [
            {
              label: 'app.NAME',
              key: 'name',
              placeHolder: 'app.NAME',
              value: entity.name,
              class: 'col-sm-4',
              type: 'text',
              validation: 'required',
            }
          ],
          [
            {
              label: 'settings.accounts.DESCRIPTION',
              key: 'description',
              placeHolder: 'settings.accounts.DESCRIPTION',
              value: entity.description,
              class: 'col-sm-8',
              type: 'text',
              validation: 'none'
            }
          ]
        ];

        entityDetails.groups = {};
        entityDetails.users = {};
        entityDetails.permissions = {};
        entityDetails.acl = {};

        // Get list of users & roles & acls
        $scope.loadRelatedEntities($scope.consts.entityTypes.group, entityDetails.groups);
        $scope.loadRelatedEntities($scope.consts.entityTypes.user, entityDetails.users);
        $scope.loadRelatedEntities($scope.consts.entityTypes.permission, entityDetails.permissions);
        $scope.loadRelatedEntities($scope.consts.entityTypes.accessControl, entityDetails.acl);

        entityDetails.canDuplicate = true;
        entityDetails.fieldsToRedefineInDuplication = [
          {
            label: 'app.NAME',
            key: 'name',
            value: ''
          },
          {
            label: 'settings.accounts.LABEL',
            key: 'label',
            value: ''
          },
          {
            label: 'settings.accounts.DESCRIPTION',
            key: 'description',
            value: ''
          }
        ];
        entityDetails.relatedEntities = [
          {
            entityDetails: {
              entityType: $scope.consts.entityTypes.accessControl,
              tabHeading: 'settings.accounts.ACCESS_CONTROL'
            },
            isSelectionListDetails: false,
            selected: true,
            getEntityList: function () {
              var deferred = $q.defer();
              var self = this;
              SettingsAccountsService.getRelatedEntities($scope.entityType, $scope.entityId, self.entityDetails.entityType, true).then(function (response) {
                if (response.data) {
                  deferred.resolve({data: response.data});
                } else {
                  deferred.reject('Error Occurred while trying to get Access Control List');
                }
              }, function (err) {
                applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
                deferred.reject('Error Occurred while trying to get Access Control List');
              });
              return deferred.promise;
            },
            templateUrl: 'modules/settings/partials/accounts/roles/include/roles-access-control-list.html'
          },
          {
            entityDetails: {
              entityType: $scope.consts.entityTypes.permission,
              tabHeading: 'settings.accounts.PERMISSIONS'
            },
            isSelectionListDetails: false,
            selected: false,
            getEntityList: function () {
              var deferred = $q.defer();
              var self = this;
              SettingsAccountsService.getRelatedEntities($scope.entityType, $scope.entityId, self.entityDetails.entityType, true).then(function (response) {
                if (response.data) {
                  deferred.resolve({data: response.data.result});
                } else {
                  deferred.reject('Error Occurred while trying to get Permissions List');
                }
              }, function (err) {
                applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
                deferred.reject('Error Occurred while trying to get Permissions List');
              });
              return deferred.promise;
            },
            getUnassociatedEntityList: function () {
              var deferred = $q.defer();
              var self = this;
              SettingsAccountsService.getRelatedEntities($scope.entityType, $scope.entityId, self.entityDetails.entityType, false).then(function (response) {
                if (response.data) {
                  deferred.resolve({data: response.data.result});
                } else {
                  deferred.reject('Error Occurred while trying to get Unassociated Permissions List');
                }
              }, function (err) {
                applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
                deferred.reject('Error Occurred while trying to get Unassociated Permissions List');
              });
              return deferred.promise;
            },
            templateUrl: 'modules/settings/partials/accounts/roles/include/roles-permissions.html'
          },
          {
            entityDetails: {
              entityType: $scope.consts.entityTypes.group,
              tabHeading: 'settings.accounts.GROUPS',
              entityColumnDefs: [
                { field: 'id', visible: false },
                { field: 'name', width: '14%' },
                { field: 'description', width: '20%' },
                { field: 'members', width: '13%' },
                { field: 'roles', width: '13%' },
                { field: 'created', width: '15%' },
                { field: 'updated', width: '15%' },
                { field: 'ownedBy', width: '10%' }
              ],
              needPagination: false,
              entityDetailsStateName: 'authenticated.settings.accounts.groups.groupDetails'
            },
            isSelectionListDetails: true,
            getEntityList: function () {
              var deferred = $q.defer();
              var self = this;
              var offset = 0;
              var limit = 0;
              SettingsAccountsService.getRelatedEntities($scope.entityType, $scope.entityId, self.entityDetails.entityType, true, null, offset, limit).then(function (response) {
                if (response.data) {
                  deferred.resolve({data: response.data.result});
                } else {
                  deferred.reject('Error Occurred while trying to get Groups List');
                }
              }, function (err) {
                applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
                deferred.reject('Error Occurred while trying to get Groups List');
              });
              return deferred.promise;
            },
            selected: false,
            convertEntityToGridRow: function (group) {
              var gridRow = {};

              gridRow.id = group.id;
              gridRow.name = group.name;
              gridRow.description = group.description;
              gridRow.members = group.nbOfMembers;
              gridRow.roles = group.roles;
              gridRow.created = new Date(group.created).toString();
              gridRow.updated = new Date(group.updated).toString();
              gridRow.ownedBy = group.ownedBy;

              return gridRow;
            },
            templateUrl: 'modules/settings/partials/include/entity-list-wrapper.html'
          },
          {
            entityDetails: {
              entityType: $scope.consts.entityTypes.user,
              tabHeading: 'settings.accounts.USERS',
              entityColumnDefs: [
                { field: 'id', visible: false },
                { field: 'name', width: '12%' },
                { field: 'login', width: '12%' },
                { field: 'status', width: '8%' },
                { field: 'employeeAccount', width: '10%' },
                { field: 'groups', width: '13%' },
                { field: 'roles', width: '13%' },
                { field: 'created', width: '12%' },
                { field: 'updated', width: '12%' },
                { field: 'ownedBy', width: '8%' }
              ],
              needPagination: true,
              entityDetailsStateName: 'authenticated.settings.accounts.users.userDetails'
            },
            isSelectionListDetails: true,
            getEntityList: function (entityListGridOptions, paginationOptions) {
              var deferred = $q.defer();
              var self = this;
              var offset = (paginationOptions.pageNumber - 1) * paginationOptions.pageSize;
              var limit = paginationOptions.pageSize;
              var orderBy = paginationOptions.orderBy;
              var orderDir = paginationOptions.orderDir;
              SettingsAccountsService.getRelatedEntities($scope.entityType, $scope.entityId, self.entityDetails.entityType, true, null, offset, limit, orderBy, orderDir).then(function (response) {
                if (response.data) {
                  entityListGridOptions.totalItems = response.data.total;
                  deferred.resolve({data: response.data.result});
                } else {
                  deferred.reject('Error Occurred while trying to get Users List');
                }
              }, function (err) {
                applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
                deferred.reject('Error Occurred while trying to get Users List');
              });
              return deferred.promise;
            },
            selected: false,
            convertEntityToGridRow: function (user) {
              var gridRow = {};

              gridRow.id = user.id;
              gridRow.name = user.name;
              gridRow.login = user.login;
              gridRow.status = user.status;

              if (typeof user.employeeId !== 'undefined' && user.employeeId !== null) {
                gridRow.employeeAccount = user.employeeFirstName + ' ' + user.employeeLastName;
              } else {
                gridRow.employeeAccount = '?';
              }

              gridRow.groups = user.groups;
              gridRow.roles = user.roles;
              gridRow.created = new Date(user.created).toString();
              gridRow.updated = new Date(user.updated).toString();
              gridRow.ownedBy = user.ownedBy;

              return gridRow;
            },
            templateUrl: 'modules/settings/partials/include/entity-list-wrapper.html'
          }
        ];

        return entityDetails;
      };

      /**
       * Load related entities
       */
      $scope.loadRelatedEntities = function(relatedEntityType, relatedEntities) {

        var deferred = $q.defer();

        SettingsAccountsService.getRelatedEntities($scope.entityType, $scope.entityId, relatedEntityType, true, null, 0,0, 'name', 'asc').then(function (response) {
          if (response.data) {
            angular.copy(response.data, relatedEntities);
            deferred.resolve(relatedEntities);
          } else {
            applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
            deferred.reject('Error Occurred while trying to get ' + relatedEntityType + ' List');
          }
        }, function (err) {
          applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
          deferred.reject('Error Occurred while trying to get ' + relatedEntityType + ' List');
        });

        return deferred.promise;
      };

      /**
       * Tag Directive Related Func
       */

      $scope.removeGroupFromRole = function(group) {

        return dataService.removeGroupsFromRole($scope.entity.id, [group.id])
          .then(function(res){
            $scope.loadRelatedEntities($scope.consts.entityTypes.group, $scope.entityDetails.groups);
            $scope.loadRelatedEntities($scope.consts.entityTypes.user, $scope.entityDetails.users);
          }, function(error) {
            if (error.message) {
              applicationContext.setNotificationMsgWithValues(error.message, '', true, '');
            }
            else {
              applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
            }
          });
      };

      $scope.removeUserFromRole = function(user) {

        return dataService.removeUsersFromRole($scope.entity.id, [user.id])
          .then(function(res){
            $scope.loadRelatedEntities($scope.consts.entityTypes.user, $scope.entityDetails.users);
            $scope.loadRelatedEntities($scope.consts.entityTypes.group, $scope.entityDetails.groups);
          }, function(error) {
            if (error.message) {
              applicationContext.setNotificationMsgWithValues(error.message, '', true, '');
            }
            else {
              applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
            }
          });
      };

      $scope.removePermissionFromRole = function(permission) {

        return dataService.removePermissionFromRole($scope.entity.id, permission.id)
          .then(function(res){
            $scope.loadRelatedEntities($scope.consts.entityTypes.permission, $scope.entityDetails.permissions);
          }, function(error) {
            if (error.message) {
              applicationContext.setNotificationMsgWithValues(error.message, '', true, '');
            }
            else {
              applicationContext.setNotificationMsgWithValues(error.data.message, '', true, error.statusText);
            }
          });
      };

      /**
       * Eml Object related functions
       */
      $scope.openGroupsModal = function (role) {

        var modalInstance = $modal.open({
          templateUrl: 'modules/settings/partials/include/settings-accounts-roles-groups-modal.tmpl.html',
          controller: 'SettingsAccountsRolesGroupsModalCtrl as te',
          windowClass: 'groups-modal',
          size: 'lg',
          resolve: {
            role: function () {
              return role;
            }
          }
        });

        modalInstance.result.then(function () {
          $scope.loadRelatedEntities($scope.consts.entityTypes.group, $scope.entityDetails.groups);
          $scope.loadRelatedEntities($scope.consts.entityTypes.user, $scope.entityDetails.users);

        }, function () {
          $log.info('Modal dismissed at: ' + new Date());
        });
      };

      $scope.openUsersModal = function (role) {

        var modalInstance = $modal.open({
          templateUrl: 'modules/settings/partials/include/settings-accounts-roles-users-modal.tmpl.html',
          controller: 'SettingsAccountsRolesUsersModalCtrl as te',
          windowClass: 'users-modal',
          size: 'lg',
          resolve: {
            role: function () {
              return role;
            }
          }
        });

        modalInstance.result.then(function () {
          $scope.loadRelatedEntities($scope.consts.entityTypes.user, $scope.entityDetails.users);
          $scope.loadRelatedEntities($scope.consts.entityTypes.group, $scope.entityDetails.groups);

        }, function () {
          $log.info('Modal dismissed at: ' + new Date());
        });
      };

      $scope.openPermissionsModal = function (role) {

        var modalInstance = $modal.open({
          templateUrl: 'modules/settings/partials/include/settings-accounts-roles-permissions-modal.tmpl.html',
          controller: 'SettingsAccountsRolesPermissionsModalCtrl as te',
          windowClass: 'permissions-modal',
          size: 'lg',
          resolve: {
            role: function () {
              return role;
            }
          }
        });

        modalInstance.result.then(function () {
          $scope.loadRelatedEntities($scope.consts.entityTypes.permission, $scope.entityDetails.permissions);

        }, function () {
          $log.info('Modal dismissed at: ' + new Date());
        });
      };

      $scope.openDuplicateEntityModal = function () {
        var modalInstance = $modal.open({
          templateUrl: 'duplicateEntity.html',
          controller: 'DuplicateEntityModalInstanceCtrl',
          backdrop: false,
          windowClass: 'duplicate-entity-modal',
          resolve: {
            entityName: function () {
              return $scope.entityName;
            },
            fieldsToRedefineInDuplication: function () {
              return $scope.entityDetails.fieldsToRedefineInDuplication;
            }
          }
        });

        /*$timeout(function() {
         var duplicateEntityButtonPosition = $('.btn-duplicate-entity').offset();
         $('.duplicate-entity-modal').css('position', 'absolute');
         $('.duplicate-entity-modal').css('top', duplicateEntityButtonPosition.top + 30);
         $('.duplicate-entity-modal').css('left', duplicateEntityButtonPosition.left - 400);
         }, 0);*/

        modalInstance.result.then(function (fieldsToRedefineInDuplication) {
          var inputJson = {};
          angular.forEach(fieldsToRedefineInDuplication, function (field) {
            inputJson[field.key] = field.value;
          });

          SettingsAccountsService.duplicateEntity($scope.entityType, $scope.entityId, inputJson).then(function (response) {
            applicationContext.setNotificationMsgWithValues('app.DUPLICATED_SUCCESSFULLY', 'success', true);
            var newEntityId = response.data.id;
            $state.go($scope.entityDetailsStateName, {entityId: newEntityId});
          }, function (err) {
            applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
          });
        });
      };

      $scope.openAclModal = function (role) {

        var modalInstance = $modal.open({
          templateUrl: 'modules/settings/partials/include/settings-accounts-roles-acl-modal.tmpl.html',
          controller: 'SettingsAccountsRolesAclModalCtrl as te',
          size: 'lg',
          resolve: {
            role: function () {
              return role;
            },
            acl: function () {
              return angular.copy($scope.entityDetails.acl);
            }
          }
        });

        modalInstance.result.then(function (response) {
          $scope.loadRelatedEntities($scope.consts.entityTypes.accessControl, $scope.entityDetails.acl);
        }, function () {
          $log.info('Modal dismissed at: ' + new Date());
        });
      };

      /**
       * Fired when user click group name
       */
      $scope.viewGroup = function(object) {
        $state.go('authenticated.settings.accounts.groups.groupDetails', {entityId: object.id});
      };

      /**
       * Fired when user click user name
       */
      $scope.viewUser = function(object) {
        $state.go('authenticated.settings.accounts.users.userDetails', {entityId: object.id});
      };

      /**
       * Update Entity: Role Details
       */
      $scope.updateEntityDetails = function () {

        $scope.submitClicked = true;

        var editPromise = null;
        $scope.entityEditDetails = {};


        if (!$scope.entityDetails.info[0][0].value) { //name
          applicationContext.setNotificationMsgWithValues('app.PLEASE_FILL_CORRECT_DATA_IN_FIELDS', 'danger', true);
          return;
        }

        $scope.entityEditDetails['name'] = $scope.entityDetails.info[0][0].value; //name
        $scope.entityEditDetails['description'] = $scope.entityDetails.info[1][0].value; //description


        if ($scope.editMode === 'New') {
          editPromise = SettingsAccountsService.createEntity($scope.entityType, $scope.entityEditDetails);
        } else {
          editPromise = SettingsAccountsService.updateEntity($scope.entityType, $scope.entityDetails.id, $scope.entityEditDetails);
        }
        editPromise.then(function (response) {
          if ($scope.editMode === 'New') {
            applicationContext.setNotificationMsgWithValues('app.CREATED_SUCCESSFULLY', 'success', true);
          } else {
            applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', 'success', true);
          }
          $state.go($scope.entityDetailsStateName, {entityId: response.data.id});
        }, function (err) {
          applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
          $state.go($scope.entityListStateName);
        });
      };

      $scope.confirmDeleteEntity = function () {
        if ($scope.entityType === $scope.consts.entityTypes.user && $scope.entityDetails.id === 'admin') {
          applicationContext.setNotificationMsgWithValues('settings.accounts.DEFAULT_ADMIN_USER_ACCOUNT_CANT_BE_DELETED', 'success', true);
          return;
        }

        if ($scope.entityType === $scope.consts.entityTypes.role && $scope.entityDetails.id === 'adminrole') {
          applicationContext.setNotificationMsgWithValues('settings.accounts.DEFAULT_ADMIN_ROLE_CANT_BE_DELETED', 'success', true);
          return;
        }

        SettingsAccountsService.deleteEntity($scope.entityType, $scope.entityId).then(function (response) {
          applicationContext.setNotificationMsgWithValues('app.DELETED_SUCCESSFULLY', 'success', true);
          $state.go($scope.entityListStateName);
        }, function (err) {
          applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
        });
      };

      //call initialization file
      $scope.init();
    }
]);

;
angular.module('emlogis.settings').controller('SettingsAccountsRolesRoleEditBreadcrumbCtrl', ['$scope', '$translate', 'applicationContext',
  function ($scope, $translate, applicationContext) {

  }
]);

;
angular.module('emlogis.settings').controller('SettingsAccountsRolesRoleEditCtrl', ['$scope', '$state', '$stateParams', '$q', '$http', '$filter', 'applicationContext', 'crudDataService', 'uiGridConstants', 'SettingsAccountsService', 'UtilsService',
  function ($scope, $state, $stateParams, $q, $http, $filter, applicationContext, crudDataService, uiGridConstants, SettingsAccountsService, UtilsService) {

    $scope.editMode = 'Edit';
    $scope.editLabel = 'app.UPDATE';
    $scope.entityId = $stateParams.entityId;

    $scope.populateEntityDetails = function (entity) {
      var entityDetails = {};

      entityDetails.id = entity.id;
      entityDetails.name = entity.name;
      entityDetails.info = [
        [
          {
            label: 'app.NAME',
            key: 'name',
            placeHolder: 'app.NAME',
            value: entity.name,
            class: 'col-sm-3',
            type: 'text',
            validation: 'required'
          },
          {
            label: 'settings.accounts.DESCRIPTION',
            key: 'description',
            placeHolder: 'settings.accounts.DESCRIPTION',
            value: entity.description,
            class: 'col-sm-4',
            type: 'text',
            validation: 'none'
          },
          {
            label: 'settings.accounts.LABEL',
            key: 'label',
            placeHolder: 'settings.accounts.LABEL',
            value: entity.label,
            class: 'col-sm-3',
            type: 'text',
            validation: 'none'
          }
        ]
      ];

      entityDetails.relatedEntities = [
        {
          entityDetails: {
            entityType: $scope.consts.entityTypes.accessControl,
            tabHeading: 'settings.accounts.ACCESS_CONTROL'
          },
          isSelectionList: false,
          selected: true,
          getEntityList: function () {
            var deferred = $q.defer();
            var self = this;
            SettingsAccountsService.getRelatedEntities($scope.entityType, $scope.entityId, self.entityDetails.entityType, true).then(function (response) {
              if (response.data) {
                deferred.resolve({data: response.data});
              } else {
                deferred.reject('Error Occurred while trying to get Access Control List');
              }
            }, function (err) {
              applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
              deferred.reject('Error Occurred while trying to get Access Control List');
            });
            return deferred.promise;
          },
          templateUrl: 'modules/settings/partials/accounts/roles/include/roles-access-control-list.html'
        },
        {
          entityDetails: {
            entityType: $scope.consts.entityTypes.permission,
            tabHeading: 'settings.accounts.PERMISSIONS'
          },
          isSelectionList: false,
          selected: false,
          getEntityList: function () {
            var deferred = $q.defer();
            var self = this;
            SettingsAccountsService.getRelatedEntities($scope.entityType, $scope.entityId, self.entityDetails.entityType, true).then(function (response) {
              if (response.data) {
                deferred.resolve({data: response.data.result});
              } else {
                deferred.reject('Error Occurred while trying to get Permissions List');
              }
            }, function (err) {
              applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
              deferred.reject('Error Occurred while trying to get Permissions List');
            });
            return deferred.promise;
          },
          getUnassociatedEntityList: function () {
            var deferred = $q.defer();
            var self = this;
            SettingsAccountsService.getRelatedEntities($scope.entityType, $scope.entityId, self.entityDetails.entityType, false).then(function (response) {
              if (response.data) {
                deferred.resolve({data: response.data.result});
              } else {
                deferred.reject('Error Occurred while trying to get Unassociated Permissions List');
              }
            }, function (err) {
              applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
              deferred.reject('Error Occurred while trying to get Unassociated Permissions List');
            });
            return deferred.promise;
          },
          templateUrl: 'modules/settings/partials/accounts/roles/include/roles-permissions.html'
        },
        {
          entityDetails: {
            entityType: $scope.consts.entityTypes.group,
            tabHeading: 'settings.accounts.GROUPS',
            entityColumnDefs: [
              { field: 'id', visible: false },
              { field: 'name', width: '14%' },
              { field: 'description', width: '20%' },
              { field: 'members', width: '13%' },
              { field: 'roles', width: '13%' },
              { field: 'created', width: '15%' },
              { field: 'updated', width: '15%' },
              { field: 'ownedBy', width: '10%' }
            ],
            needPagination: false
          },
          isSelectionList: true,
          getEntityList: function () {
            var deferred = $q.defer();
            var self = this;
            var offset = 0;
            var limit = 0;
            SettingsAccountsService.getRelatedEntities($scope.entityType, $scope.entityId, self.entityDetails.entityType, true, null, offset, limit).then(function (response) {
              if (response.data) {
                deferred.resolve({data: response.data.result});
              } else {
                deferred.reject('Error Occurred while trying to get Groups List');
              }
            }, function (err) {
              applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
              deferred.reject('Error Occurred while trying to get Groups List');
            });
            return deferred.promise;
          },
          selected: false,
          convertEntityToGridRow: function (group) {
            var gridRow = {};

            gridRow.id = group.id;
            gridRow.name = group.name;
            gridRow.description = group.description;
            gridRow.members = group.nbOfMembers;
            gridRow.roles = group.roles;
            gridRow.created = new Date(group.created).toString();
            gridRow.updated = new Date(group.updated).toString();
            gridRow.ownedBy = group.ownedBy;

            return gridRow;
          },
          templateUrl: 'modules/settings/partials/include/entity-selection-list-wrapper.html'
        },
        {
          entityDetails: {
            entityType: $scope.consts.entityTypes.user,
            tabHeading: 'settings.accounts.USERS',
            entityColumnDefs: [
              { field: 'id', visible: false },
              { field: 'name', width: '12%' },
              { field: 'login', width: '12%' },
              { field: 'status', width: '8%' },
              { field: 'employeeAccount', width: '10%' },
              { field: 'groups', width: '13%' },
              { field: 'roles', width: '13%' },
              { field: 'created', width: '12%' },
              { field: 'updated', width: '12%' },
              { field: 'ownedBy', width: '8%' }
            ],
            needPagination: true
          },
          isSelectionList: true,
          getEntityList: function (entityListGridOptions, paginationOptions) {
            var deferred = $q.defer();
            var self = this;
            var offset = (paginationOptions.pageNumber - 1) * paginationOptions.pageSize;
            var limit = paginationOptions.pageSize;
            var orderBy = paginationOptions.orderBy;
            var orderDir = paginationOptions.orderDir;
            SettingsAccountsService.getRelatedEntities($scope.entityType, $scope.entityId, self.entityDetails.entityType, true, null, offset, limit, orderBy, orderDir).then(function (response) {
              if (response.data) {
                entityListGridOptions.totalItems = response.data.total;
                deferred.resolve({data: response.data.result});
              } else {
                deferred.reject('Error Occurred while trying to get Users List');
              }
            }, function (err) {
              applicationContext.setNotificationMsgWithValues(err.data.message || JSON.stringify(err.data), 'danger', true);
              deferred.reject('Error Occurred while trying to get Users List');
            });
            return deferred.promise;
          },
          selected: false,
          convertEntityToGridRow: function (user) {
            var gridRow = {};

            gridRow.id = user.id;
            gridRow.name = user.name;
            gridRow.login = user.login;
            gridRow.status = user.status;

            if (typeof user.employeeId !== 'undefined' && user.employeeId !== null) {
              gridRow.employeeAccount = user.employeeFirstName + ' ' + user.employeeLastName;
            } else {
              gridRow.employeeAccount = '?';
            }

            gridRow.groups = user.groups;
            gridRow.roles = user.roles;
            gridRow.created = new Date(user.created).toString();
            gridRow.updated = new Date(user.updated).toString();
            gridRow.ownedBy = user.ownedBy;

            return gridRow;
          },
          templateUrl: 'modules/settings/partials/include/entity-selection-list-wrapper.html'
        }
      ];

      return entityDetails;
    };
  }
]);

;
(function () {
  "use strict";

  var settings = angular.module('emlogis.settings');

  settings.controller('SettingsAccountsRolesUsersModalCtrl',
    [
      '$scope',
      '$timeout',
      '$modalInstance',
      'uiGridConstants',
      'applicationContext',
      'dataService',
      'rulesTeamsService',
      'role',
      function ($scope, $timeout, $modalInstance, uiGridConstants, applicationContext, dataService,
                rulesTeamsService, role) {

        //--------------------------------------------------------------------
        // Defaults for Employees Modal
        //--------------------------------------------------------------------

        var te = this,
            totalUnassociatedUsers;

        te.role = role;
        te.numOfRows = 15;
        te.isEditing = false;
        te.queryParams = {
          orderby:'name',
          orderdir:'ASC'
        };

        te.unassociatedUsers = null;
        te.unassociatedUsersInit = null;
        te.usersToAdd = [];

        //
        // Load Unassociated Employees
        // that don't belong to this Team

        var loadRoleUnassociatedUsers = function(roleId, queryParams, pageNum, perPage){
          
          return dataService.getUnassociatedRolesUsers('roles', roleId, queryParams, pageNum, perPage)
            .then(function(res) {
            console.log('+++ Loaded RoleUnassociatedUsers:', res);    //DEV mode

            prepareData(res);

            $timeout(function() {
              prepareObjectsGrid(te.unassociatedUsers);
            });

            }, function(err) {
              applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
            })
          ;
        };

        loadRoleUnassociatedUsers(te.role.id, te.queryParams, 1, te.numOfRows);

        var prepareData = function(res){
          totalUnassociatedUsers = res.total;
          te.unassociatedUsersInit = res.data;

          angular.forEach(te.unassociatedUsersInit, function(obj) {
            obj.isSelected = false;
          });

          te.unassociatedUsers = angular.copy(te.unassociatedUsersInit);
        };



        //--------------------------------------------------------------------
        // Grid settings
        //--------------------------------------------------------------------

        var prepareObjectsGrid = function(unassociatedUsers){
          console.log('+++ unassociatedRoles', unassociatedUsers);

          te.gridOptions = {
            data: unassociatedUsers,
            totalItems: totalUnassociatedUsers,
            minRowsToShow: unassociatedUsers.length < te.numOfRows ? unassociatedUsers.length : te.numOfRows,

            enableHorizontalScrollbar: 0,
            enableVerticalScrollbar: 0,
            enableColumnMenus: false,

            enableFiltering: true,
            useExternalFiltering: true,

            enableSorting: true,
            useExternalSorting: true,

            needPagination: true,
            useExternalPagination: true,
            enablePaginationControls: false,
            paginationPageSize: te.numOfRows,
            paginationCurrentPage: 1,

            enableSelectAll: true,
            enableRowSelection: true,
            enableFullRowSelection: true,                   // full row selection

            columnDefs: [
              {
                field: 'name',
                enableFiltering: true,
                minWidth: '150',
                sort: {
                  direction: uiGridConstants.ASC
                }
              },
              { field: 'description',enableFiltering: false, minWidth: '100' }
            ],
            onRegisterApi: function(gridApi) {
              te.gridApi = gridApi;

              //
              // Row selection
              
              gridApi.selection.on.rowSelectionChanged($scope, function (row) {
                row.entity.isSelected = row.isSelected;
                te.updateEditing();
              });

              gridApi.selection.on.rowSelectionChangedBatch($scope,function(rows){
                _.each(rows, function(row){
                  row.entity.isSelected = row.isSelected;
                });
                te.updateEditing();
              });
              
              //
              // Back-end filtering

              gridApi.core.on.filterChanged( $scope, function() {
                var grid = this.grid;
                var filterTerm = grid.columns[1].filters[0].term;
                //console.log('~~~ filter changed - grid', grid);

                if (filterTerm === null || filterTerm === '' || filterTerm === undefined ){
                  te.queryParams = {
                    orderby : te.queryParams.orderby,
                    orderdir: te.queryParams.orderdir
                  };
                } else {
                  var filterName = 'name';
                  te.queryParams.filter = filterName + " LIKE '" + filterTerm + "%'";
                }
                getPage();
              });


              //
              // Back-end sorting

              gridApi.core.on.sortChanged($scope, function(grid, sortColumns) {
                if (sortColumns.length === 0) {
                  te.queryParams.orderdir = 'ASC';
                  te.queryParams.orderby = 'name';
                  
                } else {
                  te.queryParams.orderdir = sortColumns[0].sort.direction;

                  switch (sortColumns[0].field) {
                    case "name":
                      te.queryParams.orderby = 'name';
                      break;
                    case "description":
                      te.queryParams.orderby = 'description';
                      break;
                    default:
                      te.queryParams.orderby = 'getUnassociatedRolesUsers';
                      break;
                  }
                }
                getPage();
              });


              //
              // Back-end pagination

              gridApi.pagination.on.paginationChanged($scope, function (newPage, pageSize) {
                te.gridOptions.paginationCurrentPage = newPage;
                getPage();
              });

              var getPage = function() {
                console.log('te.gridOptions.queryParams', te.queryParams);

                dataService.getUnassociatedRolesUsers('roles', te.role.id, te.queryParams, te.gridOptions.paginationCurrentPage, te.numOfRows)
                  .then( function(res){
                    console.log('~~~ res grid upd', res);
                    refreshGrid(res);
                });
              };

            }
          };
        };


        //--------------------------------------------------------------------
        // CRUD
        //--------------------------------------------------------------------


        var refreshGrid = function(res){
          prepareData(res);
          te.gridOptions.totalItems = totalUnassociatedUsers;
          te.gridOptions.data = te.unassociatedUsers;
          te.gridOptions.minRowsToShow = totalUnassociatedUsers < te.numOfRows ? totalUnassociatedUsers : te.numOfRows;
        };


        te.updateEditing = function(){
          te.isEditing = !angular.equals(te.unassociatedUsersInit, te.unassociatedUsers);
        };


        /**
         * Add users to groups: Settings->Accounts->Groups->Roles
         */
        te.associate = function(){

          //prepare selected rows
          var toAdd = te.gridApi.selection.getSelectedRows();
          console.log('toAdd', toAdd);

          var dto = [];
          angular.forEach(toAdd, function(row){
            dto.push(row.id);
          });
          console.log('toAddDto', {roleIdList: dto});

          dataService.addUsersToRole(te.role.id, dto).then(function(res){

            te.closeModal();

          }, function(err) {
            applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
          });
        };


        //--------------------------------------------------------------------
        // Modal methods
        //--------------------------------------------------------------------


        te.closeModal = function () {
          $modalInstance.close(te.group);
        };


        //
        // If user navigates away from the page,
        // dismiss the modal

        $scope.$on('$stateChangeStart', function(){
            $modalInstance.dismiss('cancel');
          }
        );

      }
    ]);
})();
;
angular.module('emlogis.settings').controller('SettingsAccountsRolesCtrl', ['$scope', '$state', '$http', '$filter', 'applicationContext', 'crudDataService', 'uiGridConstants', 'SettingsAccountsService', 'UtilsService',
  function ($scope, $state, $http, $filter, applicationContext, crudDataService, uiGridConstants, SettingsAccountsService, UtilsService) {
    var entityFilter = applicationContext.getEntityFilter();

    entityFilter.url = 'roles/ops/quicksearch';
    entityFilter.searchFields = 'name,label';
    entityFilter.returnedFields = 'id,name';

    applicationContext.setEntityFilter(entityFilter);

    $scope.entityType = $scope.consts.entityTypes.role;
    $scope.entityName = "settings.accounts.roles.NAME";
    $scope.entityListStateName = 'authenticated.settings.accounts.roles.list';
    $scope.entityDetailsStateName = 'authenticated.settings.accounts.roles.roleDetails';
    $scope.entityEditStateName = 'authenticated.settings.accounts.roles.roleDetails';

    $scope.hasMgmtPermission = function () {
      return $scope.hasPermission('Role_Mgmt');
    };

    $scope.hasViewPermission = function () {
      return $scope.hasPermission('Role_View');
    };
  }
]);

;
angular.module('emlogis.settings').controller('SettingsAccountsBreadcrumbCtrl', ['$scope', '$state', '$translate', 'applicationContext',
  function ($scope, $state, $translate, applicationContext) {

  }
]);

;
angular.module('emlogis.settings').controller('SettingsAccountsCtrl', ['$scope', '$state',
  function ($scope, $state) {

  }
]);

;
angular.module('emlogis.settings').controller('SettingsAccountsUsersBreadcrumbCtrl', ['$scope', '$state', '$translate', 'applicationContext',
  function ($scope, $state, $translate, applicationContext) {
    $scope.entityName = "settings.accounts.users.NAME";
    $scope.entityResource = "settings.accounts.USERS";
    $scope.entityQuickSearchUrl = "useraccounts/ops/quicksearch";

    $scope.selectEntitySearchValue = function (item, model, label) {
      $state.go('authenticated.settings.accounts.users.userDetails', {entityId: item.id});
    };

    $scope.goToNewEntityState = function () {
      $state.go('authenticated.settings.accounts.users.create');
    };

    $scope.hasMgmtPermission = function () {
      return $scope.hasPermission('Account_Mgmt');
    };

    $scope.hasViewPermission = function () {
      return $scope.hasPermission('Account_View');
    };
  }
]);

;
angular.module('emlogis.settings').controller('SettingsAccountsUsersCreateBreadcrumbCtrl', ['$scope', '$translate', 'applicationContext',
  function ($scope, $translate, applicationContext) {

  }
]);

;
angular.module('emlogis.settings').controller('SettingsAccountsUsersCreateCtrl', ['$scope', '$state', 'applicationContext', 'dataService',
  function ($scope, $state, applicationContext, dataService) {

    $scope.userAccount = {
      firstName: null,
      lastName: null,
      login: null,
      workEmail: null
    };

    $scope.showValidationMessages = false;

    $scope.createUserAccount = function() {
      $scope.showValidationMessages = true;

      if (!$scope.userAccountForm.$valid) return;

      dataService.createUserAccount($scope.userAccount).
        then(function(res) {
          applicationContext.setNotificationMsgWithValues('app.CREATED_SUCCESSFULLY', 'success', true);
          $state.go('authenticated.settings.accounts.users.userDetails', {'entityId': res.data.id});
        }, function (err) {
          applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
        });
    };
  }
]);

;
angular.module('emlogis.settings').controller('SettingsAccountsUsersListBreadcrumbCtrl', ['$scope', '$translate', 'applicationContext',
  function ($scope, $translate, applicationContext) {

  }
]);

;
angular.module('emlogis.settings').controller('SettingsAccountsUsersListCtrl', ['$scope', '$state', '$http', '$filter', 'applicationContext', 'crudDataService', 'uiGridConstants', 'SettingsAccountsService', 'UtilsService',
  function ($scope, $state, $http, $filter, applicationContext, crudDataService, uiGridConstants, SettingsAccountsService, UtilsService) {

    $scope.entityDetails = {
      entityType: $scope.consts.entityTypes.user,
      entityColumnDefs: [
        { field: 'id', visible: false },
        { field: 'name'},
        { field: 'login'},
        { field: 'status'},
        { field: 'employeeAccount', enableSorting: false },
        { field: 'groups'},
        { field: 'roles', visible: false},
        { field: 'created', enableSorting: false, visible: false},
        { field: 'updated', enableSorting: false, visible: false},
        { field: 'ownedBy', enableSorting: false, visible: false}
      ],
      needPagination: true,
      entityDetailsStateName: 'authenticated.settings.accounts.users.userDetails'
    };

    $scope.convertEntityToGridRow = function (user) {
      var gridRow = {};

      gridRow.id = user.id;
      gridRow.name = user.name;
      gridRow.login = user.login;
      gridRow.status = user.status;

      if (typeof user.employeeId !== 'undefined' && user.employeeId !== null) {
        gridRow.employeeAccount = user.employeeFirstName + ' ' + user.employeeLastName;
      } else {
        gridRow.employeeAccount = '?';
      }

      gridRow.groups = user.groups;
      gridRow.roles = user.roles;
      gridRow.created = new Date(user.created).toString();
      gridRow.updated = new Date(user.updated).toString();
      gridRow.ownedBy = user.ownedBy;

      return gridRow;
    };
  }
]);

;
angular.module('emlogis.settings').controller('SettingsAccountsUsersUserDetailsBreadcrumbCtrl', ['$scope', '$translate', 'applicationContext',
  function ($scope, $translate, applicationContext) {

  }
]);

;
angular.module('emlogis.settings').controller('SettingsAccountsUsersUserDetailsCtrl',
  ['$scope', '$state', '$stateParams', '$q', '$translate', 'dataService', 'applicationContext',
  function ($scope, $state, $stateParams, $q, $translate, dataService, applicationContext) {

    $scope.userAccountId = $stateParams.entityId;
    $scope.userDetails = null;
    $scope.unassosiatedGroups = null;
    $scope.unassosiatedRoles = null;
    $scope.initialGroups = [];
    $scope.initialRoles = [];
    $scope.timeZones = [];
    $scope.createdOn = null;
    $scope.updatedOn = null;
    $scope.lastLoggedIn = "-";
    $scope.enableUserStatusEditing = false;

    $translate('settings.accounts.ARE_YOU_SURE_DELETE_USER?').
      then(function (translation) {
        $scope.confirmationToDeleteUser = translation;
      });

    dataService.getUserAccountView($scope.userAccountId).
      then(function(res) {
        $scope.userDetails = res.data;

        $scope.userName = $scope.userDetails.firstName + " " + $scope.userDetails.lastName;
        $scope.initialGroups = _.clone($scope.userDetails.groups);
        $scope.initialRoles = _.clone($scope.userDetails.roles);
        $scope.userDetails.gender = parseInt($scope.userDetails.gender);
        $scope.createdOn = new Date($scope.userDetails.created).toDateString();
        $scope.updatedOn = new Date($scope.userDetails.updated).toDateString();

        if ($scope.userDetails.lastLogged) {
          $scope.lastLoggedIn = new Date($scope.userDetails.lastLogged).toDateString();
        }
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });

    dataService.getUnassociatedAccountGroups($scope.userAccountId, {limit: 0}).
      then(function(res) {
        $scope.unassosiatedGroups = res.data.result;
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });

    dataService.getUnassociatedAccountRoles($scope.userAccountId).
      then(function(res) {
        $scope.unassosiatedRoles = res.data.result;
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });

    dataService.getTimeZones().
      then(function(res) {
        $scope.timeZones = res;
      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });

    $scope.inactivityPeriodOptions = [
      {value: 0, label: "-"}
    ];

    for (var i=5; i<35; i=i+5) {
      $scope.inactivityPeriodOptions.push({value: i, label: i +" min"});
    }

    $scope.genderOptions = [
      {value: 0, label: "N/A"},
      {value: 1, label: "Male"},
      {value: 2, label: "Female"}
    ];

    $scope.userStatusOptions = [
      {value: "Active", label: "Active"},
      {value: "Suspended", label: "Suspended"},
      {value: "Locked", label: "Locked"},
      {value: "Revoked", label: "Revoked"}
    ];

    $scope.addGroupToUser = function(group) {
      $scope.userDetails.groups.push(group);
    };

    $scope.removeGroupFromUser = function(group) {
      $scope.userDetails.groups = _.reject($scope.userDetails.groups, function(g) {
        return g.name === group.name;
      });
    };

    $scope.addRoleToUser = function(role) {
      $scope.userDetails.roles.push(role);
    };

    $scope.removeRoleFromUser = function(role) {
      $scope.userDetails.roles = _.reject($scope.userDetails.roles, function(r) {
        return r.name === role.name;
      });
    };

    $scope.editUserStatus = function(edit) {
      $scope.enableUserStatusEditing = edit;
    };

    $scope.canResetPassword = function() {
      return $scope.userDetails &&
        ($scope.userDetails.employeeId === null && $scope.hasPermission("Account_Mgmt") || // reqular account
        $scope.userDetails.employeeId && $scope.hasPermission("Employee_Mgmt"));          // employee account
    };

    $scope.requestPasswordReset = function() {
      dataService.requestUserPasswordReset($scope.userAccountId).
        then(function(res) {
          applicationContext.setNotificationMsgWithValues('settings.accounts.PASSWORD_RESETED', 'success', true);
        }, function (err) {
          var message = err.data.message || err.data.info;
          applicationContext.setNotificationMsgWithValues(message, 'danger', true);
        });
    };

    $scope.updateUserAccount = function() {
      var dto = _.clone($scope.userDetails),
        groupsToAdd = _.reject(dto.groups, function(g) {
          return _.some($scope.initialGroups, 'name', g.name);
        }),
        groupsToRemove = _.filter($scope.initialGroups, function(g) {
          return !_.some(dto.groups, 'name', g.name);
        }),
        rolesToAdd = _.reject(dto.roles, function(r) {
          return _.some($scope.initialRoles, 'name', r.name);
        }),
        rolesToRemove = _.filter($scope.initialRoles, function(r) {
          return !_.some(dto.roles, 'name', r.name);
        });

      delete dto.groups;
      delete dto.roles;
      delete dto.inheritedRoles;
      delete dto.tenantId;

      if (dto.employeeId) {
        delete dto.timeZone;
      }

      $q.all([
        dataService.updateUserAccount($scope.userAccountId, dto),
        dataService.addGroupsToUserAccount($scope.userAccountId, _.pluck(groupsToAdd, "id")),
        dataService.removeGroupsFromUserAccount($scope.userAccountId, _.pluck(groupsToRemove, "groupId")),
        dataService.addRolesToUserAccount($scope.userAccountId, _.pluck(rolesToAdd, "id")),
        dataService.removeRolesFromUserAccount($scope.userAccountId, _.pluck(rolesToRemove, "roleId"))
      ])
      .then(function(res) {
        applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', 'success', true);
        $scope.userName = $scope.userDetails.firstName + " " + $scope.userDetails.lastName;
      }, function (err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };

    $scope.deleteUserAccount = function() {
      if (confirm($scope.confirmationToDeleteUser)) {
        dataService.deleteUserAccount($scope.userAccountId).
          then(function(res) {
            applicationContext.setNotificationMsgWithValues('app.DELETED_SUCCESSFULLY', 'success', true);
            $state.go('authenticated.settings.accounts.users.list');
          }, function (err) {
            applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
          });
      }
    };

  }
]);

;
angular.module('emlogis.settings').controller('SettingsAccountsUsersCtrl', ['$scope', '$state', '$http', '$filter', 'applicationContext', 'crudDataService', 'uiGridConstants', 'SettingsAccountsService', 'UtilsService',
  function ($scope, $state, $http, $filter, applicationContext, crudDataService, uiGridConstants, SettingsAccountsService, UtilsService) {
    var entityFilter = applicationContext.getEntityFilter();

    entityFilter.url = 'useraccounts/ops/quicksearch';
    entityFilter.searchFields = 'login,name';
    entityFilter.returnedFields = 'id,name';

    applicationContext.setEntityFilter(entityFilter);

    $scope.entityType = $scope.consts.entityTypes.user;
    $scope.entityName = "settings.accounts.users.NAME";
    $scope.entityListStateName = 'authenticated.settings.accounts.users.list';
    $scope.entityDetailsStateName = 'authenticated.settings.accounts.users.userDetails';
    $scope.entityEditStateName = 'authenticated.settings.accounts.users.userEdit';

    $scope.hasMgmtPermission = function () {
      return $scope.hasPermission('Account_Mgmt');
    };

    $scope.hasViewPermission = function () {
      return $scope.hasPermission('Account_View');
    };

    $scope.hasSupportPermission = function () {
      return $scope.hasPermission('Support');
    };

  }
]);

;
var settings = angular.module('emlogis.settings');

settings.controller('SettingsGeneralBreadcrumbCtrl', ['$scope', '$translate', 'applicationContext',
  function ($scope, $translate, applicationContext) {

  }
]);

;
var settings = angular.module('emlogis.settings');

settings.controller('SettingsGeneralCtrl',
  [
    '$scope',
    '$state',
    '$http',
    '$filter',
    'applicationContext',
    'crudDataService',
    'uiGridConstants',
    function ($scope, $state, $http, $filter, applicationContext, crudDataService, uiGridConstants) {


    }
  ]
);

;
var settings = angular.module('emlogis.settings');

settings.controller('SettingsPasswordPolicyBreadcrumbCtrl', ['$scope', '$translate', 'applicationContext',
  function ($scope, $translate, applicationContext) {

  }
]);

;
var settings = angular.module('emlogis.settings');

settings.controller('SettingsPasswordPolicyCtrl',
  [
    '$scope',
    '$state',
    '$http',
    '$filter',
    'applicationContext',
    'crudDataService',
    'uiGridConstants',
    function ($scope, $state, $http, $filter, applicationContext, crudDataService, uiGridConstants) {


    }
  ]
);

;
angular.module('emlogis.settings').controller('SettingsBreadcrumbCtrl', ['$scope', '$translate', 'applicationContext', 'authService',
  function ($scope, $translate, applicationContext, authService) {
    // Update Module Information
    var module = applicationContext.getModule();

    // Call translate directive function. Put translated text;
    $translate('nav.SETTINGS')
      .then(function (translation) {
        module.name = translation;
      });
    module.href = '/settings';
    module.icoClass = 'glyphicon glyphicon-cog';
    module.disableModuleBreadcrumb = false;
    applicationContext.setModule(module);

    $scope.hasPermissionIn = function (perms) {
      return authService.hasPermissionIn(perms);
    };

    $scope.hasPermission = function (perm) {
      return authService.hasPermission(perm);
    };

  }
]);

;
angular.module('emlogis.settings').controller('SettingsCtrl', ['$scope', '$state', '$http', '$filter', 'applicationContext', 'crudDataService', 'authService',
  function ($scope, $state, $http, $filter, applicationContext, crudDataService, authService) {

    $scope.hasPermissionIn = function (perms) {
      return authService.hasPermissionIn(perms);
    };

    $scope.hasPermission = function (perm) {
      return authService.hasPermission(perm);
    };

    $scope.isTenantType = function (tenantType) {
      return authService.isTenantType(tenantType);
    };
  }
]);

;
(function () {
  "use strict";

  //
  // This directive is build upon
  // Bootstrap component Label (.label)
  //
  // all Tags must have "id" and "name" properties
  // for the current implementation of this directive to work

  var emlObjects = function ($filter) {

    return {
      restrict: 'EA',
      replace: true,
      scope: {
        readonly: '=',
        list: '=list',              // array of entities to display
        view: '&',              // method to show detail of entity from displayed list
        delete: '&',                     // method to remove entity from displayed list
        show: '&'     // method to trigger when Entity is being added to displayed list
      },
      templateUrl: 'modules/settings/partials/include/eml-objects.include.html',
      link: function(scope, element, attrs){
        // console.log('+++ Inside eml-objects directive...');                    // DEV mode

      }
    };
  };
  //
  //
  //tags.$inject = ['$filter'];
  angular.module('emlogis.settings').directive('emlObjects', emlObjects);

}());
;
(function () {
  "use strict";

  //
  // This directive is build upon
  // Bootstrap component Label (.label)
  //
  // all Tags must have "id" and "name" properties
  // for the current implementation of this directive to work

  var emlSitesTeams = function ($filter) {

    return {
      restrict: 'EA',
      replace: true,
      scope: {
        acl: '=acl',// array of entities to display
        show: '&'   // Show the dialog box of site/teams
      },
      templateUrl: 'modules/settings/partials/include/eml-sites-teams.include.html',
      link: function(scope, element, attrs){
        // console.log('+++ Inside eml-objects directive...');                    // DEV mode

        //scope.allTags = scope.tagslist.concat(scope.addtagslist);          // Combine all Tags into one array

        var deleteDuplicatesFromArray = function(arr) {
          var cleaned = [];
          arr.forEach(function(itm) {
            var unique = true;
            cleaned.forEach(function(itm2) {
              if ( _.isEqual(itm, itm2) ) unique = false;
            });
            if (unique) cleaned.push(itm);
          });
          return cleaned;
        };

        //scope.allTags = deleteDuplicatesFromArray(scope.allTags);          // Delete duplicates from array of Tags
        //scope.allTags = $filter('orderBy')(scope.allTags, 'name');         // Rearrange the list ABC order by name prop

        scope.$watch('tagslist', function(newValue) {
          if ( newValue )
            // console.log("~~~ I see a data change in Tags component!");  // DEV mode
            // console.log(scope.addtagslist);                             // DEV mode

            scope.tagslist = $filter('orderBy')(scope.tagslist, 'name');   // Display Tags in ABC order by name prop

            //
            // Check if Tags to display array (tagslist) is the same
            // as array of all potential Tags to add (addtagslist)

            if ( angular.equals(scope.tagslist, scope.addtagslist) ) {     // If arrays are equal, meaning all Tags are displayed
              scope.noMoreTagsToAdd = true;                                // hide "plus" button

            } else {                                                       // If arrays differ,
              scope.dropDownList = [];                                     // create an empty array for Tags to be added, and

              //
              // Filter out already displayed Tags
              // from the array of all Tags that can potentially be added

              scope.dropDownList = scope.allTags.filter(function(newTag){
                return scope.tagslist.filter(function(displayedTag){
                    return displayedTag.id == newTag.id;
                  }).length === 0;
              });

              scope.noMoreTagsToAdd = scope.dropDownList < 1;              // Hide "plus" btn, if dropDown list is empty
            }
          }, true)
        ;
      }
    };
  };
  //
  //
  //tags.$inject = ['$filter'];
  angular.module('emlogis.settings').directive('emlSitesTeams', emlSitesTeams);

}());
;
angular.module('emlogis.settings').directive('entityList', ['$state', '$timeout', 'uiGridConstants','applicationContext',
  function ($state, $timeout, uiGridConstants,applicationContext) {

    return {
      restrict: 'E',
      scope: {
        entityDetails: '=',
        filterTxt: '=',
        getEntityList: '&',
        convertEntityToGridRow: '&'
      },
      controller: function ($scope) {
        function rowTemplate() {
          return '<div ng-dblclick="grid.appScope.viewEntity(row)" ng-repeat="col in colContainer.renderedColumns track by col.colDef.name" class="ui-grid-cell" ui-grid-cell></div>';
        }

        $scope.entityList = [];
        $scope.entityListGridData = [];

        $scope.entityListGridOptions = {
          data: 'entityListGridData',
          rowTemplate: rowTemplate(),
          columnDefs: $scope.entityDetails.entityColumnDefs,
          enableGridMenu: true,
          enablePaginationControls: false
        };

        if ($scope.entityDetails.needPagination) {
          $scope.paginationOptions = {
            pageNumber: 1,
            pageSize: applicationContext.getGridPageItemSize(),
            orderBy: null,
            orderDir: null
          };
          $scope.entityListGridOptions = _.extend($scope.entityListGridOptions, {
//            paginationPageSizes: [25, 50, 75],
            paginationPageSize: applicationContext.getGridPageItemSize(),
            useExternalPagination: true,
            minRowsToShow: applicationContext.getGridPageItemSize(),
            paginationCurrentPage: 1,
            useExternalSorting: true,
            onRegisterApi: function (gridApi) {
              gridApi.core.on.sortChanged($scope, function (grid, sortColumns) {
                $scope.processOnSortChanged(grid, sortColumns);
              });
              gridApi.pagination.on.paginationChanged($scope, function (newPage, pageSize) {
                $scope.processOnPaginationChanged(newPage, pageSize);
              });
            }
          });

          $scope.processOnSortChanged = function (grid, sortColumns) {
            if (sortColumns.length === 0) {
              $scope.paginationOptions.orderBy = null;
              $scope.paginationOptions.orderDir = null;
            } else {
              $scope.paginationOptions.orderBy = sortColumns[0].field;
              if (sortColumns[0].sort.direction === uiGridConstants.ASC) {
                $scope.paginationOptions.orderDir = 'ASC';
              } else if (sortColumns[0].sort.direction === uiGridConstants.DESC) {
                $scope.paginationOptions.orderDir = 'DESC';
              } else {
                $scope.paginationOptions.orderBy = null;
                $scope.paginationOptions.orderDir = null;
              }
            }
            $scope.getEntityList({gridOptions: $scope.entityListGridOptions, paginationOptions: $scope.paginationOptions}).then(function (response) {
              $scope.entityList = response.data;
              $scope.parseEntityListForGrid();
            }, function (err) {
              console.log(err);
              $scope.entityList = [];
              $scope.parseEntityListForGrid();
            });
          };

          $scope.processOnPaginationChanged = function (newPage, pageSize) {
            $scope.paginationOptions.pageNumber = newPage;
            $scope.paginationOptions.pageSize = pageSize;
            $scope.getEntityList({gridOptions: $scope.entityListGridOptions, paginationOptions: $scope.paginationOptions}).then(function (response) {
              $scope.entityList = response.data;
              $scope.parseEntityListForGrid();
            }, function (err) {
              console.log(err);
              $scope.entityList = [];
              $scope.parseEntityListForGrid();
            });
          };
        }

        /**
         * Fired when user dblclick on the grid
         */
        $scope.viewEntity = function(row) {

          $state.go($scope.entityDetails.entityDetailsStateName, {entityId: row.entity.id});
        };

        $scope.initializeEntityList = function() {
          if ($scope.entityDetails.needPagination) {
            $scope.getEntityList({gridOptions: $scope.entityListGridOptions, paginationOptions: $scope.paginationOptions}).then(function (response) {
              $scope.entityList = response.data;
              $scope.parseEntityListForGrid();
            }, function (err) {
              console.log(err);
              $scope.entityList = [];
              $scope.parseEntityListForGrid();
            });
          } else {
            $scope.getEntityList().then(function (response) {
              $scope.entityList = response.data;
              $scope.parseEntityListForGrid();
            }, function (err) {
              console.log(err);
              $scope.entityList = [];
              $scope.parseEntityListForGrid();
            });
          }
        };

        $scope.parseEntityListForGrid = function () {
          $scope.entityListGridData = [];
          angular.forEach($scope.entityList, function (entity) {
            var gridRow = $scope.convertEntityToGridRow({message: entity});

            $scope.entityListGridData.push(gridRow);
          });

          $timeout(function () {
            $('.entity-list').resize();
          }, 0);
        };
      },
      link: function (scope) {
        scope.$watch('filterTxt', function (newValue, oldValue) {
          if (newValue !== oldValue) {
            scope.initializeEntityList();
          }
        });
        scope.initializeEntityList();
      },
      templateUrl: 'modules/settings/partials/include/entity-list.html'
    };
  }
]);

;
angular.module('emlogis.settings').directive('entitySelectionList', ['$timeout', '$modal',
  function ($timeout, $modal) {

    return {
      restrict: 'E',
      scope: {
        originalEntityDetails: '=',
        entityDetails: '=',
        needOperationButtons: '=',
        getEntityList: '&',
        convertEntityToGridRow: '&',
        processSelectedRow: '&',
        addSelectionList: '&',
        removeSelectionList: '&'
      },
      controller: function ($scope) {
        $scope.entityList = [];
        $scope.entityListGridData = [];
        $scope.selectedEntities = [];

        $scope.entityListGridOptions = {
          data: 'entityListGridData',
          enableRowSelection: true,
          enableSelectAll: true,
          multiSelect: true,
          columnDefs: $scope.entityDetails.entityColumnDefs
        };

        if ($scope.entityDetails.needPagination) {
          $scope.paginationOptions = {
            pageNumber: 1,
            pageSize: 25,
            orderBy: null,
            orderDir: null
          };
          $scope.entityListGridOptions = _.extend($scope.entityListGridOptions, {
            paginationPageSizes: [25, 50, 75],
            paginationPageSize: 25,
            useExternalPagination: true,
            useExternalSorting: true,
            onRegisterApi: function (gridApi) {
              gridApi.core.on.sortChanged($scope, function (grid, sortColumns) {
                $scope.processOnSortChanged(grid, sortColumns);
              });
              gridApi.pagination.on.paginationChanged($scope, function (newPage, pageSize) {
                $scope.processOnPaginationChanged(newPage, pageSize);
              });
              gridApi.selection.on.rowSelectionChanged($scope, function (row) {
                if ($scope.needOperationButtons) {
                  $scope.processSelectedRowLocal(row);
                } else {
                  $scope.processSelectedRow({message: row});
                }
              });
              gridApi.selection.on.rowSelectionChangedBatch($scope, function (rows) {
                angular.forEach(rows, function (row) {
                  if ($scope.needOperationButtons) {
                    $scope.processSelectedRowLocal(row);
                  } else {
                    $scope.processSelectedRow({message: row});
                  }
                });
              });
            }
          });
          $scope.processOnSortChanged = function (grid, sortColumns) {
            if (sortColumns.length === 0) {
              $scope.paginationOptions.orderBy = null;
              $scope.paginationOptions.orderDir = null;
            } else {
              $scope.paginationOptions.orderBy = sortColumns[0].field;
              if (sortColumns[0].sort.direction === uiGridConstants.ASC) {
                $scope.paginationOptions.orderDir = 'ASC';
              } else if (sortColumns[0].sort.direction === uiGridConstants.DESC) {
                $scope.paginationOptions.orderDir = 'DESC';
              } else {
                $scope.paginationOptions.orderBy = null;
                $scope.paginationOptions.orderDir = null;
              }
            }
            $scope.getEntityList({gridOptions: $scope.entityListGridOptions, paginationOptions: $scope.paginationOptions}).then(function (response) {
              $scope.entityList = response.data;
              $scope.parseEntityListForGrid();
            }, function (err) {
              console.log(err);
              $scope.entityList = [];
              $scope.parseEntityListForGrid();
            });
          };

          $scope.processOnPaginationChanged = function (newPage, pageSize) {
            $scope.paginationOptions.pageNumber = newPage;
            $scope.paginationOptions.pageSize = pageSize;
            $scope.getEntityList({gridOptions: $scope.entityListGridOptions, paginationOptions: $scope.paginationOptions}).then(function (response) {
              $scope.entityList = response.data;
              $scope.parseEntityListForGrid();
            }, function (err) {
              console.log(err);
              $scope.entityList = [];
              $scope.parseEntityListForGrid();
            });
          };
        } else {
          $scope.entityListGridOptions.onRegisterApi = function (gridApi) {
            gridApi.selection.on.rowSelectionChanged($scope, function (row) {
              if ($scope.needOperationButtons) {
                $scope.processSelectedRowLocal(row);
              } else {
                $scope.processSelectedRow({message: row});
              }
            });

            gridApi.selection.on.rowSelectionChangedBatch($scope, function (rows) {
              angular.forEach(rows, function (row) {
                if ($scope.needOperationButtons) {
                  $scope.processSelectedRowLocal(row);
                } else {
                  $scope.processSelectedRow({message: row});
                }
              });
            });
          };
        }

        $scope.processSelectedRowLocal = function (row) {
          if (row.isSelected) {
            $scope.selectedEntities.push(row.entity);
          } else {
            $scope.selectedEntities = _.filter($scope.selectedEntities, function(entity){ return entity.id !== row.entity.id; });
          }
        };

        $scope.openEntityListSelectionModal = function () {
          var modalInstance = $modal.open({
            templateUrl: 'listModalContent.html',
            controller: 'entitySelectionListModalCtrl',
            size: 'lg',
            resolve: {
              originalEntityDetails: function () {
                return $scope.originalEntityDetails;
              },
              entityDetails: function () {
                return {
                  entityType: $scope.entityDetails.entityType,
                  entitiesName: $scope.entityDetails.tabHeading,
                  needPagination: $scope.entityDetails.needPagination,
                  entityColumnDefs: $scope.entityDetails.entityColumnDefs
                };
              },
              convertEntityToGridRow: function () {
                return $scope.convertEntityToGridRow;
              }
            }
          });

          modalInstance.result.then(function (selectedEntityIds) {
            $scope.addSelectionList({entityDetails: $scope.entityDetails, selectedEntityIds: selectedEntityIds}).then(function (response) {
              $scope.initializeEntityList();
            });
          });
        };

        $scope.removeSelectedEntities = function () {
          $scope.removeSelectionList({entityDetails: $scope.entityDetails, selectedEntities: $scope.selectedEntities}).then(function (response) {
            $scope.initializeEntityList();
          });
        };

        $scope.initializeEntityList = function () {
          if ($scope.entityDetails.needPagination) {
            $scope.getEntityList({gridOptions: $scope.entityListGridOptions, paginationOptions: $scope.paginationOptions}).then(function (response) {
              $scope.entityList = response.data;
              $scope.parseEntityListForGrid();
            }, function (err) {
              console.log(err);
              $scope.entityList = [];
              $scope.parseEntityListForGrid();
            });
          } else {
            $scope.getEntityList().then(function (response) {
              $scope.entityList = response.data;
              $scope.parseEntityListForGrid();
            }, function (err) {
              console.log(err);
              $scope.entityList = [];
              $scope.parseEntityListForGrid();
            });
          }
        };

        $scope.parseEntityListForGrid = function () {
          $scope.entityListGridData = [];
          angular.forEach($scope.entityList, function (entity) {
            var gridRow = $scope.convertEntityToGridRow({message: entity});

            $scope.entityListGridData.push(gridRow);
          });
          $timeout(function () {
            $('.entity-selection-list').resize();
          }, 0);
        };
      },
      link: function (scope) {
        scope.initializeEntityList();
      },
      templateUrl: 'modules/settings/partials/include/entity-selection-list.html'
    };
  }
]);

;
angular.module('emlogis.rules',
  [
    'ui.bootstrap', 'ui.router', 'ui.sortable',
    'ui.grid', 'ui.grid.pagination', 'ui.grid.selection',
    'http-auth-interceptor'])
  .config(
  [
    '$stateProvider',
    '$urlRouterProvider',
    '$locationProvider',
    '$httpProvider',
    '$breadcrumbProvider',
    function ($stateProvider, $urlRouterProvider) {

      // Rules module

      $urlRouterProvider.when('/settings/rules', '/settings/rules/general');
      $urlRouterProvider.when('/settings/rules/', '/settings/rules/general');

      //Admin Role RW, ScheduleCreator & ShiftMngr RO
      function permissionsSettings (authService) {
        return authService.isTenantType('Customer') && authService.hasPermissionIn(
          ['SystemConfiguration_View','SystemConfiguration_Mgmt','Demand_View','Demand_Mgmt','Shift_Mgmt']);
      }

      $stateProvider.state('authenticated.rules', {
        url: '/settings/rules',
        abstract: true,
        views: {
          "content@authenticated": {
            templateUrl: "modules/settings/rules/rules.partial.html",
            controller: 'RulesCtrl'
          },
          "breadcrumb@authenticated": {
            templateUrl: "modules/settings/rules/rules_breadcrumb.partial.html",
            controller: 'RulesBreadcrumbCtrl'
          }
        },
        data: {
          permissions: function (authService) {
            return permissionsSettings(authService);
          }
        },
        resolve: {
          timeZones: function (dataService) {
            return dataService.getTimeZones().then( function(response) {
              return response;
            });
          },
          countriesList: function (emlogisConstants) {
            return emlogisConstants.countries;
          }
        }
      })
        .state('authenticated.rules.general', {                                   // General tab
          url: '/general',
          views: {
            "rulesContent@authenticated.rules": {
              templateUrl: "modules/settings/rules/general/rules_general.partial.html",
              controller: 'RulesGeneralCtrl'
            }
            //"rulesBreadcrumb@authenticated.rules": {
            //    //template: "<p>default breadcrumb</p>"
            //    templateUrl: "modules/rules/general/rules_general_breadcrumb.partial.html"
            //    //controller: "RulesGeneralBreadcrumbCtrl"
            //}
          },
          data: {
            ncyBreadcrumbLabel: '{{"rules.GENERAL" | translate}}'
          }
        })
        .state('authenticated.rules.site_teams', {                                // Site & Teams tab
          url: '/site_teams',
          views: {
            "rulesContent@authenticated.rules": {
              templateUrl: "modules/settings/rules/sites_teams/partials/rules_site_teams.partial.html",
              controller: 'RulesSiteTeamsCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"rules.SITE_TEAMS" | translate}}'
          }
        })
        .state('authenticated.rules.site_teams.new_site', {                                // Site & Teams tab
          url: '/new',
          views: {
            "rulesContent@authenticated.rules": {
              templateUrl: "modules/settings/rules/sites_teams/partials/rules_site_teams_new.partial.html",
              controller: 'RulesSiteNewCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"rules.site_teams.NEW_SITE" | translate}}'
          }
        })
        .state('authenticated.rules.skills', {                                   // Skills tab
          url: '/skills',
          views: {
            "rulesContent@authenticated.rules": {
              templateUrl: "modules/settings/rules/skills/rules_skills.partial.html",
              controller: 'RulesSkillsCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"rules.SKILLS" | translate}}'
          }
        })
        //.state('authenticated.rules.licenses', {                                // Licenses & Certifications tab
        //  url: '/licenses',
        //  views: {
        //    "rulesContent@authenticated.rules": {
        //      templateUrl: "modules/settings/rules/licenses/rules_licenses.partial.html",
        //      controller: 'RulesLicensesCtrl'
        //    }
        //  },
        //  data: {
        //    ncyBreadcrumbLabel: '{{"rules.LICENSES_CERTIFICATIONS" | translate}}'
        //  }
        //})
        .state('authenticated.rules.holidays',{                        // Holidays tab
          url: '/timeoff_holidays',
          views:{
            "rulesContent@authenticated.rules": {
              templateUrl: "modules/settings/rules/holidays/rules_holidays.partial.html",
              controller: 'RulesHolidaysCtrl'
            }
          },
          data: {
            ncyBreadcrumbLabel: '{{"rules.HOLIDAYS" | translate}}'
          }
        })
      ;

    }
  ])
;
;
(function () {
  "use strict";

  var injectParams = [];

  var scheduleSettingsDirective = function () {
    return {
      restrict: 'AE',
      replace: true,
      scope: {
        settingsData: '=',
        modifiedSettingsData: '=',
        isEditing: '=',
        hasPermissions: '=',
        saveClicked: '='
      },
      templateUrl: 'modules/settings/rules/directives/schedule-settings.directive.tmpl.html',
      link: function(scope, element) {
        console.log('   --> in Schedule Settings dir');

        //--------------------------------------------------------------------
        // On load
        //--------------------------------------------------------------------

        var panelsInit = {};

        scope.panels = {
          configuration: {                                           // Site Configuration panel
            title: "rules.general.SITE_CONFIGURATION",
            settings: [
              {
                function: "rules.general.BREAK_SHIFT_MIDNIGHT",
                description: "rules.general.BREAK_SHIFT_MIDNIGHT_DESC"
              },
              {
                function: "rules.general.BREAK_SHIFT_HOURS",
                description: "rules.general.BREAK_SHIFT_HOURS_DESC"
              },
              {
                function: "rules.general.REDUCE_MIN_HOURS_PTO",
                description: "rules.general.REDUCE_MIN_HOURS_PTO_DESC"
              },
              {
                function: "rules.general.ALLOW_CHAIN_TEAMS",
                description: "rules.general.ALLOW_CHAIN_TEAMS_DESC"
              },
              {
                function: "rules.general.ALLOW_CHAIN_SKILLS",
                description: "rules.general.ALLOW_CHAIN_SKILLS_DESC"
              },
              {
                function: "rules.general.ALLOW_CHAIN_MIDNIGHT",
                description: "rules.general.ALLOW_CHAIN_MIDNIGHT_DESC"
              },
              {
                function: "rules.general.FORCE_COMPLETION",
                description: "rules.general.FORCE_COMPLETION_DESC"
              }
            ],
            setConsecutiveLimit: {
              options: [-1, 1, 2, 3, 4, 5, 6, 7],
              function: "rules.general.CONSECUTIVE_LIMIT",
              description: "rules.general.CONSECUTIVE_LIMIT_DESC"
            },
            setProfileDayType: {
              function: "rules.general.PROFILE_DAY_TYPE",
              description: "rules.general.PROFILE_DAY_TYPE_DESC",
              options: ["DayShiftEnds", "DayShiftStarts", "ShiftMajority"]
            }
          },
          optimization: {                                            // Site Optimization panel
            title: "rules.general.SITE_OPTIMIZATION",
            settings: []
          }
        };



        //--------------------------------------------------------------------
        // Watch for
        //--------------------------------------------------------------------

        //
        // Settings data changed

        scope.$watch("settingsData", function(newSettings) {
          if (newSettings && !_.isEmpty(newSettings)) {
            preparePanelsToDisplay(newSettings);
            console.log('   --> in Schedule Settings dir', scope.panels);
            console.log('   --> if hasPermissions', scope.hasPermissions);
          }
        });


        //
        // Save btn clicked

        scope.$watch("saveClicked", function(saveClicked) {
          console.log('   --> saveClicked', scope.saveClicked);
          if (saveClicked === true) {
            scope.modifiedSettingsData = preparePanelsToSave(scope.panels);
          }
        });



        //--------------------------------------------------------------------
        // Other related methods
        //--------------------------------------------------------------------

        //
        // Update Editing status

        scope.updateEditing = function() {
          scope.isEditing = !angular.equals(panelsInit, scope.panels);
          console.log('   ---> updateEditing:', scope.isEditing);
        };


        //
        // Prepare Panels to display

        var preparePanelsToDisplay = function(data){
          console.log('   --> in preparePanelsToDisplay', data);

          // Set Site Configuration settings
          scope.panels.configuration.settings[0].value = data.breakShiftAtMidnightForDisplay;
          scope.panels.configuration.settings[1].value = data.breakShiftAtMidnightForHours;
          scope.panels.configuration.settings[2].value = data.reduceMaximumHoursForPTO;
          scope.panels.configuration.settings[3].value = data.allowChainingAccrossTeams;
          scope.panels.configuration.settings[4].value = data.allowChainingAccrossSkills;
          scope.panels.configuration.settings[5].value = data.allowChainingAccrossMidnight;
          scope.panels.configuration.settings[6].value = data.forceCompletion;

          scope.panels.configuration.setConsecutiveLimit.value = data.consecutiveLimitOf12hoursDays;    // digit
          scope.panels.configuration.setProfileDayType.value = data.profileDayType;                     // string


          // Set Site Optimization settings
          scope.panels.optimization.settings = [];

          for (var i = 0; i < data.optimizationSettings.length; i++) {                      // # of settings - not all?
            scope.panels.optimization.settings.push( {} );
            scope.panels.optimization.settings[i].value = data.optimizationSettings[i].value;
            scope.panels.optimization.settings[i].type = data.optimizationSettings[i].type;
            scope.panels.optimization.settings[i].name = data.optimizationSettings[i].name;

            scope.panels.optimization.settings[i].function = 'rules.general.' + data.optimizationSettings[i].name;
            scope.panels.optimization.settings[i].description = 'rules.general.' + data.optimizationSettings[i].name + '_DESC';

            if ( data.optimizationSettings[i].name === 'OptimizationPreference' ) {
              scope.panels.optimization.settings[i].options = ["None", "COP", "CPO", "OCP", "OPC", "PCO", "POC"];
            }
          }
          //console.log(scope.panels.optimization);
          panelsInit = angular.copy(scope.panels);                                          // save initial Settings
        };


        //
        // preparePanelsToSave

        var preparePanelsToSave = function(panels) {
          // Prepare Site Configuration settings
          var newScheduleSettings = { override: true };

          newScheduleSettings.breakShiftAtMidnightForDisplay = panels.configuration.settings[0].value;
          newScheduleSettings.breakShiftAtMidnightForHours = panels.configuration.settings[1].value;
          newScheduleSettings.reduceMaximumHoursForPTO = panels.configuration.settings[2].value;
          newScheduleSettings.allowChainingAccrossTeams = panels.configuration.settings[3].value;
          newScheduleSettings.allowChainingAccrossSkills = panels.configuration.settings[4].value;
          newScheduleSettings.allowChainingAccrossMidnight = panels.configuration.settings[5].value;
          newScheduleSettings.forceCompletion = panels.configuration.settings[6].value;
          newScheduleSettings.consecutiveLimitOf12hoursDays = panels.configuration.setConsecutiveLimit.value;    // digit
          newScheduleSettings.profileDayType = panels.configuration.setProfileDayType.value;                     // string


          // Prepare Site Optimization settings
          newScheduleSettings.optimizationSettings = [];

          for (var i = 0; i < panels.optimization.settings.length; i++) {
            newScheduleSettings.optimizationSettings.push( {} );
            newScheduleSettings.optimizationSettings[i] = {
              "type" : panels.optimization.settings[i].type,
              "name" : panels.optimization.settings[i].name,
              "value": panels.optimization.settings[i].value
            };
          }

          return newScheduleSettings;
        };



        //--------------------------------------------------------------------
        // UI
        //--------------------------------------------------------------------

        //
        // Sortable options
        // for drag-n-drop behavior in Optimization Settings table
        // Dependency: Angular UI Sortable

        scope.sortableOptions = {
          update: function() {
            console.log('   ---> sortableOptions upd:', scope.panels);
            scope.updateEditing(); // angular.equal doesn't evaluate 1st sortable event TODO
          },
          sort: function(e) {
            if (!scope.hasPermissions) {
              return false;
            }
          },
          axis: 'y',
          containment: 'parent',
          delay: 150,
          revert: true
        };

      }
    };
  };


  scheduleSettingsDirective.$inject = injectParams;
  angular.module('emlogis.rules').directive('schedsettings', scheduleSettingsDirective);

}());
;
(function () {
  "use strict";

  var rules = angular.module('emlogis.rules');

  rules.controller('RulesEmlogisUsersCtrl', ['$scope', 'applicationContext',
    function ($scope, applicationContext) {
    console.log('inside Rules Emlogis Users controller');

    $scope.page.editing = false;
    $scope.page.submitted = false;


    //--------------------------------------------------------------------
    // Setup Working for this page
    //--------------------------------------------------------------------

    var working = applicationContext.getWorking();

    working.entityName = 'rules.EMLOGIS_USERS';
    working.option = $scope.page;
    working.saveFunc = $scope.save;
    //working.restoreFunc = restoreOriginalSchedule;

  }]);
})();

;
(function () {
  "use strict";

  var rules = angular.module('emlogis.rules');

  rules.controller('RulesGeneralCtrl',
    ['$scope', '$http', '$q', 'rulesGeneralFactory', 'dataService', 'applicationContext',
    function ($scope, $http, $q, rulesGeneralFactory, dataService, applicationContext) {

      //--------------------------------------------------------------------
      // Defaults for General tab
      //--------------------------------------------------------------------

      $scope.page.editing = false;
      $scope.page.submitted = false;
      $scope.updatesCounter = 0;
      $scope.hasMgmtPerm = $scope.hasMgmtPermission();

      var schedSetInit, orgInit;

      $scope.org = {};
      $scope.schedSet = {};
      $scope.schedSetModified = {};
      $scope.saveClicked = false;


      $scope.$watch("schedSetModified", function(modifiedSettings) {
        if (modifiedSettings && !_.isEmpty(modifiedSettings)) {
          $scope.updateOrgSettings(modifiedSettings);
        }
      });


      // Prepare Address panel

      $scope.panels = {
        general: {
          title: "rules.general.GENERAL",
          countries: $scope.countriesList
        }
      };



      //--------------------------------------------------------------------
      // Load Org data
      //--------------------------------------------------------------------

      //
      // GET Scheduling Settings
      // for Org-level

      var getSchedulingSettings = function () {
        return rulesGeneralFactory.getSchedulingSettings().then( function (res) {
          schedSetInit = res.data;
          $scope.schedSet = angular.copy(schedSetInit);
        });
      };


      //
      // GET Organization Details

      var getOrgDetails = function () {
        return dataService.getOrgDetails()
          .then(function (res) {
            orgInit = res;
            $scope.org = angular.copy(orgInit);
          })
        ;
      };

      getSchedulingSettings();
      getOrgDetails();




      //--------------------------------------------------------------------
      // CRUD
      //--------------------------------------------------------------------

      //
      // UPDATE Org level settings

      $scope.updateOrgSettings = function(dto){

        if ($scope.scheduleSettingsForm.$valid) {
          var deferred = $q.defer();
          $scope.updatesCounter = 0;

          //
          // Check if Scheduling Settings have been changed.
          // If yes - update Scheduling Settings

          if ( !angular.equals($scope.schedSetModified, schedSetInit) ) {
            $scope.updatesCounter++;
            updateSchedulingSettings(dto).then( function(){ $scope.updatesCounter--; });
          }

          //
          // Check if Address details have been changed.
          // If yes - update Scheduling Settings

          if ( !angular.equals($scope.org, orgInit) ){
            $scope.updatesCounter++;
            updateOrgAddress().then( function(){ $scope.updatesCounter--; });
          }

          //
          // Wait for both API calls to be resolved,
          // then update page options
          // and resolve promise

          var removeThisWatcher = $scope.$watch("updatesCounter", function(newVal, oldVal) {
            if (newVal === 0 && oldVal === 1) {
              $scope.page.editing = false;
              $scope.page.submitted = false;
              $scope.saveClicked = false;
              applicationContext.setNotificationMsgWithValues('app.SAVED_SUCCESSFULLY', 'success', true);
              deferred.resolve();

              removeThisWatcher();                                           // remove this $watch
            }
          });

          return deferred.promise;
        }
      };



      //
      // UPDATE Scheduling settings on Org level

      var updateSchedulingSettings = function(dto){
        var deferred = $q.defer();

        dataService.updScheduleSettings(dto).then( function(res){
          getSchedulingSettings();
          deferred.resolve('SUCCESS');

        }, function(err) {
          applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
          deferred.resolve('ERROR');
        });

        return deferred.promise;
      };



      //
      // UPDATE Address details on Org level

      var updateOrgAddress = function(){
        var deferred = $q.defer();

        var newAddress = {
          "name"             : $scope.org.name,
          "description"      : $scope.org.description,
          "inactivityPeriod" : $scope.org.inactivityPeriod,
          "address"          : $scope.org.address,
          "address2"         : $scope.org.address2,
          "city"             : $scope.org.city,
          "country"          : $scope.org.country,
          "geo"              : $scope.org.geo,
          "state"            : $scope.org.state,
          "timeZone"         : $scope.org.timeZone,
          "zip"              : $scope.org.zip
        };

        //
        // Update Org details

        dataService.updOrgDetails(newAddress).then( function(res) {
          $scope.scheduleSettingsForm.$setPristine(true);
          getOrgDetails();
          deferred.resolve('SUCCESS');

        }, function(err) {
          applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
          deferred.resolve('ERROR');
        });

        return deferred.promise;
      };



      //--------------------------------------------------------------------
      // Other methods
      //--------------------------------------------------------------------



      $scope.clickSave = function() {
        $scope.saveClicked = true;
      };



      //
      // Register call back function,
      // for confirmation Dialog & Save btn in Notification

      var working = applicationContext.getWorking();

      working.entityName = 'rules.GENERAL';
      working.option = $scope.page;
      working.saveFunc = $scope.updateOrgSettings;
      //working.restoreFunc = restoreOriginalSchedule;
    }
  ]);
})();
;
(function () {
  "use strict";
  //console.log('+++ fire Rules factory');

  var rulesGeneralFactory = function ($http, $q, applicationContext) {
    //console.log('creating rulesGeneralFactory...');

    var baseUrl = applicationContext.getBaseRestUrl();

    return {
      getSchedulingSettings: function () {
        return $http.get(baseUrl + 'org/schedulingsettings')
          .then(function (response) {
            return response;
          });
      },

      putSchedulingSettings: function (obj) {
        return $http.put(baseUrl + 'org/schedulingsettings')
          .then(function (response) {
            return response;
          })
        ;
      }
    };
  };

  rulesGeneralFactory.$inject = ['$http', '$q', 'applicationContext'];
  angular.module('emlogis.rules').factory('rulesGeneralFactory', rulesGeneralFactory);


})();
;
angular.module('emlogis.rules')
    .controller('RulesHolidaysCtrl', ['$scope', '$state', '$q', 'appFunc', 'crudDataService', 'dataService', 'dialogs', 'applicationContext',
    function($scope, $state, $q, appFunc, crudDataService, dataService, dialogs, applicationContext) {
      $scope.holidays = [];
      $scope.organization = null;
      $scope.year = moment().year();
      $scope.duplicateHolidays = {
        toYear: $scope.year + 1,
        showControl: false
      };

      var originalHolidays = null;

      $scope.minToYear = function() {
        return $scope.year + 1;
      };

      $scope.$watch("year", function(year) {
        $scope.duplicateHolidays.toYear = $scope.minToYear();
      });

      $scope.filterHolidaysByYear = function(holidays, year) {
        return _.filter(holidays, function(h) {
          var hYear = moment(h.effectiveStartDate).year();
          return hYear == year;
        });
      };

      $scope.addRowForNewHoliday = function() {

        var hasNewHoliday = _.find($scope.holidays, function(h) {
          return h.id === undefined;
        });

        // do not add new row if there is one already
        if (hasNewHoliday) return;

        var startOfYear = moment().year($scope.year),
            newHoliday = {
              name: null,
              description: null,
              effectiveStartDate: startOfYear.valueOf(),
              inEditMode: true
            },

            firstHolidayOfYear = _.findIndex($scope.holidays, function(h) {
              return moment(h.effectiveStartDate).year() == $scope.year;
            });

        // insert a new holiday row before first holiday of year
        $scope.holidays.splice(firstHolidayOfYear, 0, newHoliday);
      };

      $scope.showDuplicateControl = function() {
        $scope.duplicateHolidays.toYear = $scope.year + 1;
        $scope.duplicateHolidays.showControl = true;
      };

      $scope.saveHoliday = function(hObj) {
        if (!$scope.validHoliday(hObj)) {
          return $q.reject({});
        } else if (hObj.id) {
          return updateHoliday(hObj);
        } else {
          return createHoliday(hObj);
        }
      };

      $scope.validHoliday = function(hObj) {
        var validDate = hObj.calendarDate && moment(hObj.calendarDate).isValid();
        return (validDate && hObj.name);
      };

      function updateHoliday(hObj) {
        var date = moment(hObj.calendarDate).toDate(),

        startDate = appFunc.getDateWithTimezone(
                date.getFullYear(),
                date.getMonth(),
                date.getDate(),
                $scope.organization.timeZone
            ),
            endDate = moment(startDate.getTime()).add(1, 'days');

        return dataService.updateHoliday(hObj.id, {
          "name": hObj.name,
          "description": hObj.description,
          "effectiveStartDate": startDate.getTime(),
          "effectiveEndDate": endDate.valueOf()
        }).
        then(function(res) {
          applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', 'success', true);
          hObj.effectiveStartDate = appFunc.convertToBrowserTimezone(res.data.effectiveStartDate, $scope.organization.timeZone);
          hObj.inEditMode = false;
          sortAndBackUpHolidays();
        },
        function (err) {
          applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
        });
      }

      function createHoliday(hObj) {
        var startDate = appFunc.getDateWithTimezone(
                hObj.calendarDate.getFullYear(),
                hObj.calendarDate.getMonth(),
                hObj.calendarDate.getDate(),
                $scope.organization.timeZone
            ),
            endDate = moment(startDate.getTime()).add(1, 'days');

        return dataService.createHoliday({
          name: hObj.name,
          updateDto: {
            description: hObj.description,
            effectiveStartDate: startDate.getTime(),
            effectiveEndDate: endDate.valueOf()
          }
        })
        .then(function(res) {
          applicationContext.setNotificationMsgWithValues('app.CREATED_SUCCESSFULLY', 'success', true);
          hObj.id = res.data.id;
          hObj.effectiveStartDate = appFunc.convertToBrowserTimezone(res.data.effectiveStartDate, $scope.organization.timeZone);
          hObj.inEditMode = false;
          sortAndBackUpHolidays();
        },
        function (err) {
          applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
        });
      }

      $scope.deleteHoliday = function(hObj) {
        if (!hObj.id) {
          removeNewHolidays();
          return;
        }

        var confirm = dialogs.confirm('app.PLEASE_CONFIRM', 'rules.holidays.ARE_YOU_SURE_REMOVE_HOLIDAY?');

        confirm.result.then(function (btn) {
          dataService.deleteHoliday(hObj.id)
              .then(function (res) {
                applicationContext.setNotificationMsgWithValues('app.DELETED_SUCCESSFULLY', 'success', true);
                $scope.holidays = _.reject($scope.holidays, function(h) {
                  return h.id === hObj.id;
                });
                originalHolidays = _.cloneDeep($scope.holidays);
              },
              function (err) {
                applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
              });
        }, function (btn) {
          // no pressed. Do nothing
        });
      };

      // remove holidays which were not send to server
      function removeNewHolidays() {
        $scope.holidays = _.reject($scope.holidays, function(h) {
          return h.id === undefined;
        });
      }

      $scope.duplicateYear = function(fromYear, toYear) {
        dataService.duplicateYear(fromYear, toYear)
            .then(function(res) {
              applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', 'success', true);
              $scope.year = toYear;
              $scope.duplicateHolidays.toYear = toYear + 1;
              $scope.duplicateHolidays.showControl = false;
              getHolidays();
            },
            function (err) {
              applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
            });
      };

      //
      // Switch to/from edit holiday mode
      $scope.edit = function(hObj, edit) {
        // cancel changes if pressed Esc while editing
        if (!edit) {
          resetHoliday(hObj);
        } else {
          var originalHoliday = _.find(originalHolidays, 'id', hObj.id);
          hObj.calendarDate = originalHoliday.calendarDate = toCalendarDateFormat(hObj.effectiveStartDate);
        }
        hObj.inEditMode = edit;
      };

      function resetHoliday(hObj) {
        // if canceled editing a new holiday - remove it from table
        if (!hObj.id) {
          removeNewHolidays();
          return;
        }

        //if canceled editing an existing holiday - restore it to previous state
        var originalHoliday = _.clone(_.find(originalHolidays, function(h) {
          return hObj.id == h.id;
        }));

        // replace holiday object with original one
        $scope.holidays = _.map($scope.holidays, function(h) {
          return (h.id === hObj.id) ? originalHoliday : h;
        });
      }

      $scope.toCellDateFormat = function(date) {
          return moment(date).format("MMM DD, dddd");
      };

      $scope.cellDate = function(date) {
        return moment(date).format("MMM DD");
      };

      $scope.cellDaYOfWeek = function(date) {
        return moment(date).format("dddd YYYY");
      };

      function toCalendarDateFormat(date) {
        return moment(date).format("MM/DD/YY");
      }

      // open calendar control
      $scope.open = function($event, hObj) {
        $event.preventDefault();
        $event.stopPropagation();
        hObj.opened = true;
      };

      function sortAndBackUpHolidays() {
        /**
         * sort by start date
         */
        $scope.holidays = _.sortBy($scope.holidays, function(h) {
          return h.effectiveStartDate;
        });
        /**
         * create a copy of holidays object to be able cancel editing
         */
        originalHolidays = _.cloneDeep($scope.holidays);
      }

      function getHolidays() {
        dataService.getHolidays()
            .then(function (res) {
              $scope.holidays = _.sortBy(res.data.result, function(h) {
                return h.effectiveStartDate;
              });
              // GET Current organization details
              return $scope.organization || crudDataService.getElement('org', '');
            })
            .then(function(res) {
              $scope.organization = res;
              /**
               * convert startDate to browser's time stack,
               * set display mode to read
               */
              angular.forEach($scope.holidays, function(h) {
                h.effectiveStartDate = appFunc.convertToBrowserTimezone(h.effectiveStartDate, $scope.organization.timeZone);
                h.inEditMode = false;
              });
              originalHolidays = _.cloneDeep($scope.holidays);
            });
      }

      getHolidays();

      //--------------------------------------------------------------------
      // Setup a window for asking to save the changes
      //--------------------------------------------------------------------

      var working = applicationContext.getWorking();

      working.entityName = 'rules.HOLIDAYS';
      working.option = {
        editing: false,
        submitted: false
      };
      working.saveFunc = function() {
        var promises = [];
        working.option.editing = false;

        _.each($scope.unsavedHolidays, function(h) {
          promises.push($scope.saveHoliday(h));
        });

        return $q.all(promises);
      };


      function holidaysAreEqual(h1, h2) {
        var areEqual = true,
          propertiesToCheck = ['name', 'description', 'calendarDate']; // 'effectiveStartDate'
        _.each(propertiesToCheck, function(prop) {
          if (!_.isEqual(h1[prop], h2[prop])) {
            areEqual = false;
          }
        });
        return areEqual;
      }


      $scope.$watch('holidays', function(holidays) {
        $scope.unsavedHolidays = [];
        working.option.editing = false;
        _.each(holidays, function(h) {
          var originalHoliday = _.find(originalHolidays, 'id', h.id);

          if (h && originalHoliday && !holidaysAreEqual(h, originalHoliday)) {
            $scope.unsavedHolidays.push(h);
            working.option.editing = true;
          }

        });
      }, true);

}]);

;
(function () {
  "use strict";

  var rules = angular.module('emlogis.rules');

  rules.controller('RulesLicensesCtrl', ['$scope', 'applicationContext',
    function ($scope, applicationContext) {
    console.log('+++ inside Rules Licenses & Certifications controller');

    $scope.page.editing = false;
    $scope.page.submitted = false;


    //--------------------------------------------------------------------
    // Setup Working for this page
    //--------------------------------------------------------------------

    var working = applicationContext.getWorking();

    working.entityName = 'rules.LICENSES_CERTIFICATIONS';
    working.option = $scope.page;
    working.saveFunc = $scope.save;
    //working.restoreFunc = restoreOriginalSchedule;

  }]);
})();
;
var rules = angular.module('emlogis.rules');

rules.controller('RulesBreadcrumbCtrl', ['$scope', '$translate', 'applicationContext',
    function($scope, $translate, applicationContext) {
        //console.log('inside Rules breadcrumbs controller');

        // Update Module Information
        var module = applicationContext.getModule();

        // Call translate directive function. Put translated text;
        $translate('nav.RULES')
            .then(function (translation) {
                module.name =  translation;
            });


        module.href = '/settings/rules/general';
        module.icoClass = 'fa fa-cogs';
        module.disableModuleBreadcrumb = false;
        applicationContext.setModule(module);

    }
]);
;
(function () {
  "use strict";

  var rules = angular.module('emlogis.rules');

  rules.controller('RulesCtrl', ['$scope', 'applicationContext', 'timeZones', 'authService', 'countriesList',
    function ($scope, applicationContext, timeZones, authService, countriesList) {

      // Countries list
      $scope.countriesList = countriesList;

      //--------------------------------------------------------------------
      // Defaults for Rules module
      //--------------------------------------------------------------------

      $scope.tabs = [
        {heading: "rules.GENERAL", route: 'authenticated.rules.general'},
        {heading: "rules.SITE_TEAMS", route: 'authenticated.rules.site_teams'},
        {heading: "rules.SKILLS", route: 'authenticated.rules.skills'},
        //{heading: "rules.LICENSES_CERTIFICATIONS", route: 'authenticated.rules.licenses'},
        {heading: "rules.HOLIDAYS", route: 'authenticated.rules.holidays'}
      ];

      $scope.timeZones = timeZones;
      $scope.username = applicationContext.getUsername();
      $scope.msg = applicationContext.getNotificationMsg();

      $scope.page = {
        editing: false,
        submitted: false
      };


      //--------------------------------------------------------------------
      // Update editing status
      //--------------------------------------------------------------------

      $scope.updateEditing = function () {
        console.log('updateEditing triggered, editing is ', $scope.page.editing);
        if ($scope.page.editing !== true) {
          $scope.page.editing = true;
          applicationContext.setNotificationMsgWithValues('Don\'t forget to save your changes', 'save', true, $scope.username);
        }
      };

      //check next permissions for save,update operations
      $scope.hasMgmtPermission = function () {
        return authService.hasPermission(['SystemConfiguration_Mgmt','Demand_Mgmt']);
      };
    }]);


  //--------------------------------------------------------------------
  // Custom filters for Rules module
  //--------------------------------------------------------------------

  rules.filter('addDaysToTranslate', function () {
    return function (number) {
      return number + "_DAYS";
    };
  });

  rules.filter('addMinutesToTranslate', function () {
    return function (number) {
      return number + "_MINUTES";
    };
  });

  rules.filter('toTranslate', function () {
    return function (val, transaltePath) {
      return transaltePath + val;
    };
  });

  rules.filter('hideMinus', function () {
    return function (number) {
      return number > -1 ? number : '';
    };
  });

  // Shift Lengths

  rules.filter('displayAsHoursMinutes', function () {
    return function (minutes) {
      var hours = Math.floor(minutes / 60);
      var mins = minutes % 60;
      return hours + 'h ' + (mins === 0 ? '' : mins + 'm');
    };
  });

  rules.filter('displayAsHMM', function () {
    return function (minutes) {
      var hours = Math.floor(minutes / 60);
      var mins = minutes % 60 + '';
      return hours + ':' + (mins.length < 2 ? '0' + mins : mins);
    };
  });

  rules.filter('filterOutHour', function () {
    return function (input, hour) {
      var newList = [];
      angular.forEach(input, function (length) {
        if (length.fullHours === hour) {
          newList.push(length);
        }
      });
      return newList;
    };
  });

  rules.filter('minsToHours', function () {
    return function (minutes) {
      return minutes > 0 ? Math.floor(minutes / 60) : minutes;
    };
  });

  rules.filter('minsToHoursFloat', function () {
    return function (minutes) {
      return minutes > 0 ? minutes / 60 : minutes;
    };
  });

  rules.filter('hoursToMins', function () {
    return function (hours) {
      return hours > 0 ? hours * 60 : hours;
    };
  });

  // Shift Types

  rules.filter('milisecondsToTime', function () {
    return function (milliseconds) {
      return moment().startOf('day').add(milliseconds, 'milliseconds').format('h:mm a');
    };
  });

  rules.filter('startTimeToEndTime', function (milisecondsToTimeFilter) {
    return function (startTimeMs, shiftLengthLengthInMin) {
      // Convert and calculate End Time in ms
      var endTimeMs = shiftLengthLengthInMin * 60 * 1000 + startTimeMs;

      // If End Time overlaps midnight
      var midnightMs = 24 * 60 * 60 * 1000;
      var endTimeMsCalc = endTimeMs >= midnightMs ? endTimeMs - midnightMs : endTimeMs;

      // Format it as 'h:mm a'
      var formatted = milisecondsToTimeFilter(endTimeMsCalc);
      var arr = formatted.split(' ');

      // If End Time overlaps midnight - add '+'
      return endTimeMs >= midnightMs ? arr.join('+ ') : arr.join(' ');
    };
  });

  // for adding a new custom Type using momentJS

  rules.filter('startTimeToEndTimeMoment', function () {
    return function (startDate, shiftLengthLength) {
      return moment(startDate).add(shiftLengthLength, 'm').format('HH:mm');
    };
  });

  rules.filter('startTimeMomentFormat', function () {
    return function (startDate) {
      return moment(startDate).format('HH:mm');
    };
  });

})();
;
(function () {
  "use strict";

  var rules = angular.module('emlogis.rules');

  rules.controller('RulesAbsenceTypesCtrl', ['$scope', '$filter', 'applicationContext', 'rulesAbsTypesService',
    function ($scope, $filter, applicationContext, rulesAbsTypesService) {


      //--------------------------------------------------------------------
      // On page load
      //--------------------------------------------------------------------

      var abs = this;
      abs.typesInit = [];
      abs.types = [];

      abs.site = {};
      abs.totalTypes = 0;
      abs.numOfRows = 20;
      abs.paginationCurrentPage = 1;


      $scope.$watch("selectedSite", function(newSite) {
        if (newSite) {
          abs.site = newSite;
          abs.getAbsenceTypes(newSite.id);
        }
      });


      abs.getAbsenceTypes = function(siteId){
        return rulesAbsTypesService.getAbsenceTypes(siteId, abs.paginationCurrentPage, abs.numOfRows).then(function(res){
          updateTypesModel(res);
        });
      };


      var updateTypesModel = function(res){
        abs.types = res.data;
        _.forEach(abs.types, function(type){
          type.isSubmitted = false;
        });
        abs.totalTypes = res.total;
        abs.paginationCurrentPage = res.pageNum;
        console.log('updateTypesModel', abs.types);
      };


      //--------------------------------------------------------------------
      // CRUD
      //--------------------------------------------------------------------


      //
      // Switch to/from Type editing

      abs.editType = function(type) {
        if (!type.isEditing) type.isEditing = true;
      };



      //
      // Add New Type to a table

      abs.addNewType = function() {
        var newType = {
          siteId: abs.site.id,
          name: '',
          description: '',
          timeToDeductInMin: $filter('minsToHours')(480),
          active: true,
          isEditing: true,
          isCreating: true
        };
        abs.types.unshift(newType);
      };



      //
      // Check if New Type is being already created

      abs.newTypeIsCreating = function() {
        return _.find(abs.types, {isCreating: true});
      };



      //
      // Save clicked

      abs.save = function(type) {
        return type.isCreating ? abs.saveNewType(type) : abs.saveType(type);
      };



      //
      // Create a New Type

      abs.saveNewType = function(type) {
        var dto = {
          name: type.name,
          description: type.description,
          timeToDeductInMin: $filter('hoursToMins')(type.timeToDeductInMin),
          active: type.active
        };

        return rulesAbsTypesService.addAbsenceType(type.siteId, dto).then(function(res){
          updateTypesModel(res);
        });
      };



      //
      // Delete a Type TODO: if isDeletable prop added

      abs.deleteType = function(type){
        return rulesAbsTypesService.deleteAbsenceType(type.siteId, type.id).then(function(res){
          updateTypesModel(res);
        });
      };



      //
      // Update a Type

      abs.saveType = function(type){
        var dto = {
          name: type.name,
          description: type.description,
          timeToDeductInMin: $filter('hoursToMins')(type.timeToDeductInMin),
          active: type.active
        };

        return rulesAbsTypesService.updateAbsenceType(type.siteId, type.id, dto).then(function(res){
          updateTypesModel(res);
        });
      };


    }]);
})();
;
var rules = angular.module('emlogis.rules');

rules.controller('RulesSiteTeamsBreadcrumbCtrl', ['$scope', '$translate', 'applicationContext',
    function($scope, $translate, applicationContext) {

        //console.log('inside Rules Site / Teams breadcrumbs controller');

    }
]);
;
(function () {
  "use strict";

  var rules = angular.module('emlogis.rules');

  rules.controller('RulesOverwriteOrgCtrl', ['$scope', 'dataService', 'applicationContext',
    function ($scope, dataService, applicationContext) {

      console.log('   +++ in SiteSchedulingSettings');


      //--------------------------------------------------------------------
      // On page load
      //--------------------------------------------------------------------

      var schedSetInit,
          over = this;

      over.site = {};
      over.schedSet = {};
      $scope.schedSetModified = {};
      over.hasMgmtPermission = false;
      over.isEditing = false;
      over.saveClicked = false;



      $scope.$watch("selectedSite", function(newSite) {
        if (newSite) {
          over.site = newSite;
          over.getSiteSchedulingSettings(newSite.id);
          over.hasMgmtPermission = $scope.hasMgmtPermission();
        }
      });


      $scope.$watch("schedSetModified", function(modifiedSettings) {
        if (modifiedSettings && !_.isEmpty(modifiedSettings)) {
          console.log('   +++ modifiedSettings', modifiedSettings);
          over.updSiteSchedulingSettings(modifiedSettings);
        }
      });


      //--------------------------------------------------------------------
      // CRUD
      //--------------------------------------------------------------------

      //
      // Update Site Scheduling Settings

      over.updSiteSchedulingSettings = function(dto) {
        console.log('   +++ updSiteSchedulingSettings: new schedSetModified', dto);
        return dataService.updateSiteSchedulingSettings(over.site.id, dto).then( function(res) {
          updateSiteSchedulingSettingsModel(res.data);
          applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', 'success', true);

        }, function (err) {
          applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
        });
      };



      //
      // Reset Site level settings to org level

      over.resetToOrgLevel = function() {
        console.log('   +++ reset SiteSchedulingSettings');
        return dataService.deleteSiteSchedulingSettings(over.site.id).then( function(res) {
          updateSiteSchedulingSettingsModel(res.data);
          applicationContext.setNotificationMsgWithValues('app.RESET_SUCCESSFULLY', 'success', true);

        }, function (err) {
          applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
        });
      };




      //--------------------------------------------------------------------
      // Other related methods
      //--------------------------------------------------------------------

      //
      // Get Site Scheduling Settings

      over.getSiteSchedulingSettings = function(siteId) {
        return dataService.getSiteSchedulingSettings(siteId).then(function(res) {
          updateSiteSchedulingSettingsModel(res.data);
        }, function (err) {
          applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
        });
      };


      //
      // Update Site Scheduling Settings model

      var updateSiteSchedulingSettingsModel = function(settings){
        schedSetInit = settings;
        over.schedSet = angular.copy(schedSetInit);
        console.log('   +++ over.schedSet updated', over.schedSet);
        over.isEditing = false;
        over.saveClicked = false;
      };

    }]);
})();
;
(function () {
  "use strict";

  var rules = angular.module('emlogis.rules');

  rules.controller('RulesShiftsCtrl', ['$scope', '$filter', '$modal', '$timeout', '$document', 'applicationContext', 'rulesShiftLTService',
    function ($scope, $filter, $modal, $timeout, $document, applicationContext, rulesShiftLTService) {


      //--------------------------------------------------------------------
      // On page load
      //--------------------------------------------------------------------

      var shiftLengthsInit,
          shiftTypesInit,
          selectedTypeInit,
          shift = this;

      shift.site = {};

      // Shift Lengths
      shift.lengths = [];
      shift.fullHoursList = [];
      shift.isLengthsEditing = false;
      shift.selectedLength = null;

      // Shift Types
      shift.types = [];
      shift.wereTypesEdited = false;
      shift.customShiftType = null;

      // Selected Type to Edit
      shift.selectedType = null;
      shift.isTypeEdited = false;


      // watch for Site being changed
      $scope.$watch("selectedSite", function(newSite) {
        if (newSite) {
          shift.site = newSite;
          shift.getShiftLengths(newSite.id);
        }
      });



      //--------------------------------------------------------------------
      // Shift Lengths
      //--------------------------------------------------------------------

      shift.getShiftLengths = function(siteId){
        return rulesShiftLTService.getShiftLengths(siteId).then(function(lengths){
          updateShiftLengthsModel(lengths);
        });
      };



      //
      // Update Lengths model

      var updateShiftLengthsModel = function(lengths){
        shift.lengths = lengths;
        console.log('shift.lengths', shift.lengths);
        shiftLengthsInit = rulesShiftLTService.getShiftsLengthsInit();
        prepareFullHoursList(shift.lengths);
        shift.isLengthsEditing = false;
      };


      //
      // Prepare Full Hours list

      var prepareFullHoursList = function(allLengths){
        shift.fullHoursList = [];

        angular.forEach(allLengths, function(length){
          var i = _.indexOf(shift.fullHoursList, length.fullHours);
          if (i < 0) {
            shift.fullHoursList.push(length.fullHours);
          }
        });
      };


      //
      // Check if Shift Lengths were changed

      shift.updLengthsEditing = function(lengthChanged) {
        shift.isLengthsEditing = !angular.equals(shift.lengths, shiftLengthsInit);

        // If any Length is unchecked and any Length is selected
        if (shift.isLengthsEditing && shift.types.length > 0) {
          // If unchecked Length is selected, empty Shift Types
          if ( !lengthChanged.active && lengthChanged.id === shift.types[0].shiftLengthId ) {
            shift.types = [];
          }
        }

        // If Length was checked back
        if (lengthChanged.active) {
          shift.selectLength(lengthChanged);
        }
      };



      //
      // Save Shift Lengths changes

      shift.saveShiftLengths = function(){
        var changedLength = [];

        angular.forEach(shift.lengths, function(length){
          var initLength = _.find(shiftLengthsInit, {id: length.id});
          if ( !angular.equals(length, initLength) ) {
            changedLength.push(length);
          }
        });

        return rulesShiftLTService.updateShiftLengths(shift.site.id, changedLength).then(function(lengths){
          if (lengths) {
            updateShiftLengthsModel(lengths);

          // If error occurs on Save, and there is no lengths returned
          // display old Lengths to avoid breaking the page (UAT-125)

          } else {
            var oldLength = rulesShiftLTService.getShiftsLengthsInit();
            updateShiftLengthsModel(oldLength);
          }
        });
      };



      //
      // Add new Shift Lengths

      shift.addNewShiftLengths = function () {
        var existingLengths = shift.lengths;
        var siteId = shift.site.id;

        var modalInstance = $modal.open({
          templateUrl: 'modules/settings/rules/sites_teams/partials/include/rules_sites-teams_shift-lengths-modal.tmpl.html',
          controller: 'RulesNewShiftLengthsModalCtrl as nsl',
          size: 'sm',
          resolve: {
            lengths: function () {
              return existingLengths;
            },
            siteId: function () {
              return siteId;
            }
          }
        });

        modalInstance.result.then(function (lengths) {
          updateShiftLengthsModel(lengths);

        }, function () {
          //$log.info('Modal dismissed at: ' + new Date());
        });
      };


      shift.stopPropagation = function($event) {
        $event.stopPropagation();
      };


      //
      // Select this Length

      shift.selectLength = function(length) {
        shift.selectedLength = length.active ? length : null;
      };



      //--------------------------------------------------------------------
      // Shift Types
      //--------------------------------------------------------------------


      // Watch for selected Length to be changed

      $scope.$watch("shift.selectedLength", function(newLength) {
        if (newLength) {
          shift.getShiftTypesForLength(newLength.id);
          //shift.wereTypesEdited = false;
          shift.selectedType = null;
          shift.isTypeEdited = false;
        }
      });


      // GET Shift Types for a selected Length

      shift.getShiftTypesForLength = function(shiftLengthId) {
        rulesShiftLTService.getShiftTypesForLength(shift.site.id, shiftLengthId).then( function(types){
          updateTypesModel(types);
        });
      };

      var updateTypesModel = function(types) {
        _.forEach(types, function(type){
          type.paidTimeInHours = type.paidTimeInMin === 0 ? type.paidTimeInMin : type.paidTimeInMin / 60;
          type.isSubmitted = false;
        });
        //console.log('types', types);
        shiftTypesInit = types;
        shift.selectedType = null;
        shift.customShiftType = null;
        refreshTypesModel();
      };



      // Refresh Types modal
      function refreshTypesModel() {
        shift.types = angular.copy(shiftTypesInit);
        shift.wereTypesEdited = false;
        $scope.selectedTypeForm.$setUntouched();
      }



      // Check if Types were changed

      shift.updTypesEditing = function() {
        shift.wereTypesEdited = !angular.equals(shift.types, shiftTypesInit);
      };



      //
      // Select this Type

      shift.selectType = function(e, typeToEdit) {

        // If Type selected, move selectedType panel to this row
        var selected;
        if (e) {
          e.preventDefault();

          var row = angular.element(e.target);
          var rowScreen = row[0].getBoundingClientRect();
          selected = row.closest('#shift-types').find('#selected-type');
          var selectedParent = selected.parent();

          $timeout(function(){
            var selectedParentScreen = selectedParent[0].getBoundingClientRect();
            selected[0].style.top = rowScreen.top - 8 - 42 - selectedParentScreen.top + 'px';
            selected[0].style.opacity = '1';
          });
        } else {
          selected = $document.find('#selected-type');
          selected[0].style.top = '0px';
          selected[0].style.opacity = '1';
        }

        // Refresh Types to initial state to remove unsaved data
        refreshTypesModel();

        selectedTypeInit = angular.copy(typeToEdit);
        shift.selectedType = typeToEdit;
        shift.updSelectedTypeEditing();

        angular.forEach(shift.types, function(type){
          type.isEditing = type.id === typeToEdit.id;
        });

        // Remove newly created Type, since it wasn't saved
        shift.customShiftType = typeToEdit.id ? null : shift.customShiftType;
      };



      //
      // Update Editing state of Selected Type

      shift.updSelectedTypeEditing = function() {
        shift.isTypeEdited = !angular.equals(shift.selectedType, selectedTypeInit);
      };



      //
      // Update multi Types active states

      shift.updShiftTypesActivation = function(){

        var dto = {};
        angular.forEach(shift.types, function(type){
          var typeInit = _.find(shiftTypesInit, {id: type.id});
          if ( !angular.equals(type, typeInit) ) {
            var id = type.id;
            dto[id] = type.active;
          }
        });

        return rulesShiftLTService.updShiftTypesActivation(shift.site.id, dto).then( function(types){
          updateTypesModel(types);
        });
      };



      //
      // Add a custom Type

      shift.addCustomShiftTypeRow = function() {
        var defaultTime = moment().hour(0).minute(0).second(0).milliseconds(0);

        shift.customShiftType = {
          name:               '',
          description:        '',
          startTime:          defaultTime,
          active:             true,
          shiftLengthLength:  shift.selectedLength.lengthInMin,
          shiftLengthId:      shift.selectedLength.id,
          isEditing:          true,
          paidTimeInHours:    shift.selectedLength.lengthInMin / 60
        };

        shift.selectType(false, shift.customShiftType);
      };



      //
      // Update a Type

      shift.saveShiftType = function() {

        if ( shift.selectedType.id ) {  // if Type exists

          var updDto = {
            name: shift.selectedType.name,
            description: shift.selectedType.description,
            startTime: shift.selectedType.startTime,
            active: shift.selectedType.active,
            paidTimeInMin: $filter('hoursToMins')(shift.selectedType.paidTimeInHours)
          };
          console.log('updDto', updDto);

          return rulesShiftLTService.saveShiftType(shift.site.id, shift.selectedType, updDto).then( function(types){
            updateTypesModel(types);
          });

        } else {   // if Type is newly created

          var startTime = moment(shift.selectedType.startTime);
          var newDto = {
            shiftLengthId: shift.selectedType.shiftLengthId,
            updateDto: {
              name: shift.selectedType.name,
              description: shift.selectedType.description,
              startTime: startTime.diff(moment(startTime).startOf('day')),
              active: shift.selectedType.active,
              paidTimeInMin: shift.selectedType.paidTimeInHours * 60
            }
          };
          console.log('newDto', newDto);

          return rulesShiftLTService.addShiftType(shift.site.id, newDto).then( function(types){
            updateTypesModel(types);
          });
        }
      };



      //
      // Delete a Type

      shift.deleteShiftType = function(type, $event) {
        $event.stopPropagation($event);
        return rulesShiftLTService.deleteShiftType(shift.site.id, type).then( function(types){
          updateTypesModel(types);
        });
      };



      //
      // Bulk add pre-defined Types

      shift.addBulkNewShiftTypes = function () {
        var existingTypes = shift.types;
        var site = shift.site;
        var selectedLength = shift.selectedLength;

        var modalInstance = $modal.open({
          templateUrl: 'modules/settings/rules/sites_teams/partials/include/rules_sites-teams_shift-bulk-types-modal.tmpl.html',
          controller: 'RulesNewShiftBulkTypesModalCtrl as bulk',
          size: 'sm',
          resolve: {
            types: function () {
              return existingTypes;
            },
            selectedLength: function () {
              return selectedLength;
            },
            site: function () {
              return site;
            }
          }
        });

        modalInstance.result.then(function (types) {
          updateTypesModel(types);

        }, function () {
          //$log.info('Modal dismissed at: ' + new Date());
        });
      };


    }]);
})();
;
(function () {
  "use strict";

  var rules = angular.module('emlogis.rules');
  
  rules.controller('RulesSiteEditCtrl', ['$scope', 'rulesSitesService', function ($scope, rulesSitesService) {
    //console.log('+++ inside Rules - Site Edit controller');

    //
    // Defaults for Sites

    $scope.siteOptions = {
      weekDays              : ["SUNDAY", "MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY"],
      shiftIncrements       : [15, 30, 60],
      shiftOverlaps         : [0, 15, 30, 60],
      maxConsecutiveShifts  : [1, 2, 3, 4, 5, 6, 7],
      datepickerOpened      : false
    };


    //
    // Listen to selected Site is being changed
    // and load details for newly selected Site

    $scope.$watch("selectedSite", function(newValue) {
      if (newValue) {
        //console.log('+++ Selected Site ID: ' + newValue.id + ' loading Site details...');
        $scope.loadSiteDetails(newValue.id);
        $scope.siteForm.$setPristine(true);
        rulesSitesService.setSiteForm($scope.siteForm);
      }
    });



    //
    // Open date picker

    $scope.siteOptions.openDatepicker = function($event) {
      $event.preventDefault();
      $event.stopPropagation();
      $scope.siteOptions.datepickerOpened = true;
    };


  }]);
})();
;
(function () {
  "use strict";

  var rules = angular.module('emlogis.rules');
  
  rules.controller('RulesSiteNewCtrl', ['$scope', '$state', 'applicationContext', 'appFunc', 'rulesSitesService',
    function ($scope, $state, applicationContext, appFunc, rulesSitesService) {

    //--------------------------------------------------------------------
    // Defaults for New Site
    //--------------------------------------------------------------------

    $scope.selectedSiteDetails = {
      name: 'Create a new Site'
    };
    $scope.selectedSiteDetailsToDisplay = {};
    $scope.selectedSiteDetailsToDisplay.overtimeDto = {};
    $scope.page.editing = false;
    $scope.page.submitted = false;

    $scope.isEditWellCollapsed = false;


    //
    // Cancel creating Site
    // and return user back to existing Sites

    $scope.cancelNewSite = function () {
      $scope.page.editing = false;
      $state.go('authenticated.rules.site_teams');
    };

    
    //
    // Save New Site
    // if form is valid
    
    $scope.saveNewSite = function() {

      if ( $scope.siteForm.$valid ) {

        //console.log('+++ Adding a New Site. Stay tuned!');
        var date = 0;

        if ($scope.selectedSiteDetailsToDisplay.twoWeeksOvertimeStartDate){
          date = appFunc.getDateWithTimezone(
            $scope.selectedSiteDetailsToDisplay.twoWeeksOvertimeStartDate.getFullYear(),
            $scope.selectedSiteDetailsToDisplay.twoWeeksOvertimeStartDate.getMonth(),
            $scope.selectedSiteDetailsToDisplay.twoWeeksOvertimeStartDate.getDate(),
            $scope.selectedSiteDetailsToDisplay.timeZone
          ).getTime();
        }

        var newSite = {
          "id": null,
          "updateDto": {
            "name":                       $scope.selectedSiteDetailsToDisplay.name,
            "abbreviation":               $scope.selectedSiteDetailsToDisplay.abbreviation,
            "description":                $scope.selectedSiteDetailsToDisplay.description,
            "timeZone":                   $scope.selectedSiteDetailsToDisplay.timeZone,
            "address":                    $scope.selectedSiteDetailsToDisplay.address,
            "address2":                   null,                                                            // ?
            "city":                       $scope.selectedSiteDetailsToDisplay.city,
            "state":                      $scope.selectedSiteDetailsToDisplay.state,
            "country":                    $scope.selectedSiteDetailsToDisplay.country,
            "zip":                        $scope.selectedSiteDetailsToDisplay.zip,
            "weekendDefinition":          "SATURDAY_SUNDAY",                                               // ?
            "firstDayOfWeek":             $scope.selectedSiteDetailsToDisplay.firstDayOfWeek,
            "isNotificationEnabled":      $scope.selectedSiteDetailsToDisplay.isNotificationEnabled,
            "shiftIncrements":            $scope.selectedSiteDetailsToDisplay.shiftIncrements,
            "shiftOverlaps":              $scope.selectedSiteDetailsToDisplay.shiftOverlaps,
            "maxConsecutiveShifts":       $scope.selectedSiteDetailsToDisplay.maxConsecutiveShifts,
            "timeOffBetweenShifts":       $scope.selectedSiteDetailsToDisplay.timeOffBetweenShifts,
            "enableWIPFragments":         $scope.selectedSiteDetailsToDisplay.enableWIPFragments || false,
            "twoWeeksOvertimeStartDate":  date,
            "overtimeDto": {
              "dailyOvertimeMins":        $scope.selectedSiteDetailsToDisplay.overtimeDto.dailyOvertimeMins || -1,
              "weeklyOvertimeMins":       $scope.selectedSiteDetailsToDisplay.overtimeDto.weeklyOvertimeMins || -1,
              "biweeklyOvertimeMins":     $scope.selectedSiteDetailsToDisplay.overtimeDto.biweeklyOvertimeMins || -1
            }
          }
        };


        return rulesSitesService.saveNewSite(newSite).then( function(response) {
          //console.log('+++ A New Site has just been created. Yay!', response);
          $scope.page.editing = false;
          $scope.page.submitted = false;
          applicationContext.setNotificationMsgWithValues('app.CREATED_SUCCESSFULLY', 'success', true);
          $state.go('authenticated.rules.site_teams');

        }, function(err) {
          applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
          //$state.go('authenticated.rules.site_teams');
        });
      } else {
        $scope.page.submitted = true;
      }
    };

    //--------------------------------------------------------------------
    // Setup Working for this page
    //--------------------------------------------------------------------

    var working = applicationContext.getWorking();

    working.entityName = 'rules.NEW_SITE';
    working.option = $scope.page;
    working.saveFunc = $scope.saveNewSite;

  }]);
})();
;
(function () {
  "use strict";

  var rules = angular.module('emlogis.rules');

  rules.controller('RulesTeamsCtrl', ['$scope', '$filter', '$modal', '$log', '$timeout',
                                       'applicationContext', 'rulesTeamsService', 'dialogs', 'uiGridConstants',
    function ($scope, $filter, $modal, $log, $timeout,
              applicationContext, rulesTeamsService, dialogs, uiGridConstants) {


      //--------------------------------------------------------------------
      // Defaults for Teams Ctrl
      //--------------------------------------------------------------------
  
      var tm = this,
          numOfRows = 12;
  
      $scope.savingTeamsCounter = 0;
      tm.isEditing = false;
  
  
      //
      // Listen to selected Site is being changed
      // and load Teams for newly selected Site
  
      $scope.$watch("selectedSite", function(newSite) {
        if (newSite) {
          //console.log('+++ Selected Site changed, newSite');
          $scope.siteDataIsLoading = true;                                              // Display loading spinner
  
          if ($scope.sitesTeamsTree){
            displaySiteChildrenFromTree(newSite.id);
          }
        }
      });
  
      $scope.$watch("sitesTeamsTree", function(newTree) {
        if (newTree) {
          displaySiteChildrenFromTree($scope.selectedSite.id);
        }
      });
  
  
  
      //--------------------------------------------------------------------
      // Teams related methods
      //--------------------------------------------------------------------
  
  
      //
      // Display initial details from Tree API
      // this will only display Panels names and Skills names
  
      var displaySiteChildrenFromTree = function(siteId){
        //console.log('+++ Displaying Panels and Skills tags for the selected Site...');
  
        var siteFromTree = _.find($scope.sitesTeamsTree, { 'id': siteId });
        $scope.selectedSiteChildren.site = {};                                           // First, clear the obj
        $scope.selectedSiteChildren.site = angular.copy(siteFromTree);                   // Then, save Site Tree data
  
  
        // Get all Teams for currently selected Site
  
        rulesTeamsService.getSiteTeams(siteId).then( function(res) {
  
          $scope.selectedSiteChildren.site.allTeamsInit = res.data;
          $scope.selectedSiteChildren.site.allTeams = angular.copy($scope.selectedSiteChildren.site.allTeamsInit);
  
          // Prepare allTeams object for Collapsing Panel
  
          angular.forEach($scope.selectedSiteChildren.site.allTeams, function(team) {
            team.isPanelCollapsed = true;                        // set the Panel collapsed value
            team.isWellCollapsed = true;                         // set the Edit Well collapsed value
            team.panelOpenedOnce = false;                        // to check is Panel for this Team was opened before
            team.panelName = team.name;                          // copy Team name to display in Panel header
            team.panelAbbreviation = team.abbreviation;          // copy Team abbreviation for Panel header
            team.refresh = true;
          });
  
          // Save initial Skills
          // from SiteTeamTree to allTeamsInit as children
  
          angular.forEach($scope.selectedSiteChildren.site.allTeamsInit, function(initTeam){
            initTeam.initSkills =_.result(_.find($scope.selectedSiteChildren.site.children, { 'id': initTeam.id}), 'children');
          });
  
          // TEMP TODO: until "Team.deletable" prop is not implemented
          angular.forEach($scope.selectedSiteChildren.site.allTeams, function(team){
            team.initSkills =_.result(_.find($scope.selectedSiteChildren.site.children, { 'id': team.id}), 'children');
          });
          // end of temp
        });
      };
  
  
  
      tm.loadAllDetailsForTeam = function(team){
        // Load Skills associated to this Team
        rulesTeamsService.getTeamSkills(team.id).then( function(res){
          team.associatedSkills = res;
          angular.forEach(team.associatedSkills, function(skill){
            skill.active = skill.isActive;
          });
        });
  
        // Load Skills unassociated to this Team
        rulesTeamsService.getUnassociatedTeamSkills(team.id).then( function(res){
          team.skillsToAdd = res;
          angular.forEach(team.skillsToAdd, function(skill){
            skill.active = skill.isActive;
          });
        });
  
        // Load Employees for this Team
        displayEmployeesGrid(team);
      };
  
  
      // Add a new Team to a Site
  
      $scope.addNewTeam = function(){
        var newTeam = {
          isPanelCollapsed: false,
          isWellCollapsed: false,
          panelOpenedOnce: true,
          panelName: 'New Team',
          active: true
        };
        $scope.selectedSiteChildren.site.allTeams.unshift(newTeam);
        tm.updateEditing();                                         // change Editing state to true
      };
  
  
      // Delete Team
  
      $scope.deleteTeam = function(team){
  
        // Confirm deletion
        var question = $filter('translate')("rules.site_teams.DELETE_TEAM") + team.name + '?';
        var dlg = dialogs.confirm('app.PLEASE_CONFIRM', question);                // Show modal window
        dlg.result.then( function(btn) {                                          // If user confirms, proceed
  
          // for an existing Team
          if (team.id) {
            return rulesTeamsService.deleteTeam(team.id).then( function(res){
  
              displaySiteChildrenFromTree($scope.selectedSite.id);  // Reload Teams
              $scope.$parent.loadAllSites();                        // Reload Site Info and SiteTeamsTree in sidebar
            });
  
          // for a new Team
          } else {
            $scope.selectedSiteChildren.site.allTeams.shift();
            $scope.page.editing = false;                            // Refresh editing state to default
          }
        });
      };
  
  
  
      //--------------------------------------------------------------------
      // Skills related methods
      //--------------------------------------------------------------------
  
      //
      // Remove a Skill from a given Team
  
      $scope.removeSkill = function(skill, team){
        var i = team.associatedSkills.indexOf(skill);               // Find index of Skill in Teams array
        if (i != -1) team.associatedSkills.splice(i, 1);            // If Skill is in Teams, remove it from array
        tm.updateEditing();                                         // and change Editing state to true
  
      };
  
  
      //
      // Attach a Skill from a given Team
  
      $scope.attachSkillToTeam = function(skill, team){
        team.associatedSkills.push(skill);
        tm.updateEditing();                                         // and change Editing state to true
      };
  
  
  
      //--------------------------------------------------------------------
      // Employees related methods
      //--------------------------------------------------------------------
  
      //
      // Prepare Employees grid
  
      var displayEmployeesGrid = function(team){
        return rulesTeamsService.loadTeamEmployees(team.id, { orderby:'Employee.lastName', orderdir:'ASC' }, 1, numOfRows)
          .then( function(res){
            team.associatedEmployees = res;
  
            //
            // Employees table
            // placed inside each Team
  
            team.gridOptions = {
              data: team.associatedEmployees.data,
              totalItems: team.associatedEmployees.total,
              minRowsToShow: team.associatedEmployees.total < numOfRows ? team.associatedEmployees.total : numOfRows,
  
              enableHorizontalScrollbar: 0,
              enableVerticalScrollbar: 0,
              enableColumnMenus: false,
  
              enableFiltering: true,
              useExternalFiltering: true,
  
              enableSorting: true,
              useExternalSorting: true,
  
              needPagination: true,
              useExternalPagination: true,
              enablePaginationControls: false,
              paginationPageSize: numOfRows,
              paginationCurrentPage: 1,
  
              enableSelectAll: true,
              enableRowSelection: true,
              enableFullRowSelection: true,               // full row selection
              enableHighlighting: false,
  
              /*isRowSelectable: function(row) {            // prevent selection employees whos HomeTeam is current Team
                return row.entity.homeTeamId !== team.id;
              },
              rowTemplate: '<div ng-repeat="(colRenderIndex, col) in colContainer.renderedColumns track by col.uid" ' +
                                'class="ui-grid-cell" ' +
                                'ng-class="{ \'ui-grid-row-header-cell\': col.isRowHeader,' +
                                            ' \'not-selectable\': !row.enableSelection }"  ' +
                                'ui-grid-cell></div>',*/
  
              columnDefs: [
                {
                  field: 'lastName',
                  displayName: 'Last Name', // TODO translate
                  enableFiltering: true,
                  minWidth: '150',
                  sort: {
                    direction: uiGridConstants.ASC
                  }
                },
                { field: 'firstName',        enableFiltering: false, displayName: 'First Name' }, // TODO translate
                { field: 'isFloating',                          enableFiltering: false, displayName: 'Is Floating', enableSorting: false },
                { field: 'employeeType',     enableFiltering: false, displayName: 'Employee Type' },
                { field: 'primarySkillName', enableFiltering: false, displayName: 'Primary Skill' },
                { field: 'homeTeamName',                        enableFiltering: false, displayName: 'Home Team' },
                { field: 'hireDate',         enableFiltering: false, displayName: 'Hire Date', cellFilter: 'date' },
                { field: 'primarySkillId',   visible: false },
                { field: 'homeTeamId',                          visible: false },
                { field: 'employeeId',               visible: false }
              ],
              onRegisterApi: function(gridApi) {
                team.gridApi = gridApi;
                team.gridOptions.queryParams = {
                  orderby:'lastName',
                  orderdir:'ASC'
                };
  
  
                //
                // Back-end filtering
  
                team.gridApi.core.on.filterChanged( $scope, function() {
                  var grid = this.grid;
                  var filterTerm = grid.columns[1].filters[0].term;
                  //console.log('~~~ filter changed - grid', grid);
  
                  if (filterTerm === null || filterTerm === '' || filterTerm === undefined ){
                    team.gridOptions.queryParams = {
                      orderby : team.gridOptions.queryParams.orderby,
                      orderdir: team.gridOptions.queryParams.orderdir
                    };
                  } else {
                    var filterName = 'Employee.lastName';
                    team.gridOptions.queryParams.filter = filterName + " LIKE '" + filterTerm + "%'";
                  }
                  getPage();
                });
  
  
                //
                // Back-end sorting
  
                team.gridApi.core.on.sortChanged($scope, function(grid, sortColumns) {
                  //console.log('~~~ sortColumns', sortColumns);
                  //console.log('~~~ sorting changed - grid', grid);
                  if (sortColumns.length === 0) {
                    team.gridOptions.queryParams.orderdir = 'ASC';
                    team.gridOptions.queryParams.orderby = 'lastName';
                  } else {
                    team.gridOptions.queryParams.orderdir = sortColumns[0].sort.direction;
  
                    switch (sortColumns[0].field) {
                      case "lastName":
                        team.gridOptions.queryParams.orderby = 'Employee.lastName';
                        break;
                      case "firstName":
                        team.gridOptions.queryParams.orderby = 'Employee.firstName';
                        break;
                      case "isFloating":
                        team.gridOptions.queryParams.orderby = 'EmployeeTeam.isFloating';  // TODO: Yuriy is adding the logic
                        break;
                      case "employeeType":
                        team.gridOptions.queryParams.orderby = 'Employee.employeeType';
                        break;
                      case "primarySkillName":
                        team.gridOptions.queryParams.orderby = 'Skill.name';
                        break;
                      case "homeTeamName":
                        team.gridOptions.queryParams.orderby = 'Team.name';
                        break;
                      case "hireDate":
                        team.gridOptions.queryParams.orderby = 'Employee.hireDate';
                        break;
                      default:
                        team.gridOptions.queryParams.orderby = 'Employee.lastName';
                        break;
                    }
                  }
                  getPage();
                });
  
  
                //
                // Back-end pagination
  
                team.gridApi.pagination.on.paginationChanged($scope, function (newPage, pageSize) {
                  team.gridOptions.paginationCurrentPage = newPage;
                  getPage();
                });
  
                var getPage = function() {
                  //console.log('team.gridOptions.queryParams', team.gridOptions.queryParams);
                  rulesTeamsService.loadTeamEmployees(team.id, team.gridOptions.queryParams, team.gridOptions.paginationCurrentPage, numOfRows)
                    .then(function(res){
                      refreshEmployeesGrid(team, res);
                    })
                  ;
                };
              }
            };
        }, function (err) {
          applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
        });
      };
  
  
      //
      // Remove selected Employees
      // from this Team
  
      $scope.removeEmployeesFromTeam = function(team, emplIdsList){
        var toDelete = team.gridApi.selection.getSelectedRows();
        var toDeleteIds = [];
        angular.forEach(toDelete, function(row){
          toDeleteIds.push(row.employeeId);
        });
  
        rulesTeamsService.removeEmployeesTeamMembership(team.id, toDeleteIds).then(function(res){
          //displayEmployeesGrid(team);
          return rulesTeamsService.loadTeamEmployees(team.id, team.gridOptions.queryParams, team.gridOptions.paginationCurrentPage, numOfRows)
            .then(function(res){
              refreshEmployeesGrid(team, res);
            })
          ;
        });
      };
  
  
      var refreshEmployeesGrid = function(team, res){
        team.associatedEmployees = res;
        team.gridOptions.totalItems = res.total;
        team.gridOptions.data = res.data;
        team.gridOptions.minRowsToShow = res.total < numOfRows ? res.total : numOfRows;
        team.gridApi.core.refresh();
        refreshGrid(team);
      };
  
  
      // Hacky way to re-render the whole grid
      // to update the number of rows shown, because of
      // UI-Grid does not recalculate # of rows once rendered: https://github.com/angular-ui/ng-grid/issues/2531
  
      function refreshGrid(team) {
        team.refresh = false;
        $timeout( function() {
          team.refresh = true;
        });
      }
  
  
      //--------------------------------------------------------------------
      // CRUD
      //--------------------------------------------------------------------
  
  
      tm.saveTeams = function() {
        $scope.savingTeamsCounter = 0;
  
        // First, check if a New Team was added to a Site
  
        if ($scope.selectedSiteChildren.site.allTeamsInit.length < $scope.selectedSiteChildren.site.allTeams.length){
  
          // For a new Team check if Team name was filled.
          // If not - display notification and cancel Saving process
          if ( !$scope.selectedSiteChildren.site.allTeams[0].name ) {
            applicationContext.setNotificationMsgWithValues('Please enter a name for a New Team!', 'danger', true);
            return;
          }
  
          // If New Team has a name filled, proceed
          $scope.savingTeamsCounter++;
          var newTeamDto = {
            "id":               null,
            "siteId":           $scope.selectedSiteChildren.site.id,
            "updateDto": {
              "name":           $scope.selectedSiteChildren.site.allTeams[0].name,                  // required
              "abbreviation":   $scope.selectedSiteChildren.site.allTeams[0].abbreviation,          // required
              "description":    $scope.selectedSiteChildren.site.allTeams[0].description || null,
              "active":         $scope.selectedSiteChildren.site.allTeams[0].active,
              "startDate":      0,
              "endDate":        0
            }
          };
  
          rulesTeamsService.addNewTeam(newTeamDto).then( function(res){
            applicationContext.setNotificationMsgWithValues('New Team was successfully added!', 'success', true);
            $scope.savingTeamsCounter--;
  
          }, function(err) {
            applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
          });
        }
  
  
        // Next,
        // Compare initial and new states of every Team
  
        angular.forEach($scope.selectedSiteChildren.site.allTeamsInit, function(initTeam) {
          var newTeam = _.find($scope.selectedSiteChildren.site.allTeams, { 'id': initTeam.id });
  
          // Check if Team Details were modified
  
          var initTeamDetails = {                                                           // initial Team details dto
            name:         initTeam.name,
            abbreviation: initTeam.abbreviation,
            description:  initTeam.description,
            active:       initTeam.active
          };
  
          var newTeamDetails = {                                                            // current Team details dto
            name:         newTeam.name,
            abbreviation: newTeam.abbreviation,
            description:  newTeam.description,
            active:       newTeam.active
          };
  
          if ( !angular.equals(initTeamDetails, newTeamDetails) ) {                         // if initial and current DTOs differ
            if ( newTeamDetails.name && newTeamDetails.name.length <= 50 &&
                 newTeamDetails.abbreviation && newTeamDetails.abbreviation.length <= 5 ) {
  
              $scope.savingTeamsCounter++;
              console.log('SAVING newTeamDetails', newTeamDetails);
              rulesTeamsService.putTeamDetails(newTeam.id, newTeamDetails).then( function(){   // update Team details
                $scope.savingTeamsCounter--;
              }, function (err) {
                applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
              })
              ;
  
            } else {
              applicationContext.setNotificationMsgWithValues('Please make sure you entered all Team details properly!', 'danger', true);
              return;
            }
          }
  
  
          // Check,
          // if list of Skills was modified.
  
          if (newTeam.associatedSkills){
            if (initTeam.initSkills.length > newTeam.associatedSkills.length){                      // If some Skills were removed:
              var skillsToRemove = diffNotInArray(initTeam.initSkills, newTeam.associatedSkills);   // find all deleted Skills,
              //console.log('~~~ skillsToRemove', skillsToRemove);
  
              angular.forEach(skillsToRemove, function(skill) {                                     // for every added Skill
                $scope.savingTeamsCounter++;                                                        // increase counter for every API call,
                rulesTeamsService.removeSkillFromTeam(newTeam.id, skill.id).then( function(){       // remove this Skill from the Team,
                  $scope.savingTeamsCounter--;                                                      // decrease counter for every API call resolved.
                }, function (err) {
                  applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
                });
              });
  
            } else if (initTeam.initSkills.length < newTeam.associatedSkills.length) {              // If some Skills were added:
              var skillsToAdd = diffNotInArray(newTeam.associatedSkills, initTeam.initSkills);      // find all added Skills,
              //console.log('~~~ skillsToAdd', skillsToAdd);
  
              angular.forEach(skillsToAdd, function(skill) {                                        // for every added Skill
                $scope.savingTeamsCounter++;                                                        // increase counter for every API call,
                rulesTeamsService.addTeamSkill(newTeam.id, skill.id).then( function(){              // attach this Skill to the Team,
                  $scope.savingTeamsCounter--;                                                      // decrease counter for every API call resolved.
                }, function (err) {
                  applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
                });
              });
  
            } else if (initTeam.initSkills.length === newTeam.associatedSkills.length){             // If number of Skills is the same
              angular.forEach(newTeam.associatedSkills, function(skill) {
                var skillIsAssociated = _.find(initTeam.initSkills, { 'id': skill.id });            // Check if any Skills were removed
                if (!skillIsAssociated) {
                  $scope.savingTeamsCounter++;                                                      // increase counter for every API call,
                  rulesTeamsService.addTeamSkill(newTeam.id, skill.id).then( function(){            // remove this Skill from the Team,
                    $scope.savingTeamsCounter--;                                                    // decrease counter for every API call resolved.
                  }, function (err) {
                    applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
                  });
                }
              });
  
              angular.forEach(initTeam.initSkills, function(skill) {                                // Check if any Skills were removed
                var skillIsKept = _.find(newTeam.associatedSkills, { 'id': skill.id });
                if (!skillIsKept) {
                  $scope.savingTeamsCounter++;                                                      // increase counter for every API call,
                  rulesTeamsService.removeSkillFromTeam(newTeam.id, skill.id).then( function(){     // remove this Skill from the Team,
                    $scope.savingTeamsCounter--;                                                    // decrease counter for every API call resolved.
                  }, function (err) {
                    applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
                  });
                }
              });
            }
          }
        });

        // Finally,
        // wait for when all API calls are resolved
        // and after that - reload SitesTeamsTree

        var removeThisWatcher = $scope.$watch("savingTeamsCounter", function(newVal, oldVal) {
          if (newVal === 0 && oldVal === 1) {
            applicationContext.setNotificationMsgWithValues('app.SAVED_SUCCESSFULLY', 'success', true);
            $scope.$parent.loadAllSites();
            tm.isEditing = false;
            removeThisWatcher();                                           // remove this $watch
          }
        });
      };
  
  
  
      //--------------------------------------------------------------------
      // Other related methods
      //--------------------------------------------------------------------
  
      //
      // Update Site Scheduling Settings model
  
      tm.updateEditing = function(){
        tm.isEditing = true;
      };
  
  
  
      $scope.openEmployeesModal = function (team) {
        var modalTeam = team;
  
        var modalInstance = $modal.open({
          templateUrl: 'modules/settings/rules/sites_teams/partials/include/rules_sites-teams_employees-modal.tmpl.html',
          controller: 'RulesSitesTeamsEmployeesModalCtrl as te',
          windowClass: 'employees-modal',
          size: 'lg',
          resolve: {
            team: function () {
              return modalTeam;
            }
          }
        });
  
        modalInstance.result.then(function () {
          applicationContext.setNotificationMsgWithValues('app.ADDED_SUCCESSFULLY', 'success', true);
          //displayEmployeesGrid(team);
          rulesTeamsService.loadTeamEmployees(team.id, team.gridOptions.queryParams, team.gridOptions.paginationCurrentPage, numOfRows)
            .then(function(res){
              refreshEmployeesGrid(team, res);
            })
          ;
        }, function () {
          $log.info('Modal dismissed at: ' + new Date());
        });
      };
  
  
  
      function diffNotInArray(bigArray, smArray){
        var smArrayIds = {};
        _.forEach(smArray, function(obj) {
          smArrayIds[obj.id] = obj;
        });
  
        return bigArray.filter(function(obj){
          return !(obj.id in smArrayIds);
        });
      }
    }
  ]);
})();
;
(function () {
  "use strict";

  var rules = angular.module('emlogis.rules');

  rules.controller('RulesSiteTeamsCtrl', ['$scope', '$state', '$filter',
                                           'applicationContext', 'dialogs', 'appFunc',
                                           'dataService', 'rulesSitesService', 'rulesTeamsService',
    function ($scope, $state, $filter,
              applicationContext, dialogs, appFunc,
              dataService, rulesSitesService, rulesTeamsService) {

    //console.log('+++ inside Rules Site / Teams controller');


    //--------------------------------------------------------------------
    // Defaults for Sites & Teams tab
    //--------------------------------------------------------------------

    var i,
        allSitesInit,
        lastModifiedSiteId = rulesTeamsService.getSiteLastModified();

    $scope.page.editing = false;
    $scope.page.submitted = false;
    $scope.updatesCounter = 0;
    $scope.isEditWellCollapsed = true;


    // Site
    $scope.allSites = [];
    $scope.siteDataIsLoading = true;
    $scope.sitesTeamsTree = null;
    $scope.selectedSite = null;

    // Teams
    $scope.selectedSiteChildren = {
      site: {}
    };



    //--------------------------------------------------------------------
    // Site related methods
    //--------------------------------------------------------------------


    //
    // Check if Site can be deleted by user
    // TEMP TODO change when API property is implemented

    $scope.isSiteDeletable = function(){
      return _.find($scope.selectedSiteChildren.site.allTeams, { 'isDeleted': false }) ? true : false;
    };



    //
    // GET the list of all Sites

    $scope.loadAllSites = function() {
      return rulesSitesService.getAllSites().then( function(res) {
        // Save response
        allSitesInit = res.data;
        $scope.allSites = angular.copy(allSitesInit);

        // and load SitesTeamsTree
        loadSitesTeamsTree();

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);

      }).finally( function() {

        // After all Sites were loaded
        // display the most recently updated Site

        if (lastModifiedSiteId) $scope.selectedSite = _.find($scope.allSites, {id: lastModifiedSiteId});
        else {
          var lastUpdated = _.sortBy($scope.allSites, function(site) { return site.updated.getTime(); }).reverse();
          $scope.selectedSite = lastUpdated[0];
        }
      });
    };



    //
    // GET all details for a Site

    $scope.loadSiteDetails = function(siteId) {
      rulesSitesService.getSiteDetails(siteId).then( function(res) {
        $scope.selectedSiteDetails = res.data;
        $scope.selectedSiteDetails.twoWeeksOvertimeStartDate = appFunc.convertToBrowserTimezone(res.data.twoWeeksOvertimeStartDate, res.data.timeZone);

        // Hide '-1' in input fields
        $scope.selectedSiteDetails.overtimeDto.biweeklyOvertimeMins = $filter('hideMinus')($scope.selectedSiteDetails.overtimeDto.biweeklyOvertimeMins);
        $scope.selectedSiteDetails.overtimeDto.weeklyOvertimeMins = $filter('hideMinus')($scope.selectedSiteDetails.overtimeDto.weeklyOvertimeMins);
        $scope.selectedSiteDetails.overtimeDto.dailyOvertimeMins = $filter('hideMinus')($scope.selectedSiteDetails.overtimeDto.dailyOvertimeMins);

        // Convert to hours
        $scope.selectedSiteDetails.overtimeDto.biweeklyOvertimeMins = $filter('minsToHoursFloat')($scope.selectedSiteDetails.overtimeDto.biweeklyOvertimeMins);
        $scope.selectedSiteDetails.overtimeDto.weeklyOvertimeMins = $filter('minsToHoursFloat')($scope.selectedSiteDetails.overtimeDto.weeklyOvertimeMins);
        $scope.selectedSiteDetails.overtimeDto.dailyOvertimeMins = $filter('minsToHoursFloat')($scope.selectedSiteDetails.overtimeDto.dailyOvertimeMins);

        displaySiteDetails();

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);

      }).finally( function(){
        $scope.siteDataIsLoading = false;                                      // hide loading spinner
      });
    };



    //
    // GET all details for a Site

    var displaySiteDetails = function() {
      $scope.selectedSiteDetailsToDisplay = angular.copy($scope.selectedSiteDetails);

      // Resetting the page state
      $scope.page.submitted = false;
      $scope.page.editing = false;
    };



    // Load Sites Teams tree

    var loadSitesTeamsTree = function() {
      rulesSitesService.getSitesTeamsTree().then( function(res) {
        $scope.sitesTeamsTree = res.data;

        $scope.sitesTeamsTree = $filter('orderBy')($scope.sitesTeamsTree, 'name');    // sort Sites in ABC order
        angular.forEach($scope.sitesTeamsTree, function(site) {                       // sort Teams in ABC order
          site.children = $filter('orderBy')(site.children, 'name');
        });

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);

      });
    };



    $scope.loadAllSites();



    //--------------------------------------------------------------------
    // CRUD
    //--------------------------------------------------------------------

    //
    // Add new Site
    // and move user to /new state

    $scope.addNewSiteInit = function () {
      $state.go('authenticated.rules.site_teams.new_site');
      $scope.selectedSiteDetailsToDisplay = {};
    };



    //
    // Save button clicked

    $scope.saveSite = function(){
      console.log('+++ SITE SAVE clicked');

      // Check if Site's Details were modified.
      // If so, update Site

      if ( !angular.equals($scope.selectedSiteDetailsToDisplay, $scope.selectedSiteDetails) ) {
        if ( rulesSitesService.getSiteForm().$valid ) {
          console.log('+++ UPDATING the Site...');

          // Prepare to save
          // var date = new Date($scope.selectedSiteDetailsToDisplay.twoWeeksOvertimeStartDate).getTime(); // TODO: Time Zone?
          var saveSiteId = $scope.selectedSiteDetailsToDisplay.id,
              date = null;

          if ($scope.selectedSiteDetailsToDisplay.twoWeeksOvertimeStartDate) {
            date = appFunc.getDateWithTimezone(
              $scope.selectedSiteDetailsToDisplay.twoWeeksOvertimeStartDate.getFullYear(),
              $scope.selectedSiteDetailsToDisplay.twoWeeksOvertimeStartDate.getMonth(),
              $scope.selectedSiteDetailsToDisplay.twoWeeksOvertimeStartDate.getDate(),
              $scope.selectedSiteDetailsToDisplay.timeZone
            ).getTime();
          }

          var updatedSite = {
            "properties": {},
            "name":                       $scope.selectedSiteDetailsToDisplay.name,
            "description":                $scope.selectedSiteDetailsToDisplay.description,
            "weekendDefinition":          $scope.selectedSiteDetailsToDisplay.weekendDefinition,
            "firstDayOfWeek":             $scope.selectedSiteDetailsToDisplay.firstDayOfWeek,
            "isNotificationEnabled":      $scope.selectedSiteDetailsToDisplay.isNotificationEnabled,
            "timeZone":                   $scope.selectedSiteDetailsToDisplay.timeZone,
            "abbreviation":               $scope.selectedSiteDetailsToDisplay.abbreviation,
            "address":                    $scope.selectedSiteDetailsToDisplay.address,
            "address2":                   $scope.selectedSiteDetailsToDisplay.address2,
            "city":                       $scope.selectedSiteDetailsToDisplay.city,
            "state":                      $scope.selectedSiteDetailsToDisplay.state,
            "country":                    $scope.selectedSiteDetailsToDisplay.country,
            "zip":                        $scope.selectedSiteDetailsToDisplay.zip,
            "shiftIncrements":            $scope.selectedSiteDetailsToDisplay.shiftIncrements,
            "shiftOverlaps":              $scope.selectedSiteDetailsToDisplay.shiftOverlaps,
            "maxConsecutiveShifts":       $scope.selectedSiteDetailsToDisplay.maxConsecutiveShifts,
            "timeOffBetweenShifts":       $scope.selectedSiteDetailsToDisplay.timeOffBetweenShifts,
            "enableWIPFragments":         $scope.selectedSiteDetailsToDisplay.enableWIPFragments,
            "twoWeeksOvertimeStartDate":  date,
            "overtimeDto": {
              "dailyOvertimeMins":        $filter('hoursToMins')($scope.selectedSiteDetailsToDisplay.overtimeDto.dailyOvertimeMins) || -1,
              "weeklyOvertimeMins":       $filter('hoursToMins')($scope.selectedSiteDetailsToDisplay.overtimeDto.weeklyOvertimeMins) || -1,
              "biweeklyOvertimeMins":     $filter('hoursToMins')($scope.selectedSiteDetailsToDisplay.overtimeDto.biweeklyOvertimeMins) || -1
            }
          };

          return rulesSitesService.updateSite($scope.selectedSiteDetailsToDisplay.id, updatedSite).then( function(res) {
            applicationContext.setNotificationMsgWithValues('app.SAVED_SUCCESSFULLY', 'success', true);
            $scope.page.editing = false;
            $scope.page.submitted = false;

            $scope.loadSiteDetails(saveSiteId);
            $scope.loadAllSites();

            // Save current selected Site,
            // as the one that was last modified,
            // even if the attempt to save the changes wasn't successful

            lastModifiedSiteId = $scope.selectedSiteDetailsToDisplay.id;
            rulesTeamsService.saveSiteLastModified(lastModifiedSiteId);

          }, function(err) {
            applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);

          });

        } else {
          $scope.page.submitted = true;
          $scope.isEditWellCollapsed = false;
          applicationContext.setNotificationMsgWithValues('Please enter all required details for selected Site!', 'danger', true);
          return;
        }
      }
    };



    // Delete Site

    $scope.deleteSite = function(site){

      // Confirm deletion
      var question = $filter('translate')("rules.site_teams.DELETE_SITE") + site.name + '?';
      var dlg = dialogs.confirm('app.PLEASE_CONFIRM', question);                // Show modal window
      dlg.result.then(function (btn) {                                          // If user confirms, proceed
        return dataService.deleteSite(site.id)
          .then(function(res){
            //Reload all Sites
            $scope.loadAllSites();
            applicationContext.setNotificationMsgWithValues('rules.site_teams.SITE_DELETED', 'success', true);

          }, function (err) {
            applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
          });
      });
    };



    //--------------------------------------------------------------------
    // Sidebar related methods
    //--------------------------------------------------------------------


    //
    // Toggle Sidebar
    $scope.toggleSidebar = function(){
      $scope.sidebarVisible = !$scope.sidebarVisible;
    };


    //
    // Change Selected Site with its ID
    $scope.setSelectedSite = function(siteId) {
      angular.forEach($scope.allSites, function(site) {
        if (site.id === siteId) $scope.selectedSite = site;
      });
    };


    //
    // Choose team in sidebar
    $scope.displayTeam = function(siteId, teamId) {
      if ( $scope.selectedSiteChildren.site.id != siteId ) {
        $scope.setSelectedSite(siteId);
        openTeam(teamId); // TODO promise
      } else {
        openTeam(teamId);
      }
    };

    var openTeam = function(teamId){
      angular.forEach($scope.selectedSiteChildren.site.allTeams, function(team) {
        if (team.id === teamId && !team.isSelected) {
          console.log('team', team);

          team.isPanelCollapsed = false;          // open panel
          team.panelOpenedOnce = true;            // team was opened at least once
          team.isSelected = true;                 //

          // scroll to team panel
          // add class to panel
          // load team details

        } else if (team.id !== teamId){
          team.isSelected = false;
          team.isPanelCollapsed = true;
        }
      });
    };



    //--------------------------------------------------------------------
    // Setup Working for this page
    //--------------------------------------------------------------------

    var working = applicationContext.getWorking();

    working.entityName = 'rules.SITE_TEAMS';
    working.option = $scope.page;
    working.saveFunc = $scope.save;
    //working.restoreFunc = restoreOriginalSchedule;

    console.log('working', working);


  }]);
})();
;
(function () {
  "use strict";

  var rules = angular.module('emlogis.rules');

  rules.controller('RulesSitesTeamsEmployeesModalCtrl',
    ['$scope', '$timeout', '$modalInstance', 'uiGridConstants', 'applicationContext', 'dataService', 'rulesTeamsService', 'team',
      function ($scope, $timeout, $modalInstance, uiGridConstants, applicationContext, dataService, rulesTeamsService, team) {

        //--------------------------------------------------------------------
        // Defaults for Employees Modal
        //--------------------------------------------------------------------

        var te = this,
            totalUnnassociatedEmployees;

        te.team = team;
        te.numOfRows = 15;
        te.isEditing = false;
        te.queryParams = {
          orderby:'lastName',
          orderdir:'ASC'
        };

        te.unassociatedEmployees = null;
        te.unassociatedEmployeesInit = null;
        te.employeesToAdd = [];

        //
        // Load Unassociated Employees
        // that don't belong to this Team

        var loadTeamUnassociatedEmployees = function(teamId, queryParams, pageNum, perPage){
          return rulesTeamsService.getTeamUnassociatedEmployees(teamId, queryParams, pageNum, perPage).then( function(res){
            console.log('+++ Loaded getTeamMembership:', res);    //DEV mode

            prepareData(res);

            $timeout(function() {
              prepareEmployeesGrid(te.unassociatedEmployees);
            });

            }, function(err) {
              applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
            })
          ;
        };

        loadTeamUnassociatedEmployees(te.team.id, te.queryParams, 1, te.numOfRows);

        var prepareData = function(res){
          totalUnnassociatedEmployees = res.total;
          te.unassociatedEmployeesInit = res.data;

          angular.forEach(te.unassociatedEmployeesInit, function(employee) {
            employee.isSelected = false;
          });

          te.unassociatedEmployees = angular.copy(te.unassociatedEmployeesInit);
        };



        //--------------------------------------------------------------------
        // Grid settings
        //--------------------------------------------------------------------

        var prepareEmployeesGrid = function(unassociatedEmployees){
          console.log('+++ unassociatedEmployees', unassociatedEmployees);

          te.gridOptions = {
            data: unassociatedEmployees,
            totalItems: totalUnnassociatedEmployees,
            minRowsToShow: unassociatedEmployees.length < te.numOfRows ? unassociatedEmployees.length : te.numOfRows,

            enableHorizontalScrollbar: 0,
            enableVerticalScrollbar: 0,
            enableColumnMenus: false,

            enableFiltering: true,
            useExternalFiltering: true,

            enableSorting: true,
            useExternalSorting: true,

            needPagination: true,
            useExternalPagination: true,
            enablePaginationControls: false,
            paginationPageSize: te.numOfRows,
            paginationCurrentPage: 1,

            enableSelectAll: true,
            enableRowSelection: true,
            enableFullRowSelection: true,                   // full row selection

            columnDefs: [
              {
                field: 'lastName',
                enableFiltering: true,
                minWidth: '150',
                sort: {
                  direction: uiGridConstants.ASC
                }
              },
              { field: 'firstName',        enableFiltering: false, minWidth: '100' },
              {
                field: 'isFloating',
                enableFiltering: false,
                minWidth: '90',
                enableSorting: false,
                cellTemplate: '<div>' +
                                '<span ng-show="row.isSelected">' +
                                  '<label class="eml-switch">' +
                                  '<input type="checkbox" ' +
                                          'class="eml-switch-input" ' +
                                          'ng-model="row.entity.isFloating" ' +
                                          'ng-checked="row.entity.isFloating"' +
                                          'ng-change="grid.appScope.te.updateEditing()">' +
                                  '<span class="eml-switch-label" ' +
                                        'data-on="{{ ::\'app.YES\' | translate }}" ' +
                                        'data-off="{{ ::\'app.NO\' | translate }}"></span>' +
                                  '<span class="eml-switch-handle"></span>' +
                                '</span>' +
                              '</div>'
              },
              { field: 'primarySkillName', enableFiltering: false, minWidth: '150' },
              { field: 'homeTeamName',     enableFiltering: false, minWidth: '150' }
              //{ field: 'employeeType',     enableFiltering: false, minWidth: '100' },
              //{ field: 'hireDate',         enableFiltering: false, minWidth: '100', cellFilter: 'date' }
            ],
            onRegisterApi: function(gridApi) {
              te.gridApi = gridApi;

              //
              // Row selection
              
              gridApi.selection.on.rowSelectionChanged($scope, function (row) {
                row.entity.isSelected = row.isSelected;
                te.updateEditing();
              });


              //
              // Select All event

              gridApi.selection.on.rowSelectionChangedBatch($scope, function (arrRows) {
                angular.forEach(arrRows, function(row){
                  row.entity.isSelected = row.isSelected;
                });
                te.updateEditing();
              });

              
              //
              // Back-end filtering

              gridApi.core.on.filterChanged( $scope, function() {
                var grid = this.grid;
                var filterTerm = grid.columns[1].filters[0].term;
                //console.log('~~~ filter changed - grid', grid);

                if (filterTerm === null || filterTerm === '' || filterTerm === undefined ){
                  te.queryParams = {
                    orderby : te.queryParams.orderby,
                    orderdir: te.queryParams.orderdir
                  };
                } else {
                  var filterName = 'lastName';
                  te.queryParams.filter = filterName + " LIKE '" + filterTerm + "%'";
                }
                getPage();
              });


              //
              // Back-end sorting

              gridApi.core.on.sortChanged($scope, function(grid, sortColumns) {
                if (sortColumns.length === 0) {
                  te.queryParams.orderdir = 'ASC';
                  te.queryParams.orderby = 'lastName';
                  
                } else {
                  te.queryParams.orderdir = sortColumns[0].sort.direction;

                  switch (sortColumns[0].field) {
                    case "lastName":
                      te.queryParams.orderby = 'lastName';
                      break;
                    case "firstName":
                      te.queryParams.orderby = 'firstName';
                      break;
                    case "isFloating":
                      te.queryParams.orderby = 'isFloating';
                      break;
                    case "employeeType":
                      te.queryParams.orderby = 'employeeType';
                      break;
                    case "primarySkillName":
                      te.queryParams.orderby = 'Skill.name';
                      break;
                    case "homeTeamName":
                      te.queryParams.orderby = 'Team.name';
                      break;
                    case "hireDate":
                      te.queryParams.orderby = 'hireDate';
                      break;
                    default:
                      te.queryParams.orderby = 'lastName';
                      break;
                  }
                }
                getPage();
              });


              //
              // Back-end pagination

              gridApi.pagination.on.paginationChanged($scope, function (newPage, pageSize) {
                te.gridOptions.paginationCurrentPage = newPage;

                // Refresh Employees modal
                te.revertEmployeesToInit();                // bring Employees list to initial state
                gridApi.grid.selection.selectAll = false;  // to remove `ui-grid-all-selected` class that un-checks Select All
                gridApi.grid.selection.selectedCount = 0;

                getPage();
              });

              var getPage = function() {
                console.log('te.gridOptions.queryParams', te.queryParams);

                rulesTeamsService.getTeamUnassociatedEmployees(te.team.id, te.queryParams, te.gridOptions.paginationCurrentPage, te.numOfRows)
                  .then( function(res){
                    console.log('~~~ res grid upd', res);
                    refreshGrid(res);
                });
              };
            }
          };
        };


        //--------------------------------------------------------------------
        // CRUD
        //--------------------------------------------------------------------


        var refreshGrid = function(res){
          prepareData(res);
          te.gridOptions.totalItems = totalUnnassociatedEmployees;
          te.gridOptions.data = te.unassociatedEmployees;
          te.gridOptions.minRowsToShow = totalUnnassociatedEmployees < te.numOfRows ? totalUnnassociatedEmployees : te.numOfRows;
        };


        te.updateEditing = function(){
          te.isEditing = !angular.equals(te.unassociatedEmployeesInit, te.unassociatedEmployees);
        };

        te.revertEmployeesToInit = function(){
          te.unassociatedEmployees = angular.copy(te.unassociatedEmployeesInit);
          te.updateEditing();
        };


        te.associateEmployees = function(){
          //prepare selected rows
          var toAdd = te.gridApi.selection.getSelectedRows();
          console.log('toAdd', toAdd);
          var toAddDto = [];
          angular.forEach(toAdd, function(row){
            var dto = {
              isFloating: row.isFloating,
              //isHomeTeam: false,
              //isSchedulable: false,
              employeeId: row.employeeId
            };
            toAddDto.push(dto);
          });
          console.log('toAddDto', toAddDto);

          rulesTeamsService.addEmployeesTeamMembership(te.team.id, toAddDto).then(function(res){
            $modalInstance.close(te.team);

          }, function(err) {
            applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
          });
        };


        //--------------------------------------------------------------------
        // Modal methods
        //--------------------------------------------------------------------


        te.closeModal = function () {
          $modalInstance.dismiss('cancel');
        };


        //
        // If user navigates away from the page,
        // dismiss the modal

        $scope.$on('$stateChangeStart', function(){
            $modalInstance.dismiss('cancel');
          }
        );

      }
    ]);
})();
;
(function () {
  "use strict";

  var rules = angular.module('emlogis.rules');

  rules.controller('RulesNewShiftBulkTypesModalCtrl',
    ['$scope', '$timeout', '$modalInstance', 'rulesShiftLTService', 'types', 'selectedLength', 'site',
      function ($scope, $timeout, $modalInstance, rulesShiftLTService, types, selectedLength, site) {

        //--------------------------------------------------------------------
        // Defaults for Bulk Shift Types Modal
        //--------------------------------------------------------------------

        var defaultTime = moment().hour(0).minute(0).second(0).milliseconds(0),
            bulk = this;

        bulk.types = types;
        bulk.site = site;
        bulk.selectedLength = selectedLength;

        bulk.minutesSteps = [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60];
        bulk.minutesStepSelected = 0;

        bulk.startTime = defaultTime;
        bulk.endTime = defaultTime;



        bulk.add = function() {
          var startTime = moment(bulk.startTime);
          var endTime = moment(bulk.endTime);

          var dto = {
            "isActive":       true,
            "shiftLengthId":  bulk.selectedLength.id,
            "interval":       bulk.minutesStepSelected,
            "startTime":      startTime.diff(moment(startTime).startOf('day')),
            "endTime":        endTime.diff(moment(endTime).startOf('day')),
            "baseName":       ''
          };
          console.log('bulkDto', dto);

          rulesShiftLTService.bulkAddNewShiftTypes(bulk.site.id, dto).then(function(types){
            bulk.types = types;
            bulk.closeModal();
          });
        };



        bulk.isValid = function() {
          var startTime = moment(bulk.startTime);
          var endTime = moment(bulk.endTime);
          return startTime.isBefore(endTime) && bulk.minutesStepSelected !== 0;
        };



        //--------------------------------------------------------------------
        // Modal methods
        //--------------------------------------------------------------------


        bulk.closeModal = function () {
          $modalInstance.close(bulk.types);
        };


        //
        // If user navigates away from the page,
        // dismiss the modal

        $scope.$on('$stateChangeStart', function(){
            $modalInstance.dismiss('cancel');
          }
        );

      }
    ]);
})();
;
(function () {
  "use strict";

  var rules = angular.module('emlogis.rules');

  rules.controller('RulesNewShiftLengthsModalCtrl',
    ['$scope', '$timeout', '$modalInstance', 'rulesShiftLTService', 'lengths', 'siteId',
      function ($scope, $timeout, $modalInstance, rulesShiftLTService, lengths, siteId) {

        //--------------------------------------------------------------------
        // Defaults for New Shift Lengths Modal
        //--------------------------------------------------------------------

        var i,
            lengthsToSelectInit = [],
            nsl = this;

        nsl.lengths = lengths;
        nsl.siteId = siteId;

        nsl.lengthsEndings = [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55];
        nsl.lengthEngingSelected = 0;
        nsl.lengthsToSelect = [];
        nsl.newLengthsToAdd = [];

        nsl.isEditing = false;



        nsl.createListOfLengthsToSelect = function(){
          lengthsToSelectInit = [];
          for (i = 0; i <= 24; i++) {
            var minutes = i * 60 + nsl.lengthEngingSelected;
            var lengthExists = checkIfLengthExists(minutes);

            var lengthObj = {
              lengthInMin: minutes,
              exists: lengthExists,
              disabled: lengthExists
            };
            lengthsToSelectInit.push(lengthObj);
          }
          nsl.lengthsToSelect = angular.copy(lengthsToSelectInit);
        };


        var checkIfLengthExists = function(minutes){
          var found = _.find(nsl.lengths, { 'lengthInMin': minutes});
          return found !== undefined;
        };


        nsl.createListOfLengthsToSelect();



        //--------------------------------------------------------------------
        // CRUD
        //--------------------------------------------------------------------


        nsl.updateEditing = function(length){
          nsl.isEditing = !angular.equals(lengthsToSelectInit, nsl.lengthsToSelect);
          nsl.newLengthsToAdd.push(length);
        };



        // Add New Shift

        nsl.addNewShiftLengths = function(){
          var uniqueList = _.uniq(nsl.newLengthsToAdd, function(length, key, a) {
            return length.lengthInMin;
          });

          var multiAdd = { shiftLengthDtos: [] };

          angular.forEach(uniqueList, function(lengthToAdd){
            var dto = {
              lengthInMin: lengthToAdd.lengthInMin,
              active: true
            };
            multiAdd.shiftLengthDtos.push(dto);
          });

          rulesShiftLTService.addNewShiftLengths(nsl.siteId, multiAdd).then( function(lengths){
            if (lengths) {
              nsl.lengths = lengths;
              nsl.closeModal();

            } else {
              var oldLength = rulesShiftLTService.getShiftsLengthsInit();
              nsl.lengths = oldLength;
              nsl.closeModal();
            }
          });

        };


        //--------------------------------------------------------------------
        // Modal methods
        //--------------------------------------------------------------------


        nsl.closeModal = function () {
          $modalInstance.close(nsl.lengths);
        };


        //
        // If user navigates away from the page,
        // dismiss the modal

        $scope.$on('$stateChangeStart', function(){
            $modalInstance.dismiss('cancel');
          }
        );

      }
    ]);
})();
;
(function() {
  "use strict";

  // Service
  // Create service function

  var rulesAbsenceTypesService = function($http, $q, $filter, applicationContext, crudDataService, dataService, dialogs){

    var ats = this,
        absTypesInit,
        totalTypes,
        absTypes,
        atsNumOfRows,
        atsPageNum,
        abcOrder = { orderby: 'name', orderdir: 'ASC' };


    //--------------------------------------------------------------------
    // Teams related methods
    //--------------------------------------------------------------------


    // GET all existing Absence Types

    ats.getAbsenceTypes = function(siteId, pageNum, numOfRows){
      atsNumOfRows = numOfRows;
      atsPageNum = pageNum;

      return dataService.getAbsenceTypes(siteId, abcOrder, pageNum, numOfRows).then(function(res){
        //console.log('getAbsenceTypes', res);

        absTypesInit = res.data;
        totalTypes = res.total;

        angular.forEach(absTypesInit, function(type){
          type.isEditing = false;
          type.isCreating = false;
          type.timeToDeductInMin = $filter('minsToHours')(type.timeToDeductInMin);
        });

        absTypes = angular.copy(absTypesInit);
        var returnDto = {
          data: absTypes,
          total: totalTypes,
          pageNum: atsPageNum
        };
        return returnDto;

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };


    //
    // provide an Initial Abs Types list

    ats.getAbsTypesInit = function(){
      return absTypesInit;
    };


    //
    // provide current total number of Abs Types

    ats.getAbsTypesTotal = function(){
      return totalTypes;
    };


    // DELETE a Type

    ats.deleteAbsenceType = function(siteId, typeId){

      var deferred = $q.defer();
      var dlg = dialogs.confirm('app.PLEASE_CONFIRM', 'rules.DELETE');                      // Show modal window
      dlg.result
        .then(function (btn) {                                                              // If user confirms, proceed

          return dataService.deleteAbsenceType(siteId, typeId).then(function(res){
            applicationContext.setNotificationMsgWithValues('app.DELETED_SUCCESSFULLY', 'success', true);
            deferred.resolve(ats.getAbsenceTypes(siteId, atsPageNum, atsNumOfRows));

          }, function(err) {
            applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
          });

        }, function (btn) {                                                                 // If user doesn't confirm
          // rollback
        }
      );
      return deferred.promise;
    };


    // UPDATE a Type

    ats.updateAbsenceType = function(siteId, typeId, dto){
      return dataService.updateAbsenceType(siteId, typeId, dto).then(function(res){

        applicationContext.setNotificationMsgWithValues('app.SAVED_SUCCESSFULLY', 'success', true);
        return ats.getAbsenceTypes(siteId, atsPageNum, atsNumOfRows);

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };


    // CREATE a Type

    ats.addAbsenceType = function(siteId, dto){
      return dataService.addAbsenceType(siteId, dto).then(function(res){

        applicationContext.setNotificationMsgWithValues('app.CREATED_SUCCESSFULLY', 'success', true);
        var pageNum = findPageNumForNewTypeName(dto);
        return ats.getAbsenceTypes(siteId, pageNum, atsNumOfRows);

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };


    var findPageNumForNewTypeName = function(newType){
      var allTypes = angular.copy(absTypesInit);
      allTypes.push(newType);
      allTypes = $filter('orderBy')(allTypes, 'name');

      var newTypeIndex = _.findIndex(allTypes, { name: newType.name });
      var pageNum = Math.floor(newTypeIndex / atsNumOfRows) + 1;
      return pageNum;
    };

  };


  // Inject dependencies and
  // add service to the Rules module

  rulesAbsenceTypesService.$inject = ['$http', '$q', '$filter', 'applicationContext', 'crudDataService', 'dataService', 'dialogs'];
  angular.module('emlogis.rules').service('rulesAbsTypesService', rulesAbsenceTypesService);

})();
;
(function() {
  "use strict";

  // Service
  // Create service function

  var rulesShiftLengthsTypesService = function($http, $q, $filter, applicationContext, dataService){

    var slt = this,
        sltShiftLengthsInit,
        sltShiftLengths,
        sltShiftTypesInit,
        sltShiftTypes,
        abcOrder = { orderby: 'name', orderdir: 'ASC' };


    //--------------------------------------------------------------------
    // Shift Lengths related methods
    //--------------------------------------------------------------------


    // GET all existing Shift Lengths for a Site

    slt.getShiftLengths = function(siteId){

      var filter = abcOrder;
      filter.activefilter = 'Both';

      return dataService.getShiftLengths(siteId, filter, 1, -1).then(function(res){
        console.log('getShiftLengths', res);
        sltShiftLengthsInit = res.data;

        angular.forEach(sltShiftLengthsInit, function(length){
          length.fullHours = Math.floor(length.lengthInMin / 60);
        });

        sltShiftLengths = angular.copy(sltShiftLengthsInit);
        return sltShiftLengths;

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };



    //
    // provide an Initial SLT Lengths

    slt.getShiftsLengthsInit = function(){
      return sltShiftLengthsInit;
    };



    // UPDATE a Shift Length

    slt.updateShiftLengths = function(siteId, lengthsList){
      var deferred = $q.defer();

      angular.forEach(lengthsList, function(lengthToEdit, i){

        var dto = {
          name: lengthToEdit.name,
          description: lengthToEdit.description,
          lengthInMin: lengthToEdit.lengthInMin,
          active: lengthToEdit.active
        };

        return dataService.updateShiftLength(siteId, lengthToEdit.id, dto).then(function(res){
          applicationContext.setNotificationMsgWithValues('app.SAVED_SUCCESSFULLY', 'success', true);

          if ( i + 1 === lengthsList.length ) {
            deferred.resolve( slt.getShiftLengths(siteId) );
          }

        }, function(err) {
          applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
        });
      });

      return deferred.promise;
    };



    // Multi add new Lengths

    slt.addNewShiftLengths = function(siteId, dto){
      return dataService.addNewShiftLengths(siteId, dto).then(function(res){
        applicationContext.setNotificationMsgWithValues('app.CREATED_SUCCESSFULLY', 'success', true);

        return slt.getShiftLengths(siteId);

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };



    //--------------------------------------------------------------------
    // Shift Types related methods
    //--------------------------------------------------------------------

    // GET Shift Types for a Shift Length

    slt.getShiftTypesForLength = function(siteId, shiftLengthId){

      return dataService.getShiftTypesForLength(siteId, shiftLengthId, { orderby: 'startTime', orderdir: 'ASC' }, 1, -1).then(function(res){
        console.log('getShiftTypesForLength', res);
        sltShiftTypesInit = res.data;

        angular.forEach(sltShiftTypesInit, function(type){
          type.isEditing = false;
          //type.isCreating = false;
        });

        sltShiftTypes = angular.copy(sltShiftTypesInit);
        return sltShiftTypes;

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };



    // Upd multi Types activation

    slt.updShiftTypesActivation = function(siteId, dto){
      return dataService.updShiftTypesActivation(siteId, dto).then(function(res){
        applicationContext.setNotificationMsgWithValues('app.SAVED_SUCCESSFULLY', 'success', true);

        return slt.getShiftTypesForLength(siteId, res.data[0].shiftLengthId);

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };



    // save Shift Type

    slt.saveShiftType = function(siteId, type, dto) {
      return dataService.updateShiftType(siteId, type.id, dto).then(function(res){
        applicationContext.setNotificationMsgWithValues('app.SAVED_SUCCESSFULLY', 'success', true);
        return slt.getShiftTypesForLength(siteId, type.shiftLengthId);

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };



    // add custom Type

    slt.addShiftType = function(siteId, dto) {
      return dataService.addShiftType(siteId, dto).then(function(res){
        applicationContext.setNotificationMsgWithValues('app.SAVED_SUCCESSFULLY', 'success', true);
        return slt.getShiftTypesForLength(siteId, dto.shiftLengthId);

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };



    // delete Shift Type

    slt.deleteShiftType = function(siteId, type) {
      return dataService.deleteShiftType(siteId, type.id).then(function(res){
        applicationContext.setNotificationMsgWithValues('app.DELETED_SUCCESSFULLY', 'success', true);
        return slt.getShiftTypesForLength(siteId, type.shiftLengthId);

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };



    // bulk add Shift Types

    slt.bulkAddNewShiftTypes = function(siteId, dto) {
      return dataService.bulkAddNewShiftTypes(siteId, dto).then(function(res){
        applicationContext.setNotificationMsgWithValues('app.SAVED_SUCCESSFULLY', 'success', true);
        return slt.getShiftTypesForLength(siteId, dto.shiftLengthId);

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };

  };


  // Inject dependencies and
  // add service to the Rules module

  rulesShiftLengthsTypesService.$inject = ['$http', '$q', '$filter', 'applicationContext', 'dataService'];
  angular.module('emlogis.rules').service('rulesShiftLTService', rulesShiftLengthsTypesService);

})();
;
(function() {
  "use strict";

  // Service
  // Create service function

  var rulesSitesService = function($http, $q, applicationContext, dataService){

    var siteForm,
        baseUrl = applicationContext.getBaseRestUrl(),
        factory = _.clone(dataService);


    // Set Site Form

    this.setSiteForm = function(form){
      siteForm = form;
    };

    // Get Site Form

    this.getSiteForm = function(){
      return siteForm;
    };


    // GET all Sites associated to an Org

    this.getAllSites = function() {
      return factory.getElements('sites', { orderby:'name', orderdir:'ASC', offset: 1, limit: -1});
    };


    
    // GET Sites+Teams tree
    
    this.getSitesTeamsTree = function(){
      return dataService.getSitesTeamsTree({});
    };



    // GET a full Site DTO

    this.getSiteDetails = function(siteId) {
      return $http.get( baseUrl + 'sites/' + siteId )
        .then( function (response) {
          return response;
        });
    };



    // Update a Site

    this.updateSite = function(siteId, siteObj) {
      return factory.updateElement('sites', siteId, siteObj);
    };



    // Create a New Site

    this.saveNewSite = function(newSiteObj) {
      return factory.createElement('sites', newSiteObj);
    };

  };


  // Inject dependencies and
  // add service to the Rules module

  rulesSitesService.$inject = ['$http', '$q', 'applicationContext', 'dataService'];
  angular.module('emlogis.rules').service('rulesSitesService', rulesSitesService);

})();
;
(function() {
  "use strict";

  // Service
  // Create service function

  var rulesTeamsService = function($http, $q, applicationContext, crudDataService, dataService){

    var baseUrl = applicationContext.getBaseRestUrl(),
        siteLastModified,
        factory = _.clone(crudDataService),
        abcOrder = {orderby:'name', orderdir:'ASC'};


    this.saveSiteLastModified = function(siteId){
      siteLastModified = siteId;
    };

    this.getSiteLastModified = function(){
      return siteLastModified;
    };


    //--------------------------------------------------------------------
    // Teams related methods
    //--------------------------------------------------------------------


    // GET all Teams for a Site

    this.getSiteTeams = function(siteId){
      return dataService.getSiteTeams(siteId, abcOrder, 1, -1).then( function(response){
          //console.log('~~~ allTeams for current Site: ', res.data);
          return response;

        }, function (err) {
          applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
        })
      ;
    };

    // GET a Team details

    this.getTeamDetails = function(teamId) {
      return $http.get( baseUrl + 'teams/' + teamId ).then( function(response) {
        return response;
      });
    };


    // Update a Team details

    this.putTeamDetails = function(teamId, dto) {
      return factory.updateElement('teams', teamId, dto).then( function(response) {
        return response;
      });
    };


    // Add a New Team

    this.addNewTeam = function(newTeamDto) {
      return factory.createElement('teams', newTeamDto).then( function(res){
        return res;
      });
    };



    //--------------------------------------------------------------------
    // Team's Skills related methods
    //--------------------------------------------------------------------


    // GET Skills for a Team

    this.getTeamSkills = function(teamId) {
      return dataService.getTeamSkills(teamId, abcOrder, 1, -1).then( function(response) {
        //console.log('~~~ Loaded Skills for the Team...', response.data);
        return response.data;

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };


    // GET Unassociated Skills for a Team

    this.getUnassociatedTeamSkills = function(teamId) {
      return dataService.getUnassociatedTeamSkills(teamId, abcOrder, 1, -1).then( function(response) {
        //console.log('~~~ Loaded Unassosiated Skills for the Team...', response.data);
        return response.data;

      }, function (err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };


    // Attach Skill to a Team

    this.addTeamSkill = function(newTeamId, skillId){
      return dataService.addTeamSkill(newTeamId, skillId).then( function(res){
        return res;
      });
    };


    // Remove Skill from a Team

    this.removeSkillFromTeam = function(newTeamId, skillId){
      return dataService.removeSkillFromTeam(newTeamId, skillId).then( function(res){
        return res;
      });
    };



    //--------------------------------------------------------------------
    // Team's Employees related methods
    //--------------------------------------------------------------------


    // Load Employees
    // that belong to this Team

    this.loadTeamEmployees = function(teamId, queryParams, pageNum, numOfRows){
      return dataService.getTeamEmployees(teamId, queryParams, pageNum, numOfRows).then( function(res){
        //console.log('+++ Loaded Employees for the Team:', res);    //DEV mode
        return res;

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };



    // Removes association between a team and specified employees

    this.removeEmployeesTeamMembership = function(teamId, emplIdsList) {
      var url = baseUrl + 'teams/' + teamId + '/membership/ops/removeemployees';
      return $http.post(url, emplIdsList).then( function (res) {
        applicationContext.setNotificationMsgWithValues('Selected employees were successfully removed!', 'success', true);
        return res;

      }, function(err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };


    // Adds association between a team and specified employees

    this.addEmployeesTeamMembership = function(teamId, emplIdsList) {
      return $http.post( baseUrl + 'teams/' + teamId + '/membership/ops/addemployees', emplIdsList ).then( function(res) {
        return res;
      });
    };


    // GET Emloyees NOT belonging to a Team

    this.getTeamUnassociatedEmployees = function(teamId, sortParams, pageNum, perPage){
      return dataService.getUnassociatedTeamEmployees(teamId, sortParams, pageNum, perPage).then( function(res){
        return res;
      });
    };


    // GET Employee details || , queryParams, pageIndex, pageSize

    this.getEmployeeDetails = function(employeeId){
      return $http.get(baseUrl + 'employees/' + employeeId + '/info').then( function(res){
        return res;
      });
    };


    // Delete a Team

    this.deleteTeam = function(teamId) {
      return dataService.deleteTeam(teamId).then( function(res){
        applicationContext.setNotificationMsgWithValues('rules.site_teams.TEAM_DELETED', 'success', true);
        return res;

      }, function (err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });
    };



  };


  // Inject dependencies and
  // add service to the Rules module

  rulesTeamsService.$inject = ['$http', '$q', 'applicationContext', 'crudDataService', 'dataService'];
  angular.module('emlogis.rules').service('rulesTeamsService', rulesTeamsService);

})();
;
angular.module('emlogis.rules').controller('RulesSkillsCtrl',
    ['$scope', '$modal', '$translate', '$q', 'appFunc', 'crudDataService', 'dataService', 'dialogs', 'applicationContext',
    function($scope, $modal, $translate, $q, appFunc, crudDataService, dataService, dialogs, applicationContext) {

      var originalSkills = [],
          translations = {
            available: 'Available',
            neverEnd: 'Never End',
            skillName: 'Skill Name',
            abbreviation: 'Abbreviation',
            active: 'Active',
            inactive: 'Inactive'
          };

      $translate(["rules.skills.AVAILABLE",
                  "rules.skills.NEVER_END",
                  "rules.skills.SKILL_NAME",
                  "rules.skills.ABBREVIATION",
                  "rules.skills.ACTIVE",
                  "rules.skills.INACTIVE"]).
          then(function (translation) {
            translations.available =  translation["rules.skills.AVAILABLE"];
            translations.neverEnd =  translation["rules.skills.NEVER_END"];
            translations.skillName =  translation["rules.skills.SKILL_NAME"];
            translations.abbreviation =  translation["rules.skills.ABBREVIATION"];
            translations.active =  translation["rules.skills.ACTIVE"];
            translations.inactive =  translation["rules.skills.INACTIVE"];
          });


      $scope.skills = [];
      $scope.organization = null;
      $scope.skillsReceived = false;

      $scope.fieldsToSort = [
        {name: 'name', buttonLabel: translations.skillName},
        {name: 'abbreviation', buttonLabel: translations.abbreviation}
      ];

      $scope.fieldsToFilter = [
        {name: 'isActive', value: true, buttonLabel: translations.active},
        {name: 'isActive', value: false, buttonLabel: translations.inactive}
      ];

      // open calendar control
      $scope.openCalendar = function($event, sObj, propName) {
        $event.preventDefault();
        $event.stopPropagation();
        sObj[propName] = true;
      };

      // open modal window
      $scope.openModal = function (sObj) {
        var modalInstance = $modal.open({
          templateUrl: 'myModalContent.html',
          controller: 'SkillsModalCtrl',
          windowClass: 'rules-skills-modal',
          size: 'lg',
          resolve: {
            sObj: function() {
              return sObj;
            }
          }
        });
      };

      $scope.getTeamsForSkill = function(sObj) {
        if (sObj.teamsForSkill || !sObj.id) return;

        dataService.getTeamAssociations(sObj.id).
            then(function(res) {
              sObj.teamsForSkill = _.groupBy(res.data, function(t) {
                return t.siteName;
              });
            },
            function (err) {
              applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
            });
      };

      $scope.saveSkill = function($event, sObj) {
        if ($event) {
          $event.preventDefault();
          $event.stopPropagation();
        }

        // In case if skill is invalid
        if (!sObj.name || !sObj.abbreviation ||
            sObj.calendarStartDate === undefined ||
            sObj.calendarEndDate === undefined) {
          return $q.reject({});
        }

        if (sObj.id) {
          return updateSkill(sObj);
        } else {
          return createSkill(sObj);
        }
      };

      function updateSkill(sObj) {
        var startDate = 0, endDate = 0;

        if (sObj.calendarStartDate) {
          startDate = appFunc.getDateWithTimezone(
              sObj.calendarStartDate.getFullYear(),
              sObj.calendarStartDate.getMonth(),
              sObj.calendarStartDate.getDate(),
              $scope.organization.timeZone
          ).getTime();
        }

        if (sObj.calendarEndDate) {
          endDate = appFunc.getDateWithTimezone(
              sObj.calendarEndDate.getFullYear(),
              sObj.calendarEndDate.getMonth(),
              sObj.calendarEndDate.getDate(),
              $scope.organization.timeZone
          ).getTime();
        }

        return dataService.updateSkill(sObj.id, {
          name: sObj.name,
          abbreviation: sObj.abbreviation,
          description: sObj.description,
          startDate: startDate,
          endDate: endDate,
          isActive: sObj.isActive
        }).
        then(function(res) {
          applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', 'success', true);
          sObj.originalName = sObj.name;

          if (res.data.startDate) {
            sObj.startDate = appFunc.convertToBrowserTimezone(res.data.startDate, $scope.organization.timeZone);
          } else {
            sObj.startDate = 0;
          }
          if (res.data.endDate) {
            sObj.endDate = appFunc.convertToBrowserTimezone(res.data.endDate, $scope.organization.timeZone);
          } else {
            sObj.endDate = 0;
          }
          originalSkills = _.cloneDeep($scope.skills);
        },
        function (err) {
          applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
        });
      }

      function createSkill(sObj) {
        var startDate = 0, endDate = 0;

        sObj.submitted = true;

        if (sObj.calendarStartDate) {
          startDate = appFunc.getDateWithTimezone(
              sObj.calendarStartDate.getFullYear(),
              sObj.calendarStartDate.getMonth(),
              sObj.calendarStartDate.getDate(),
              $scope.organization.timeZone
          ).getTime();
        }

        if (sObj.calendarEndDate) {
          endDate = appFunc.getDateWithTimezone(
              sObj.calendarEndDate.getFullYear(),
              sObj.calendarEndDate.getMonth(),
              sObj.calendarEndDate.getDate(),
              $scope.organization.timeZone
          ).getTime();
        }

        return dataService.createSkill({
          name: sObj.name,
          abbreviation: sObj.abbreviation,
          description: sObj.description,
          startDate: startDate,
          endDate: endDate,
          isActive: sObj.isActive
        }).
        then(function(res) {
          applicationContext.setNotificationMsgWithValues('app.CREATED_SUCCESSFULLY', 'success', true);
          sObj.id = res.data.id;
          sObj.originalName = sObj.name;

          if (res.data.startDate) {
            sObj.startDate = appFunc.convertToBrowserTimezone(res.data.startDate, $scope.organization.timeZone);
          } else {
            sObj.startDate = 0;
          }
          if (res.data.endDate) {
            sObj.endDate = appFunc.convertToBrowserTimezone(res.data.endDate, $scope.organization.timeZone);
          } else {
            sObj.endDate = 0;
          }
          originalSkills = _.cloneDeep($scope.skills);
        },
        function (err) {
          applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
        });
      }

      $scope.showValidationMessages = function(sObj) {
        if (sObj.id) {
          return true;
        } else {
          return sObj.submitted;
        }
      };

      $scope.addRowForNewSkill = function() {

        var newSkillOpened = _.find($scope.skills, function(s) {
          return s.id === undefined;
        });

        // do not add new row if there is one already
        if (newSkillOpened) return;

        var newSkill = {
          name: null,
          abbreviation: null,
          description: null,
          calendarStartDate: moment().toDate(),
          calendarEndDate: null,
          isActive: true,
          isCollapsed: false
        };

        $scope.skills.unshift(newSkill);
      };

      $scope.resetSkill = function(sObj) {
        // if canceled editing a new skill - remove it from table
        if (!sObj.id) {
          removeNewSkills();
          return;
        }

        //if canceled editing an existing skill - restore it to previous state
        var originalSkill = _.clone(_.find(originalSkills, function(s) {
          return sObj.id == s.id;
        }));

        // do not reset skill teams because you add/remove them in another window
        originalSkill.teamsForSkill = sObj.teamsForSkill;

        // leave skill in expanded state
        originalSkill.isCollapsed = false;

        // replace holiday object with original one
        $scope.skills = _.map($scope.skills, function(s) {
          return (s.id === sObj.id) ? originalSkill : s;
        });
      };

      function removeNewSkills() {
        $scope.skills = _.reject($scope.skills, function(s) {
          return s.id === undefined;
        });
      }

      $scope.deleteSkill = function($event, sObj) {
        $event.preventDefault();
        $event.stopPropagation();

        // if canceled editing a new skill - remove it from table
        if (!sObj.id) {
          removeNewSkills();
          return;
        }

        var confirm = dialogs.confirm('app.PLEASE_CONFIRM', 'rules.skills.ARE_YOU_SURE_REMOVE_SKILL?');

        confirm.result.then(function (btn) {
          dataService.deleteSkill(sObj.id)
              .then(function (res) {
                applicationContext.setNotificationMsgWithValues('app.DELETED_SUCCESSFULLY', 'success', true);
                $scope.skills = _.reject($scope.skills, function(s) {
                  return s.id === sObj.id;
                });
                originalSkills = _.cloneDeep($scope.skills);
              },
              function (err) {
                applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
              });
        }, function (btn) {
          // no pressed. Do nothing
        });
      };

      $scope.toReadableFormat = function(date, noDateText) {
        if (date) {
          return moment(date).format("MM/DD/YY");
        } else {
          switch(noDateText) {
            case 'Available':
              noDateText = translations.available;
              break;
            case 'Never End':
              noDateText = translations.neverEnd;
              break;
          }
          return noDateText;
        }
      };

      dataService.getSkills({}, 1, -1)
        .then(
          function (res) {
            $scope.skills = res.data;
            $scope.skillsReceived = true;

            angular.forEach($scope.skills, function (s) {
              s.isCollapsed = true;
              s.originalName = s.name;
            });

            // GET Current organization details
            return $scope.organization || crudDataService.getElement('org', '');
          },
          function (err) {
            applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
          })
        .then(
          function(res) {
            $scope.organization = res;
            /**
             * convert dates to browser's time stack,
             */
            angular.forEach($scope.skills, function(s) {
              if (s.startDate) {
                s.calendarStartDate = appFunc.convertToBrowserTimezone(s.startDate, $scope.organization.timeZone);
              } else {
                s.calendarStartDate = null;
              }
              if (s.endDate) {
                s.calendarEndDate = appFunc.convertToBrowserTimezone(s.endDate, $scope.organization.timeZone);
              } else {
                s.calendarEndDate = null;
              }
            });

            originalSkills = _.cloneDeep($scope.skills);
          },
          function (err) {
            applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
          });

      //--------------------------------------------------------------------
      // Setup a window for asking to save the changes
      //--------------------------------------------------------------------

      var working = applicationContext.getWorking();

      working.entityName = 'rules.SKILLS';
      working.option = {
        editing: false,
        submitted: false
      };
      working.saveFunc = function() {
        var promises = [];
        _.each($scope.unsavedSkills, function(s) {
          promises.push($scope.saveSkill(null, s));
        });
        working.option.editing = false;

        return $q.all(promises);
      };


      function skillsAreEqual(s1, s2) {
        var areEqual = true,
          propertiesToCheck = ['name', 'abbreviation', 'description', 'calendarStartDate', 'calendarEndDate'];
        _.each(propertiesToCheck, function(prop) {
          if (!_.isEqual(s1[prop], s2[prop])) {
            areEqual = false;
          }
        });
        return areEqual;
      }


      $scope.$watch('skills', function(skills) {
        $scope.unsavedSkills = [];
        working.option.editing = false;
        _.each(skills, function(s) {
          var originalSkill = _.find(originalSkills, 'id', s.id);
          if (s && originalSkill && !skillsAreEqual(s, originalSkill)) {
            $scope.unsavedSkills.push(s);
            working.option.editing = true;
          }
        });
      }, true);
}]);



angular.module('emlogis.rules').controller('SkillsModalCtrl',
  ['$scope', '$timeout', '$modalInstance', 'dataService', 'applicationContext', 'sObj',
  function ($scope, $timeout, $modalInstance, dataService, applicationContext, sObj) {

    $scope.sObj = sObj;
    sObj.gridOptions = null;

    dataService.getSiteTeamAssociations(sObj.id).
      then(function(res) {

        function rowTemplate() {
          return '<div>' +
                    '<div ng-repeat="(colRenderIndex, col) in colContainer.renderedColumns track by col.colDef.name" ' +
                      'class="ui-grid-cell" ' +
                      'ng-class="{ \'ui-grid-row-header-cell\': col.isRowHeader,          '  +
                      '            \'team-to-add\': grid.appScope.teamToAdd(row),         '  +
                      '            \'team-to-remove\': grid.appScope.teamToRemove(row)}"  '  +
                      ' ui-grid-cell>' +
                    '</div>' +
                  '</div>';
        }

        $scope.teamToAdd = function(row) {
          return row.entity.teamHasSkill === false && row.isSelected === true;
        };

        $scope.teamToRemove = function(row) {
          return row.entity.teamHasSkill === true && row.isSelected === false;
        };


        sObj.gridOptions = {
          data: res.data,
          enableHorizontalScrollbar: 0,
          enableVerticalScrollbar: 1,
          enableColumnMenus: false,
          enableFiltering: false,
          enableSorting: true,
          needPagination: false,
          enableSelectAll: true,
          enableRowSelection: true,
          columnDefs: [
            { field: 'teamName'},
            { field: 'siteName'},
            { field: 'teamDescription'},
            { field: 'teamid',   visible: false },
            { field: 'siteid',   visible: false }
          ],
          rowTemplate: rowTemplate(),
          onRegisterApi: function(gridApi) {
            $scope.gridApi = gridApi;

            $timeout(function() {
              _.each(sObj.gridOptions.data, function(t) {
                // convert string "true/false" to boolean
                t.teamHasSkill = (t.teamHasSkill === "true");
                if (t.teamHasSkill) {
                  $scope.gridApi.selection.selectRow(t);
                }
              });
            });
          }
        };
      },
      function (err) {
        applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
      });


    $scope.updateTeamAssociations = function() {
      var selectedRows = $scope.gridApi.selection.getSelectedRows(),
          teams = _.pluck(selectedRows, 'teamId');

      dataService.updateTeamAssociations(sObj.id, teams).
          then(
            function(res) {
              applicationContext.setNotificationMsgWithValues('app.UPDATED_SUCCESSFULLY', 'success', true);
              sObj.teamsForSkill = _.groupBy(res.data, function(t) {
                return t.siteName;
              });
              $scope.cancel();
            },
            function (err) {
              applicationContext.setNotificationMsgWithValues(err.data.message, 'danger', true);
            });
    };

    $scope.cancel = function () {
      $modalInstance.dismiss('cancel');
    };
}]);


;
angular.module('emlogis.settings')
  .service('SettingsAccountsService', ['$http', '$rootScope', '$q', 'applicationContext', 'UtilsService',
    function ($http, $rootScope, $q, applicationContext, UtilsService) {
      var baseUrl = applicationContext.getBaseRestUrl();

      function sendRequest(urlPart, method, requestPayload) {
        var apiUrl = baseUrl + urlPart;
        var req = {
          method: method,
          url: apiUrl
        };
        if (method === 'POST' || method === 'PUT') {
          req.data = requestPayload;
        }

        return $http(req);
      }

      this.getEntityList = function (entityType, filterTxt, offset, limit, orderBy, orderDir) {
        var urlPart = '';
        var queryPart = [];

        if (entityType === $rootScope.consts.entityTypes.group) {
          urlPart = 'groupaccounts/ops/query';
        } else if (entityType === $rootScope.consts.entityTypes.user) {
          urlPart = 'useraccounts/ops/query';
        } else if (entityType === $rootScope.consts.entityTypes.role) {
          urlPart = 'roles/ops/query';
        } else {
          // do other operations
        }

        if (!UtilsService.checkEmpty(filterTxt)) {
          queryPart.push('search=' + filterTxt + '&searchfields=name');
        }
        if (!UtilsService.checkEmpty(offset)) {
          queryPart.push('offset=' + offset);
        }
        if (!UtilsService.checkEmpty(limit)) {
          queryPart.push('limit=' + limit);
        }
        if (!UtilsService.checkEmpty(orderBy)) {
          queryPart.push('orderby=' + orderBy);
        }
        if (!UtilsService.checkEmpty(orderDir)) {
          queryPart.push('orderdir=' + orderDir);
        }

        if (queryPart.length > 0) {
          urlPart += '?' + queryPart.join('&');
        }

        return sendRequest(urlPart, 'GET', null);
      };

      this.getEntityDetails = function (entityType, entityId) {
        var urlPart;
        if (entityType === $rootScope.consts.entityTypes.group) {
          urlPart = 'groupaccounts/' + entityId;
        } else if (entityType === $rootScope.consts.entityTypes.user) {
          urlPart = 'useraccounts/' + entityId;
        } else if (entityType === $rootScope.consts.entityTypes.role) {
          urlPart = 'roles/' + entityId;
        } else {
          // Other operations
        }


        return sendRequest(urlPart, 'GET', null);
      };

      this.getRelatedEntities = function (sourceEntityType, sourceEntityId, relatedEntityType, associated, filter, offset, limit, orderBy, orderDir) {
        var urlPart = '';
        var queryPart = [];
        var associatedString = '';
        if (!associated) {
          associatedString = 'unassociated';
        }

        if (sourceEntityType === $rootScope.consts.entityTypes.group) {
          if (relatedEntityType === $rootScope.consts.entityTypes.user) {
            urlPart = 'groupaccounts/' + sourceEntityId + '/' + associatedString + 'users';
          } else if (relatedEntityType === $rootScope.consts.entityTypes.role) {
            urlPart = 'groupaccounts/' + sourceEntityId + '/' + associatedString + 'roles';
          } else if (relatedEntityType === $rootScope.consts.entityTypes.accessControl) {
            urlPart = 'groupaccounts/' + sourceEntityId + '/aces/ops/getsitesteamsaces';
          }
          else {
            // do other operations
          }
        } else if (sourceEntityType === $rootScope.consts.entityTypes.user) {
          if (relatedEntityType === $rootScope.consts.entityTypes.group) {
            urlPart = 'useraccounts/' + sourceEntityId + '/' + associatedString + 'groups';
          } else if (relatedEntityType === $rootScope.consts.entityTypes.role) {
            urlPart = 'useraccounts/' + sourceEntityId + '/' + associatedString + 'roles';
          } else {
            // do other operations
          }
        } else if (sourceEntityType === $rootScope.consts.entityTypes.role) {
          if (relatedEntityType === $rootScope.consts.entityTypes.accessControl) {
            urlPart = 'roles/' + sourceEntityId + '/aces/ops/getsitesteamsaces';
          } else if (relatedEntityType === $rootScope.consts.entityTypes.permission) {
            urlPart = 'roles/' + sourceEntityId + '/' + associatedString + 'permissions';
          } else if (relatedEntityType === $rootScope.consts.entityTypes.group) {
            urlPart = 'roles/' + sourceEntityId + '/' + associatedString + 'groupaccounts';
          } else if (relatedEntityType === $rootScope.consts.entityTypes.user) {
            urlPart = 'roles/' + sourceEntityId + '/' + associatedString + 'useraccounts';
          } else {
            // do other operations
          }
        } else {
          // do Other operations
        }

        if (!UtilsService.checkEmpty(offset)) {
          queryPart.push('offset=' + offset);
        }
        if (!UtilsService.checkEmpty(limit)) {
          queryPart.push('limit=' + limit);
        }
        if (!UtilsService.checkEmpty(orderBy)) {
          queryPart.push('orderby=' + orderBy);
        }
        if (!UtilsService.checkEmpty(orderDir)) {
          queryPart.push('orderdir=' + orderDir);
        }
        if (!UtilsService.checkEmpty(filter)) {
          queryPart.push('filter=' + filter);
        }

        if (queryPart.length > 0) {
          urlPart += '?' + queryPart.join('&');
        }

        return sendRequest(urlPart, 'GET', null);
      };

      this.operateOnRelatedEntity = function (operation, sourceEntityType, sourceEntityId, relatedEntityType, payLoad) {
        var urlPart = null;
        var method = 'POST';

        if (sourceEntityType === $rootScope.consts.entityTypes.group) {
          if (relatedEntityType === $rootScope.consts.entityTypes.user) {
            urlPart = 'groupaccounts/' + sourceEntityId + '/ops/' + operation + 'users';
          } else if (relatedEntityType === $rootScope.consts.entityTypes.role) {
            urlPart = 'groupaccounts/' + sourceEntityId + '/ops/' + operation + 'roles';
          } else if (relatedEntityType === $rootScope.consts.entityTypes.accessControl) {
          urlPart = 'groupaccounts/' + sourceEntityId + '/aces/ops/setsitesteamsaces';
          } else {
            // do other operations
          }
        } else if (sourceEntityType === $rootScope.consts.entityTypes.user) {
          if (relatedEntityType === $rootScope.consts.entityTypes.group) {
            urlPart = 'useraccounts/' + sourceEntityId + '/ops/' + operation + 'groups';
          } else if (relatedEntityType === $rootScope.consts.entityTypes.role) {
            urlPart = 'useraccounts/' + sourceEntityId + '/ops/' + operation + 'roles';
          } else {
            // do other operations
          }
        } else if (sourceEntityType === $rootScope.consts.entityTypes.role) {
          if (relatedEntityType === $rootScope.consts.entityTypes.group) {
            urlPart = 'roles/' + sourceEntityId + '/ops/' + operation + 'groups';
          } else if (relatedEntityType === $rootScope.consts.entityTypes.user) {
            urlPart = 'roles/' + sourceEntityId + '/ops/' + operation + 'users';
          } else if (relatedEntityType === $rootScope.consts.entityTypes.accessControl) {
            urlPart = 'roles/' + sourceEntityId + '/aces/ops/setsitesteamsaces';
          } else if (relatedEntityType === $rootScope.consts.entityTypes.permission) {
            urlPart = 'roles/' + sourceEntityId + '/ops/' + operation + 'permissions';
          } else {
            // do other operations
          }
        } else {
          // do other operations
        }

        return sendRequest(urlPart, method, payLoad);
      };

      this.createEntity = function (entityType, entityDetails) {
        var urlPart = null;

        if (entityType === $rootScope.consts.entityTypes.group) {
          urlPart = 'groupaccounts/';
        } else if (entityType === $rootScope.consts.entityTypes.user) {
          urlPart = 'useraccounts/';
        } else if (entityType === $rootScope.consts.entityTypes.role) {
          urlPart = 'roles/';
        } else {
          // do other operations
        }

        return sendRequest(urlPart, 'POST', entityDetails);
      };

      this.updateEntity = function (entityType, entityId, entityDetails) {
        var urlPart = null;

        if (entityType === $rootScope.consts.entityTypes.group) {
          urlPart = 'groupaccounts/' + entityId;
        } else if (entityType === $rootScope.consts.entityTypes.user) {
          urlPart = 'useraccounts/' + entityId;
        } else if (entityType === $rootScope.consts.entityTypes.role) {
          urlPart = 'roles/' + entityId;
        } else {
          // do other operations
        }

        return sendRequest(urlPart, 'PUT', entityDetails);
      };

      this.duplicateEntity = function (entityType, entityId, entityDetails) {
        var urlPart = null;

        if (entityType === $rootScope.consts.entityTypes.role) {
          urlPart = 'roles/' + entityId + '/ops/duplicate';
        } else {
          //do other operations
        }

        return sendRequest(urlPart, 'POST', entityDetails);
      };

      this.deleteEntity = function (entityType, entityId) {
        var urlPart = null;

        if (entityType === $rootScope.consts.entityTypes.group) {
          urlPart = 'groupaccounts/' + entityId;
        } else if (entityType === $rootScope.consts.entityTypes.user) {
          urlPart = 'useraccounts/' + entityId;
        } else if (entityType === $rootScope.consts.entityTypes.role) {
          urlPart = 'roles/' + entityId;
        } else {
          // do other operations
        }

        return sendRequest(urlPart, 'DELETE', null);
      };
    }
  ]);
;
/**
 * Created by emlogis on 11/27/14.
 */

;
/**
 * Created by emlogis on 11/27/14.
 */
